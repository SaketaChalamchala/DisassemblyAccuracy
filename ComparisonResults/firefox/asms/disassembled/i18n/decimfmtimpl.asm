;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8A5CDF8193FB79C00A800AC7C6E61AE8
; Input	CRC32 :	146CB466

; File Name   :	D:\compspace\objfiles\firefox\i18n\decimfmtimpl.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset off_8000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8 ; DATA XREF:	.text:0000796Co
					; .text:00007AD0o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FB:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 130h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 134h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Formattable::operator!=(class icu_56::Formattable const &)const
		public ??9Formattable@icu_56@@QBECABV01@@Z
??9Formattable@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Formattable@icu_56@@QBECABV01@@Z ; icu_56::Formattable::operator==(icu_56::Formattable const	&)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Formattable@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDouble(icu_56::Formattable *__hidden this)
		public ?getDouble@Formattable@icu_56@@QBENXZ
?getDouble@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_1BF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDouble@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this)
		public ?getLong@Formattable@icu_56@@QBEHXZ
?getLong@Formattable@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_1FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLong@Formattable@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::Formattable::getInt64(icu_56::Formattable *__hidden this)
		public ?getInt64@Formattable@icu_56@@QBE_JXZ
?getInt64@Formattable@icu_56@@QBE_JXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+8]
		mov	edx, [ecx+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInt64@Formattable@icu_56@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *__hidden this)
		public ?getDate@Formattable@icu_56@@QBENXZ
?getDate@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDate@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 280h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *this, struct icu_56::UnicodeString *)
		public ?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Formattable::getArray(icu_56::Formattable *this,	int *)
		public ?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator[](int)
		public ??AFormattable@icu_56@@QAEAAV01@H@Z
??AFormattable@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		imul	eax, 0E0h
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??AFormattable@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 354h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::Formattable::getDigitList(icu_56::Formattable *__hidden this)
		public ?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *this, enum UErrorCode *)
		public ?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+98h], 0
		jz	short loc_3D5
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3D1
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 3

loc_3D1:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+42j
		fldz
		jmp	short loc_3DB
; ---------------------------------------------------------------------------

loc_3D5:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+2Dj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]

loc_3DB:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3F4h
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+35p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl	const &,UErrorCode &)+2F1p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp

loc_3FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 428h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden this)
		public ?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 458h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden	this)
		public ?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 488h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *this, enum UErrorCode *)
		public ?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z ; icu_56::Formattable::getLong(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 500h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *const *__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 530h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void **)
		public ?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 558h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void *const *)
		public ?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 580h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *__hidden this)
		public ??0FieldPosition@icu_56@@QAE@XZ
??0FieldPosition@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0FieldPosition@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5F4h
		dd offset ??_R4FieldPosition@icu_56@@6B@ ; const icu_56::FieldPosition::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`vftable'
??_7FieldPosition@icu_56@@6B@ dd offset	??_EFieldPosition@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FieldPosition::FieldPosition(void)+38o
					; icu_56::FieldPosition::FieldPosition(int)+38o ...
					; icu_56::FieldPosition::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ ; icu_56::FieldPosition::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 600h
		public ??_R4FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`RTTI Complete Object Locator'
??_R4FieldPosition@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000005F4o
		dd offset ??_R0?AVFieldPosition@icu_56@@@8 ; icu_56::FieldPosition `RTTI Type Descriptor'
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 614h
		public ??_R0?AVFieldPosition@icu_56@@@8
; class	icu_56::FieldPosition `RTTI Type Descriptor'
??_R0?AVFieldPosition@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000060Co
					; .rdata$r:icu_56::FieldPosition::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avfieldposit	db '.?AVFieldPosition@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 638h
		public ??_R3FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
??_R3FieldPosition@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00000610o
					; .rdata$r:00000670o
		dd 3
		dd offset ??_R2FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 648h
		public ??_R2FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Array'
??_R2FieldPosition@icu_56@@8 dd	offset ??_R1A@?0A@EA@FieldPosition@icu_56@@8
					; DATA XREF: .rdata$r:00000644o
					; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 658h
		public ??_R1A@?0A@EA@FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@FieldPosition@icu_56@@8 dd offset	??_R0?AVFieldPosition@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FieldPosition::`RTTI Base	Class Array'o
					; icu_56::FieldPosition	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 674h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:0000064Co
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 690h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6B0h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000068Co
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6C0h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000006BCo
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6CCh
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000650o
					; .rdata$r:000006C4o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6E8h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 708h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000006E4o
					; .rdata$r:00000738o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 718h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000714o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 720h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, int)
		public ??0FieldPosition@icu_56@@QAE@H@Z
??0FieldPosition@icu_56@@QAE@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, const struct icu_56::FieldPosition *)
		public ??0FieldPosition@icu_56@@QAE@ABV01@@Z
??0FieldPosition@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx

loc_7FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 830h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getField(icu_56::FieldPosition *__hidden this)
		public ?getField@FieldPosition@icu_56@@QBEHXZ
?getField@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getField@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 860h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getBeginIndex(icu_56::FieldPosition *__hidden this)
		public ?getBeginIndex@FieldPosition@icu_56@@QBEHXZ
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 890h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getEndIndex(icu_56::FieldPosition *__hidden this)
		public ?getEndIndex@FieldPosition@icu_56@@QBEHXZ
?getEndIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setField(icu_56::FieldPosition	*this, int)
		public ?setField@FieldPosition@icu_56@@QAEXH@Z
?setField@FieldPosition@icu_56@@QAEXH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setField@FieldPosition@icu_56@@QAEXH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setBeginIndex(icu_56::FieldPosition *this, int)
		public ?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 930h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setEndIndex(icu_56::FieldPosition *this, int)
		public ?setEndIndex@FieldPosition@icu_56@@QAEXH@Z
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 968h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`scalar deleting destructor'(unsigned int)
		public ??_GFieldPosition@icu_56@@UAEPAXI@Z
??_GFieldPosition@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_9B1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9B1:				; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`vector deleting destructor'(unsigned int)
		public ??_EFieldPosition@icu_56@@UAEPAXI@Z
??_EFieldPosition@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::FieldPosition::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_A37
		push	offset ??1FieldPosition@icu_56@@UAE@XZ ; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A2F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A2F:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_A60
; ---------------------------------------------------------------------------

loc_A37:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A5D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A5D:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_A60:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPosition &	__thiscall icu_56::FieldPosition::operator=(class icu_56::FieldPosition	const &)
		public ??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ACCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator==(class icu_56::FieldPosition const &)const
		public ??8FieldPosition@icu_56@@QBECABV01@@Z
??8FieldPosition@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::FieldPosition::operator!=(icu_56::FieldPosition const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_B22
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_B22
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jnz	short loc_B22
		mov	[ebp+var_CD], 1
		jmp	short loc_B29
; ---------------------------------------------------------------------------

loc_B22:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+2Fj
					; icu_56::FieldPosition::operator==(icu_56::FieldPosition const	&)+3Dj	...
		mov	[ebp+var_CD], 0

loc_B29:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+54j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8FieldPosition@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator!=(class icu_56::FieldPosition const &)const
		public ??9FieldPosition@icu_56@@QBECABV01@@Z
??9FieldPosition@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPosition@icu_56@@QBECABV01@@Z ;	icu_56::FieldPosition::operator==(icu_56::FieldPosition	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPosition@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPositionIterator::operator!=(class icu_56::FieldPositionIterator const &)const
		public ??9FieldPositionIterator@icu_56@@QBECABV01@@Z
??9FieldPositionIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPositionIterator@icu_56@@QBECABV01@@Z ;	icu_56::FieldPositionIterator::operator==(icu_56::FieldPositionIterator	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPositionIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPositionIterator &	__thiscall icu_56::FieldPositionIterator::operator=(class icu_56::FieldPositionIterator	const &)
		public ??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Format::operator!=(class icu_56::Format const &)const
		public ??9Format@icu_56@@QBECABV01@@Z
??9Format@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Format@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Measure::getNumber(icu_56::Measure *__hidden this)
		public ?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 8
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::MeasureUnit *__thiscall icu_56::Measure::getUnit(icu_56::Measure	*__hidden this)
		public ?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	proc near
					; CODE XREF: icu_56::CurrencyAmount::getCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0E8h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *__hidden this)
		public ??0MeasureUnit@icu_56@@QAE@XZ
??0MeasureUnit@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MeasureUnit@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D74h
		dd offset ??_R4MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`vftable'
??_7MeasureUnit@icu_56@@6B@ dd offset ??_EMeasureUnit@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::MeasureUnit::MeasureUnit(void)+38o
					; icu_56::MeasureUnit::MeasureUnit(int,int)+38o
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ ; icu_56::MeasureUnit::getDynamicClassID(void)
		dd offset ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ	; icu_56::MeasureUnit::clone(void)
		dd offset ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z ; icu_56::MeasureUnit::operator==(icu_56::UObject const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D88h
		public ??_R4MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`RTTI Complete Object Locator'
??_R4MeasureUnit@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000D74o
		dd offset ??_R0?AVMeasureUnit@icu_56@@@8 ; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0D9Ch
		public ??_R0?AVMeasureUnit@icu_56@@@8
; class	icu_56::MeasureUnit `RTTI Type Descriptor'
??_R0?AVMeasureUnit@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000D94o
					; .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avmeasureuni	db '.?AVMeasureUnit@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DC0h
		public ??_R3MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Class Hierarchy Descriptor'
??_R3MeasureUnit@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00000D98o
					; .rdata$r:00000DF8o
		dd 3
		dd offset ??_R2MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DD0h
		public ??_R2MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Array'
??_R2MeasureUnit@icu_56@@8 dd offset ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
					; DATA XREF: .rdata$r:00000DCCo
					; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DE0h
		public ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@MeasureUnit@icu_56@@8 dd offset ??_R0?AVMeasureUnit@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Array'o
					; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MeasureUnit::operator!=(class icu_56::UObject const &)const
		public ??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *this,	int, int)
		public ??0MeasureUnit@icu_56@@AAE@HH@Z
??0MeasureUnit@icu_56@@AAE@HH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0MeasureUnit@icu_56@@AAE@HH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`scalar deleting destructor'(unsigned int)
		public ??_GMeasureUnit@icu_56@@UAEPAXI@Z
??_GMeasureUnit@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F11
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F11:				; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`vector deleting destructor'(unsigned int)
		public ??_EMeasureUnit@icu_56@@UAEPAXI@Z
??_EMeasureUnit@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::MeasureUnit::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F97
		push	offset ??1MeasureUnit@icu_56@@UAE@XZ ; icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F8F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F8F:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_FC0
; ---------------------------------------------------------------------------

loc_F97:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_FBD
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_FBD:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_FC0:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyUnit::getISOCurrency(icu_56::CurrencyUnit *__hidden	this)
		public ?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+2Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]

loc_FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		add	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1008h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::CurrencyUnit *__thiscall	icu_56::CurrencyAmount::getCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	; icu_56::Measure::getUnit(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1048h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyAmount::getISOCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ ; icu_56::CurrencyAmount::getCurrency(void)
		mov	ecx, eax	; this
		call	?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ ; icu_56::CurrencyUnit::getISOCurrency(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1090h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		public ??0NumberFormatFactory@icu_56@@QAE@XZ
??0NumberFormatFactory@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0NumberFormatFactory@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10E8h
		dd offset ??_R4NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`vftable'
??_7NumberFormatFactory@icu_56@@6B@ dd offset ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::NumberFormatFactory::NumberFormatFactory(void)+38o
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+3Co
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1100h
		public ??_R4NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
??_R4NumberFormatFactory@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:000010E8o
		dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8 ; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1114h
		public ??_R0?AVNumberFormatFactory@icu_56@@@8
; class	icu_56::NumberFormatFactory `RTTI Type Descriptor'
??_R0?AVNumberFormatFactory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000110Co
					; .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avnumberform	db '.?AVNumberFormatFactory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1140h
		public ??_R3NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3NumberFormatFactory@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00001110o
					; .rdata$r:00001178o
		dd 3
		dd offset ??_R2NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1150h
		public ??_R2NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Array'
??_R2NumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:0000114Co
					; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1160h
		public ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Array'o
					; .rdata$r:000014B4o
					; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 117Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *this,	const struct icu_56::NumberFormatFactory *)
		public ??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::NumberFormatFactory & __thiscall icu_56::NumberFormatFactory::operator=(class icu_56::NumberFormatFactory const	&)
		public ??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 122Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`scalar deleting destructor'(unsigned int)
		public ??_GNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1275
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1275:				; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1290h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`vector deleting destructor'(unsigned int)
		public ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::NumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_12FB
		push	offset ??1NumberFormatFactory@icu_56@@UAE@XZ ; icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_12F3
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_12F3:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1324
; ---------------------------------------------------------------------------

loc_12FB:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1321
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1321:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1324:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 133Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *this, const	struct icu_56::SimpleNumberFormatFactory *)
		public ??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NumberFormatFactory *
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z ; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+4]
		mov	[eax+4], dl
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 13F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00001434o
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1418h
		dd offset ??_R4SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`vftable'
??_7SimpleNumberFormatFactory@icu_56@@6B@ dd offset ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+58o
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ ; icu_56::SimpleNumberFormatFactory::visible(void)
		dd offset ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z ; icu_56::SimpleNumberFormatFactory::getSupportedIDs(int &,UErrorCode &)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1430h
__unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001440o
		dd offset __unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 145Ch
		public ??_R4SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
??_R4SimpleNumberFormatFactory@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00001418o
		dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 ; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1470h
		public ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
; class	icu_56::SimpleNumberFormatFactory `RTTI	Type Descriptor'
??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001468o
					; .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avsimplenumb	db '.?AVSimpleNumberFormatFactory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 14A0h
		public ??_R3SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3SimpleNumberFormatFactory@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000146Co
					; .rdata$r:000014DCo
		dd 4
		dd offset ??_R2SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 14B0h
		public ??_R2SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Array'
??_R2SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:000014ACo
					; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 ;	icu_56::NumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 14C4h
		public ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'o
					; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`scalar deleting	destructor'(unsigned int)
		public ??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1529
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1529:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1544h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`vector deleting	destructor'(unsigned int)
		public ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::SimpleNumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_15AF
		push	offset ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	48h ; 'H'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_15A7
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_15A7:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_15D8
; ---------------------------------------------------------------------------

loc_15AF:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_15D5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_15D5:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_15D8:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isParseIntegerOnly(icu_56::NumberFormat *__hidden this)
		public ?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+154h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isLenient(icu_56::NumberFormat	*__hidden this)
		public ?isLenient@NumberFormat@icu_56@@UBECXZ
?isLenient@NumberFormat@icu_56@@UBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+155h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@NumberFormat@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1658h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::PluralRules::operator!=(class icu_56::PluralRules const &)const
		public ??9PluralRules@icu_56@@QBECABV01@@Z
??9PluralRules@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9PluralRules@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator!=(class	icu_56::DecimalFormatSymbols const &)const
		public ??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z ; icu_56::DecimalFormatSymbols::operator==(icu_56::DecimalFormatSymbols const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1704h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+255p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1738h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomIntlCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+28Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD1h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 176Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::DecimalFormatSymbols::getSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_E0], 0
		cmp	[ebp+arg_4], 1Ch
		jge	short loc_17B1
		mov	eax, [ebp+arg_4]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_17BC
; ---------------------------------------------------------------------------

loc_17B1:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+31j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_17BC:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+43j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		or	ecx, 1
		mov	[ebp+var_E0], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString const & __thiscall icu_56::DecimalFormatSymbols::getConstSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+26Cp
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+2A4p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_1837
		mov	eax, [ebp+arg_0]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_1842
; ---------------------------------------------------------------------------

loc_1837:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+27j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_1842:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+39j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1850h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DecimalFormatSymbols::setSymbol(enum	icu_56::DecimalFormatSymbols::ENumberFormatSymbol, class icu_56::UnicodeString const &,	signed char)
		public ?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z proc near

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= byte ptr -138h
var_2D		= byte ptr -2Dh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_0], 8
		jnz	short loc_18A7
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD0h], 1
		jmp	short loc_18B7
; ---------------------------------------------------------------------------

loc_18A7:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+49j
		cmp	[ebp+arg_0], 9
		jnz	short loc_18B7
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD1h], 1

loc_18B7:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+55j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+5Bj
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_18DD
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		lea	ecx, [edx+ecx+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_18DD:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+6Bj
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_19DE
		cmp	[ebp+arg_0], 4
		jnz	loc_19DE
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	loc_19DE
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax
		call	_u_charDigitValue_56
		add	esp, 4
		test	eax, eax
		jnz	loc_19DE
		mov	[ebp+var_2D], 1
		jmp	short loc_194E
; ---------------------------------------------------------------------------

loc_1946:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+189j
		mov	al, [ebp+var_2D]
		add	al, 1
		mov	[ebp+var_2D], al

loc_194E:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+F4j
		movsx	eax, [ebp+var_2D]
		cmp	eax, 9
		jg	loc_19DE
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@H@Z ; icu_56::UnicodeString::UnicodeString(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	ecx, [ebp+var_140]
		mov	[ebp+var_144], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	edx, [ebp+var_144]
		push	edx
		movsx	eax, [ebp+var_2D]
		add	eax, 11h
		shl	eax, 6
		mov	ecx, [ebp+var_18]
		lea	ecx, [ecx+eax+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1946
; ---------------------------------------------------------------------------

loc_19DE:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+93j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+9Dj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1A0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 proc near
					; DATA XREF: .xdata$x:00001A50o
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	proc near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1A4Ch
__unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001A5Co
		dd offset __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0
__ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+1Eo
		dd offset __unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Locale __thiscall icu_56::DecimalFormatSymbols::getLocale(void)const
		public ?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+97p
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+116p ...

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+var_8]
		add	eax, 744h
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::DecimalFormatSymbols::getCurrencyPattern(icu_56::DecimalFormatSymbols *__hidden this)
		public ?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+94Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DigitList::operator!=(class icu_56::DigitList const &)const
		public ??9DigitList@icu_56@@QBECABV01@@Z
??9DigitList@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DigitList@icu_56@@QBECABV01@@Z ; icu_56::DigitList::operator==(icu_56::DigitList const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DigitList@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isNaN(icu_56::DigitList *__hidden	this)
		public ?isNaN@DigitList@icu_56@@QBECXZ
?isNaN@DigitList@icu_56@@QBECXZ	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 30h
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNaN@DigitList@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isInfinite(icu_56::DigitList *__hidden this)
		public ?isInfinite@DigitList@icu_56@@QBECXZ
?isInfinite@DigitList@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+54p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 40h
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isInfinite@DigitList@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::setToZero(icu_56::DigitList *__hidden this)
		public ?setToZero@DigitList@icu_56@@QAEXXZ
?setToZero@DigitList@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		push	ecx
		call	_uprv_decNumberZero_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToZero@DigitList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::digits(icu_56::DigitList *__hidden this)
		public ?digits@DigitList@icu_56@@QBEHXZ
?digits@DigitList@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?digits@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitList::isPositive(icu_56::DigitList *__hidden this)
		public ?isPositive@DigitList@icu_56@@QBECXZ
?isPositive@DigitList@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		movzx	edx, byte ptr [ecx+8]
		and	edx, 80h
		neg	edx
		sbb	edx, edx
		neg	edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isPositive@DigitList@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitList::getLowerExponent(icu_56::DigitList *__hidden this)
		public ?getLowerExponent@DigitList@icu_56@@QBEHXZ
?getLowerExponent@DigitList@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+18Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+1Ch]
		mov	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLowerExponent@DigitList@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void *	__cdecl	icu_56::DigitList::operator new(unsigned int, void *, enum  icu_56::EStackMode)
		public ??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z
??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z	proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2DigitList@icu_56@@SAPAXIPAXW4EStackMode@1@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::DigitList::operator delete(void *)
		public ??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z
??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3DigitList@icu_56@@SAXPAX0W4EStackMode@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalSetDouble(icu_56::DigitList *this,	double)
		public ?internalSetDouble@DigitList@icu_56@@AAEXN@Z
?internalSetDouble@DigitList@icu_56@@AAEXN@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 1
		mov	eax, [ebp+var_8]
		fld	[ebp+arg_0]
		fstp	qword ptr [eax+60h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetDouble@DigitList@icu_56@@AAEXN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalSetInt64(icu_56::DigitList	*this, __int64)
		public ?internalSetInt64@DigitList@icu_56@@AAEX_J@Z
?internalSetInt64@DigitList@icu_56@@AAEX_J@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 2
		mov	eax, [ebp+var_8]
		mov	ecx, dword ptr [ebp+arg_0]
		mov	[eax+60h], ecx
		mov	edx, dword ptr [ebp+arg_0+4]
		mov	[eax+64h], edx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?internalSetInt64@DigitList@icu_56@@AAEX_J@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitList::internalClear(icu_56::DigitList *__hidden this)
		public ?internalClear@DigitList@icu_56@@AAEXXZ
?internalClear@DigitList@icu_56@@AAEXXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+68h], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?internalClear@DigitList@icu_56@@AAEXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitAffix::countChar32(icu_56::DigitAffix *__hidden this)
		public ?countChar32@DigitAffix@icu_56@@QBEHXZ
?countChar32@DigitAffix@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?countChar32@DigitAffix@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::DigitAffix::toString(icu_56::DigitAffix *__hidden this)
		public ?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ
?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ proc near
					; CODE XREF: icu_56::DigitFormatter::countChar32ForNaN(void)+35p
					; icu_56::DigitFormatter::countChar32ForInfinity(void)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitAffix::equals(icu_56::DigitAffix *this,	const struct icu_56::DigitAffix	*)
		public ?equals@DigitAffix@icu_56@@QBECABV12@@Z
?equals@DigitAffix@icu_56@@QBECABV12@@Z	proc near
					; CODE XREF: icu_56::PluralAffix::eq(icu_56::DigitAffix	const &,icu_56::DigitAffix const &)+25p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1ED0
		mov	edx, [ebp+arg_0]
		add	edx, 40h ; '@'
		mov	esi, esp
		push	edx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_1ED0
		mov	[ebp+var_CD], 1
		jmp	short loc_1ED7
; ---------------------------------------------------------------------------

loc_1ED0:				; CODE XREF: icu_56::DigitAffix::equals(icu_56::DigitAffix const &)+3Ej
					; icu_56::DigitAffix::equals(icu_56::DigitAffix	const &)+61j
		mov	[ebp+var_CD], 0

loc_1ED7:				; CODE XREF: icu_56::DigitAffix::equals(icu_56::DigitAffix const &)+6Aj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitAffix@icu_56@@QBECABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitAffix::~DigitAffix(icu_56::DigitAffix *__hidden this)
		public ??1DigitAffix@icu_56@@QAE@XZ
??1DigitAffix@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::DigitFormatter::~DigitFormatter(void)+6Ep
					; icu_56::DigitFormatter::~DigitFormatter(void)+80p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DigitAffix@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DigitAffix@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1F8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitAffix@icu_56@@QAE@XZ$0 proc near ; DATA	XREF: .xdata$x:00001FC0o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DigitAffix@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DigitAffix@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::DigitAffix::~DigitAffix(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DigitAffix@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DigitAffix@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1FBCh
__unwindtable$??1DigitAffix@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA	XREF: .xdata$x:00001FCCo
		dd offset __unwindfunclet$??1DigitAffix@icu_56@@QAE@XZ$0
__ehfuncinfo$??1DigitAffix@icu_56@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??1DigitAffix@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1DigitAffix@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix *this, const struct icu_56::DigitAffix *)
		public ??0DigitAffix@icu_56@@QAE@ABV01@@Z
??0DigitAffix@icu_56@@QAE@ABV01@@Z proc	near
					; CODE XREF: icu_56::DigitFormatter::DigitFormatter(icu_56::DigitFormatter const &)+EEp
					; icu_56::DigitFormatter::DigitFormatter(icu_56::DigitFormatter	const &)+109p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DigitAffix@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx

loc_2000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0DigitAffix@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2090h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffix@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000020C4o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DigitAffix@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DigitAffix@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DigitAffix@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DigitAffix@icu_56@@QAE@ABV01@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 20C0h
__unwindtable$??0DigitAffix@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000020D0o
		dd offset __unwindfunclet$??0DigitAffix@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DigitAffix@icu_56@@QAE@ABV01@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0DigitAffix@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0DigitAffix@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix & __thiscall	icu_56::DigitAffix::operator=(class icu_56::DigitAffix const &)
		public ??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z
??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z	proc near
					; CODE XREF: icu_56::DigitFormatter::operator=(icu_56::DigitFormatter const &)+DBp
					; icu_56::DigitFormatter::operator=(icu_56::DigitFormatter const &)+F2p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 215Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix *__hidden this)
		public ??0PluralAffix@icu_56@@QAE@XZ
??0PluralAffix@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(void)+45p
					; icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(void)+5Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ ; icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0PluralAffix@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix *this,	const struct icu_56::DigitAffix	*)
		public ??0PluralAffix@icu_56@@QAE@ABVDigitAffix@1@@Z
??0PluralAffix@icu_56@@QAE@ABVDigitAffix@1@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_8]
		call	??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::DigitAffix const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralAffix@icu_56@@QAE@ABVDigitAffix@1@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::DigitAffix *__thiscall icu_56::PluralAffix::getOtherVariant(icu_56::PluralAffix *__hidden this)
		public ?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ
?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::getPositivePrefix(icu_56::UnicodeString	&)+2Cp
					; icu_56::DecimalFormatImpl::getPositiveSuffix(icu_56::UnicodeString &)+2Cp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getOther@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@XZ ; icu_56::PluralMap<icu_56::DigitAffix>::getOther(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2228h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::PluralAffix::equals(icu_56::PluralAffix *this, const	struct icu_56::PluralAffix *)
		public ?equals@PluralAffix@icu_56@@QBECABV12@@Z
?equals@PluralAffix@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::CurrencyAffixInfo::equals(icu_56::CurrencyAffixInfo const &)+76p
					; icu_56::DigitAffixesAndPadding::equals(icu_56::DigitAffixesAndPadding	const &)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	offset ?eq@PluralAffix@icu_56@@CACABVDigitAffix@2@0@Z ;	icu_56::PluralAffix::eq(icu_56::DigitAffix const &,icu_56::DigitAffix const &)
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?equals@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBECABV12@P6ACABVDigitAffix@2@1@Z@Z ; icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@PluralAffix@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2274h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::PluralAffix::eq(const struct icu_56::DigitAffix	*, const struct	icu_56::DigitAffix *)
		public ?eq@PluralAffix@icu_56@@CACABVDigitAffix@2@0@Z
?eq@PluralAffix@icu_56@@CACABVDigitAffix@2@0@Z proc near
					; DATA XREF: icu_56::PluralAffix::equals(icu_56::PluralAffix const &)+23o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+arg_0] ; this
		call	?equals@DigitAffix@icu_56@@QBECABV12@@Z	; icu_56::DigitAffix::equals(icu_56::DigitAffix	const &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?eq@PluralAffix@icu_56@@CACABVDigitAffix@2@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAffix::~PluralAffix(icu_56::PluralAffix *__hidden this)
		public ??1PluralAffix@icu_56@@QAE@XZ
??1PluralAffix@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)+52p
					; __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$0+3j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ ; icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1PluralAffix@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix *this,	const struct icu_56::PluralAffix *)
		public ??0PluralAffix@icu_56@@QAE@ABV01@@Z
??0PluralAffix@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::CurrencyAffixInfo::CurrencyAffixInfo(icu_56::CurrencyAffixInfo const &)+91p
					; icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(icu_56::DigitAffixesAndPadding	const &)+49p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_8]
		call	??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix> const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralAffix@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 233Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralAffix & __thiscall icu_56::PluralAffix::operator=(class icu_56::PluralAffix const	&)
		public ??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z
??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::CurrencyAffixInfo::operator=(icu_56::CurrencyAffixInfo const &)+67p
					; icu_56::DigitAffixesAndPadding::operator=(icu_56::DigitAffixesAndPadding const &)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::CurrencyAffixInfo::getSymbol(icu_56::CurrencyAffixInfo	*__hidden this)
		public ?getSymbol@CurrencyAffixInfo@icu_56@@QBEABVUnicodeString@2@XZ
?getSymbol@CurrencyAffixInfo@icu_56@@QBEABVUnicodeString@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getSymbol@CurrencyAffixInfo@icu_56@@QBEABVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::CurrencyAffixInfo::getISO(icu_56::CurrencyAffixInfo *__hidden this)
		public ?getISO@CurrencyAffixInfo@icu_56@@QBEABVUnicodeString@2@XZ
?getISO@CurrencyAffixInfo@icu_56@@QBEABVUnicodeString@2@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 40h ; '@'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getISO@CurrencyAffixInfo@icu_56@@QBEABVUnicodeString@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::PluralAffix *__thiscall icu_56::CurrencyAffixInfo::getLong(icu_56::CurrencyAffixInfo *__hidden this)
		public ?getLong@CurrencyAffixInfo@icu_56@@QBEABVPluralAffix@2@XZ
?getLong@CurrencyAffixInfo@icu_56@@QBEABVPluralAffix@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 80h ; ''
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLong@CurrencyAffixInfo@icu_56@@QBEABVPluralAffix@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2418h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::CurrencyAffixInfo::setSymbol(icu_56::CurrencyAffixInfo *this,	const struct icu_56::UnicodeString *)
		public ?setSymbol@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z
?setSymbol@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+27Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+118h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setSymbol@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2474h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::CurrencyAffixInfo::setISO(icu_56::CurrencyAffixInfo *this, const struct icu_56::UnicodeString	*)
		public ?setISO@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z
?setISO@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+2B3p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+118h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setISO@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CurrencyAffixInfo::equals(icu_56::CurrencyAffixInfo *this, const struct icu_56::CurrencyAffixInfo *)
		public ?equals@CurrencyAffixInfo@icu_56@@QBECABV12@@Z
?equals@CurrencyAffixInfo@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+1D6p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2573
		mov	edx, [ebp+arg_0]
		add	edx, 40h ; '@'
		mov	esi, esp
		push	edx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_2573
		mov	ecx, [ebp+arg_0]
		add	ecx, 80h ; ''
		push	ecx		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_8]
		add	ecx, 80h ; ''  ; this
		call	?equals@PluralAffix@icu_56@@QBECABV12@@Z ; icu_56::PluralAffix::equals(icu_56::PluralAffix const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_2573
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+118h]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx+118h]
		cmp	ecx, eax
		jnz	short loc_2573
		mov	[ebp+var_CD], 1
		jmp	short loc_257A
; ---------------------------------------------------------------------------

loc_2573:				; CODE XREF: icu_56::CurrencyAffixInfo::equals(icu_56::CurrencyAffixInfo const &)+3Ej
					; icu_56::CurrencyAffixInfo::equals(icu_56::CurrencyAffixInfo const &)+61j ...
		mov	[ebp+var_CD], 0

loc_257A:				; CODE XREF: icu_56::CurrencyAffixInfo::equals(icu_56::CurrencyAffixInfo const &)+A1j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@CurrencyAffixInfo@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2598h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CurrencyAffixInfo::isDefault(icu_56::CurrencyAffixInfo *__hidden this)
		public ?isDefault@CurrencyAffixInfo@icu_56@@QBECXZ
?isDefault@CurrencyAffixInfo@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+88p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+118h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isDefault@CurrencyAffixInfo@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(icu_56::CurrencyAffixInfo *__hidden this)
		public ??1CurrencyAffixInfo@icu_56@@QAE@XZ
??1CurrencyAffixInfo@icu_56@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$7+9j
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$7+9j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1CurrencyAffixInfo@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 80h ; ''  ; this
		call	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1CurrencyAffixInfo@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2674h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1CurrencyAffixInfo@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000026C0o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1CurrencyAffixInfo@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1CurrencyAffixInfo@icu_56@@QAE@XZ$1 proc near
					; DATA XREF: .xdata$x:000026C8o
		mov	ecx, [ebp-14h]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1CurrencyAffixInfo@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1CurrencyAffixInfo@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1CurrencyAffixInfo@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1CurrencyAffixInfo@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 26BCh
__unwindtable$??1CurrencyAffixInfo@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000026D4o
		dd offset __unwindfunclet$??1CurrencyAffixInfo@icu_56@@QAE@XZ$0
		align 8
		dd offset __unwindfunclet$??1CurrencyAffixInfo@icu_56@@QAE@XZ$1
__ehfuncinfo$??1CurrencyAffixInfo@icu_56@@QAE@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$??1CurrencyAffixInfo@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1CurrencyAffixInfo@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CurrencyAffixInfo::CurrencyAffixInfo(icu_56::CurrencyAffixInfo *this, const	struct icu_56::CurrencyAffixInfo *)
		public ??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z
??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+1E0p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		add	eax, 80h ; ''
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_14]
		add	ecx, 80h ; ''  ; this
		call	??0PluralAffix@icu_56@@QAE@ABV01@@Z ; icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix const &)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+118h]
		mov	[eax+118h], dl
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 27C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00002810o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00002818o
		mov	ecx, [ebp-14h]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::CurrencyAffixInfo::CurrencyAffixInfo(icu_56::CurrencyAffixInfo const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 280Ch
__unwindtable$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002824o
		dd offset __unwindfunclet$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z$0
		align 8
		dd offset __unwindfunclet$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2840h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::CurrencyAffixInfo & __thiscall icu_56::CurrencyAffixInfo::operator=(class icu_56::CurrencyAffixInfo const &)
		public ??4CurrencyAffixInfo@icu_56@@QAEAAV01@ABV01@@Z
??4CurrencyAffixInfo@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+1B9p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 80h ; ''
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 80h ; ''
		call	??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralAffix::operator=(icu_56::PluralAffix const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+118h]
		mov	[eax+118h], dl
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4CurrencyAffixInfo@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern *__hidden this)
		public ??0AffixPattern@icu_56@@QAE@XZ
??0AffixPattern@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+AAp
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale const &,icu_56::UnicodeString const &,UErrorCode &)+BCp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0AffixPattern@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+80h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+81h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+82h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+84h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0AffixPattern@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 299Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AffixPattern@icu_56@@QAE@XZ$0 proc near ; DATA XREF:	.xdata$x:000029D0o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AffixPattern@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0AffixPattern@icu_56@@QAE@XZ proc	near
					; DATA XREF: icu_56::AffixPattern::AffixPattern(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0AffixPattern@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0AffixPattern@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 29CCh
__unwindtable$??0AffixPattern@icu_56@@QAE@XZ dd	0FFFFFFFFh ; DATA XREF:	.xdata$x:000029DCo
		dd offset __unwindfunclet$??0AffixPattern@icu_56@@QAE@XZ$0
__ehfuncinfo$??0AffixPattern@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0AffixPattern@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0AffixPattern@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AffixPattern::usesCurrency(icu_56::AffixPattern *__hidden this)
		public ?usesCurrency@AffixPattern@icu_56@@QBECXZ
?usesCurrency@AffixPattern@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+3Bp
					; icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+50p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+80h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?usesCurrency@AffixPattern@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AffixPattern::usesPercent(icu_56::AffixPattern *__hidden this)
		public ?usesPercent@AffixPattern@icu_56@@QBECXZ
?usesPercent@AffixPattern@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+2Cp
					; icu_56::DecimalFormatImpl::getPatternScale(void)+41p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+81h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?usesPercent@AffixPattern@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AffixPattern::usesPermill(icu_56::AffixPattern *__hidden this)
		public ?usesPermill@AffixPattern@icu_56@@QBECXZ
?usesPermill@AffixPattern@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+A8p
					; icu_56::DecimalFormatImpl::getPatternScale(void)+BDp	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+82h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?usesPermill@AffixPattern@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::AffixPattern::countChar32(icu_56::AffixPattern	*__hidden this)
		public ?countChar32@AffixPattern@icu_56@@QBEHXZ
?countChar32@AffixPattern@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+289p
					; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString	const &,signed char,UParseError	&,UErrorCode &)+29Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+84h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?countChar32@AffixPattern@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AffixPattern::equals(icu_56::AffixPattern *this, const struct icu_56::AffixPattern *)
		public ?equals@AffixPattern@icu_56@@QBECABV12@@Z
?equals@AffixPattern@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+110p
					; icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const	&)+133p ...

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_2B94
		mov	edx, [ebp+arg_0]
		add	edx, 40h ; '@'
		mov	esi, esp
		push	edx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_2B94
		mov	ecx, [ebp+var_8]
		movsx	edx, byte ptr [ecx+80h]
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+80h]
		cmp	edx, ecx
		jnz	short loc_2B94
		mov	edx, [ebp+var_8]
		movsx	eax, byte ptr [edx+81h]
		mov	ecx, [ebp+arg_0]
		movsx	edx, byte ptr [ecx+81h]
		cmp	eax, edx
		jnz	short loc_2B94
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+82h]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx+82h]
		cmp	ecx, eax
		jnz	short loc_2B94
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+84h]
		cmp	eax, [edx+84h]
		jnz	short loc_2B94
		mov	[ebp+var_CD], 1
		jmp	short loc_2B9B
; ---------------------------------------------------------------------------

loc_2B94:				; CODE XREF: icu_56::AffixPattern::equals(icu_56::AffixPattern const &)+3Ej
					; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)+65j ...
		mov	[ebp+var_CD], 0

loc_2B9B:				; CODE XREF: icu_56::AffixPattern::equals(icu_56::AffixPattern const &)+CAj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@AffixPattern@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AffixPattern::~AffixPattern(icu_56::AffixPattern *__hidden this)
		public ??1AffixPattern@icu_56@@QAE@XZ
??1AffixPattern@icu_56@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$2+9j
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$3+9j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1AffixPattern@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1AffixPattern@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2C50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1AffixPattern@icu_56@@QAE@XZ$0 proc near ; DATA XREF:	.xdata$x:00002C84o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1AffixPattern@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1AffixPattern@icu_56@@QAE@XZ proc	near
					; DATA XREF: icu_56::AffixPattern::~AffixPattern(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1AffixPattern@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1AffixPattern@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2C80h
__unwindtable$??1AffixPattern@icu_56@@QAE@XZ dd	0FFFFFFFFh ; DATA XREF:	.xdata$x:00002C90o
		dd offset __unwindfunclet$??1AffixPattern@icu_56@@QAE@XZ$0
__ehfuncinfo$??1AffixPattern@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1AffixPattern@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1AffixPattern@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern *this, const struct	icu_56::AffixPattern *)
		public ??0AffixPattern@icu_56@@QAE@ABV01@@Z
??0AffixPattern@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+116p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl	const &,UErrorCode &)+131p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0AffixPattern@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+80h]
		mov	[eax+80h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+81h]
		mov	[eax+81h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+82h]
		mov	[eax+82h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+84h]
		mov	[eax+84h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0AffixPattern@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2D9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AffixPattern@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00002DD0o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AffixPattern@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0AffixPattern@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0AffixPattern@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0AffixPattern@icu_56@@QAE@ABV01@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2DCCh
__unwindtable$??0AffixPattern@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002DDCo
		dd offset __unwindfunclet$??0AffixPattern@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0AffixPattern@icu_56@@QAE@ABV01@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0AffixPattern@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0AffixPattern@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::AffixPattern & __thiscall icu_56::AffixPattern::operator=(class	icu_56::AffixPattern const &)
		public ??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z
??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+122p
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+139p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+80h]
		mov	[eax+80h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+81h]
		mov	[eax+81h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+82h]
		mov	[eax+82h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+84h]
		mov	[eax+84h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AffixPatternIterator::AffixPatternIterator(icu_56::AffixPatternIterator *__hidden this)
		public ??0AffixPatternIterator@icu_56@@QAE@XZ
??0AffixPatternIterator@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0AffixPatternIterator@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::AffixPatternParser::equals(icu_56::AffixPatternParser *this,	const struct icu_56::AffixPatternParser	*)
		public ?equals@AffixPatternParser@icu_56@@QBECABV12@@Z
?equals@AffixPatternParser@icu_56@@QBECABV12@@Z	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+1B3p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2FCD
		mov	edx, [ebp+arg_0]
		add	edx, 40h ; '@'
		mov	esi, esp
		push	edx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_2FCD
		mov	ecx, [ebp+arg_0]
		add	ecx, 80h ; ''
		mov	esi, esp
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 80h ; ''
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		test	edx, edx
		jz	short loc_2FCD
		mov	eax, [ebp+arg_0]
		add	eax, 0C0h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 0C0h ; ''
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_2FCD
		mov	[ebp+var_CD], 1
		jmp	short loc_2FD4
; ---------------------------------------------------------------------------

loc_2FCD:				; CODE XREF: icu_56::AffixPatternParser::equals(icu_56::AffixPatternParser const &)+3Ej
					; icu_56::AffixPatternParser::equals(icu_56::AffixPatternParser	const &)+61j ...
		mov	[ebp+var_CD], 0

loc_2FD4:				; CODE XREF: icu_56::AffixPatternParser::equals(icu_56::AffixPatternParser const &)+BBj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@AffixPatternParser@icu_56@@QBECABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AffixPatternParser::~AffixPatternParser(icu_56::AffixPatternParser *__hidden this)
		public ??1AffixPatternParser@icu_56@@QAE@XZ
??1AffixPatternParser@icu_56@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$6+9j
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$6+9j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1AffixPatternParser@icu_56@@QAE@XZ
		mov	eax, large fs:0

loc_3000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 0C0h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 80h ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1AffixPatternParser@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 30C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00003124o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$1 proc near
					; DATA XREF: .xdata$x:0000312Co
		mov	ecx, [ebp-14h]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$2 proc near
					; DATA XREF: .xdata$x:00003134o
		mov	ecx, [ebp-14h]
		add	ecx, 80h ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1AffixPatternParser@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::AffixPatternParser::~AffixPatternParser(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1AffixPatternParser@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1AffixPatternParser@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3120h
__unwindtable$??1AffixPatternParser@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003140o
		dd offset __unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1AffixPatternParser@icu_56@@QAE@XZ$2
__ehfuncinfo$??1AffixPatternParser@icu_56@@QAE@XZ dd 19930522h,	3
					; DATA XREF: __ehhandler$??1AffixPatternParser@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1AffixPatternParser@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 315Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::AffixPatternParser::AffixPatternParser(icu_56::AffixPatternParser *this, const struct icu_56::AffixPatternParser *)
		public ??0AffixPatternParser@icu_56@@QAE@ABV01@@Z
??0AffixPatternParser@icu_56@@QAE@ABV01@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+1C5p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		add	eax, 80h ; ''
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 80h ; ''  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+arg_0]
		add	eax, 0C0h ; ''
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 0C0h ; '' ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0AffixPatternParser@icu_56@@QAE@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 324Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000032B0o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:000032B8o
		mov	ecx, [ebp-14h]
		add	ecx, 40h ; '@'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$2 proc near
					; DATA XREF: .xdata$x:000032C0o
		mov	ecx, [ebp-14h]
		add	ecx, 80h ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::AffixPatternParser::AffixPatternParser(icu_56::AffixPatternParser const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 32ACh
__unwindtable$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000032CCo
		dd offset __unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$0
		align 8
		dd offset __unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$1
		dd 1
		dd offset __unwindfunclet$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z$2
__ehfuncinfo$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z	dd 19930522h, 3
					; DATA XREF: __ehhandler$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0AffixPatternParser@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::AffixPatternParser & __thiscall	icu_56::AffixPatternParser::operator=(class icu_56::AffixPatternParser const &)
		public ??4AffixPatternParser@icu_56@@QAEAAV01@ABV01@@Z
??4AffixPatternParser@icu_56@@QAEAAV01@ABV01@@Z	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+1A2p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 40h ; '@'
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 80h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 80h ; ''
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 0C0h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 0C0h ; ''
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4AffixPatternParser@icu_56@@QAEAAV01@ABV01@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(icu_56::DigitAffixesAndPadding *__hidden this)
		public ??0DigitAffixesAndPadding@icu_56@@QAE@XZ
??0DigitAffixesAndPadding@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+187p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+183p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::PluralAffix(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''  ; this
		call	??0PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::PluralAffix(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 130h	; this
		call	??0PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::PluralAffix(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 1C8h	; this
		call	??0PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::PluralAffix(void)
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+260h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+264h], 2Ah ; '*'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+268h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0DigitAffixesAndPadding@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 346Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$0 proc	near
					; DATA XREF: .xdata$x:000034B4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$1 proc	near
					; DATA XREF: .xdata$x:000034BCo
		mov	ecx, [ebp-14h]
		add	ecx, 98h ; ''  ; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$2 proc	near
					; DATA XREF: .xdata$x:000034C4o
		mov	ecx, [ebp-14h]
		add	ecx, 130h	; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DigitAffixesAndPadding@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 34B0h
__unwindtable$??0DigitAffixesAndPadding@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000034D0o
		dd offset __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@XZ$2
__ehfuncinfo$??0DigitAffixesAndPadding@icu_56@@QAE@XZ dd 19930522h, 3
					; DATA XREF: __ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0DigitAffixesAndPadding@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitAffixesAndPadding::equals(icu_56::DigitAffixesAndPadding *this,	const struct icu_56::DigitAffixesAndPadding *)
		public ?equals@DigitAffixesAndPadding@icu_56@@QBECABV12@@Z
?equals@DigitAffixesAndPadding@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+283p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_8] ; this
		call	?equals@PluralAffix@icu_56@@QBECABV12@@Z ; icu_56::PluralAffix::equals(icu_56::PluralAffix const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_35CB
		mov	edx, [ebp+arg_0]
		add	edx, 98h ; ''
		push	edx		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?equals@PluralAffix@icu_56@@QBECABV12@@Z ; icu_56::PluralAffix::equals(icu_56::PluralAffix const &)
		movsx	eax, al
		test	eax, eax
		jz	loc_35CB
		mov	ecx, [ebp+arg_0]
		add	ecx, 130h
		push	ecx		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_8]
		add	ecx, 130h	; this
		call	?equals@PluralAffix@icu_56@@QBECABV12@@Z ; icu_56::PluralAffix::equals(icu_56::PluralAffix const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_35CB
		mov	eax, [ebp+arg_0]
		add	eax, 1C8h
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_8]
		add	ecx, 1C8h	; this
		call	?equals@PluralAffix@icu_56@@QBECABV12@@Z ; icu_56::PluralAffix::equals(icu_56::PluralAffix const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_35CB
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+260h]
		cmp	ecx, [eax+260h]
		jnz	short loc_35CB
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+268h]
		cmp	ecx, [eax+268h]
		jnz	short loc_35CB
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+264h]
		cmp	ecx, [eax+264h]
		jnz	short loc_35CB
		mov	[ebp+var_CD], 1
		jmp	short loc_35D2
; ---------------------------------------------------------------------------

loc_35CB:				; CODE XREF: icu_56::DigitAffixesAndPadding::equals(icu_56::DigitAffixesAndPadding const &)+34j
					; icu_56::DigitAffixesAndPadding::equals(icu_56::DigitAffixesAndPadding	const &)+57j ...
		mov	[ebp+var_CD], 0

loc_35D2:				; CODE XREF: icu_56::DigitAffixesAndPadding::equals(icu_56::DigitAffixesAndPadding const &)+DDj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitAffixesAndPadding@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(icu_56::DigitAffixesAndPadding *__hidden this)
		public ??1DigitAffixesAndPadding@icu_56@@QAE@XZ
??1DigitAffixesAndPadding@icu_56@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$10+9j
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$10+9j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DigitAffixesAndPadding@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 1C8h	; this
		call	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 130h	; this
		call	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''  ; this
		call	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DigitAffixesAndPadding@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 369Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$0 proc	near
					; DATA XREF: .xdata$x:000036E4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$1 proc	near
					; DATA XREF: .xdata$x:000036ECo
		mov	ecx, [ebp-14h]
		add	ecx, 98h ; ''  ; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$2 proc	near
					; DATA XREF: .xdata$x:000036F4o
		mov	ecx, [ebp-14h]
		add	ecx, 130h	; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DigitAffixesAndPadding@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DigitAffixesAndPadding@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DigitAffixesAndPadding@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 36E0h
__unwindtable$??1DigitAffixesAndPadding@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003700o
		dd offset __unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1DigitAffixesAndPadding@icu_56@@QAE@XZ$2
__ehfuncinfo$??1DigitAffixesAndPadding@icu_56@@QAE@XZ dd 19930522h, 3
					; DATA XREF: __ehhandler$??1DigitAffixesAndPadding@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1DigitAffixesAndPadding@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 371Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(icu_56::DigitAffixesAndPadding *this, const struct icu_56::DigitAffixesAndPadding *)
		public ??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z
??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+266p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_14] ; this
		call	??0PluralAffix@icu_56@@QAE@ABV01@@Z ; icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		add	eax, 98h ; ''
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''  ; this
		call	??0PluralAffix@icu_56@@QAE@ABV01@@Z ; icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix const &)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		add	eax, 130h
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_14]
		add	ecx, 130h	; this
		call	??0PluralAffix@icu_56@@QAE@ABV01@@Z ; icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix const &)
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+arg_0]
		add	eax, 1C8h
		push	eax		; struct icu_56::PluralAffix *
		mov	ecx, [ebp+var_14]
		add	ecx, 1C8h	; this
		call	??0PluralAffix@icu_56@@QAE@ABV01@@Z ; icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix const &)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+260h]
		mov	[eax+260h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+264h]
		mov	[eax+264h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+268h]
		mov	[eax+268h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3820h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00003868o
		mov	ecx, [ebp-14h]	; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00003870o
		mov	ecx, [ebp-14h]
		add	ecx, 98h ; ''  ; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$2 proc near
					; DATA XREF: .xdata$x:00003878o
		mov	ecx, [ebp-14h]
		add	ecx, 130h	; this
		jmp	??1PluralAffix@icu_56@@QAE@XZ ;	icu_56::PluralAffix::~PluralAffix(void)
__unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z proc	near
					; DATA XREF: icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(icu_56::DigitAffixesAndPadding const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3864h
__unwindtable$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00003884o
		dd offset __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$0
		align 10h
		dd offset __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$1
		dd 1
		dd offset __unwindfunclet$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z$2
__ehfuncinfo$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffixesAndPadding & __thiscall icu_56::DigitAffixesAndPadding::operator=(class icu_56::DigitAffixesAndPadding const &)
		public ??4DigitAffixesAndPadding@icu_56@@QAEAAV01@ABV01@@Z
??4DigitAffixesAndPadding@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+233p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralAffix::operator=(icu_56::PluralAffix const &)
		mov	eax, [ebp+arg_0]
		add	eax, 98h ; ''
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''
		call	??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralAffix::operator=(icu_56::PluralAffix const &)
		mov	eax, [ebp+arg_0]
		add	eax, 130h
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 130h
		call	??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralAffix::operator=(icu_56::PluralAffix const &)
		mov	eax, [ebp+arg_0]
		add	eax, 1C8h
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1C8h
		call	??4PluralAffix@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralAffix::operator=(icu_56::PluralAffix const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+260h]
		mov	[eax+260h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+264h]
		mov	[eax+264h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+268h]
		mov	[eax+268h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitAffixesAndPadding@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3964h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitFormatterOptions::DigitFormatterOptions(icu_56::DigitFormatterOptions *__hidden this)
		public ??0DigitFormatterOptions@icu_56@@QAE@XZ
??0DigitFormatterOptions@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::SciFormatterOptions::SciFormatterOptions(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0DigitFormatterOptions@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3998h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitFormatterOptions::equals(icu_56::DigitFormatterOptions *this, const struct icu_56::DigitFormatterOptions *)
		public ?equals@DigitFormatterOptions@icu_56@@QBECABV12@@Z
?equals@DigitFormatterOptions@icu_56@@QBECABV12@@Z proc	near
					; CODE XREF: icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx]
		cmp	ecx, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitFormatterOptions@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitFormatterOptions::isFastFormattable(icu_56::DigitFormatterOptions *__hidden this)
		public ?isFastFormattable@DigitFormatterOptions@icu_56@@QBECXZ
?isFastFormattable@DigitFormatterOptions@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isFastFormattable@DigitFormatterOptions@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitFormatterOptions &	__thiscall icu_56::DigitFormatterOptions::operator=(class icu_56::DigitFormatterOptions	const &)
		public ??4DigitFormatterOptions@icu_56@@QAEAAV01@ABV01@@Z
??4DigitFormatterOptions@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	edx, [ebp+var_8]
		mov	[edx], cl
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitFormatterOptions@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitFormatterIntOptions::DigitFormatterIntOptions(icu_56::DigitFormatterIntOptions	*__hidden this)
		public ??0DigitFormatterIntOptions@icu_56@@QAE@XZ
??0DigitFormatterIntOptions@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::SciFormatterOptions::SciFormatterOptions(void)+31p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0DigitFormatterIntOptions@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitFormatterIntOptions::equals(icu_56::DigitFormatterIntOptions *this, const struct icu_56::DigitFormatterIntOptions *)
		public ?equals@DigitFormatterIntOptions@icu_56@@QBECABV12@@Z
?equals@DigitFormatterIntOptions@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions const &)+43p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx]
		cmp	ecx, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitFormatterIntOptions@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitFormatterIntOptions & __thiscall icu_56::DigitFormatterIntOptions::operator=(class	icu_56::DigitFormatterIntOptions const &)
		public ??4DigitFormatterIntOptions@icu_56@@QAEAAV01@ABV01@@Z
??4DigitFormatterIntOptions@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	edx, [ebp+var_8]
		mov	[edx], cl
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitFormatterIntOptions@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions *this, const	struct icu_56::SciFormatterOptions *)
		public ?equals@SciFormatterOptions@icu_56@@QBECABV12@@Z
?equals@SciFormatterOptions@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+23Ep

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitFormatterOptions *
		mov	ecx, [ebp+var_8] ; this
		call	?equals@DigitFormatterOptions@icu_56@@QBECABV12@@Z ; icu_56::DigitFormatterOptions::equals(icu_56::DigitFormatterOptions const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_3B54
		mov	edx, [ebp+arg_0]
		add	edx, 1
		push	edx		; struct icu_56::DigitFormatterIntOptions *
		mov	ecx, [ebp+var_8]
		add	ecx, 1		; this
		call	?equals@DigitFormatterIntOptions@icu_56@@QBECABV12@@Z ;	icu_56::DigitFormatterIntOptions::equals(icu_56::DigitFormatterIntOptions const	&)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3B54
		mov	[ebp+var_CD], 1
		jmp	short loc_3B5B
; ---------------------------------------------------------------------------

loc_3B54:				; CODE XREF: icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions const &)+34j
					; icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions const	&)+4Dj
		mov	[ebp+var_CD], 0

loc_3B5B:				; CODE XREF: icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions const &)+56j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@SciFormatterOptions@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SciFormatterOptions::SciFormatterOptions(icu_56::SciFormatterOptions *__hidden this)
		public ??0SciFormatterOptions@icu_56@@QAE@XZ
??0SciFormatterOptions@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+167p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+163p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0DigitFormatterOptions@icu_56@@QAE@XZ	; icu_56::DigitFormatterOptions::DigitFormatterOptions(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 1		; this
		call	??0DigitFormatterIntOptions@icu_56@@QAE@XZ ; icu_56::DigitFormatterIntOptions::DigitFormatterIntOptions(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0SciFormatterOptions@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::SciFormatterOptions & __thiscall icu_56::SciFormatterOptions::operator=(class icu_56::SciFormatterOptions const	&)
		public ??4SciFormatterOptions@icu_56@@QAEAAV01@ABV01@@Z
??4SciFormatterOptions@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	cx, [eax]
		mov	edx, [ebp+var_8]
		mov	[edx], cx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4SciFormatterOptions@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DigitFormatter::formatNaN(icu_56::DigitFormatter *this, struct icu_56::FieldPositionHandler *, struct icu_56::UnicodeString *)
		public ?formatNaN@DigitFormatter@icu_56@@ABEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z
?formatNaN@DigitFormatter@icu_56@@ABEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?format@DigitAffix@icu_56@@QBEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z ; icu_56::DigitAffix::format(icu_56::FieldPositionHandler &,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?formatNaN@DigitFormatter@icu_56@@ABEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitFormatter::countChar32ForNaN(icu_56::DigitFormatter *__hidden this)
		public ?countChar32ForNaN@DigitFormatter@icu_56@@ABEHXZ
?countChar32ForNaN@DigitFormatter@icu_56@@ABEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::DigitAffix::toString(void)
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?countChar32ForNaN@DigitFormatter@icu_56@@ABEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DigitFormatter::formatInfinity(icu_56::DigitFormatter *this,	struct icu_56::FieldPositionHandler *, struct icu_56::UnicodeString *)
		public ?formatInfinity@DigitFormatter@icu_56@@ABEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z
?formatInfinity@DigitFormatter@icu_56@@ABEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	ecx, [ebp+var_8]
		add	ecx, 128h	; this
		call	?format@DigitAffix@icu_56@@QBEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z ; icu_56::DigitAffix::format(icu_56::FieldPositionHandler &,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?formatInfinity@DigitFormatter@icu_56@@ABEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitFormatter::countChar32ForInfinity(icu_56::DigitFormatter *__hidden this)
		public ?countChar32ForInfinity@DigitFormatter@icu_56@@ABEHXZ
?countChar32ForInfinity@DigitFormatter@icu_56@@ABEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 128h	; this
		call	?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::DigitAffix::toString(void)
		mov	ecx, eax	; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?countChar32ForInfinity@DigitFormatter@icu_56@@ABEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitFormatter::~DigitFormatter(icu_56::DigitFormatter *__hidden this)
		public ??1DigitFormatter@icu_56@@QAE@XZ
??1DigitFormatter@icu_56@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$9+9j
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$9+9j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DigitFormatter@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 5
		mov	ecx, [ebp+var_14]
		add	ecx, 22Ch	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_14]
		add	ecx, 1A8h	; this
		call	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_14]
		add	ecx, 128h	; this
		call	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 0E8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 0A8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		add	ecx, 28h ; '('  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DigitFormatter@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$0 proc	near ; DATA XREF: .xdata$x:00003F34o
		mov	ecx, [ebp-14h]
		add	ecx, 28h ; '('  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$1 proc	near ; DATA XREF: .xdata$x:00003F3Co
		mov	ecx, [ebp-14h]
		add	ecx, 68h ; 'h'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$2 proc	near ; DATA XREF: .xdata$x:00003F44o
		mov	ecx, [ebp-14h]
		add	ecx, 0A8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$3 proc	near ; DATA XREF: .xdata$x:00003F4Co
		mov	ecx, [ebp-14h]
		add	ecx, 0E8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$4 proc	near ; DATA XREF: .xdata$x:00003F54o
		mov	ecx, [ebp-14h]
		add	ecx, 128h	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$5 proc	near ; DATA XREF: .xdata$x:00003F5Co
		mov	ecx, [ebp-14h]
		add	ecx, 1A8h	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$5 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DigitFormatter@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::DigitFormatter::~DigitFormatter(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DigitFormatter@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DigitFormatter@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3F0Ch
__ehfuncinfo$??1DigitFormatter@icu_56@@QAE@XZ dd 19930522h, 6
					; DATA XREF: __ehhandler$??1DigitFormatter@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1DigitFormatter@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
__unwindtable$??1DigitFormatter@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA XREF: .xdata$x:00003F14o
		dd offset __unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$2
		dd 2
		dd offset __unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$3
		dd 3
		dd offset __unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$4
		dd 4
		dd offset __unwindfunclet$??1DigitFormatter@icu_56@@QAE@XZ$5
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitFormatter::DigitFormatter(icu_56::DigitFormatter *this, const struct icu_56::DigitFormatter *)
		public ??0DigitFormatter@icu_56@@QAE@ABV01@@Z
??0DigitFormatter@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+24Bp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DigitFormatter@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, 0Ah
		mov	esi, [ebp+arg_0]
		mov	edi, [ebp+var_14]
		rep movsd
		mov	eax, [ebp+arg_0]
		add	eax, 28h ; '('
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 28h ; '('  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		add	eax, 68h ; 'h'
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		add	eax, 0A8h ; ''
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		add	ecx, 0A8h ; '' ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+arg_0]
		add	eax, 0E8h ; ''
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 0E8h ; '' ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+arg_0]
		add	eax, 128h
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_14]
		add	ecx, 128h	; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	byte ptr [ebp+var_4], 4
		mov	eax, [ebp+arg_0]
		add	eax, 1A8h
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_14]
		add	ecx, 1A8h	; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	byte ptr [ebp+var_4], 5
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+228h]
		mov	[eax+228h], dl
		mov	eax, [ebp+arg_0]
		add	eax, 22Ch
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 22Ch	; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0DigitFormatter@icu_56@@QAE@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 40D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000418Co
		mov	ecx, [ebp-14h]
		add	ecx, 28h ; '('  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00004194o
		mov	ecx, [ebp-14h]
		add	ecx, 68h ; 'h'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$2 proc near
					; DATA XREF: .xdata$x:0000419Co
		mov	ecx, [ebp-14h]
		add	ecx, 0A8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$3 proc near
					; DATA XREF: .xdata$x:000041A4o
		mov	ecx, [ebp-14h]
		add	ecx, 0E8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$4 proc near
					; DATA XREF: .xdata$x:000041ACo
		mov	ecx, [ebp-14h]
		add	ecx, 128h	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$5 proc near
					; DATA XREF: .xdata$x:000041B4o
		mov	ecx, [ebp-14h]
		add	ecx, 1A8h	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DigitFormatter@icu_56@@QAE@ABV01@@Z proc	near
					; DATA XREF: icu_56::DigitFormatter::DigitFormatter(icu_56::DigitFormatter const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DigitFormatter@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DigitFormatter@icu_56@@QAE@ABV01@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4164h
__ehfuncinfo$??0DigitFormatter@icu_56@@QAE@ABV01@@Z dd 19930522h, 6
					; DATA XREF: __ehhandler$??0DigitFormatter@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0DigitFormatter@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$??0DigitFormatter@icu_56@@QAE@ABV01@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000416Co
		dd offset __unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$0
		dd 0
		dd offset __unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$1
		dd 1
		dd offset __unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$2
		dd 2
		dd offset __unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$3
		dd 3
		dd offset __unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$4
		dd 4
		dd offset __unwindfunclet$??0DigitFormatter@icu_56@@QAE@ABV01@@Z$5
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitFormatter & __thiscall icu_56::DigitFormatter::operator=(class icu_56::DigitFormatter const &)
		public ??4DigitFormatter@icu_56@@QAEAAV01@ABV01@@Z
??4DigitFormatter@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+21Cp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_41ED
; ---------------------------------------------------------------------------

loc_41E4:				; CODE XREF: icu_56::DigitFormatter::operator=(icu_56::DigitFormatter const &)+4Dj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_41ED:				; CODE XREF: icu_56::DigitFormatter::operator=(icu_56::DigitFormatter const &)+2Aj
		cmp	[ebp+var_14], 0Ah
		jnb	short loc_4207
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+arg_0]
		mov	edx, [esi+edx*4]
		mov	[ecx+eax*4], edx
		jmp	short loc_41E4
; ---------------------------------------------------------------------------

loc_4207:				; CODE XREF: icu_56::DigitFormatter::operator=(icu_56::DigitFormatter const &)+39j
		mov	eax, [ebp+arg_0]
		add	eax, 28h ; '('
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 28h ; '('
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 68h ; 'h'
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 0A8h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 0A8h ; ''
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 0E8h ; ''
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 0E8h ; ''
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 128h
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 128h
		call	??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::DigitAffix::operator=(icu_56::DigitAffix const &)
		mov	eax, [ebp+arg_0]
		add	eax, 1A8h
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h
		call	??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::DigitAffix::operator=(icu_56::DigitAffix const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+228h]
		mov	[eax+228h], dl
		mov	eax, [ebp+arg_0]
		add	eax, 22Ch
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 22Ch
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitFormatter@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitGrouping::DigitGrouping(icu_56::DigitGrouping *__hidden this)
		public ??0DigitGrouping@icu_56@@QAE@XZ
??0DigitGrouping@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+9Cp
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale const &,icu_56::UnicodeString const &,UErrorCode &)+159p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0DigitGrouping@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4348h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitGrouping::equals(icu_56::DigitGrouping *this, const struct icu_56::DigitGrouping *)
		public ?equals@DigitGrouping@icu_56@@QBECABV12@@Z
?equals@DigitGrouping@icu_56@@QBECABV12@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+EEp
					; icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const	&)+21Bp

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_439C
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_439C
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jnz	short loc_439C
		mov	[ebp+var_CD], 1
		jmp	short loc_43A3
; ---------------------------------------------------------------------------

loc_439C:				; CODE XREF: icu_56::DigitGrouping::equals(icu_56::DigitGrouping const &)+2Dj
					; icu_56::DigitGrouping::equals(icu_56::DigitGrouping const &)+3Bj ...
		mov	[ebp+var_CD], 0

loc_43A3:				; CODE XREF: icu_56::DigitGrouping::equals(icu_56::DigitGrouping const &)+52j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitGrouping@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitGrouping::isGroupingUsed(icu_56::DigitGrouping *__hidden this)
		public ?isGroupingUsed@DigitGrouping@icu_56@@QBECXZ
?isGroupingUsed@DigitGrouping@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isGroupingUsed@DigitGrouping@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitGrouping &	__thiscall icu_56::DigitGrouping::operator=(class icu_56::DigitGrouping	const &)
		public ??4DigitGrouping@icu_56@@QAEAAV01@ABV01@@Z
??4DigitGrouping@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax]
		mov	[ecx], edx
		mov	edx, [eax+4]
		mov	[ecx+4], edx
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitGrouping@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DigitInterval::DigitInterval(icu_56::DigitInterval *__hidden this)
		public ??0DigitInterval@icu_56@@QAE@XZ
??0DigitInterval@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::VisibleDigits::VisibleDigits(void)+61p
					; icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+89p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 80000000h
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0DigitInterval@icu_56@@QAE@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4470h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::clear(icu_56::DigitInterval *__hidden this)
		public ?clear@DigitInterval@icu_56@@QAEXXZ
?clear@DigitInterval@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+3Dp
					; icu_56::DecimalFormatImpl::updatePrecisionForFixed(void)+85p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 80000000h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@DigitInterval@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DigitInterval::equals(icu_56::DigitInterval *this, const struct icu_56::DigitInterval *)
		public ?equals@DigitInterval@icu_56@@QBECABV12@@Z
?equals@DigitInterval@icu_56@@QBECABV12@@Z proc	near
					; CODE XREF: icu_56::FixedPrecision::equals(icu_56::FixedPrecision const &)+2Ap
					; icu_56::FixedPrecision::equals(icu_56::FixedPrecision	const &)+47p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_44F6
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_44F6
		mov	[ebp+var_CD], 1
		jmp	short loc_44FD
; ---------------------------------------------------------------------------

loc_44F6:				; CODE XREF: icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+2Dj
					; icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+3Bj
		mov	[ebp+var_CD], 0

loc_44FD:				; CODE XREF: icu_56::DigitInterval::equals(icu_56::DigitInterval const &)+44j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@DigitInterval@icu_56@@QBECABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 450Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::setLeastSignificantInclusive(icu_56::DigitInterval *this, int)
		public ?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z
?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setnl	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setLeastSignificantInclusive@DigitInterval@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4550h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DigitInterval::setMostSignificantExclusive(icu_56::DigitInterval *this, int)
		public ?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z
?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setle	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setMostSignificantExclusive@DigitInterval@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4590h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getMostSignificantExclusive(icu_56::DigitInterval *__hidden this)
		public ?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ
?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+2AFp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getIntDigitCount(icu_56::DigitInterval *__hidden this)
		public ?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ
?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+45p
					; icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+50p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getFracDigitCount(icu_56::DigitInterval	*__hidden this)
		public ?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ
?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	proc near
					; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+5Bp
					; icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+66p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 80000000h
		jnz	short loc_462B
		mov	[ebp+var_D0], 7FFFFFFFh
		jmp	short loc_4639
; ---------------------------------------------------------------------------

loc_462B:				; CODE XREF: icu_56::DigitInterval::getFracDigitCount(void)+2Dj
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		neg	edx
		mov	[ebp+var_D0], edx

loc_4639:				; CODE XREF: icu_56::DigitInterval::getFracDigitCount(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::length(icu_56::DigitInterval *__hidden this)
		public ?length@DigitInterval@icu_56@@QBEHXZ
?length@DigitInterval@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	eax, [eax]
		sub	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@DigitInterval@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DigitInterval::getLeastSignificantInclusive(icu_56::DigitInterval *__hidden this)
		public ?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ
?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+2BDp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitInterval &	__thiscall icu_56::DigitInterval::operator=(class icu_56::DigitInterval	const &)
		public ??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z
??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4DigitInterval@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SignificantDigitInterval::SignificantDigitInterval(icu_56::SignificantDigitInterval	*__hidden this)
		public ??0SignificantDigitInterval@icu_56@@QAE@XZ
??0SignificantDigitInterval@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+8Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0SignificantDigitInterval@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4730h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SignificantDigitInterval::clear(icu_56::SignificantDigitInterval *__hidden this)
		public ?clear@SignificantDigitInterval@icu_56@@QAEXXZ
?clear@SignificantDigitInterval@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+70p
					; icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 7FFFFFFFh
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@SignificantDigitInterval@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4770h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::SignificantDigitInterval::equals(icu_56::SignificantDigitInterval *this, const struct icu_56::SignificantDigitInterval *)
		public ?equals@SignificantDigitInterval@icu_56@@QBECABV12@@Z
?equals@SignificantDigitInterval@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::FixedPrecision::equals(icu_56::FixedPrecision const &)+60p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_47B6
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_47B6
		mov	[ebp+var_CD], 1
		jmp	short loc_47BD
; ---------------------------------------------------------------------------

loc_47B6:				; CODE XREF: icu_56::SignificantDigitInterval::equals(icu_56::SignificantDigitInterval const &)+2Dj
					; icu_56::SignificantDigitInterval::equals(icu_56::SignificantDigitInterval const &)+3Bj
		mov	[ebp+var_CD], 0

loc_47BD:				; CODE XREF: icu_56::SignificantDigitInterval::equals(icu_56::SignificantDigitInterval const &)+44j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@SignificantDigitInterval@icu_56@@QBECABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SignificantDigitInterval::setMax(icu_56::SignificantDigitInterval *this, int)
		public ?setMax@SignificantDigitInterval@icu_56@@QAEXH@Z
?setMax@SignificantDigitInterval@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+123p
					; icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval &)+8Ap

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_4801
		mov	[ebp+var_D0], 7FFFFFFFh
		jmp	short loc_480A
; ---------------------------------------------------------------------------

loc_4801:				; CODE XREF: icu_56::SignificantDigitInterval::setMax(int)+27j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax

loc_480A:				; CODE XREF: icu_56::SignificantDigitInterval::setMax(int)+33j
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_D0]
		mov	[ecx], edx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setMax@SignificantDigitInterval@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4820h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::SignificantDigitInterval::getMax(icu_56::SignificantDigitInterval *__hidden this)
		public ?getMax@SignificantDigitInterval@icu_56@@QBEHXZ
?getMax@SignificantDigitInterval@icu_56@@QBEHXZ	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+A5p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMax@SignificantDigitInterval@icu_56@@QBEHXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4850h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::SignificantDigitInterval::setMin(icu_56::SignificantDigitInterval *this, int)
		public ?setMin@SignificantDigitInterval@icu_56@@QAEXH@Z
?setMin@SignificantDigitInterval@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+117p
					; icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval &)+54p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		cmp	[ebp+arg_0], 0
		setle	al
		sub	eax, 1
		and	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setMin@SignificantDigitInterval@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::SignificantDigitInterval::getMin(icu_56::SignificantDigitInterval *__hidden this)
		public ?getMin@SignificantDigitInterval@icu_56@@QBEHXZ
?getMin@SignificantDigitInterval@icu_56@@QBEHXZ	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+BAp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMin@SignificantDigitInterval@icu_56@@QBEHXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::SignificantDigitInterval::isNoConstraints(icu_56::SignificantDigitInterval *__hidden	this)
		public ?isNoConstraints@SignificantDigitInterval@icu_56@@QBECXZ
?isNoConstraints@SignificantDigitInterval@icu_56@@QBECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_4904
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx], 7FFFFFFFh
		jnz	short loc_4904
		mov	[ebp+var_CD], 1
		jmp	short loc_490B
; ---------------------------------------------------------------------------

loc_4904:				; CODE XREF: icu_56::SignificantDigitInterval::isNoConstraints(void)+2Aj
					; icu_56::SignificantDigitInterval::isNoConstraints(void)+35j
		mov	[ebp+var_CD], 0

loc_490B:				; CODE XREF: icu_56::SignificantDigitInterval::isNoConstraints(void)+3Ej
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNoConstraints@SignificantDigitInterval@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4918h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::SignificantDigitInterval & __thiscall icu_56::SignificantDigitInterval::operator=(class	icu_56::SignificantDigitInterval const &)
		public ??4SignificantDigitInterval@icu_56@@QAEAAV01@ABV01@@Z
??4SignificantDigitInterval@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4SignificantDigitInterval@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4958h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::FixedPrecision::equals(icu_56::FixedPrecision *this,	const struct icu_56::FixedPrecision *)
		public ?equals@FixedPrecision@icu_56@@QBECABV12@@Z
?equals@FixedPrecision@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::ScientificPrecision::equals(icu_56::ScientificPrecision const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?equals@DigitInterval@icu_56@@QBECABV12@@Z ; icu_56::DigitInterval::equals(icu_56::DigitInterval const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_4A2A
		mov	edx, [ebp+arg_0]
		add	edx, 8
		push	edx		; struct icu_56::DigitInterval *
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?equals@DigitInterval@icu_56@@QBECABV12@@Z ; icu_56::DigitInterval::equals(icu_56::DigitInterval const &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_4A2A
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		push	ecx		; struct icu_56::SignificantDigitInterval *
		mov	ecx, [ebp+var_8]
		add	ecx, 10h	; this
		call	?equals@SignificantDigitInterval@icu_56@@QBECABV12@@Z ;	icu_56::SignificantDigitInterval::equals(icu_56::SignificantDigitInterval const	&)
		movsx	edx, al
		test	edx, edx
		jz	short loc_4A2A
		mov	eax, [ebp+arg_0]
		add	eax, 18h
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 18h
		call	??8DigitList@icu_56@@QBECABV01@@Z ; icu_56::DigitList::operator==(icu_56::DigitList const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_4A2A
		mov	edx, [ebp+var_8]
		movsx	eax, byte ptr [edx+88h]
		mov	ecx, [ebp+arg_0]
		movsx	edx, byte ptr [ecx+88h]
		cmp	eax, edx
		jnz	short loc_4A2A
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+89h]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx+89h]
		cmp	ecx, eax
		jnz	short loc_4A2A
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+8Ch]
		cmp	eax, [edx+8Ch]
		jnz	short loc_4A2A
		mov	[ebp+var_CD], 1
		jmp	short loc_4A31
; ---------------------------------------------------------------------------

loc_4A2A:				; CODE XREF: icu_56::FixedPrecision::equals(icu_56::FixedPrecision const &)+34j
					; icu_56::FixedPrecision::equals(icu_56::FixedPrecision	const &)+51j ...
		mov	[ebp+var_CD], 0

loc_4A31:				; CODE XREF: icu_56::FixedPrecision::equals(icu_56::FixedPrecision const &)+D0j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@FixedPrecision@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedPrecision::~FixedPrecision(icu_56::FixedPrecision *__hidden this)
		public ??1FixedPrecision@icu_56@@QAE@XZ
??1FixedPrecision@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::ScientificPrecision::~ScientificPrecision(void)+26p
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+343p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 18h	; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1FixedPrecision@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FixedPrecision::FixedPrecision(icu_56::FixedPrecision *this, const struct icu_56::FixedPrecision *)
		public ??0FixedPrecision@icu_56@@QAE@ABV01@@Z
??0FixedPrecision@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::ScientificPrecision::ScientificPrecision(icu_56::ScientificPrecision const	&)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+var_8]
		mov	[eax+8], ecx
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [eax+14h]
		mov	eax, [ebp+var_8]
		mov	[eax+10h], ecx
		mov	[eax+14h], edx
		mov	eax, [ebp+arg_0]
		add	eax, 18h
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8]
		add	ecx, 18h	; this
		call	??0DigitList@icu_56@@QAE@ABV01@@Z ; icu_56::DigitList::DigitList(icu_56::DigitList const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+88h]
		mov	[eax+88h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+89h]
		mov	[eax+89h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8Ch]
		mov	[eax+8Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FixedPrecision@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FixedPrecision & __thiscall icu_56::FixedPrecision::operator=(class icu_56::FixedPrecision const &)
		public ??4FixedPrecision@icu_56@@QAEAAV01@ABV01@@Z
??4FixedPrecision@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::ScientificPrecision::operator=(icu_56::ScientificPrecision	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+var_8]
		mov	[eax+8], ecx
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [eax+14h]
		mov	eax, [ebp+var_8]
		mov	[eax+10h], ecx
		mov	[eax+14h], edx
		mov	eax, [ebp+arg_0]
		add	eax, 18h
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 18h
		call	??4DigitList@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitList::operator=(icu_56::DigitList	const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+88h]
		mov	[eax+88h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+89h]
		mov	[eax+89h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8Ch]
		mov	[eax+8Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4FixedPrecision@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::ScientificPrecision::equals(icu_56::ScientificPrecision *this, const	struct icu_56::ScientificPrecision *)
		public ?equals@ScientificPrecision@icu_56@@QBECABV12@@Z
?equals@ScientificPrecision@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+1F8p

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::FixedPrecision	*
		mov	ecx, [ebp+var_8] ; this
		call	?equals@FixedPrecision@icu_56@@QBECABV12@@Z ; icu_56::FixedPrecision::equals(icu_56::FixedPrecision const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_4C57
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+90h]
		cmp	ecx, [eax+90h]
		jnz	short loc_4C57
		mov	[ebp+var_CD], 1
		jmp	short loc_4C5E
; ---------------------------------------------------------------------------

loc_4C57:				; CODE XREF: icu_56::ScientificPrecision::equals(icu_56::ScientificPrecision const &)+34j
					; icu_56::ScientificPrecision::equals(icu_56::ScientificPrecision const	&)+48j
		mov	[ebp+var_CD], 0

loc_4C5E:				; CODE XREF: icu_56::ScientificPrecision::equals(icu_56::ScientificPrecision const &)+51j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@ScientificPrecision@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ScientificPrecision::~ScientificPrecision(icu_56::ScientificPrecision *__hidden this)
		public ??1ScientificPrecision@icu_56@@QAE@XZ
??1ScientificPrecision@icu_56@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$8+9j
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$8+9j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FixedPrecision@icu_56@@QAE@XZ ; icu_56::FixedPrecision::~FixedPrecision(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1ScientificPrecision@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ScientificPrecision::ScientificPrecision(icu_56::ScientificPrecision *this,	const struct icu_56::ScientificPrecision *)
		public ??0ScientificPrecision@icu_56@@QAE@ABV01@@Z
??0ScientificPrecision@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+1FBp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::FixedPrecision	*
		mov	ecx, [ebp+var_8] ; this
		call	??0FixedPrecision@icu_56@@QAE@ABV01@@Z ; icu_56::FixedPrecision::FixedPrecision(icu_56::FixedPrecision const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+90h]
		mov	[eax+90h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0ScientificPrecision@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::ScientificPrecision & __thiscall icu_56::ScientificPrecision::operator=(class icu_56::ScientificPrecision const	&)
		public ??4ScientificPrecision@icu_56@@QAEAAV01@ABV01@@Z
??4ScientificPrecision@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+1D0p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4FixedPrecision@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::FixedPrecision::operator=(icu_56::FixedPrecision const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+90h]
		mov	[eax+90h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4ScientificPrecision@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPositionHandler::FieldPositionHandler(icu_56::FieldPositionHandler *__hidden this)
		public ??0FieldPositionHandler@icu_56@@QAE@XZ
??0FieldPositionHandler@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPositionHandler@icu_56@@6B@ ; const icu_56::FieldPositionHandler::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0FieldPositionHandler@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4DACh
		dd offset ??_R4FieldPositionHandler@icu_56@@6B@	; const	icu_56::FieldPositionHandler::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FieldPositionHandler@icu_56@@6B@
; const	icu_56::FieldPositionHandler::`vftable'
??_7FieldPositionHandler@icu_56@@6B@ dd	offset ??_EFieldPositionHandler@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FieldPositionHandler::FieldPositionHandler(void)+26o
					; icu_56::FieldPositionHandler::FieldPositionHandler(icu_56::FieldPositionHandler const	&)+44o
					; icu_56::FieldPositionHandler::`vector	deleting destructor'(uint)
		dd offset ?addAttribute@FieldPositionHandler@icu_56@@UAEXHHH@Z ; icu_56::FieldPositionHandler::addAttribute(int,int,int)
		dd offset ?shiftLast@FieldPositionHandler@icu_56@@UAEXH@Z ; icu_56::FieldPositionHandler::shiftLast(int)
		dd offset ?isRecording@FieldPositionHandler@icu_56@@UBECXZ ; icu_56::FieldPositionHandler::isRecording(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4DC0h
		public ??_R4FieldPositionHandler@icu_56@@6B@
; const	icu_56::FieldPositionHandler::`RTTI Complete Object Locator'
??_R4FieldPositionHandler@icu_56@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00004DACo
		dd offset ??_R0?AVFieldPositionHandler@icu_56@@@8 ; icu_56::FieldPositionHandler `RTTI Type Descriptor'
		dd offset ??_R3FieldPositionHandler@icu_56@@8 ;	icu_56::FieldPositionHandler::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4DD4h
		public ??_R0?AVFieldPositionHandler@icu_56@@@8
; class	icu_56::FieldPositionHandler `RTTI Type	Descriptor'
??_R0?AVFieldPositionHandler@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004DCCo
					; .rdata$r:icu_56::FieldPositionHandler::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avfieldpos_0	db '.?AVFieldPositionHandler@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E00h
		public ??_R3FieldPositionHandler@icu_56@@8
; icu_56::FieldPositionHandler::`RTTI Class Hierarchy Descriptor'
??_R3FieldPositionHandler@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00004DD0o
					; .rdata$r:00004E34o
		dd 2
		dd offset ??_R2FieldPositionHandler@icu_56@@8 ;	icu_56::FieldPositionHandler::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E10h
		public ??_R2FieldPositionHandler@icu_56@@8
; icu_56::FieldPositionHandler::`RTTI Base Class Array'
??_R2FieldPositionHandler@icu_56@@8 dd offset ??_R1A@?0A@EA@FieldPositionHandler@icu_56@@8
					; DATA XREF: .rdata$r:00004E0Co
					; icu_56::FieldPositionHandler::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E1Ch
		public ??_R1A@?0A@EA@FieldPositionHandler@icu_56@@8
; icu_56::FieldPositionHandler::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@FieldPositionHandler@icu_56@@8 dd	offset ??_R0?AVFieldPositionHandler@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FieldPositionHandler::`RTTI Base Class Array'o
					; icu_56::FieldPositionHandler `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FieldPositionHandler@icu_56@@8 ;	icu_56::FieldPositionHandler::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPositionHandler::FieldPositionHandler(icu_56::FieldPositionHandler *this, const struct	icu_56::FieldPositionHandler *)
		public ??0FieldPositionHandler@icu_56@@QAE@ABV01@@Z
??0FieldPositionHandler@icu_56@@QAE@ABV01@@Z proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_4E6F
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_4E79
; ---------------------------------------------------------------------------

loc_4E6F:				; CODE XREF: icu_56::FieldPositionHandler::FieldPositionHandler(icu_56::FieldPositionHandler const &)+27j
		mov	[ebp+var_D0], 0

loc_4E79:				; CODE XREF: icu_56::FieldPositionHandler::FieldPositionHandler(icu_56::FieldPositionHandler const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPositionHandler@icu_56@@6B@ ; const icu_56::FieldPositionHandler::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPositionHandler@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPositionHandler & __thiscall icu_56::FieldPositionHandler::operator=(class	icu_56::FieldPositionHandler const &)
		public ??4FieldPositionHandler@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPositionHandler@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPositionHandler@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4EC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPositionHandler::`scalar deleting destructor'(unsigned int)
		public ??_GFieldPositionHandler@icu_56@@UAEPAXI@Z
??_GFieldPositionHandler@icu_56@@UAEPAXI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPositionHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionHandler::~FieldPositionHandler(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4F09
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4F09:				; CODE XREF: icu_56::FieldPositionHandler::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFieldPositionHandler@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPositionHandler::`vector deleting destructor'(unsigned int)
		public ??_EFieldPositionHandler@icu_56@@UAEPAXI@Z
??_EFieldPositionHandler@icu_56@@UAEPAXI@Z proc	near
					; DATA XREF: .rdata:const icu_56::FieldPositionHandler::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4F8F
		push	offset ??1FieldPositionHandler@icu_56@@UAE@XZ ;	icu_56::FieldPositionHandler::~FieldPositionHandler(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4F87
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4F87:				; CODE XREF: icu_56::FieldPositionHandler::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4FB8
; ---------------------------------------------------------------------------

loc_4F8F:				; CODE XREF: icu_56::FieldPositionHandler::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPositionHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionHandler::~FieldPositionHandler(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4FB5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4FB5:				; CODE XREF: icu_56::FieldPositionHandler::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_4FB8:				; CODE XREF: icu_56::FieldPositionHandler::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFieldPositionHandler@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4FD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FixedDecimal & __thiscall icu_56::FixedDecimal::operator=(class	icu_56::FixedDecimal const &)
		public ??4FixedDecimal@icu_56@@QAEAAV01@ABV01@@Z
??4FixedDecimal@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, [ebp+arg_0]
		mov	ecx, 0Ch
		mov	edi, [ebp+var_8]
		rep movsd
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FixedDecimal@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 500Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration *this, const	struct icu_56::PluralAvailableLocalesEnumeration *)
		public ??0PluralAvailableLocalesEnumeration@icu_56@@QAE@ABV01@@Z
??0PluralAvailableLocalesEnumeration@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::StringEnumeration *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0StringEnumeration@icu_56@@QAE@ABV01@@Z ; icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7PluralAvailableLocalesEnumeration@icu_56@@6B@ ; const icu_56::PluralAvailableLocalesEnumeration::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+6Ch]
		mov	[eax+6Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+70h]
		mov	[eax+70h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+74h]
		mov	[eax+74h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0PluralAvailableLocalesEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 508Ch
		dd offset ??_R4PluralAvailableLocalesEnumeration@icu_56@@6B@ ; const icu_56::PluralAvailableLocalesEnumeration::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7PluralAvailableLocalesEnumeration@icu_56@@6B@
; const	icu_56::PluralAvailableLocalesEnumeration::`vftable'
??_7PluralAvailableLocalesEnumeration@icu_56@@6B@ dd offset ??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration const &)+3Co
					; icu_56::PluralAvailableLocalesEnumeration::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ ; icu_56::StringEnumeration::clone(void)
		dd offset ?count@PluralAvailableLocalesEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z ; icu_56::PluralAvailableLocalesEnumeration::count(UErrorCode	&)
		dd offset ?next@PluralAvailableLocalesEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z ;	icu_56::PluralAvailableLocalesEnumeration::next(int *,UErrorCode &)
		dd offset ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z	; icu_56::StringEnumeration::unext(int *,UErrorCode &)
		dd offset ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::StringEnumeration::snext(UErrorCode &)
		dd offset ?reset@PluralAvailableLocalesEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z ; icu_56::PluralAvailableLocalesEnumeration::reset(UErrorCode	&)
		dd offset ??8StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator==(icu_56::StringEnumeration const &)
		dd offset ??9StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator!=(icu_56::StringEnumeration const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 50B8h
		public ??_R4PluralAvailableLocalesEnumeration@icu_56@@6B@
; const	icu_56::PluralAvailableLocalesEnumeration::`RTTI Complete Object Locator'
??_R4PluralAvailableLocalesEnumeration@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:0000508Co
		dd offset ??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8 ; icu_56::PluralAvailableLocalesEnumeration `RTTI Type Descriptor'
		dd offset ??_R3PluralAvailableLocalesEnumeration@icu_56@@8 ; icu_56::PluralAvailableLocalesEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 50CCh
		public ??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8
; class	icu_56::PluralAvailableLocalesEnumeration `RTTI	Type Descriptor'
??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000050C4o
					; .rdata$r:icu_56::PluralAvailableLocalesEnumeration::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avpluralavai	db '.?AVPluralAvailableLocalesEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5104h
		public ??_R3PluralAvailableLocalesEnumeration@icu_56@@8
; icu_56::PluralAvailableLocalesEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3PluralAvailableLocalesEnumeration@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000050C8o
					; .rdata$r:00005140o
		dd 4
		dd offset ??_R2PluralAvailableLocalesEnumeration@icu_56@@8 ; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5114h
		public ??_R2PluralAvailableLocalesEnumeration@icu_56@@8
; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base	Class Array'
??_R2PluralAvailableLocalesEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@PluralAvailableLocalesEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:00005110o
					; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5128h
		public ??_R1A@?0A@EA@PluralAvailableLocalesEnumeration@icu_56@@8
; icu_56::PluralAvailableLocalesEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@PluralAvailableLocalesEnumeration@icu_56@@8 dd offset ??_R0?AVPluralAvailableLocalesEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::PluralAvailableLocalesEnumeration::`RTTI Base Class Array'o
					; icu_56::PluralAvailableLocalesEnumeration `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3PluralAvailableLocalesEnumeration@icu_56@@8 ; icu_56::PluralAvailableLocalesEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5144h
		public ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@StringEnumeration@icu_56@@8 dd offset ??_R0?AVStringEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:00005118o
					; .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Array'o
					; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5160h
		public ??_R0?AVStringEnumeration@icu_56@@@8
; class	icu_56::StringEnumeration `RTTI	Type Descriptor'
??_R0?AVStringEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avstringenum	db '.?AVStringEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5188h
		public ??_R3StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3StringEnumeration@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000515Co
		dd 3
		dd offset ??_R2StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5198h
		public ??_R2StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Array'
??_R2StringEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:00005194o
					; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralAvailableLocalesEnumeration & __thiscall icu_56::PluralAvailableLocalesEnumeration::operator=(class icu_56::PluralAvailableLocalesEnumeration const &)
		public ??4PluralAvailableLocalesEnumeration@icu_56@@QAEAAV01@ABV01@@Z
??4PluralAvailableLocalesEnumeration@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+6Ch]
		mov	[eax+6Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+70h]
		mov	[eax+70h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+74h]
		mov	[eax+74h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4PluralAvailableLocalesEnumeration@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5220h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralAvailableLocalesEnumeration::`scalar deleting	destructor'(unsigned int)
		public ??_GPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z
??_GPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ ; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5269
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5269:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5284h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::PluralAvailableLocalesEnumeration::`vector deleting	destructor'(unsigned int)
		public ??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z
??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::PluralAvailableLocalesEnumeration::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_52EF
		push	offset ??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ ; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	78h ; 'x'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_52E7
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_52E7:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_5318
; ---------------------------------------------------------------------------

loc_52EF:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ ; icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5315
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5315:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_5318:				; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EPluralAvailableLocalesEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5330h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ValueFormatter::ValueFormatter(icu_56::ValueFormatter *__hidden this)
		public ??0ValueFormatter@icu_56@@QAE@XZ
??0ValueFormatter@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+69p
					; icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+45p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ValueFormatter@icu_56@@6B@ ; const icu_56::ValueFormatter::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 2
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0ValueFormatter@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5390h
		dd offset ??_R4ValueFormatter@icu_56@@6B@ ; const icu_56::ValueFormatter::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7ValueFormatter@icu_56@@6B@
; const	icu_56::ValueFormatter::`vftable'
??_7ValueFormatter@icu_56@@6B@ dd offset ??_EValueFormatter@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ValueFormatter::ValueFormatter(void)+38o
					; icu_56::ValueFormatter::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 539Ch
		public ??_R4ValueFormatter@icu_56@@6B@
; const	icu_56::ValueFormatter::`RTTI Complete Object Locator'
??_R4ValueFormatter@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00005390o
		dd offset ??_R0?AVValueFormatter@icu_56@@@8 ; icu_56::ValueFormatter `RTTI Type	Descriptor'
		dd offset ??_R3ValueFormatter@icu_56@@8	; icu_56::ValueFormatter::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 53B0h
		public ??_R0?AVValueFormatter@icu_56@@@8
; class	icu_56::ValueFormatter `RTTI Type Descriptor'
??_R0?AVValueFormatter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000053A8o
					; .rdata$r:icu_56::ValueFormatter::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avvalueforma	db '.?AVValueFormatter@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 53D4h
		public ??_R3ValueFormatter@icu_56@@8
; icu_56::ValueFormatter::`RTTI	Class Hierarchy	Descriptor'
??_R3ValueFormatter@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000053ACo
					; .rdata$r:0000540Co
		dd 3
		dd offset ??_R2ValueFormatter@icu_56@@8	; icu_56::ValueFormatter::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 53E4h
		public ??_R2ValueFormatter@icu_56@@8
; icu_56::ValueFormatter::`RTTI	Base Class Array'
??_R2ValueFormatter@icu_56@@8 dd offset	??_R1A@?0A@EA@ValueFormatter@icu_56@@8
					; DATA XREF: .rdata$r:000053E0o
					; icu_56::ValueFormatter::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 53F4h
		public ??_R1A@?0A@EA@ValueFormatter@icu_56@@8
; icu_56::ValueFormatter::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@ValueFormatter@icu_56@@8 dd offset ??_R0?AVValueFormatter@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ValueFormatter::`RTTI Base Class Array'o
					; icu_56::ValueFormatter `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ValueFormatter@icu_56@@8	; icu_56::ValueFormatter::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5410h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ValueFormatter::`scalar deleting destructor'(unsigned int)
		public ??_GValueFormatter@icu_56@@UAEPAXI@Z
??_GValueFormatter@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5459
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5459:				; CODE XREF: icu_56::ValueFormatter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GValueFormatter@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5474h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ValueFormatter::`vector deleting destructor'(unsigned int)
		public ??_EValueFormatter@icu_56@@UAEPAXI@Z
??_EValueFormatter@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ValueFormatter::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_54DF
		push	offset ??1ValueFormatter@icu_56@@UAE@XZ	; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	20h ; ' '
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_54D7
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_54D7:				; CODE XREF: icu_56::ValueFormatter::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_5508
; ---------------------------------------------------------------------------

loc_54DF:				; CODE XREF: icu_56::ValueFormatter::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5505
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5505:				; CODE XREF: icu_56::ValueFormatter::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_5508:				; CODE XREF: icu_56::ValueFormatter::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EValueFormatter@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5520h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigits::VisibleDigits(icu_56::VisibleDigits *__hidden this)
		public ??0VisibleDigits@icu_56@@QAE@XZ
??0VisibleDigits@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)+45p
					; icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)+57p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0VisibleDigits@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 38h ; '8'  ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+40h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		fldz
		fstp	qword ptr [eax+58h]
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+60h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0VisibleDigits@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 55ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0 proc near ; DATA XREF: .xdata$x:00005620o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0VisibleDigits@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::VisibleDigits::VisibleDigits(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0VisibleDigits@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0VisibleDigits@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 561Ch
__unwindtable$??0VisibleDigits@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA XREF: .xdata$x:0000562Co
		dd offset __unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0
__ehfuncinfo$??0VisibleDigits@icu_56@@QAE@XZ dd	19930522h, 1
					; DATA XREF: __ehhandler$??0VisibleDigits@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0VisibleDigits@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::DigitInterval *__thiscall icu_56::VisibleDigits::getInterval(icu_56::VisibleDigits *__hidden this)
		public ?getInterval@VisibleDigits@icu_56@@QBEABVDigitInterval@2@XZ
?getInterval@VisibleDigits@icu_56@@QBEABVDigitInterval@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 38h ; '8'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInterval@VisibleDigits@icu_56@@QBEABVDigitInterval@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5678h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigits::~VisibleDigits(icu_56::VisibleDigits	*__hidden this)
		public ??1VisibleDigits@icu_56@@QAE@XZ
??1VisibleDigits@icu_56@@QAE@XZ	proc near
					; CODE XREF: __unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0+3j
					; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)+4Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1VisibleDigits@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
??0VisibleDigitsWithExponent@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+87p
					; icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+4Bp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::VisibleDigits(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		call	??0VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::VisibleDigits(void)
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0D0h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0VisibleDigitsWithExponent@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5754h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00005780o
		mov	ecx, [ebp-14h]	; this
		jmp	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
__unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 577Ch
__unwindtable$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000578Co
		dd offset __unwindfunclet$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ$0
__ehfuncinfo$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0VisibleDigitsWithExponent@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::VisibleDigits *__thiscall icu_56::VisibleDigitsWithExponent::getMantissa(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ
?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMantissa@VisibleDigitsWithExponent@icu_56@@QBEABVVisibleDigits@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::VisibleDigits *__thiscall icu_56::VisibleDigitsWithExponent::getExponent(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ
?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+0D0h]
		test	ecx, ecx
		jz	short loc_5817
		mov	edx, [ebp+var_8]
		add	edx, 68h ; 'h'
		mov	[ebp+var_D0], edx
		jmp	short loc_5821
; ---------------------------------------------------------------------------

loc_5817:				; CODE XREF: icu_56::VisibleDigitsWithExponent::getExponent(void)+2Fj
		mov	[ebp+var_D0], 0

loc_5821:				; CODE XREF: icu_56::VisibleDigitsWithExponent::getExponent(void)+3Dj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getExponent@VisibleDigitsWithExponent@icu_56@@QBEPBVVisibleDigits@2@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5830h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::VisibleDigitsWithExponent::clear(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?clear@VisibleDigitsWithExponent@icu_56@@QAEXXZ
?clear@VisibleDigitsWithExponent@icu_56@@QAEXXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?clear@VisibleDigits@icu_56@@AAEXXZ ; icu_56::VisibleDigits::clear(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'  ; this
		call	?clear@VisibleDigits@icu_56@@AAEXXZ ; icu_56::VisibleDigits::clear(void)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0D0h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@VisibleDigitsWithExponent@icu_56@@QAEXXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5884h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::VisibleDigitsWithExponent::isNegative(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?isNegative@VisibleDigitsWithExponent@icu_56@@QBECXZ
?isNegative@VisibleDigitsWithExponent@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isNegative@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isNegative(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isNegative@VisibleDigitsWithExponent@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 58C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::VisibleDigitsWithExponent::isNaN(icu_56::VisibleDigitsWithExponent *__hidden	this)
		public ?isNaN@VisibleDigitsWithExponent@icu_56@@QBECXZ
?isNaN@VisibleDigitsWithExponent@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isNaN@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isNaN(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isNaN@VisibleDigitsWithExponent@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5904h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::VisibleDigitsWithExponent::isInfinite(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ?isInfinite@VisibleDigitsWithExponent@icu_56@@QBECXZ
?isInfinite@VisibleDigitsWithExponent@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isInfinite@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isInfinite(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isInfinite@VisibleDigitsWithExponent@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent *__hidden this)
		public ??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
??1VisibleDigitsWithExponent@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+DCp
					; __unwindfunclet$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0+6j ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		call	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1VisibleDigitsWithExponent@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 59C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000059F4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
__unwindfunclet$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 59F0h
__unwindtable$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005A00o
		dd offset __unwindfunclet$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ$0
__ehfuncinfo$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1VisibleDigitsWithExponent@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::DecimalFormatImpl *this, struct icu_56::NumberFormat *, const struct icu_56::Locale *,	const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z
??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z proc near

var_148		= dword	ptr -148h
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_68		= byte ptr -68h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_148]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax], offset	??_7DecimalFormatImpl@icu_56@@6B@ ; const icu_56::DecimalFormatImpl::`vftable'
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	ecx, [ebp+var_18]
		add	ecx, 8		; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+78h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+7Ch], 4
		mov	ecx, [ebp+var_18]
		add	ecx, 8Ch ; ''  ; this
		call	??0DigitGrouping@icu_56@@QAE@XZ	; icu_56::DigitGrouping::DigitGrouping(void)
		mov	ecx, [ebp+var_18]
		add	ecx, 98h ; ''  ; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_18]
		add	ecx, 120h	; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h	; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_18]
		add	ecx, 230h	; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 5
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+2B8h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+2BCh], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+2C0h], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+2C4h], 0
		mov	ecx, [ebp+var_18]
		add	ecx, 2C8h	; this
		call	??0AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::AffixPatternParser(void)
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_18]
		add	ecx, 3C8h	; this
		call	??0CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::CurrencyAffixInfo(void)
		mov	byte ptr [ebp+var_4], 7
		mov	ecx, [ebp+var_18]
		add	ecx, 4E8h	; this
		call	??0ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::ScientificPrecision(void)
		mov	byte ptr [ebp+var_4], 8
		mov	ecx, [ebp+var_18]
		add	ecx, 580h	; this
		call	??0DigitGrouping@icu_56@@QAE@XZ	; icu_56::DigitGrouping::DigitGrouping(void)
		mov	ecx, [ebp+var_18]
		add	ecx, 58Ch	; this
		call	??0SciFormatterOptions@icu_56@@QAE@XZ ;	icu_56::SciFormatterOptions::SciFormatterOptions(void)
		mov	ecx, [ebp+var_18]
		add	ecx, 590h	; this
		call	??0DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::DigitFormatter(void)
		mov	byte ptr [ebp+var_4], 9
		mov	ecx, [ebp+var_18]
		add	ecx, 7FCh	; this
		call	??0DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(void)
		mov	byte ptr [ebp+var_4], 0Ah
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5BC6
		jmp	loc_5C6D
; ---------------------------------------------------------------------------

loc_5BC6:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+1A3j
		mov	esi, esp
		push	0AD4h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_134], eax
		mov	byte ptr [ebp+var_4], 0Bh
		cmp	[ebp+var_134], 0
		jz	short loc_5C0B
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::Locale	*
		mov	ecx, [ebp+var_134] ; this
		call	??0DecimalFormatSymbols@icu_56@@QAE@ABVLocale@1@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::Locale const &,UErrorCode &)
		mov	[ebp+var_148], eax
		jmp	short loc_5C15
; ---------------------------------------------------------------------------

loc_5C0B:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+1D2j
		mov	[ebp+var_148], 0

loc_5C15:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+1EDj
		mov	edx, [ebp+var_148]
		mov	[ebp+var_140], edx
		mov	byte ptr [ebp+var_4], 0Ah
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_140]
		mov	[eax+2B8h], ecx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+2B8h], 0
		jnz	short loc_5C4B
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		jmp	short loc_5C6D
; ---------------------------------------------------------------------------

loc_5C4B:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+222j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_68]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18] ; this
		call	?updateAll@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateAll(UErrorCode &)

loc_5C6D:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+1A5j
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale const &,icu_56::UnicodeString const &,UErrorCode &)+22Dj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_18]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 148h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN22		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+25Fo
		dd offset $LN21
$LN21		dd 0FFFFFF98h, 48h	; DATA XREF: .text:00005CB8o
		dd offset $LN19		; "parseError"
$LN19		db 'parseError',0       ; DATA XREF: .text:00005CC4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5CD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005DE4o
		mov	esi, esp
		mov	ecx, [ebp-18h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00005DECo
		mov	ecx, [ebp-18h]
		add	ecx, 8		; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00005DF4o
		mov	ecx, [ebp-18h]
		add	ecx, 98h ; ''  ; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00005DFCo
		mov	ecx, [ebp-18h]
		add	ecx, 120h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$4 proc near
					; DATA XREF: .xdata$x:00005E04o
		mov	ecx, [ebp-18h]
		add	ecx, 1A8h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$5 proc near
					; DATA XREF: .xdata$x:00005E0Co
		mov	ecx, [ebp-18h]
		add	ecx, 230h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$6 proc near
					; DATA XREF: .xdata$x:00005E14o
		mov	ecx, [ebp-18h]
		add	ecx, 2C8h	; this
		jmp	??1AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::~AffixPatternParser(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$7 proc near
					; DATA XREF: .xdata$x:00005E1Co
		mov	ecx, [ebp-18h]
		add	ecx, 3C8h	; this
		jmp	??1CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$8 proc near
					; DATA XREF: .xdata$x:00005E24o
		mov	ecx, [ebp-18h]
		add	ecx, 4E8h	; this
		jmp	??1ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::~ScientificPrecision(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$8 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$9 proc near
					; DATA XREF: .xdata$x:00005E2Co
		mov	ecx, [ebp-18h]
		add	ecx, 590h	; this
		jmp	??1DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::~DigitFormatter(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$9 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$10	proc near
					; DATA XREF: .xdata$x:00005E34o
		mov	ecx, [ebp-18h]
		add	ecx, 7FCh	; this
		jmp	??1DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$10	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$11	proc near
					; DATA XREF: .xdata$x:00005E3Co
		mov	esi, esp
		mov	eax, [ebp-134h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$11	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5DB0h
		dd offset ??_R4DecimalFormatImpl@icu_56@@6B@ ; const icu_56::DecimalFormatImpl::`RTTI Complete Object Locator'
		public ??_7DecimalFormatImpl@icu_56@@6B@
; const	icu_56::DecimalFormatImpl::`vftable'
??_7DecimalFormatImpl@icu_56@@6B@ dd offset ??_EDecimalFormatImpl@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+61o
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+5Eo ...
					; icu_56::DecimalFormatImpl::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5DBCh
__ehfuncinfo$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z dd 19930522h,	0Ch
					; DATA XREF: __ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005DC4o
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$3
		dd 3
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$4
		dd 4
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$5
		dd 5
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$6
		dd 6
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$7
		dd 7
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$8
		dd 8
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$9
		dd 9
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$10
		dd 0Ah
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$11
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5E40h
		public ??_R4DecimalFormatImpl@icu_56@@6B@
; const	icu_56::DecimalFormatImpl::`RTTI Complete Object Locator'
??_R4DecimalFormatImpl@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00005DB0o
		dd offset ??_R0?AVDecimalFormatImpl@icu_56@@@8 ; icu_56::DecimalFormatImpl `RTTI Type Descriptor'
		dd offset ??_R3DecimalFormatImpl@icu_56@@8 ; icu_56::DecimalFormatImpl::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5E54h
		public ??_R0?AVDecimalFormatImpl@icu_56@@@8
; class	icu_56::DecimalFormatImpl `RTTI	Type Descriptor'
??_R0?AVDecimalFormatImpl@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00005E4Co
					; .rdata$r:icu_56::DecimalFormatImpl::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avdecimalfor	db '.?AVDecimalFormatImpl@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5E7Ch
		public ??_R3DecimalFormatImpl@icu_56@@8
; icu_56::DecimalFormatImpl::`RTTI Class Hierarchy Descriptor'
??_R3DecimalFormatImpl@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00005E50o
					; .rdata$r:00005EB4o
		dd 3
		dd offset ??_R2DecimalFormatImpl@icu_56@@8 ; icu_56::DecimalFormatImpl::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5E8Ch
		public ??_R2DecimalFormatImpl@icu_56@@8
; icu_56::DecimalFormatImpl::`RTTI Base	Class Array'
??_R2DecimalFormatImpl@icu_56@@8 dd offset ??_R1A@?0A@EA@DecimalFormatImpl@icu_56@@8
					; DATA XREF: .rdata$r:00005E88o
					; icu_56::DecimalFormatImpl::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5E9Ch
		public ??_R1A@?0A@EA@DecimalFormatImpl@icu_56@@8
; icu_56::DecimalFormatImpl::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@DecimalFormatImpl@icu_56@@8 dd offset ??_R0?AVDecimalFormatImpl@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::DecimalFormatImpl::`RTTI Base Class Array'o
					; icu_56::DecimalFormatImpl `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3DecimalFormatImpl@icu_56@@8 ; icu_56::DecimalFormatImpl::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5EB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+196p
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+48p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::DecimalFormatImpl::`scalar deleting	destructor'(unsigned int)
		public ??_GDecimalFormatImpl@icu_56@@UAEPAXI@Z
??_GDecimalFormatImpl@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1DecimalFormatImpl@icu_56@@UAE@XZ ; icu_56::DecimalFormatImpl::~DecimalFormatImpl(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5F2D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5F2D:				; CODE XREF: icu_56::DecimalFormatImpl::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDecimalFormatImpl@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::DecimalFormatImpl *this, struct icu_56::NumberFormat *, const struct icu_56::UnicodeString *, struct icu_56::DecimalFormatSymbols *, struct UParseError *, enum UErrorCode *)
		public ??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z
??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7DecimalFormatImpl@icu_56@@6B@ ; const icu_56::DecimalFormatImpl::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+78h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+7Ch], 4
		mov	ecx, [ebp+var_14]
		add	ecx, 8Ch ; ''  ; this
		call	??0DigitGrouping@icu_56@@QAE@XZ	; icu_56::DigitGrouping::DigitGrouping(void)
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''  ; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 120h	; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_14]
		add	ecx, 1A8h	; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_14]
		add	ecx, 230h	; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 5
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_8]
		mov	[eax+2B8h], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2BCh], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2C0h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+2C4h], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 2C8h	; this
		call	??0AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::AffixPatternParser(void)
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_14]
		add	ecx, 3C8h	; this
		call	??0CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::CurrencyAffixInfo(void)
		mov	byte ptr [ebp+var_4], 7
		mov	ecx, [ebp+var_14]
		add	ecx, 4E8h	; this
		call	??0ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::ScientificPrecision(void)
		mov	byte ptr [ebp+var_4], 8
		mov	ecx, [ebp+var_14]
		add	ecx, 580h	; this
		call	??0DigitGrouping@icu_56@@QAE@XZ	; icu_56::DigitGrouping::DigitGrouping(void)
		mov	ecx, [ebp+var_14]
		add	ecx, 58Ch	; this
		call	??0SciFormatterOptions@icu_56@@QAE@XZ ;	icu_56::SciFormatterOptions::SciFormatterOptions(void)
		mov	ecx, [ebp+var_14]
		add	ecx, 590h	; this
		call	??0DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::DigitFormatter(void)
		mov	byte ptr [ebp+var_4], 9
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh	; this
		call	??0DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(void)
		mov	byte ptr [ebp+var_4], 0Ah
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?updateAll@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateAll(UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6124h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006208o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00006210o
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00006218o
		mov	ecx, [ebp-14h]
		add	ecx, 98h ; ''  ; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00006220o
		mov	ecx, [ebp-14h]
		add	ecx, 120h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$4 proc near
					; DATA XREF: .xdata$x:00006228o
		mov	ecx, [ebp-14h]
		add	ecx, 1A8h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$5 proc near
					; DATA XREF: .xdata$x:00006230o
		mov	ecx, [ebp-14h]
		add	ecx, 230h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$6 proc near
					; DATA XREF: .xdata$x:00006238o
		mov	ecx, [ebp-14h]
		add	ecx, 2C8h	; this
		jmp	??1AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::~AffixPatternParser(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$7 proc near
					; DATA XREF: .xdata$x:00006240o
		mov	ecx, [ebp-14h]
		add	ecx, 3C8h	; this
		jmp	??1CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$8 proc near
					; DATA XREF: .xdata$x:00006248o
		mov	ecx, [ebp-14h]
		add	ecx, 4E8h	; this
		jmp	??1ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::~ScientificPrecision(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$8 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$9 proc near
					; DATA XREF: .xdata$x:00006250o
		mov	ecx, [ebp-14h]
		add	ecx, 590h	; this
		jmp	??1DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::~DigitFormatter(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$9 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$10 proc near
					; DATA XREF: .xdata$x:00006258o
		mov	ecx, [ebp-14h]
		add	ecx, 7FCh	; this
		jmp	??1DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$10 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 61E0h
__ehfuncinfo$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z	dd 19930522h, 0Bh
					; DATA XREF: __ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z
		align 20h
		dd 1
__unwindtable$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000061E8o
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$3
		dd 3
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$4
		dd 4
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$5
		dd 5
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$6
		dd 6
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$7
		dd 7
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$8
		dd 8
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$9
		dd 9
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$10
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 625Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::DecimalFormatImpl *this, struct icu_56::NumberFormat *, const struct icu_56::DecimalFormatImpl	*, enum	UErrorCode *)
		public ??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z
??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z proc near

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7DecimalFormatImpl@icu_56@@6B@ ; const icu_56::DecimalFormatImpl::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+arg_4]
		add	eax, 8
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??0DigitList@icu_56@@QAE@ABV01@@Z ; icu_56::DigitList::DigitList(icu_56::DigitList const &)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+78h]
		mov	[eax+78h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+7Ch]
		mov	[eax+7Ch], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+80h]
		mov	[eax+80h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+84h]
		mov	[eax+84h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx+88h]
		mov	[eax+88h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx+89h]
		mov	[eax+89h], dl
		mov	eax, [ebp+arg_4]
		add	eax, 8Ch ; ''
		mov	ecx, [ebp+var_14]
		add	ecx, 8Ch ; ''
		mov	edx, [eax]
		mov	[ecx], edx
		mov	edx, [eax+4]
		mov	[ecx+4], edx
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_4]
		add	eax, 98h ; ''
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''  ; this
		call	??0AffixPattern@icu_56@@QAE@ABV01@@Z ; icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern const &)
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+arg_4]
		add	eax, 120h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_14]
		add	ecx, 120h	; this
		call	??0AffixPattern@icu_56@@QAE@ABV01@@Z ; icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern const &)
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+arg_4]
		add	eax, 1A8h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_14]
		add	ecx, 1A8h	; this
		call	??0AffixPattern@icu_56@@QAE@ABV01@@Z ; icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern const &)
		mov	byte ptr [ebp+var_4], 4
		mov	eax, [ebp+arg_4]
		add	eax, 230h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_14]
		add	ecx, 230h	; this
		call	??0AffixPattern@icu_56@@QAE@ABV01@@Z ; icu_56::AffixPattern::AffixPattern(icu_56::AffixPattern const &)
		mov	byte ptr [ebp+var_4], 5
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+2B8h]
		mov	[eax+2B8h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+2BCh]
		mov	[eax+2BCh], edx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2C0h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx+2C4h]
		mov	[eax+2C4h], dl
		mov	eax, [ebp+arg_4]
		add	eax, 2C8h
		push	eax		; struct icu_56::AffixPatternParser *
		mov	ecx, [ebp+var_14]
		add	ecx, 2C8h	; this
		call	??0AffixPatternParser@icu_56@@QAE@ABV01@@Z ; icu_56::AffixPatternParser::AffixPatternParser(icu_56::AffixPatternParser const &)
		mov	byte ptr [ebp+var_4], 6
		mov	eax, [ebp+arg_4]
		add	eax, 3C8h
		push	eax		; struct icu_56::CurrencyAffixInfo *
		mov	ecx, [ebp+var_14]
		add	ecx, 3C8h	; this
		call	??0CurrencyAffixInfo@icu_56@@QAE@ABV01@@Z ; icu_56::CurrencyAffixInfo::CurrencyAffixInfo(icu_56::CurrencyAffixInfo const &)
		mov	byte ptr [ebp+var_4], 7
		mov	eax, [ebp+arg_4]
		add	eax, 4E8h
		push	eax		; struct icu_56::ScientificPrecision *
		mov	ecx, [ebp+var_14]
		add	ecx, 4E8h	; this
		call	??0ScientificPrecision@icu_56@@QAE@ABV01@@Z ; icu_56::ScientificPrecision::ScientificPrecision(icu_56::ScientificPrecision const &)
		mov	byte ptr [ebp+var_4], 8
		mov	eax, [ebp+arg_4]
		add	eax, 580h
		mov	ecx, [ebp+var_14]
		add	ecx, 580h
		mov	edx, [eax]
		mov	[ecx], edx
		mov	edx, [eax+4]
		mov	[ecx+4], edx
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_4]
		mov	cx, [eax+58Ch]
		mov	edx, [ebp+var_14]
		mov	[edx+58Ch], cx
		mov	eax, [ebp+arg_4]
		add	eax, 590h
		push	eax		; struct icu_56::DigitFormatter	*
		mov	ecx, [ebp+var_14]
		add	ecx, 590h	; this
		call	??0DigitFormatter@icu_56@@QAE@ABV01@@Z ; icu_56::DigitFormatter::DigitFormatter(icu_56::DigitFormatter const &)
		mov	byte ptr [ebp+var_4], 9
		mov	eax, [ebp+arg_4]
		add	eax, 7FCh
		push	eax		; struct icu_56::DigitAffixesAndPadding	*
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh	; this
		call	??0DigitAffixesAndPadding@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffixesAndPadding::DigitAffixesAndPadding(icu_56::DigitAffixesAndPadding const &)
		mov	byte ptr [ebp+var_4], 0Ah
		mov	esi, esp
		push	0AD4h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F8], eax
		mov	byte ptr [ebp+var_4], 0Bh
		cmp	[ebp+var_F8], 0
		jz	short loc_6512
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2B8h]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	ecx, [ebp+var_F8] ; this
		call	??0DecimalFormatSymbols@icu_56@@QAE@ABV01@@Z ; icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::DecimalFormatSymbols const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_651C
; ---------------------------------------------------------------------------

loc_6512:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+297j
		mov	[ebp+var_10C], 0

loc_651C:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+2B4j
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_104], edx
		mov	byte ptr [ebp+var_4], 0Ah
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_104]
		mov	[eax+2B8h], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2B8h], 0
		jnz	short loc_6565
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6565
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_6565:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+2E9j
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl	const &,UErrorCode &)+2FEj
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax+2C0h], 0
		jz	loc_660C
		mov	esi, esp
		push	8		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 0Ch
		cmp	[ebp+var_E0], 0
		jz	short loc_65B9
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+2C0h]
		push	ecx		; struct icu_56::PluralRules *
		mov	ecx, [ebp+var_E0] ; this
		call	??0PluralRules@icu_56@@QAE@ABV01@@Z ; icu_56::PluralRules::PluralRules(icu_56::PluralRules const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_65C3
; ---------------------------------------------------------------------------

loc_65B9:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+33Ej
		mov	[ebp+var_10C], 0

loc_65C3:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+35Bj
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_EC], edx
		mov	byte ptr [ebp+var_4], 0Ah
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+2C0h], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2C0h], 0
		jnz	short loc_660C
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_660C
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_660C:				; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+313j
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl	const &,UErrorCode &)+390j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000674Co
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00006754o
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:0000675Co
		mov	ecx, [ebp-14h]
		add	ecx, 98h ; ''  ; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00006764o
		mov	ecx, [ebp-14h]
		add	ecx, 120h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$4 proc near
					; DATA XREF: .xdata$x:0000676Co
		mov	ecx, [ebp-14h]
		add	ecx, 1A8h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$5 proc near
					; DATA XREF: .xdata$x:00006774o
		mov	ecx, [ebp-14h]
		add	ecx, 230h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$6 proc near
					; DATA XREF: .xdata$x:0000677Co
		mov	ecx, [ebp-14h]
		add	ecx, 2C8h	; this
		jmp	??1AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::~AffixPatternParser(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$7 proc near
					; DATA XREF: .xdata$x:00006784o
		mov	ecx, [ebp-14h]
		add	ecx, 3C8h	; this
		jmp	??1CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$8 proc near
					; DATA XREF: .xdata$x:0000678Co
		mov	ecx, [ebp-14h]
		add	ecx, 4E8h	; this
		jmp	??1ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::~ScientificPrecision(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$8 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$9 proc near
					; DATA XREF: .xdata$x:00006794o
		mov	ecx, [ebp-14h]
		add	ecx, 590h	; this
		jmp	??1DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::~DigitFormatter(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$9 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$10 proc near
					; DATA XREF: .xdata$x:0000679Co
		mov	ecx, [ebp-14h]
		add	ecx, 7FCh	; this
		jmp	??1DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(void)
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$10 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$11 proc near
					; DATA XREF: .xdata$x:000067A4o
		mov	esi, esp
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$11 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$12 proc near
					; DATA XREF: .xdata$x:000067ACo
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$12 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6724h
__ehfuncinfo$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z dd 19930522h, 0Dh
					; DATA XREF: __ehhandler$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000672Co
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$3
		dd 3
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$4
		dd 4
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$5
		dd 5
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$6
		dd 6
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$7
		dd 7
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$8
		dd 8
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$9
		dd 9
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$10
		dd 0Ah
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$11
		dd 0Ah
		dd offset __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABV01@AAW4UErrorCode@@@Z$12
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 67B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DecimalFormatImpl *__thiscall icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl *this, const	struct icu_56::DecimalFormatImpl *, enum UErrorCode *)
		public ?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z
?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z proc near

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jnz	short loc_680F
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_6817

loc_680F:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+55j
		mov	eax, [ebp+var_14]
		jmp	loc_6B3A
; ---------------------------------------------------------------------------

loc_6817:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+5Dj
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, 8
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 8
		call	??4DigitList@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitList::operator=(icu_56::DigitList	const &)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+78h]
		mov	[eax+78h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+7Ch]
		mov	[eax+7Ch], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		mov	[eax+80h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+84h]
		mov	[eax+84h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+88h]
		mov	[eax+88h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+89h]
		mov	[eax+89h], dl
		mov	eax, [ebp+arg_0]
		add	eax, 8Ch ; ''
		mov	ecx, [ebp+var_14]
		add	ecx, 8Ch ; ''
		mov	edx, [eax]
		mov	[ecx], edx
		mov	edx, [eax+4]
		mov	[ecx+4], edx
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_0]
		add	eax, 98h ; ''
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		mov	eax, [ebp+arg_0]
		add	eax, 120h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 120h
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		mov	eax, [ebp+arg_0]
		add	eax, 1A8h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1A8h
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		mov	eax, [ebp+arg_0]
		add	eax, 230h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 230h
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2BCh]
		mov	[eax+2BCh], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+2C4h]
		mov	[eax+2C4h], dl
		mov	eax, [ebp+arg_0]
		add	eax, 2C8h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 2C8h
		call	??4AffixPatternParser@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::AffixPatternParser::operator=(icu_56::AffixPatternParser const &)
		mov	eax, [ebp+arg_0]
		add	eax, 3C8h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 3C8h
		call	??4CurrencyAffixInfo@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::CurrencyAffixInfo::operator=(icu_56::CurrencyAffixInfo	const &)
		mov	eax, [ebp+arg_0]
		add	eax, 4E8h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4E8h
		call	??4ScientificPrecision@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::ScientificPrecision::operator=(icu_56::ScientificPrecision const &)
		mov	eax, [ebp+arg_0]
		add	eax, 580h
		mov	ecx, [ebp+var_14]
		add	ecx, 580h
		mov	edx, [eax]
		mov	[ecx], edx
		mov	edx, [eax+4]
		mov	[ecx+4], edx
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_0]
		mov	cx, [eax+58Ch]
		mov	edx, [ebp+var_14]
		mov	[edx+58Ch], cx
		mov	eax, [ebp+arg_0]
		add	eax, 590h
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 590h
		call	??4DigitFormatter@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitFormatter::operator=(icu_56::DigitFormatter const &)
		mov	eax, [ebp+arg_0]
		add	eax, 7FCh
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh
		call	??4DigitAffixesAndPadding@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitAffixesAndPadding::operator=(icu_56::DigitAffixesAndPadding const &)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2B8h]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+2B8h]
		call	??4DecimalFormatSymbols@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DecimalFormatSymbols::operator=(icu_56::DecimalFormatSymbols const &)
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2C0h], 0
		jz	short loc_6A35
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+2C0h], 0
		jz	short loc_6A35
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2C0h]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+2C0h]
		call	??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::PluralRules::operator=(icu_56::PluralRules const &)
		jmp	loc_6B37
; ---------------------------------------------------------------------------

loc_6A35:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+25Aj
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+266j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2C0h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_6A7E
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_6A88
; ---------------------------------------------------------------------------

loc_6A7E:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+2A7j
		mov	[ebp+var_10C], 0

loc_6A88:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+2CCj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2C0h]
		mov	[eax+2C0h], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2C0h], 0
		jz	loc_6B37
		mov	esi, esp
		push	8		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_6AF1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2C0h]
		push	ecx		; struct icu_56::PluralRules *
		mov	ecx, [ebp+var_E0] ; this
		call	??0PluralRules@icu_56@@QAE@ABV01@@Z ; icu_56::PluralRules::PluralRules(icu_56::PluralRules const &)
		mov	[ebp+var_10C], eax
		jmp	short loc_6AFB
; ---------------------------------------------------------------------------

loc_6AF1:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+322j
		mov	[ebp+var_10C], 0

loc_6AFB:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+33Fj
		mov	edx, [ebp+var_10C]
		mov	[ebp+var_EC], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+2C0h], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2C0h], 0
		jnz	short loc_6B37
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_14]
		jmp	short loc_6B3A
; ---------------------------------------------------------------------------

loc_6B37:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+280j
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+2F4j ...
		mov	eax, [ebp+var_14]

loc_6B3A:				; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+62j
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+385j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6B5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006B98o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6B94h
__unwindtable$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006BA4o
		dd offset __unwindfunclet$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?assign@DecimalFormatImpl@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6BC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DecimalFormatImpl::operator==(class icu_56::DecimalFormatImpl const &)const
		public ??8DecimalFormatImpl@icu_56@@QBECABV01@@Z
??8DecimalFormatImpl@icu_56@@QBECABV01@@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_6BF2
		mov	al, 1
		jmp	loc_6F05
; ---------------------------------------------------------------------------

loc_6BF2:				; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+29j
		mov	eax, [ebp+arg_0]
		add	eax, 8
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	??8DigitList@icu_56@@QBECABV01@@Z ; icu_56::DigitList::operator==(icu_56::DigitList const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_6EF8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+78h]
		cmp	ecx, [eax+78h]
		jnz	loc_6EF8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+7Ch]
		cmp	ecx, [eax+7Ch]
		jnz	loc_6EF8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+80h]
		cmp	ecx, [eax+80h]
		jnz	loc_6EF8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+84h]
		cmp	ecx, [eax+84h]
		jnz	loc_6EF8
		mov	edx, [ebp+var_8]
		movsx	eax, byte ptr [edx+88h]
		mov	ecx, [ebp+arg_0]
		movsx	edx, byte ptr [ecx+88h]
		cmp	eax, edx
		jnz	loc_6EF8
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+89h]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx+89h]
		cmp	ecx, eax
		jnz	loc_6EF8
		mov	ecx, [ebp+arg_0]
		add	ecx, 8Ch ; ''
		push	ecx		; struct icu_56::DigitGrouping *
		mov	ecx, [ebp+var_8]
		add	ecx, 8Ch ; ''  ; this
		call	?equals@DigitGrouping@icu_56@@QBECABV12@@Z ; icu_56::DigitGrouping::equals(icu_56::DigitGrouping const &)
		movsx	edx, al
		test	edx, edx
		jz	loc_6EF8
		mov	eax, [ebp+arg_0]
		add	eax, 98h ; ''
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_6EF8
		mov	edx, [ebp+arg_0]
		add	edx, 120h
		push	edx		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 120h	; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	eax, al
		test	eax, eax
		jz	loc_6EF8
		mov	ecx, [ebp+arg_0]
		add	ecx, 1A8h
		push	ecx		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	edx, al
		test	edx, edx
		jz	loc_6EF8
		mov	eax, [ebp+arg_0]
		add	eax, 230h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 230h	; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_6EF8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+2BCh]
		cmp	ecx, [eax+2BCh]
		jnz	loc_6EF8
		mov	edx, [ebp+arg_0]
		add	edx, 2C8h
		push	edx		; struct icu_56::AffixPatternParser *
		mov	ecx, [ebp+var_8]
		add	ecx, 2C8h	; this
		call	?equals@AffixPatternParser@icu_56@@QBECABV12@@Z	; icu_56::AffixPatternParser::equals(icu_56::AffixPatternParser	const &)
		movsx	eax, al
		test	eax, eax
		jz	loc_6EF8
		mov	ecx, [ebp+arg_0]
		add	ecx, 3C8h
		push	ecx		; struct icu_56::CurrencyAffixInfo *
		mov	ecx, [ebp+var_8]
		add	ecx, 3C8h	; this
		call	?equals@CurrencyAffixInfo@icu_56@@QBECABV12@@Z ; icu_56::CurrencyAffixInfo::equals(icu_56::CurrencyAffixInfo const &)
		movsx	edx, al
		test	edx, edx
		jz	loc_6EF8
		mov	eax, [ebp+arg_0]
		add	eax, 4E8h
		push	eax		; struct icu_56::ScientificPrecision *
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?equals@ScientificPrecision@icu_56@@QBECABV12@@Z ; icu_56::ScientificPrecision::equals(icu_56::ScientificPrecision const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_6EF8
		mov	edx, [ebp+arg_0]
		add	edx, 580h
		push	edx		; struct icu_56::DigitGrouping *
		mov	ecx, [ebp+var_8]
		add	ecx, 580h	; this
		call	?equals@DigitGrouping@icu_56@@QBECABV12@@Z ; icu_56::DigitGrouping::equals(icu_56::DigitGrouping const &)
		movsx	eax, al
		test	eax, eax
		jz	loc_6EF8
		mov	ecx, [ebp+arg_0]
		add	ecx, 58Ch
		push	ecx		; struct icu_56::SciFormatterOptions *
		mov	ecx, [ebp+var_8]
		add	ecx, 58Ch	; this
		call	?equals@SciFormatterOptions@icu_56@@QBECABV12@@Z ; icu_56::SciFormatterOptions::equals(icu_56::SciFormatterOptions const &)
		movsx	edx, al
		test	edx, edx
		jz	loc_6EF8
		mov	eax, [ebp+arg_0]
		add	eax, 590h
		push	eax		; struct icu_56::DigitFormatter	*
		mov	ecx, [ebp+var_8]
		add	ecx, 590h	; this
		call	?equals@DigitFormatter@icu_56@@QBECABV12@@Z ; icu_56::DigitFormatter::equals(icu_56::DigitFormatter const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_6EF8
		mov	edx, [ebp+arg_0]
		add	edx, 7FCh
		push	edx		; struct icu_56::DigitAffixesAndPadding	*
		mov	ecx, [ebp+var_8]
		add	ecx, 7FCh	; this
		call	?equals@DigitAffixesAndPadding@icu_56@@QBECABV12@@Z ; icu_56::DigitAffixesAndPadding::equals(icu_56::DigitAffixesAndPadding const &)
		movsx	eax, al
		test	eax, eax
		jz	loc_6EF8
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2B8h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2B8h]
		call	??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z ; icu_56::DecimalFormatSymbols::operator==(icu_56::DecimalFormatSymbols const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_6EF8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+2C0h]
		cmp	ecx, [eax+2C0h]
		jz	short loc_6ED7
		mov	edx, [ebp+var_8]
		cmp	dword ptr [edx+2C0h], 0
		jz	short loc_6EF8
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+2C0h], 0
		jz	short loc_6EF8
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2C0h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2C0h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+2C0h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6EF8

loc_6ED7:				; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+2C8j
		mov	edx, [ebp+var_8]
		movsx	eax, byte ptr [edx+2C4h]
		mov	ecx, [ebp+arg_0]
		movsx	edx, byte ptr [ecx+2C4h]
		cmp	eax, edx
		jnz	short loc_6EF8
		mov	[ebp+var_CD], 1
		jmp	short loc_6EFF
; ---------------------------------------------------------------------------

loc_6EF8:				; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+49j
					; icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const	&)+5Bj	...
		mov	[ebp+var_CD], 0

loc_6EFF:				; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+336j
		mov	al, [ebp+var_CD]

loc_6F05:				; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8DecimalFormatImpl@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DecimalFormatImpl::~DecimalFormatImpl(icu_56::DecimalFormatImpl *__hidden this)
		public ??1DecimalFormatImpl@icu_56@@UAE@XZ
??1DecimalFormatImpl@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::`scalar	deleting destructor'(uint)+26p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DecimalFormatImpl@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7DecimalFormatImpl@icu_56@@6B@ ; const icu_56::DecimalFormatImpl::`vftable'
		mov	[ebp+var_4], 0Ah
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2B8h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_6FB7
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_6FC1
; ---------------------------------------------------------------------------

loc_6FB7:				; CODE XREF: icu_56::DecimalFormatImpl::~DecimalFormatImpl(void)+74j
		mov	[ebp+var_10C], 0

loc_6FC1:				; CODE XREF: icu_56::DecimalFormatImpl::~DecimalFormatImpl(void)+99j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2C0h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_700A
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_7014
; ---------------------------------------------------------------------------

loc_700A:				; CODE XREF: icu_56::DecimalFormatImpl::~DecimalFormatImpl(void)+C7j
		mov	[ebp+var_10C], 0

loc_7014:				; CODE XREF: icu_56::DecimalFormatImpl::~DecimalFormatImpl(void)+ECj
		mov	byte ptr [ebp+var_4], 9
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh	; this
		call	??1DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(void)
		mov	byte ptr [ebp+var_4], 8
		mov	ecx, [ebp+var_14]
		add	ecx, 590h	; this
		call	??1DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::~DigitFormatter(void)
		mov	byte ptr [ebp+var_4], 7
		mov	ecx, [ebp+var_14]
		add	ecx, 4E8h	; this
		call	??1ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::~ScientificPrecision(void)
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_14]
		add	ecx, 3C8h	; this
		call	??1CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)
		mov	byte ptr [ebp+var_4], 5
		mov	ecx, [ebp+var_14]
		add	ecx, 2C8h	; this
		call	??1AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::~AffixPatternParser(void)
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_14]
		add	ecx, 230h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_14]
		add	ecx, 1A8h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 120h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 98h ; ''  ; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DecimalFormatImpl@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000071E4o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$1 proc near
					; DATA XREF: .xdata$x:000071ECo
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$2 proc near
					; DATA XREF: .xdata$x:000071F4o
		mov	ecx, [ebp-14h]
		add	ecx, 98h ; ''  ; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$3 proc near
					; DATA XREF: .xdata$x:000071FCo
		mov	ecx, [ebp-14h]
		add	ecx, 120h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$4 proc near
					; DATA XREF: .xdata$x:00007204o
		mov	ecx, [ebp-14h]
		add	ecx, 1A8h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$5 proc near
					; DATA XREF: .xdata$x:0000720Co
		mov	ecx, [ebp-14h]
		add	ecx, 230h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$6 proc near
					; DATA XREF: .xdata$x:00007214o
		mov	ecx, [ebp-14h]
		add	ecx, 2C8h	; this
		jmp	??1AffixPatternParser@icu_56@@QAE@XZ ; icu_56::AffixPatternParser::~AffixPatternParser(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$7 proc near
					; DATA XREF: .xdata$x:0000721Co
		mov	ecx, [ebp-14h]
		add	ecx, 3C8h	; this
		jmp	??1CurrencyAffixInfo@icu_56@@QAE@XZ ; icu_56::CurrencyAffixInfo::~CurrencyAffixInfo(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$8 proc near
					; DATA XREF: .xdata$x:00007224o
		mov	ecx, [ebp-14h]
		add	ecx, 4E8h	; this
		jmp	??1ScientificPrecision@icu_56@@QAE@XZ ;	icu_56::ScientificPrecision::~ScientificPrecision(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$8 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$9 proc near
					; DATA XREF: .xdata$x:0000722Co
		mov	ecx, [ebp-14h]
		add	ecx, 590h	; this
		jmp	??1DigitFormatter@icu_56@@QAE@XZ ; icu_56::DigitFormatter::~DigitFormatter(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$9 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$10 proc near
					; DATA XREF: .xdata$x:00007234o
		mov	ecx, [ebp-14h]
		add	ecx, 7FCh	; this
		jmp	??1DigitAffixesAndPadding@icu_56@@QAE@XZ ; icu_56::DigitAffixesAndPadding::~DigitAffixesAndPadding(void)
__unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$10 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DecimalFormatImpl@icu_56@@UAE@XZ	proc near
					; DATA XREF: icu_56::DecimalFormatImpl::~DecimalFormatImpl(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DecimalFormatImpl@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DecimalFormatImpl@icu_56@@UAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 71BCh
__ehfuncinfo$??1DecimalFormatImpl@icu_56@@UAE@XZ dd 19930522h, 0Bh
					; DATA XREF: __ehhandler$??1DecimalFormatImpl@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1DecimalFormatImpl@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
__unwindtable$??1DecimalFormatImpl@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000071C4o
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$0
		dd 0
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$2
		dd 2
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$3
		dd 3
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$4
		dd 4
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$5
		dd 5
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$6
		dd 6
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$7
		dd 7
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$8
		dd 8
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$9
		dd 9
		dd offset __unwindfunclet$??1DecimalFormatImpl@icu_56@@UAE@XZ$10
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7238h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::ValueFormatter	*__thiscall icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::DecimalFormatImpl *this, struct icu_56::ValueFormatter *)
		public ?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z
?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+92p
					; icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+6Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_7293
		mov	eax, [ebp+var_8]
		add	eax, 58Ch
		push	eax		; struct icu_56::SciFormatterOptions *
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h
		push	ecx		; struct icu_56::ScientificPrecision *
		mov	edx, [ebp+var_8]
		add	edx, 590h
		push	edx		; struct icu_56::DigitFormatter	*
		mov	ecx, [ebp+arg_0] ; this
		call	?prepareScientificFormatting@ValueFormatter@icu_56@@QAEXABVDigitFormatter@2@ABVScientificPrecision@2@ABVSciFormatterOptions@2@@Z ; icu_56::ValueFormatter::prepareScientificFormatting(icu_56::DigitFormatter const &,icu_56::ScientificPrecision const	&,icu_56::SciFormatterOptions const &)
		mov	eax, [ebp+arg_0]
		jmp	short loc_72C4
; ---------------------------------------------------------------------------

loc_7293:				; CODE XREF: icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)+2Fj
		mov	eax, [ebp+var_8]
		add	eax, 58Ch
		push	eax		; struct icu_56::DigitFormatterOptions *
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h
		push	ecx		; struct icu_56::FixedPrecision	*
		mov	edx, [ebp+var_8]
		add	edx, 580h
		push	edx		; struct icu_56::DigitGrouping *
		mov	eax, [ebp+var_8]
		add	eax, 590h
		push	eax		; struct icu_56::DigitFormatter	*
		mov	ecx, [ebp+arg_0] ; this
		call	?prepareFixedDecimalFormatting@ValueFormatter@icu_56@@QAEXABVDigitFormatter@2@ABVDigitGrouping@2@ABVFixedPrecision@2@ABVDigitFormatterOptions@2@@Z ; icu_56::ValueFormatter::prepareFixedDecimalFormatting(icu_56::DigitFormatter const	&,icu_56::DigitGrouping	const &,icu_56::FixedPrecision const &,icu_56::DigitFormatterOptions const &)
		mov	eax, [ebp+arg_0]

loc_72C4:				; CODE XREF: icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)+59j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DecimalFormatImpl::getPatternScale(icu_56::DecimalFormatImpl *__hidden	this)
		public ?getPatternScale@DecimalFormatImpl@icu_56@@ABEHXZ
?getPatternScale@DecimalFormatImpl@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateAll(int,signed char,UErrorCode &)+62p

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_1D		= byte ptr -1Dh
var_11		= byte ptr -11h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?usesPercent@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPercent(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_735C
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?usesPercent@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPercent(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_735C
		mov	ecx, [ebp+var_8]
		add	ecx, 120h	; this
		call	?usesPercent@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPercent(void)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_735C
		mov	ecx, [ebp+var_8]
		add	ecx, 230h	; this
		call	?usesPercent@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPercent(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_735C
		mov	[ebp+var_E5], 0
		jmp	short loc_7363
; ---------------------------------------------------------------------------

loc_735C:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+36j
					; icu_56::DecimalFormatImpl::getPatternScale(void)+4Bj	...
		mov	[ebp+var_E5], 1

loc_7363:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+7Ej
		mov	cl, [ebp+var_E5]
		mov	[ebp+var_11], cl
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_737B
		mov	eax, 2
		jmp	short loc_73F9
; ---------------------------------------------------------------------------

loc_737B:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+96j
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?usesPermill@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPermill(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_73D8
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?usesPermill@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPermill(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_73D8
		mov	ecx, [ebp+var_8]
		add	ecx, 120h	; this
		call	?usesPermill@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPermill(void)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_73D8
		mov	ecx, [ebp+var_8]
		add	ecx, 230h	; this
		call	?usesPermill@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesPermill(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_73D8
		mov	[ebp+var_E5], 0
		jmp	short loc_73DF
; ---------------------------------------------------------------------------

loc_73D8:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+B2j
					; icu_56::DecimalFormatImpl::getPatternScale(void)+C7j	...
		mov	[ebp+var_E5], 1

loc_73DF:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+FAj
		mov	cl, [ebp+var_E5]
		mov	[ebp+var_1D], cl
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_73F7
		mov	eax, 3
		jmp	short loc_73F9
; ---------------------------------------------------------------------------

loc_73F7:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+112j
		xor	eax, eax

loc_73F9:				; CODE XREF: icu_56::DecimalFormatImpl::getPatternScale(void)+9Dj
					; icu_56::DecimalFormatImpl::getPatternScale(void)+119j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getPatternScale@DecimalFormatImpl@icu_56@@ABEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7410h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setMultiplierScale(icu_56::DecimalFormatImpl *this, int)
		public ?setMultiplierScale@DecimalFormatImpl@icu_56@@AAEXH@Z
?setMultiplierScale@DecimalFormatImpl@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateAll(int,signed char,UErrorCode &)+6Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_7448
		push	0		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?set@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::set(int)
		jmp	short loc_7464
; ---------------------------------------------------------------------------

loc_7448:				; CODE XREF: icu_56::DecimalFormatImpl::setMultiplierScale(int)+27j
		push	1		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?set@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::set(int)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)

loc_7464:				; CODE XREF: icu_56::DecimalFormatImpl::setMultiplierScale(int)+36j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMultiplierScale@DecimalFormatImpl@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 747Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, int, struct icu_56::UnicodeString	*, struct icu_56::FieldPosition	*, enum	UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near

var_F4		= byte ptr -0F4h
var_F0		= dword	ptr -0F0h
var_24		= byte ptr -24h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::FieldPosition *
		lea	ecx, [ebp+var_24] ; this
		call	??0FieldPositionOnlyHandler@icu_56@@QAE@AAVFieldPosition@1@@Z ;	icu_56::FieldPositionOnlyHandler::FieldPositionOnlyHandler(icu_56::FieldPosition &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_24]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode	&)
		mov	[ebp+var_F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24] ; this
		call	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
		mov	eax, [ebp+var_F0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+8Co
		dd offset $LN6
$LN6		dd 0FFFFFFDCh, 8	; DATA XREF: .text:0000753Co
		dd offset $LN4		; "handler"
$LN4		db 'handler',0          ; DATA XREF: .text:00007548o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7554h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00007580o
		lea	ecx, [ebp-24h]	; this
		jmp	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 757Ch
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000758Co
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 75A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, int, struct icu_56::UnicodeString	*, struct icu_56::FieldPositionIterator	*, enum	UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near

var_FC		= byte ptr -0FCh
var_F8		= dword	ptr -0F8h
var_2C		= byte ptr -2Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionIterator *
		lea	ecx, [ebp+var_2C] ; this
		call	??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z ; icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIterator *,UErrorCode &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_2C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode	&)
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
		mov	eax, [ebp+var_F8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_0		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+90o
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:0000766Co
		dd offset $LN4_0	; "handler"
$LN4_0		db 'handler',0          ; DATA XREF: .text:00007678o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000076B0o
		lea	ecx, [ebp-2Ch]	; this
		jmp	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-100h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 76ACh
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000076BCo
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 76D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::formatInt32(icu_56::DecimalFormatImpl *this, int,	struct icu_56::UnicodeString *,	struct icu_56::FieldPositionHandler *, enum UErrorCode *)
		public ?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+68p
					; icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+6Cp ...

var_10C		= byte ptr -10Ch
var_108		= dword	ptr -108h
var_3C		= byte ptr -3Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		call	??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_773E
		mov	eax, [ebp+arg_4]
		jmp	short loc_779D
; ---------------------------------------------------------------------------

loc_773E:				; CODE XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5Fj
		lea	ecx, [ebp+var_3C] ; this
		call	??0ValueFormatter@icu_56@@QAE@XZ ; icu_56::ValueFormatter::ValueFormatter(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+var_14]
		mov	eax, [edx+2C0h]
		push	eax		; struct icu_56::PluralRules *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		lea	edx, [ebp+var_3C]
		push	edx		; struct icu_56::ValueFormatter	*
		mov	ecx, [ebp+var_14] ; this
		call	?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z ; icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)
		push	eax		; struct icu_56::ValueFormatter	*
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh	; this
		call	?formatInt32@DigitAffixesAndPadding@icu_56@@QBEAAVUnicodeString@2@HABVValueFormatter@2@AAVFieldPositionHandler@2@PBVPluralRules@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DigitAffixesAndPadding::formatInt32(int,icu_56::ValueFormatter const &,icu_56::FieldPositionHandler &,icu_56::PluralRules const *,icu_56::UnicodeString &,UErrorCode &)
		mov	[ebp+var_108], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_3C] ; this
		call	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+var_108]

loc_779D:				; CODE XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+64j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN8		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+C9o
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFC4h, 20h	; DATA XREF: .text:000077D4o
		dd offset $LN5
; ---------------------------------------------------------------------------

$LN5:					; DATA XREF: .text:000077E0o
		jbe	short loc_784C
		add	bh, bh
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 77E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00007814o
		lea	ecx, [ebp-3Ch]	; this
		jmp	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
__unwindfunclet$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7810h
__unwindtable$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007820o
		dd offset __unwindfunclet$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 783Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::formatInt64(icu_56::DecimalFormatImpl *this, __int64, struct icu_56::UnicodeString *, struct icu_56::FieldPositionHandler	*, enum	UErrorCode *)
		public ?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+6Cp
					; icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+70p

var_1C8		= byte ptr -1C8h
var_1C4		= dword	ptr -1C4h
var_F8		= byte ptr -0F8h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0

loc_784C:				; CODE XREF: .text:$LN5j
		push	eax
		sub	esp, 1BCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C8]
		mov	ecx, 6Fh ; 'o'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	dword ptr [ebp+arg_0+4], 0FFFFFFFFh
		jl	short loc_78BD
		jg	short loc_7892
		cmp	dword ptr [ebp+arg_0], 80000000h
		jb	short loc_78BD

loc_7892:				; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+4Bj
		cmp	dword ptr [ebp+arg_0+4], 0
		jg	short loc_78BD
		jl	short loc_78A3
		cmp	dword ptr [ebp+arg_0], 7FFFFFFFh
		ja	short loc_78BD

loc_78A3:				; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5Cj
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_18] ; this
		call	?formatInt32@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@HAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode	&)
		jmp	short loc_7923
; ---------------------------------------------------------------------------

loc_78BD:				; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+49j
					; icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+54j ...
		lea	ecx, [ebp+var_F8] ; this
		call	??0VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_F8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode	&)
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_F8]
		push	eax		; struct icu_56::VisibleDigitsWithExponent *
		mov	ecx, [ebp+var_18] ; this
		call	?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_F8] ; this
		call	??1VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)
		mov	eax, [ebp+var_1C4]

loc_7923:				; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+7Fj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN10		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+EBo
		dd offset $LN9
$LN9		db 8, 0FFh		; DATA XREF: .text:00007964o
		dw 0FFFFh
		dd offset ?app@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Openmode const std::_Iosb<int>::app
		dd offset $LN7_2	; "digits"
$LN7_2		db 'digits',0           ; DATA XREF: .text:00007970o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 797Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000079B4o
		lea	ecx, [ebp-0F8h]	; this
		jmp	??1VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)
__unwindfunclet$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1CCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 79B0h
__unwindtable$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000079C0o
		dd offset __unwindfunclet$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 79DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::formatDouble(icu_56::DecimalFormatImpl *this, double, struct icu_56::UnicodeString *, struct icu_56::FieldPositionHandler	*, enum	UErrorCode *)
		public ?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+6Dp
					; icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+71p

var_1E8		= qword	ptr -1E8h
var_1C8		= byte ptr -1C8h
var_1C4		= dword	ptr -1C4h
var_F8		= byte ptr -0F8h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1BCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C8]
		mov	ecx, 6Fh ; 'o'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		lea	ecx, [ebp+var_F8] ; this
		call	??0VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_F8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+1E8h+var_1E8] ; double
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_F8]
		push	eax		; struct icu_56::VisibleDigitsWithExponent *
		mov	ecx, [ebp+var_18] ; this
		call	?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_F8] ; this
		call	??1VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)
		mov	eax, [ebp+var_1C4]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN7_3		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+B0o
		dd offset $LN6_1
$LN6_1		db 8, 0FFh		; DATA XREF: .text:00007AC8o
		dw 0FFFFh
		dd offset ?app@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Openmode const std::_Iosb<int>::app
		dd offset $LN4_1	; "digits"
$LN4_1		db 'digits',0           ; DATA XREF: .text:00007AD4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7AE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00007B18o
		lea	ecx, [ebp-0F8h]	; this
		jmp	??1VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)
__unwindfunclet$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1CCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7B14h
__unwindtable$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007B24o
		dd offset __unwindfunclet$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, double, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *, enum UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near

var_118		= qword	ptr -118h
var_F4		= byte ptr -0F4h
var_F0		= dword	ptr -0F0h
var_24		= byte ptr -24h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::FieldPosition *
		lea	ecx, [ebp+var_24] ; this
		call	??0FieldPositionOnlyHandler@icu_56@@QAE@AAVFieldPosition@1@@Z ;	icu_56::FieldPositionOnlyHandler::FieldPositionOnlyHandler(icu_56::FieldPosition &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_24]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+118h+var_118] ; double
		mov	ecx, [ebp+var_14] ; this
		call	?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler	&,UErrorCode &)
		mov	[ebp+var_F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24] ; this
		call	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
		mov	eax, [ebp+var_F0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN7_4		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+91o
		dd offset $LN6_2
$LN6_2		dd 0FFFFFFDCh, 8	; DATA XREF: .text:00007C04o
		dd offset $LN4_2	; "handler"
$LN4_2		db 'handler',0          ; DATA XREF: .text:00007C10o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7C1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00007C48o
		lea	ecx, [ebp-24h]	; this
		jmp	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7C44h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007C54o
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, const struct icu_56::DigitList *,	struct icu_56::UnicodeString *,	struct icu_56::FieldPosition *,	enum UErrorCode	*)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc	near

var_170		= byte ptr -170h
var_16C		= dword	ptr -16Ch
var_A0		= byte ptr -0A0h
var_90		= byte ptr -90h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 164h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_170]
		mov	ecx, 59h ; 'Y'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_90] ; this
		call	??0DigitList@icu_56@@QAE@ABV01@@Z ; icu_56::DigitList::DigitList(icu_56::DigitList const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::FieldPosition *
		lea	ecx, [ebp+var_A0] ; this
		call	??0FieldPositionOnlyHandler@icu_56@@QAE@AAVFieldPosition@1@@Z ;	icu_56::FieldPositionOnlyHandler::FieldPositionOnlyHandler(icu_56::FieldPosition &)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_A0]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_90]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_16C], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_A0] ; this
		call	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	eax, [ebp+var_16C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 170h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9_0		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+BDo
		dd offset $LN8_0
$LN8_0		dd 0FFFFFF70h, 70h	; DATA XREF: .text:00007D6Co
		dd offset $LN5_0	; "dl"
		dd 0FFFFFF60h, 8
		dd offset $LN6_3	; "handler"
$LN6_3		db 'handler',0          ; DATA XREF: .text:00007D84o
$LN5_0		db 'dl',0               ; DATA XREF: .text:00007D78o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7D94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00007DD8o
		lea	ecx, [ebp-90h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00007DE0o
		lea	ecx, [ebp-0A0h]	; this
		jmp	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-174h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7DD4h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007DECo
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, __int64, struct icu_56::UnicodeString *, struct icu_56::FieldPosition *, enum UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near

var_F4		= byte ptr -0F4h
var_F0		= dword	ptr -0F0h
var_24		= byte ptr -24h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::FieldPosition *
		lea	ecx, [ebp+var_24] ; this
		call	??0FieldPositionOnlyHandler@icu_56@@QAE@AAVFieldPosition@1@@Z ;	icu_56::FieldPositionOnlyHandler::FieldPositionOnlyHandler(icu_56::FieldPosition &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_24]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, dword ptr [ebp+arg_0+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_0]
		push	ecx		; __int64
		mov	ecx, [ebp+var_14] ; this
		call	?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler	&,UErrorCode &)
		mov	[ebp+var_F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24] ; this
		call	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
		mov	eax, [ebp+var_F0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_5		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+90o
		dd offset $LN6_4
$LN6_4		dd 0FFFFFFDCh, 8	; DATA XREF: .text:00007ECCo
		dd offset $LN4_3	; "handler"
$LN4_3		db 'handler',0          ; DATA XREF: .text:00007ED8o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00007F10o
		lea	ecx, [ebp-24h]	; this
		jmp	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7F0Ch
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007F1Co
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, __int64, struct icu_56::UnicodeString *, struct icu_56::FieldPositionIterator *, enum UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near

var_FC		= byte ptr -0FCh
var_F8		= dword	ptr -0F8h
var_2C		= byte ptr -2Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::FieldPositionIterator *
		lea	ecx, [ebp+var_2C] ; this
		call	??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z ; icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIterator *,UErrorCode &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_2C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, dword ptr [ebp+arg_0+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_0]
		push	ecx		; __int64
		mov	ecx, [ebp+var_14] ; this
		call	?formatInt64@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@_JAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler	&,UErrorCode &)
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
		mov	eax, [ebp+var_F8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_6		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+94o
off_8000	dd offset $LN6_5	; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
$LN6_5		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:off_8000o
		dd offset $LN4_4	; "handler"
$LN4_4		db 'handler',0          ; DATA XREF: .text:0000800Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00008044o
		lea	ecx, [ebp-2Ch]	; this
		jmp	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-100h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8040h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008050o
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@_JAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 806Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, double, struct icu_56::UnicodeString *, struct icu_56::FieldPositionIterator *, enum UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near

var_120		= qword	ptr -120h
var_FC		= byte ptr -0FCh
var_F8		= dword	ptr -0F8h
var_2C		= byte ptr -2Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct icu_56::FieldPositionIterator *
		lea	ecx, [ebp+var_2C] ; this
		call	??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z ; icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIterator *,UErrorCode &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_2C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+120h+var_120] ; double
		mov	ecx, [ebp+var_14] ; this
		call	?formatDouble@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@NAAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler	&,UErrorCode &)
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
		mov	eax, [ebp+var_F8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN7_7		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+95o
		dd offset $LN6_6
$LN6_6		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:00008134o
		dd offset $LN4_5	; "handler"
$LN4_5		db 'handler',0          ; DATA XREF: .text:00008140o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 814Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008178o
		lea	ecx, [ebp-2Ch]	; this
		jmp	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-100h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8174h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008184o
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@NAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 81A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, const struct icu_56::DigitList *,	struct icu_56::UnicodeString *,	struct icu_56::FieldPositionIterator *,	enum UErrorCode	*)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc	near

var_178		= byte ptr -178h
var_174		= dword	ptr -174h
var_A8		= byte ptr -0A8h
var_90		= byte ptr -90h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 16Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_178]
		mov	ecx, 5Bh ; '['
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_90] ; this
		call	??0DigitList@icu_56@@QAE@ABV01@@Z ; icu_56::DigitList::DigitList(icu_56::DigitList const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionIterator *
		lea	ecx, [ebp+var_A8] ; this
		call	??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z ; icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIterator *,UErrorCode &)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_A8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_90]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_A8] ; this
		call	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	eax, [ebp+var_174]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 178h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9_1		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+C1o
		dd offset $LN8_1
$LN8_1		dd 0FFFFFF70h, 70h	; DATA XREF: .text:000082A0o
		dd offset $LN5_1	; "dl"
		dd 0FFFFFF58h, 10h
		dd offset $LN6_7	; "handler"
$LN6_7		db 'handler',0          ; DATA XREF: .text:000082B8o
$LN5_1		db 'dl',0               ; DATA XREF: .text:000082ACo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 82C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000830Co
		lea	ecx, [ebp-90h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00008314o
		lea	ecx, [ebp-0A8h]	; this
		jmp	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-17Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8308h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008320o
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVDigitList@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 833Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, const struct icu_56::StringPiece *, struct icu_56::UnicodeString *, struct icu_56::FieldPositionIterator *, enum UErrorCode *)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near

var_178		= byte ptr -178h
var_174		= dword	ptr -174h
var_A8		= byte ptr -0A8h
var_90		= byte ptr -90h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 16Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_178]
		mov	ecx, 5Bh ; '['
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		lea	ecx, [ebp+var_90] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 0
		push	0		; unsigned int
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_90] ; this
		call	?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z	; icu_56::DigitList::set(icu_56::StringPiece const &,UErrorCode	&,uint)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionIterator *
		lea	ecx, [ebp+var_A8] ; this
		call	??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z ; icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIterator *,UErrorCode &)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_A8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_90]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_174], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_A8] ; this
		call	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	eax, [ebp+var_174]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 178h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9_2		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::StringPiece const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+D2o
		dd offset $LN8_2
$LN8_2		dd 0FFFFFF70h, 70h	; DATA XREF: .text:0000844Co
		dd offset $LN5_2	; "dl"
		dd 0FFFFFF58h, 10h
		dd offset $LN6_8	; "handler"
$LN6_8		db 'handler',0          ; DATA XREF: .text:00008464o
$LN5_2		db 'dl',0               ; DATA XREF: .text:00008458o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8474h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000084B8o
		lea	ecx, [ebp-90h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000084C0o
		lea	ecx, [ebp-0A8h]	; this
		jmp	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::StringPiece const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-17Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 84B4h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000084CCo
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0
		align 10h
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVStringPiece@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, const struct icu_56::VisibleDigitsWithExponent *,	struct icu_56::UnicodeString *,	struct icu_56::FieldPosition *,	enum UErrorCode	*)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc	near

var_F4		= byte ptr -0F4h
var_F0		= dword	ptr -0F0h
var_24		= byte ptr -24h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::FieldPosition *
		lea	ecx, [ebp+var_24] ; this
		call	??0FieldPositionOnlyHandler@icu_56@@QAE@AAVFieldPosition@1@@Z ;	icu_56::FieldPositionOnlyHandler::FieldPositionOnlyHandler(icu_56::FieldPosition &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_24]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::VisibleDigitsWithExponent *
		mov	ecx, [ebp+var_14] ; this
		call	?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_F0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24] ; this
		call	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
		mov	eax, [ebp+var_F0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_8		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::VisibleDigitsWithExponent const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+8Co
		dd offset $LN6_9
$LN6_9		dd 0FFFFFFDCh, 8	; DATA XREF: .text:000085A8o
		dd offset $LN4_6	; "handler"
$LN4_6		db 'handler',0          ; DATA XREF: .text:000085B4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 85C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000085ECo
		lea	ecx, [ebp-24h]	; this
		jmp	??1FieldPositionOnlyHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::VisibleDigitsWithExponent const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 85E8h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000085F8o
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::format(icu_56::DecimalFormatImpl *this, const struct icu_56::VisibleDigitsWithExponent *,	struct icu_56::UnicodeString *,	struct icu_56::FieldPositionIterator *,	enum UErrorCode	*)
		public ?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc	near

var_FC		= byte ptr -0FCh
var_F8		= dword	ptr -0F8h
var_2C		= byte ptr -2Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionIterator *
		lea	ecx, [ebp+var_2C] ; this
		call	??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z ; icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIterator *,UErrorCode &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_2C]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::VisibleDigitsWithExponent *
		mov	ecx, [ebp+var_14] ; this
		call	?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2C] ; this
		call	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
		mov	eax, [ebp+var_F8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_9		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::VisibleDigitsWithExponent const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+90o
		dd offset $LN6_10
$LN6_10		dd 0FFFFFFD4h, 10h	; DATA XREF: .text:000086D8o
		dd offset $LN4_7	; "handler"
$LN4_7		db 'handler',0          ; DATA XREF: .text:000086E4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 86F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000871Co
		lea	ecx, [ebp-2Ch]	; this
		jmp	??1FieldPositionIteratorHandler@icu_56@@UAE@XZ ; icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(void)
__unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::format(icu_56::VisibleDigitsWithExponent const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-100h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8718h
__unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008728o
		dd offset __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8744h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DecimalFormatImpl *this, struct icu_56::DigitList *, enum UErrorCode *)
		public ?adjustDigitList@DecimalFormatImpl@icu_56@@ABEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
?adjustDigitList@DecimalFormatImpl@icu_56@@ABEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+2Ep
					; icu_56::DecimalFormatImpl::round(icu_56::DigitList &,UErrorCode &)+70p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+7Ch]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	?setRoundingMode@DigitList@icu_56@@QAEXW4ERoundingMode@DecimalFormat@2@@Z ; icu_56::DigitList::setRoundingMode(icu_56::DecimalFormat::ERoundingMode)
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_879B
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		push	ecx		; struct icu_56::DigitList *
		mov	ecx, [ebp+arg_0] ; this
		call	?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)

loc_879B:				; CODE XREF: icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+42j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+78h], 0
		jz	short loc_87B3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+78h]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)

loc_87B3:				; CODE XREF: icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+5Ej
		mov	ecx, [ebp+arg_0] ; this
		call	?reduce@DigitList@icu_56@@QAEXXZ ; icu_56::DigitList::reduce(void)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?adjustDigitList@DecimalFormatImpl@icu_56@@ABEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::formatDigitList(icu_56::DecimalFormatImpl	*this, struct icu_56::DigitList	*, struct icu_56::UnicodeString	*, struct icu_56::FieldPositionHandler *, enum UErrorCode *)
		public ?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+87p
					; icu_56::DecimalFormatImpl::format(icu_56::DigitList const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+8Bp ...

var_1C8		= byte ptr -1C8h
var_1C4		= dword	ptr -1C4h
var_F8		= byte ptr -0F8h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1BCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C8]
		mov	ecx, 6Fh ; 'o'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		lea	ecx, [ebp+var_F8] ; this
		call	??0VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::VisibleDigitsWithExponent(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_F8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_F8]
		push	eax		; struct icu_56::VisibleDigitsWithExponent *
		mov	ecx, [ebp+var_18] ; this
		call	?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_F8] ; this
		call	??1VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)
		mov	eax, [ebp+var_1C4]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_10		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::formatDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+ABo
		dd offset $LN6_11
$LN6_11		db 8, 0FFh		; DATA XREF: .text:000088BCo
		dw 0FFFFh
		dd offset ?app@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Openmode const std::_Iosb<int>::app
		dd offset $LN4_8	; "digits"
$LN4_8		db 'digits',0           ; DATA XREF: .text:000088C8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 88D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000890Co
		lea	ecx, [ebp-0F8h]	; this
		jmp	??1VisibleDigitsWithExponent@icu_56@@QAE@XZ ; icu_56::VisibleDigitsWithExponent::~VisibleDigitsWithExponent(void)
__unwindfunclet$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::formatDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1CCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8908h
__unwindtable$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008918o
		dd offset __unwindfunclet$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?formatDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8934h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DecimalFormatImpl	*this, struct icu_56::DigitList	*, struct icu_56::UnicodeString	*, struct icu_56::FieldPositionHandler *, enum UErrorCode *)
		public ?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+BAp
					; icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+132p

var_10C		= byte ptr -10Ch
var_108		= dword	ptr -108h
var_3C		= byte ptr -3Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		lea	ecx, [ebp+var_3C] ; this
		call	??0ValueFormatter@icu_56@@QAE@XZ ; icu_56::ValueFormatter::ValueFormatter(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+var_14]
		mov	eax, [edx+2C0h]
		push	eax		; struct icu_56::PluralRules *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		lea	edx, [ebp+var_3C]
		push	edx		; struct icu_56::ValueFormatter	*
		mov	ecx, [ebp+var_14] ; this
		call	?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z ; icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)
		push	eax		; struct icu_56::ValueFormatter	*
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh	; this
		call	?format@DigitAffixesAndPadding@icu_56@@QBEAAVUnicodeString@2@AAVDigitList@2@ABVValueFormatter@2@AAVFieldPositionHandler@2@PBVPluralRules@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DigitAffixesAndPadding::format(icu_56::DigitList &,icu_56::ValueFormatter	const &,icu_56::FieldPositionHandler &,icu_56::PluralRules const *,icu_56::UnicodeString &,UErrorCode &)
		mov	[ebp+var_108], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_3C] ; this
		call	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+var_108]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_11		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+A5o
		dd offset $LN6_12
$LN6_12		dd 0FFFFFFC4h, 20h	; DATA XREF: .text:00008A0Co
		dd offset $LN4_9
; ---------------------------------------------------------------------------

$LN4_9:					; DATA XREF: .text:00008A18o
		jbe	short loc_8A84
		add	bh, bh
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8A20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008A4Co
		lea	ecx, [ebp-3Ch]	; this
		jmp	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
__unwindfunclet$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8A48h
__unwindtable$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008A58o
		dd offset __unwindfunclet$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::DecimalFormatImpl	*this, const struct icu_56::VisibleDigitsWithExponent *, struct	icu_56::UnicodeString *, struct	icu_56::FieldPositionHandler *,	enum UErrorCode	*)
		public ?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+C4p
					; icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+89p ...

var_10C		= byte ptr -10Ch
var_108		= dword	ptr -108h
var_3C		= byte ptr -3Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0

loc_8A84:				; CODE XREF: .text:$LN4_9j
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		lea	ecx, [ebp+var_3C] ; this
		call	??0ValueFormatter@icu_56@@QAE@XZ ; icu_56::ValueFormatter::ValueFormatter(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+var_14]
		mov	eax, [edx+2C0h]
		push	eax		; struct icu_56::PluralRules *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		lea	edx, [ebp+var_3C]
		push	edx		; struct icu_56::ValueFormatter	*
		mov	ecx, [ebp+var_14] ; this
		call	?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z ; icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)
		push	eax		; struct icu_56::ValueFormatter	*
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::VisibleDigitsWithExponent *
		mov	ecx, [ebp+var_14]
		add	ecx, 7FCh	; this
		call	?format@DigitAffixesAndPadding@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@ABVValueFormatter@2@AAVFieldPositionHandler@2@PBVPluralRules@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DigitAffixesAndPadding::format(icu_56::VisibleDigitsWithExponent const &,icu_56::ValueFormatter const &,icu_56::FieldPositionHandler &,icu_56::PluralRules const *,icu_56::UnicodeString &,UErrorCode &)
		mov	[ebp+var_108], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_3C] ; this
		call	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+var_108]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_12		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+A5o
		dd offset $LN6_13
$LN6_13		dd 0FFFFFFC4h, 20h	; DATA XREF: .text:00008B4Co
		dd offset $LN4_10
; ---------------------------------------------------------------------------

$LN4_10:				; DATA XREF: .text:00008B58o
		jbe	short loc_8BC4
		add	bh, bh
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8B60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008B8Co
		lea	ecx, [ebp-3Ch]	; this
		jmp	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
__unwindfunclet$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8B88h
__unwindtable$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008B98o
		dd offset __unwindfunclet$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?formatVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::FixedDecimal *__thiscall icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DecimalFormatImpl *this, double, struct icu_56::FixedDecimal *, enum UErrorCode *)
		public ?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z
?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z proc near

var_178		= qword	ptr -178h
var_158		= byte ptr -158h
var_154		= dword	ptr -154h
var_88		= byte ptr -88h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z
		mov	eax, large fs:0

loc_8BC4:				; CODE XREF: .text:$LN4_10j
		push	eax
		sub	esp, 14Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_158]
		mov	ecx, 53h ; 'S'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8C13
		mov	eax, [ebp+arg_8]
		jmp	short loc_8C78
; ---------------------------------------------------------------------------

loc_8C13:				; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(double,icu_56::FixedDecimal &,UErrorCode &)+58j
		lea	ecx, [ebp+var_88] ; this
		call	??0VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::VisibleDigits(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_88]
		push	ecx		; struct icu_56::VisibleDigits *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+178h+var_178] ; double
		mov	ecx, [ebp+var_18]
		add	ecx, 4E8h	; this
		call	?initVisibleDigits@FixedPrecision@icu_56@@QBEAAVVisibleDigits@2@NAAV32@AAW4UErrorCode@@@Z ; icu_56::FixedPrecision::initVisibleDigits(double,icu_56::VisibleDigits &,UErrorCode	&)
		mov	eax, [ebp+arg_8]
		push	eax		; double *
		lea	ecx, [ebp+var_88]
		push	ecx		; icu_56::VisibleDigits	*
		call	?initFixedDecimal@icu_56@@YAAAVFixedDecimal@1@ABVVisibleDigits@1@AAV21@@Z ; icu_56::initFixedDecimal(icu_56::VisibleDigits const &,icu_56::FixedDecimal	&)
		add	esp, 8
		mov	[ebp+var_154], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_88] ; this
		call	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
		mov	eax, [ebp+var_154]

loc_8C78:				; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(double,icu_56::FixedDecimal &,UErrorCode &)+5Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 158h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN8_3		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::getFixedDecimal(double,icu_56::FixedDecimal &,UErrorCode &)+C8o
		dd offset $LN7_13
$LN7_13		dd 0FFFFFF78h, 68h	; DATA XREF: .text:00008CB8o
		dd offset $LN5_3	; "digits"
$LN5_3		db 'digits',0           ; DATA XREF: .text:00008CC4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8CD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008D08o
		lea	ecx, [ebp-88h]	; this
		jmp	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
__unwindfunclet$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::getFixedDecimal(double,icu_56::FixedDecimal &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-15Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8D04h
__unwindtable$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008D14o
		dd offset __unwindfunclet$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@NAAV32@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::initFixedDecimal(icu_56::VisibleDigits *,	double *)
?initFixedDecimal@icu_56@@YAAAVFixedDecimal@1@ABVVisibleDigits@1@AAV21@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(double,icu_56::FixedDecimal &,UErrorCode &)+9Ep
					; icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DigitList &,icu_56::FixedDecimal &,UErrorCode &)+99p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		fldz
		fstp	qword ptr [eax]
		mov	ecx, [ebp+arg_0] ; this
		call	?isNegative@VisibleDigits@icu_56@@QBECXZ ; icu_56::VisibleDigits::isNegative(void)
		mov	ecx, [ebp+arg_4]
		mov	[ecx+29h], al
		mov	ecx, [ebp+arg_0] ; this
		call	?isNaNOrInfinity@VisibleDigits@icu_56@@QBECXZ ;	icu_56::VisibleDigits::isNaNOrInfinity(void)
		mov	ecx, [ebp+arg_4]
		mov	[ecx+2Ah], al
		mov	eax, [ebp+arg_4]
		add	eax, 28h ; '('
		push	eax		; signed __int8	*
		mov	ecx, [ebp+arg_4]
		add	ecx, 8
		push	ecx		; int *
		mov	edx, [ebp+arg_4]
		add	edx, 18h
		push	edx		; __int64 *
		mov	eax, [ebp+arg_4]
		add	eax, 10h
		push	eax		; __int64 *
		mov	ecx, [ebp+arg_4]
		add	ecx, 20h ; ' '
		push	ecx		; __int64 *
		mov	edx, [ebp+arg_4]
		push	edx		; double *
		mov	ecx, [ebp+arg_0] ; this
		call	?getFixedDecimal@VisibleDigits@icu_56@@QBEXAANAA_J11AAHAAC@Z ; icu_56::VisibleDigits::getFixedDecimal(double &,__int64 &,__int64 &,__int64 &,int &,signed char &)
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initFixedDecimal@icu_56@@YAAAVFixedDecimal@1@ABVVisibleDigits@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::FixedDecimal *__thiscall icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DecimalFormatImpl *this, struct icu_56::DigitList *, struct icu_56::FixedDecimal *, enum UErrorCode *)
		public ?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z	proc near

var_158		= byte ptr -158h
var_154		= dword	ptr -154h
var_88		= byte ptr -88h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 14Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_158]
		mov	ecx, 53h ; 'S'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8E17
		mov	eax, [ebp+arg_4]
		jmp	short loc_8E77
; ---------------------------------------------------------------------------

loc_8E17:				; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DigitList &,icu_56::FixedDecimal &,UErrorCode &)+58j
		lea	ecx, [ebp+var_88] ; this
		call	??0VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::VisibleDigits(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_88]
		push	ecx		; struct icu_56::VisibleDigits *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18]
		add	ecx, 4E8h	; this
		call	?initVisibleDigits@FixedPrecision@icu_56@@QBEAAVVisibleDigits@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z	; icu_56::FixedPrecision::initVisibleDigits(icu_56::DigitList &,icu_56::VisibleDigits &,UErrorCode &)
		mov	eax, [ebp+arg_4]
		push	eax		; double *
		lea	ecx, [ebp+var_88]
		push	ecx		; icu_56::VisibleDigits	*
		call	?initFixedDecimal@icu_56@@YAAAVFixedDecimal@1@ABVVisibleDigits@1@AAV21@@Z ; icu_56::initFixedDecimal(icu_56::VisibleDigits const &,icu_56::FixedDecimal	&)
		add	esp, 8
		mov	[ebp+var_154], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_88] ; this
		call	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
		mov	eax, [ebp+var_154]

loc_8E77:				; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DigitList &,icu_56::FixedDecimal &,UErrorCode &)+5Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 158h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN8_4		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DigitList &,icu_56::FixedDecimal &,UErrorCode &)+C3o
		dd offset $LN7_14
$LN7_14		dd 0FFFFFF78h, 68h	; DATA XREF: .text:00008EB8o
		dd offset $LN5_4	; "digits"
$LN5_4		db 'digits',0           ; DATA XREF: .text:00008EC4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8ED0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008F08o
		lea	ecx, [ebp-88h]	; this
		jmp	??1VisibleDigits@icu_56@@QAE@XZ	; icu_56::VisibleDigits::~VisibleDigits(void)
__unwindfunclet$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DigitList &,icu_56::FixedDecimal &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-15Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8F04h
__unwindtable$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008F14o
		dd offset __unwindfunclet$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getFixedDecimal@DecimalFormatImpl@icu_56@@QBEAAVFixedDecimal@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(icu_56::DecimalFormatImpl *this, __int64, struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		public ?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z
?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt64(__int64,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+A9p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_8]
		call	??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8F77
		mov	eax, [ebp+arg_8]
		jmp	short loc_8FC6
; ---------------------------------------------------------------------------

loc_8F77:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+40j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_8FA5
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?initVisibleDigitsWithExponent@ScientificPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z	; icu_56::ScientificPrecision::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		jmp	short loc_8FC3
; ---------------------------------------------------------------------------

loc_8FA5:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+53j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?initVisibleDigitsWithExponent@FixedPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z ; icu_56::FixedPrecision::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)

loc_8FC3:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+73j
		mov	eax, [ebp+arg_8]

loc_8FC6:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+45j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8FDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(icu_56::DecimalFormatImpl *this, double, struct	icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		public ?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z
?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatDouble(double,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+6Ep

var_E8		= qword	ptr -0E8h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E8h+var_E8] ; double
		mov	ecx, [ebp+var_8]
		call	??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_9024
		mov	eax, [ebp+arg_8]
		jmp	short loc_9075
; ---------------------------------------------------------------------------

loc_9024:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+41j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_9053
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E8h+var_E8] ; double
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?initVisibleDigitsWithExponent@ScientificPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z ; icu_56::ScientificPrecision::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		jmp	short loc_9072
; ---------------------------------------------------------------------------

loc_9053:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+54j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E8h+var_E8] ; double
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?initVisibleDigitsWithExponent@FixedPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z ; icu_56::FixedPrecision::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode	&)

loc_9072:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+75j
		mov	eax, [ebp+arg_8]

loc_9075:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+46j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 908Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(icu_56::DecimalFormatImpl *this, struct	icu_56::DigitList *, struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		public ?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::formatDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+69p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8] ; this
		call	?adjustDigitList@DecimalFormatImpl@icu_56@@ABEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8] ; this
		call	?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?initVisibleDigitsWithExponent@DecimalFormatImpl@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DecimalFormatImpl *this, struct	icu_56::DigitList *, struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		public ?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+42p
					; icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+BAp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_9139
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?initVisibleDigitsWithExponent@ScientificPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::ScientificPrecision::initVisibleDigitsWithExponent(icu_56::DigitList &,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)
		jmp	short loc_9153
; ---------------------------------------------------------------------------

loc_9139:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+2Fj
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_8]
		add	ecx, 4E8h	; this
		call	?initVisibleDigitsWithExponent@FixedPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z	; icu_56::FixedPrecision::initVisibleDigitsWithExponent(icu_56::DigitList &,icu_56::VisibleDigitsWithExponent &,UErrorCode &)

loc_9153:				; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+4Bj
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 916Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::DecimalFormatImpl::round(icu_56::DecimalFormatImpl *this, struct	icu_56::DigitList *, enum UErrorCode *)
		public ?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z proc near

var_10C		= byte ptr -10Ch
var_108		= dword	ptr -108h
var_3C		= byte ptr -3Ch
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isNaN@DigitList@icu_56@@QBECXZ	; icu_56::DigitList::isNaN(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_91CC
		mov	ecx, [ebp+arg_0] ; this
		call	?isInfinite@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isInfinite(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_91D1

loc_91CC:				; CODE XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+4Fj
		mov	eax, [ebp+arg_0]
		jmp	short loc_9227
; ---------------------------------------------------------------------------

loc_91D1:				; CODE XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+5Ej
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_14] ; this
		call	?adjustDigitList@DecimalFormatImpl@icu_56@@ABEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)
		lea	ecx, [ebp+var_3C] ; this
		call	??0ValueFormatter@icu_56@@QAE@XZ ; icu_56::ValueFormatter::ValueFormatter(void)
		mov	[ebp+var_4], 0
		lea	eax, [ebp+var_3C]
		push	eax		; struct icu_56::ValueFormatter	*
		mov	ecx, [ebp+var_14] ; this
		call	?prepareValueFormatter@DecimalFormatImpl@icu_56@@ABEAAVValueFormatter@2@AAV32@@Z ; icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_3C] ; this
		call	?round@ValueFormatter@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::ValueFormatter::round(icu_56::DigitList &,UErrorCode	&)
		mov	[ebp+var_108], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_3C] ; this
		call	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
		mov	eax, [ebp+var_108]

loc_9227:				; CODE XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+63j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9_3		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+BFo
		dd offset $LN8_5
$LN8_5		dd 0FFFFFFC4h, 20h	; DATA XREF: .text:00009260o
		dd offset $LN6_14
$LN6_14		db 76h,	66h, 0		; DATA XREF: .text:0000926Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9274h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000092A0o
		lea	ecx, [ebp-3Ch]	; this
		jmp	??1ValueFormatter@icu_56@@UAE@XZ ; icu_56::ValueFormatter::~ValueFormatter(void)
__unwindfunclet$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 929Ch
__unwindtable$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000092ACo
		dd offset __unwindfunclet$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?round@DecimalFormatImpl@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 92C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setMinimumSignificantDigits(icu_56::DecimalFormatImpl *this, int)
		public ?setMinimumSignificantDigits@DecimalFormatImpl@icu_56@@QAEXH@Z
?setMinimumSignificantDigits@DecimalFormatImpl@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+80h], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+89h], 1
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMinimumSignificantDigits@DecimalFormatImpl@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setMaximumSignificantDigits(icu_56::DecimalFormatImpl *this, int)
		public ?setMaximumSignificantDigits@DecimalFormatImpl@icu_56@@QAEXH@Z
?setMaximumSignificantDigits@DecimalFormatImpl@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+84h], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+89h], 1
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMaximumSignificantDigits@DecimalFormatImpl@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9378h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setMinMaxSignificantDigits(icu_56::DecimalFormatImpl *this, int, int)
		public ?setMinMaxSignificantDigits@DecimalFormatImpl@icu_56@@QAEXHH@Z
?setMinMaxSignificantDigits@DecimalFormatImpl@icu_56@@QAEXHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+80h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+84h], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+89h], 1
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setMinMaxSignificantDigits@DecimalFormatImpl@icu_56@@QAEXHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setScientificNotation(icu_56::DecimalFormatImpl *this, signed __int8)
		public ?setScientificNotation@DecimalFormatImpl@icu_56@@QAEXC@Z
?setScientificNotation@DecimalFormatImpl@icu_56@@QAEXC@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+arg_0]
		mov	[eax+88h], cl
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setScientificNotation@DecimalFormatImpl@icu_56@@QAEXC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 942Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setSignificantDigitsUsed(icu_56::DecimalFormatImpl	*this, signed __int8)
		public ?setSignificantDigitsUsed@DecimalFormatImpl@icu_56@@QAEXC@Z
?setSignificantDigitsUsed@DecimalFormatImpl@icu_56@@QAEXC@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+arg_0]
		mov	[eax+89h], cl
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setSignificantDigitsUsed@DecimalFormatImpl@icu_56@@QAEXC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 947Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setGroupingSize(icu_56::DecimalFormatImpl *this, int)
		public ?setGroupingSize@DecimalFormatImpl@icu_56@@QAEXH@Z
?setGroupingSize@DecimalFormatImpl@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8Ch], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updateGrouping(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setGroupingSize@DecimalFormatImpl@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 94CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setSecondaryGroupingSize(icu_56::DecimalFormatImpl	*this, int)
		public ?setSecondaryGroupingSize@DecimalFormatImpl@icu_56@@QAEXH@Z
?setSecondaryGroupingSize@DecimalFormatImpl@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+90h], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updateGrouping(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setSecondaryGroupingSize@DecimalFormatImpl@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 951Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setMinimumGroupingDigits(icu_56::DecimalFormatImpl	*this, int)
		public ?setMinimumGroupingDigits@DecimalFormatImpl@icu_56@@QAEXH@Z
?setMinimumGroupingDigits@DecimalFormatImpl@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+94h], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updateGrouping(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMinimumGroupingDigits@DecimalFormatImpl@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 956Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DecimalFormatImpl::setCurrencyUsage(enum  UCurrencyUsage, enum  UErrorCode &)
		public ?setCurrencyUsage@DecimalFormatImpl@icu_56@@QAEXW4UCurrencyUsage@@AAW4UErrorCode@@@Z
?setCurrencyUsage@DecimalFormatImpl@icu_56@@QAEXW4UCurrencyUsage@@AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+2BCh], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		push	20h ; ' '       ; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setCurrencyUsage@DecimalFormatImpl@icu_56@@QAEXW4UCurrencyUsage@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 95C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setRoundingIncrement(icu_56::DecimalFormatImpl *this, double)
		public ?setRoundingIncrement@DecimalFormatImpl@icu_56@@QAEXN@Z
?setRoundingIncrement@DecimalFormatImpl@icu_56@@QAEXN@Z	proc near

var_E0		= qword	ptr -0E0h
var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		fldz
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 5
		jp	short loc_9608
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0E0h+var_E0] ; double
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?set@DigitList@icu_56@@QAEXN@Z ; icu_56::DigitList::set(double)
		jmp	short loc_961E
; ---------------------------------------------------------------------------

loc_9608:				; CODE XREF: icu_56::DecimalFormatImpl::setRoundingIncrement(double)+2Dj
		sub	esp, 8
		fldz
		fstp	[esp+0E0h+var_E0] ; double
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?set@DigitList@icu_56@@QAEXN@Z ; icu_56::DigitList::set(double)

loc_961E:				; CODE XREF: icu_56::DecimalFormatImpl::setRoundingIncrement(double)+46j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setRoundingIncrement@DecimalFormatImpl@icu_56@@QAEXN@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9634h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::DecimalFormatImpl::getRoundingIncrement(icu_56::DecimalFormatImpl *__hidden	this)
		public ?getRoundingIncrement@DecimalFormatImpl@icu_56@@QBENXZ
?getRoundingIncrement@DecimalFormatImpl@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?getDouble@DigitList@icu_56@@QBENXZ ; icu_56::DigitList::getDouble(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getRoundingIncrement@DecimalFormatImpl@icu_56@@QBENXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 967Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DecimalFormatImpl::getMultiplier(icu_56::DecimalFormatImpl *__hidden this)
		public ?getMultiplier@DecimalFormatImpl@icu_56@@QBEHXZ
?getMultiplier@DecimalFormatImpl@icu_56@@QBEHXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_96B8
		mov	eax, 1
		jmp	short loc_96C8
; ---------------------------------------------------------------------------

loc_96B8:				; CODE XREF: icu_56::DecimalFormatImpl::getMultiplier(void)+33j
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?getDouble@DigitList@icu_56@@QBENXZ ; icu_56::DigitList::getDouble(void)
		call	__ftol2_sse

loc_96C8:				; CODE XREF: icu_56::DecimalFormatImpl::getMultiplier(void)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getMultiplier@DecimalFormatImpl@icu_56@@QBEHXZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setMultiplier(icu_56::DecimalFormatImpl *this, int)
		public ?setMultiplier@DecimalFormatImpl@icu_56@@QAEXH@Z
?setMultiplier@DecimalFormatImpl@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_970B
		cmp	[ebp+arg_0], 1
		jnz	short loc_971A

loc_970B:				; CODE XREF: icu_56::DecimalFormatImpl::setMultiplier(int)+27j
		push	0		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?set@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::set(int)
		jmp	short loc_9729
; ---------------------------------------------------------------------------

loc_971A:				; CODE XREF: icu_56::DecimalFormatImpl::setMultiplier(int)+2Dj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?set@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::set(int)

loc_9729:				; CODE XREF: icu_56::DecimalFormatImpl::setMultiplier(int)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMultiplier@DecimalFormatImpl@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9740h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::DecimalFormatImpl *__hidden this, const struct icu_56::UnicodeString *)
		public ?setPositivePrefix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z
?setPositivePrefix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi		; int
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?remove@AffixPattern@icu_56@@QAEXXZ ; icu_56::AffixPattern::remove(void)
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?addLiteral@AffixPattern@icu_56@@QAEXPB_WHH@Z ;	icu_56::AffixPattern::addLiteral(wchar_t const *,int,int)
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	1		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setPositivePrefix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_5		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::UnicodeString	const &)+80o
		dd offset $LN4_11
$LN4_11		dd 0FFFFFFECh, 4	; DATA XREF: .text:000097E8o
		dd offset $LN3		; "status"
$LN3		db 'status',0           ; DATA XREF: .text:000097F4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9800h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setPositiveSuffix(icu_56::DecimalFormatImpl *__hidden this, const struct icu_56::UnicodeString *)
		public ?setPositiveSuffix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z
?setPositiveSuffix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi		; int
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?remove@AffixPattern@icu_56@@QAEXXZ ; icu_56::AffixPattern::remove(void)
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?addLiteral@AffixPattern@icu_56@@QAEXPB_WHH@Z ;	icu_56::AffixPattern::addLiteral(wchar_t const *,int,int)
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	4		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setPositiveSuffix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_6		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::setPositiveSuffix(icu_56::UnicodeString	const &)+80o
		dd offset $LN4_12
$LN4_12		dd 0FFFFFFECh, 4	; DATA XREF: .text:000098A8o
		dd offset $LN3_0	; "status"
$LN3_0		db 'status',0           ; DATA XREF: .text:000098B4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 98C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setNegativePrefix(icu_56::DecimalFormatImpl *__hidden this, const struct icu_56::UnicodeString *)
		public ?setNegativePrefix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z
?setNegativePrefix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi		; int
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 120h	; this
		call	?remove@AffixPattern@icu_56@@QAEXXZ ; icu_56::AffixPattern::remove(void)
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8]
		add	ecx, 120h	; this
		call	?addLiteral@AffixPattern@icu_56@@QAEXPB_WHH@Z ;	icu_56::AffixPattern::addLiteral(wchar_t const *,int,int)
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	2		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setNegativePrefix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_7		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::setNegativePrefix(icu_56::UnicodeString	const &)+80o
		dd offset $LN4_13
$LN4_13		dd 0FFFFFFECh, 4	; DATA XREF: .text:00009968o
		dd offset $LN3_1	; "status"
$LN3_1		db 'status',0           ; DATA XREF: .text:00009974o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9980h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::setNegativeSuffix(icu_56::DecimalFormatImpl *__hidden this, const struct icu_56::UnicodeString *)
		public ?setNegativeSuffix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z
?setNegativeSuffix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi		; int
		push	edi		; int
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 230h	; this
		call	?remove@AffixPattern@icu_56@@QAEXXZ ; icu_56::AffixPattern::remove(void)
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		push	0		; int
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8]
		add	ecx, 230h	; this
		call	?addLiteral@AffixPattern@icu_56@@QAEXPB_WHH@Z ;	icu_56::AffixPattern::addLiteral(wchar_t const *,int,int)
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	8		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setNegativeSuffix@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_8		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::setNegativeSuffix(icu_56::UnicodeString	const &)+80o
		dd offset $LN4_14
$LN4_14		dd 0FFFFFFECh, 4	; DATA XREF: .text:00009A28o
		dd offset $LN3_2	; "status"
$LN3_2		db 'status',0           ; DATA XREF: .text:00009A34o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::getPositivePrefix(icu_56::DecimalFormatImpl *this, struct	icu_56::UnicodeString *)
		public ?getPositivePrefix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getPositivePrefix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 7FCh	; this
		call	?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ ; icu_56::PluralAffix::getOtherVariant(void)
		mov	ecx, eax	; this
		call	?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::DigitAffix::toString(void)
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getPositivePrefix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9AA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::getPositiveSuffix(icu_56::DecimalFormatImpl *this, struct	icu_56::UnicodeString *)
		public ?getPositiveSuffix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getPositiveSuffix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 894h	; this
		call	?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ ; icu_56::PluralAffix::getOtherVariant(void)
		mov	ecx, eax	; this
		call	?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::DigitAffix::toString(void)
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getPositiveSuffix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::getNegativePrefix(icu_56::DecimalFormatImpl *this, struct	icu_56::UnicodeString *)
		public ?getNegativePrefix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getNegativePrefix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 92Ch	; this
		call	?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ ; icu_56::PluralAffix::getOtherVariant(void)
		mov	ecx, eax	; this
		call	?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::DigitAffix::toString(void)
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getNegativePrefix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::getNegativeSuffix(icu_56::DecimalFormatImpl *this, struct	icu_56::UnicodeString *)
		public ?getNegativeSuffix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getNegativeSuffix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 9C4h	; this
		call	?getOtherVariant@PluralAffix@icu_56@@QBEABVDigitAffix@2@XZ ; icu_56::PluralAffix::getOtherVariant(void)
		mov	ecx, eax	; this
		call	?toString@DigitAffix@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::DigitAffix::toString(void)
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getNegativeSuffix@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9BD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::adoptDecimalFormatSymbols(icu_56::DecimalFormatImpl *this,	struct icu_56::DecimalFormatSymbols *)
		public ?adoptDecimalFormatSymbols@DecimalFormatImpl@icu_56@@QAEXPAVDecimalFormatSymbols@2@@Z
?adoptDecimalFormatSymbols@DecimalFormatImpl@icu_56@@QAEXPAVDecimalFormatSymbols@2@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_9BFB
		jmp	short loc_9C6F
; ---------------------------------------------------------------------------

loc_9BFB:				; CODE XREF: icu_56::DecimalFormatImpl::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+27j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2B8h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_9C44
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_9C4E
; ---------------------------------------------------------------------------

loc_9C44:				; CODE XREF: icu_56::DecimalFormatImpl::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+4Dj
		mov	[ebp+var_F4], 0

loc_9C4E:				; CODE XREF: icu_56::DecimalFormatImpl::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+72j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+2B8h], ecx
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	10h		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)

loc_9C6F:				; CODE XREF: icu_56::DecimalFormatImpl::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+29j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?adoptDecimalFormatSymbols@DecimalFormatImpl@icu_56@@QAEXPAVDecimalFormatSymbols@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN8_6		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::adoptDecimalFormatSymbols(icu_56::DecimalFormatSymbols *)+A3o
		dd offset $LN7_15
$LN7_15		dd 0FFFFFFECh, 4	; DATA XREF: .text:00009C9Co
		dd offset $LN6_15	; "status"
$LN6_15		db 'status',0           ; DATA XREF: .text:00009CA8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::applyPatternFavorCurrencyPrecision(icu_56::DecimalFormatImpl *this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ?applyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
?applyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z	proc near

var_120		= byte ptr -120h
var_5C		= byte ptr -5Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_5C]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_C] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C] ; this
		call	?updateForApplyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::updateForApplyPatternFavorCurrencyPrecision(UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?applyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
$LN5_9		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::applyPatternFavorCurrencyPrecision(icu_56::UnicodeString const &,UErrorCode &)+53o
		dd offset $LN4_15
$LN4_15		dd 0FFFFFFA4h, 48h	; DATA XREF: .text:00009D38o
		dd offset $LN3_3	; "perror"
$LN3_3		db 'perror',0           ; DATA XREF: .text:00009D44o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::applyPattern(icu_56::DecimalFormatImpl *this, const struct	icu_56::UnicodeString *, enum UErrorCode *)
		public ?applyPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
?applyPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z proc near

var_120		= byte ptr -120h
var_5C		= byte ptr -5Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_5C]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_C] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C] ; this
		call	?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z	; icu_56::DecimalFormatImpl::updateForApplyPattern(UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?applyPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN5_10		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,UErrorCode &)+53o
		dd offset $LN4_16
$LN4_16		dd 0FFFFFFA4h, 48h	; DATA XREF: .text:00009DD4o
		dd offset $LN3_4	; "perror"
$LN3_4		db 'perror',0           ; DATA XREF: .text:00009DE0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::applyPattern(icu_56::DecimalFormatImpl *this, const struct	icu_56::UnicodeString *, struct	UParseError *, enum UErrorCode *)
		public ?applyPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z
?applyPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z	; icu_56::DecimalFormatImpl::updateForApplyPattern(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?applyPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::applyLocalizedPattern(icu_56::DecimalFormatImpl *this, const struct icu_56::UnicodeString *, enum UErrorCode *)
		public ?applyLocalizedPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z
?applyLocalizedPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z proc	near

var_120		= byte ptr -120h
var_5C		= byte ptr -5Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_5C]
		push	ecx		; struct UParseError *
		push	1		; char
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_C] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C] ; this
		call	?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z	; icu_56::DecimalFormatImpl::updateForApplyPattern(UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?applyLocalizedPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN5_11		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::applyLocalizedPattern(icu_56::UnicodeString const &,UErrorCode &)+53o
		dd offset $LN4_17
$LN4_17		dd 0FFFFFFA4h, 48h	; DATA XREF: .text:00009ECCo
		dd offset $LN3_5	; "perror"
$LN3_5		db 'perror',0           ; DATA XREF: .text:00009ED8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::applyLocalizedPattern(icu_56::DecimalFormatImpl *this, const struct icu_56::UnicodeString *, struct UParseError *,	enum UErrorCode	*)
		public ?applyLocalizedPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z
?applyLocalizedPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		push	1		; char
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z	; icu_56::DecimalFormatImpl::updateForApplyPattern(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?applyLocalizedPattern@DecimalFormatImpl@icu_56@@QAEXABVUnicodeString@2@AAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::applyPattern(icu_56::DecimalFormatImpl *this, const struct	icu_56::UnicodeString *, char, struct UParseError *, enum UErrorCode *)
		public ?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z
?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+240p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+19Dp ...

var_760		= dword	ptr -760h
var_698		= dword	ptr -698h
var_694		= dword	ptr -694h
var_690		= dword	ptr -690h
var_68C		= dword	ptr -68Ch
var_688		= byte ptr -688h
var_684		= dword	ptr -684h
var_680		= dword	ptr -680h
var_67C		= byte ptr -67Ch
var_678		= dword	ptr -678h
var_674		= byte ptr -674h
var_66C		= byte ptr -66Ch
var_668		= dword	ptr -668h
var_664		= dword	ptr -664h
var_65C		= byte ptr -65Ch
var_658		= dword	ptr -658h
var_654		= byte ptr -654h
var_650		= byte ptr -650h
var_5E0		= dword	ptr -5E0h
var_4D8		= byte ptr -4D8h
var_450		= byte ptr -450h
var_3C8		= byte ptr -3C8h
var_340		= byte ptr -340h
var_2B8		= dword	ptr -2B8h
var_2A8		= byte ptr -2A8h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 754h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_760]
		mov	ecx, 1D5h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9F9F
		jmp	loc_A278
; ---------------------------------------------------------------------------

loc_9F9F:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+58j
		lea	ecx, [ebp+var_2A8] ; this
		call	??0DecimalFormatPatternParser@icu_56@@QAE@XZ ; icu_56::DecimalFormatPatternParser::DecimalFormatPatternParser(void)
		mov	[ebp+var_4], 0
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_9FCE
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2B8h]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		lea	ecx, [ebp+var_2A8] ; this
		call	?useSymbols@DecimalFormatPatternParser@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z	; icu_56::DecimalFormatPatternParser::useSymbols(icu_56::DecimalFormatSymbols const &)

loc_9FCE:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+77j
		lea	ecx, [ebp+var_698] ; this
		call	??0DecimalFormatPattern@icu_56@@QAE@XZ ; icu_56::DecimalFormatPattern::DecimalFormatPattern(void)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		lea	edx, [ebp+var_698]
		push	edx		; struct icu_56::DecimalFormatPattern *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_2A8] ; this
		call	?applyPatternWithoutExpandAffix@DecimalFormatPatternParser@icu_56@@QAEXABVUnicodeString@2@AAUDecimalFormatPattern@2@AAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatPatternParser::applyPatternWithoutExpandAffix(icu_56::UnicodeString const	&,icu_56::DecimalFormatPattern &,UParseError &,UErrorCode &)
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A036
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_698] ; this
		call	??1DecimalFormatPattern@icu_56@@QAE@XZ ; icu_56::DecimalFormatPattern::~DecimalFormatPattern(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2A8] ; this
		call	??1DecimalFormatPatternParser@icu_56@@QAE@XZ ; icu_56::DecimalFormatPatternParser::~DecimalFormatPatternParser(void)
		jmp	loc_A278
; ---------------------------------------------------------------------------

loc_A036:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+CEj
		mov	eax, [ebp+var_18]
		mov	cl, [ebp+var_67C]
		mov	[eax+88h], cl
		mov	eax, [ebp+var_18]
		mov	cl, [ebp+var_688]
		mov	[eax+89h], cl
		mov	eax, [ebp+var_698]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	?setMinimumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z ;	icu_56::NumberFormat::setMinimumIntegerDigits(int)
		mov	eax, [ebp+var_694]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	?setMaximumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z ;	icu_56::NumberFormat::setMaximumIntegerDigits(int)
		mov	eax, [ebp+var_690]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	?setMinimumFractionDigits@NumberFormat@icu_56@@UAEXH@Z ; icu_56::NumberFormat::setMinimumFractionDigits(int)
		mov	eax, [ebp+var_68C]
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	?setMaximumFractionDigits@NumberFormat@icu_56@@UAEXH@Z ; icu_56::NumberFormat::setMaximumFractionDigits(int)
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_684]
		mov	[eax+80h], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_680]
		mov	[eax+84h], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_678]
		mov	[eax+578h], ecx
		mov	eax, [ebp+var_18]
		mov	cl, [ebp+var_674]
		mov	[eax+58Dh], cl
		movzx	eax, [ebp+var_66C]
		push	eax		; signed __int8
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+4]	; this
		call	?setGroupingUsed@NumberFormat@icu_56@@UAEXC@Z ;	icu_56::NumberFormat::setGroupingUsed(signed char)
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_668]
		mov	[eax+8Ch], ecx
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_664]
		mov	[eax+90h], ecx
		mov	eax, [ebp+var_18]
		mov	cl, [ebp+var_65C]
		mov	[eax+58Ch], cl
		movsx	eax, [ebp+var_654]
		test	eax, eax
		jz	short loc_A13A
		lea	eax, [ebp+var_650]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 500h
		call	??4DigitList@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitList::operator=(icu_56::DigitList	const &)
		jmp	short loc_A148
; ---------------------------------------------------------------------------

loc_A13A:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+1E1j
		mov	ecx, [ebp+var_18]
		add	ecx, 500h	; this
		call	?clear@DigitList@icu_56@@QAEXXZ	; icu_56::DigitList::clear(void)

loc_A148:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+1F8j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_5E0]
		mov	[eax+0A60h], ecx
		lea	eax, [ebp+var_4D8]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 120h
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		lea	eax, [ebp+var_450]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 230h
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		lea	eax, [ebp+var_3C8]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 98h ; ''
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		lea	eax, [ebp+var_340]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h
		call	??4AffixPattern@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::AffixPattern::operator=(icu_56::AffixPattern const &)
		cmp	[ebp+var_658], 0
		jnz	short loc_A1C0
		mov	[ebp+var_760], 0
		jmp	short loc_A1EC
; ---------------------------------------------------------------------------

loc_A1C0:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+272j
		mov	ecx, [ebp+var_18]
		add	ecx, 98h ; ''  ; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		mov	esi, eax
		add	esi, [ebp+var_658]
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		add	esi, eax
		mov	[ebp+var_760], esi

loc_A1EC:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+27Ej
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_760]
		mov	[eax+0A64h], ecx
		mov	eax, [ebp+var_2B8]
		mov	[ebp+var_760], eax
		cmp	[ebp+var_760], 3 ; switch 4 cases
		ja	short loc_A257	; jumptable 0000A216 default case
		mov	ecx, [ebp+var_760]
		jmp	ds:$LN24[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN5_12:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+2D6j
					; DATA XREF: .text:$LN24o
		mov	eax, [ebp+var_18] ; jumptable 0000A216 case 0
		mov	dword ptr [eax+0A5Ch], 0
		jmp	short loc_A257	; jumptable 0000A216 default case
; ---------------------------------------------------------------------------

$LN4_18:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+2D6j
					; DATA XREF: .text:$LN24o
		mov	eax, [ebp+var_18] ; jumptable 0000A216 case 1
		mov	dword ptr [eax+0A5Ch], 1
		jmp	short loc_A257	; jumptable 0000A216 default case
; ---------------------------------------------------------------------------

$LN3_6:					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+2D6j
					; DATA XREF: .text:$LN24o
		mov	eax, [ebp+var_18] ; jumptable 0000A216 case 2
		mov	dword ptr [eax+0A5Ch], 2
		jmp	short loc_A257	; jumptable 0000A216 default case
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+2D6j
					; DATA XREF: .text:$LN24o
		mov	eax, [ebp+var_18] ; jumptable 0000A216 case 3
		mov	dword ptr [eax+0A5Ch], 3

loc_A257:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+2CEj
					; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString	const &,signed char,UParseError	&,UErrorCode &)+2EAj ...
		mov	byte ptr [ebp+var_4], 0	; jumptable 0000A216 default case
		lea	ecx, [ebp+var_698] ; this
		call	??1DecimalFormatPattern@icu_56@@QAE@XZ ; icu_56::DecimalFormatPattern::~DecimalFormatPattern(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_2A8] ; this
		call	??1DecimalFormatPatternParser@icu_56@@QAE@XZ ; icu_56::DecimalFormatPatternParser::~DecimalFormatPatternParser(void)

loc_A278:				; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+5Aj
					; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString	const &,signed char,UParseError	&,UErrorCode &)+F1j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 760h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN23		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+33Co
		dd offset $LN22_0
$LN22_0		dd 0FFFFFD58h, 288h	; DATA XREF: .text:0000A2B8o
		dd offset $LN19_0	; "patternParser"
		dd 0FFFFF968h, 3E8h
		dd offset $LN20
$LN20		dd 74756Fh		; DATA XREF: .text:0000A2D0o
$LN19_0		db 'patternParser',0    ; DATA XREF: .text:0000A2C4o
		align 4
$LN24		dd offset $LN5_12	; DATA XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+2D6r
		dd offset $LN4_18	; jump table for switch	statement
		dd offset $LN3_6
		dd offset $LN2
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A2F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000A33Co
		lea	ecx, [ebp-2A8h]	; this
		jmp	??1DecimalFormatPatternParser@icu_56@@QAE@XZ ; icu_56::DecimalFormatPatternParser::~DecimalFormatPatternParser(void)
__unwindfunclet$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000A344o
		lea	ecx, [ebp-698h]	; this
		jmp	??1DecimalFormatPattern@icu_56@@QAE@XZ ; icu_56::DecimalFormatPattern::~DecimalFormatPattern(void)
__unwindfunclet$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-764h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0A338h
__unwindtable$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000A350o
		dd offset __unwindfunclet$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?applyPattern@DecimalFormatImpl@icu_56@@AAEXABVUnicodeString@2@CAAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A36Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DecimalFormatPatternParser::~DecimalFormatPatternParser(icu_56::DecimalFormatPatternParser *__hidden this)
		public ??1DecimalFormatPatternParser@icu_56@@QAE@XZ
??1DecimalFormatPatternParser@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+ECp
					; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString	const &,signed char,UParseError	&,UErrorCode &)+333p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DecimalFormatPatternParser@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 8
		mov	ecx, [ebp+var_14]
		add	ecx, 248h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 7
		mov	ecx, [ebp+var_14]
		add	ecx, 208h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_14]
		add	ecx, 1C8h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 5
		mov	ecx, [ebp+var_14]
		add	ecx, 188h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_14]
		add	ecx, 148h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_14]
		add	ecx, 108h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 0C8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 88h ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 48h ; 'H'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DecimalFormatPatternParser@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A4E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000A600o
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$1 proc near
					; DATA XREF: .xdata$x:0000A608o
		mov	ecx, [ebp-14h]
		add	ecx, 48h ; 'H'  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$2 proc near
					; DATA XREF: .xdata$x:0000A610o
		mov	ecx, [ebp-14h]
		add	ecx, 88h ; ''  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$3 proc near
					; DATA XREF: .xdata$x:0000A618o
		mov	ecx, [ebp-14h]
		add	ecx, 0C8h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$4 proc near
					; DATA XREF: .xdata$x:0000A620o
		mov	ecx, [ebp-14h]
		add	ecx, 108h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$5 proc near
					; DATA XREF: .xdata$x:0000A628o
		mov	ecx, [ebp-14h]
		add	ecx, 148h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$6 proc near
					; DATA XREF: .xdata$x:0000A630o
		mov	ecx, [ebp-14h]
		add	ecx, 188h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$7 proc near
					; DATA XREF: .xdata$x:0000A638o
		mov	ecx, [ebp-14h]
		add	ecx, 1C8h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$8 proc near
					; DATA XREF: .xdata$x:0000A640o
		mov	ecx, [ebp-14h]
		add	ecx, 208h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$8 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DecimalFormatPatternParser@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::DecimalFormatPatternParser::~DecimalFormatPatternParser(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DecimalFormatPatternParser@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DecimalFormatPatternParser@icu_56@@QAE@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0A5D8h
__ehfuncinfo$??1DecimalFormatPatternParser@icu_56@@QAE@XZ dd 19930522h,	9
					; DATA XREF: __ehhandler$??1DecimalFormatPatternParser@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1DecimalFormatPatternParser@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
__unwindtable$??1DecimalFormatPatternParser@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000A5E0o
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$0
		align 8
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$2
		dd 2
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$3
		dd 3
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$4
		dd 4
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$5
		dd 5
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$6
		dd 6
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$7
		dd 7
		dd offset __unwindfunclet$??1DecimalFormatPatternParser@icu_56@@QAE@XZ$8
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::DecimalFormatPattern::~DecimalFormatPattern(icu_56::DecimalFormatPattern *__hidden this)
		public ??1DecimalFormatPattern@icu_56@@QAE@XZ
??1DecimalFormatPattern@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+DAp
					; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString	const &,signed char,UParseError	&,UErrorCode &)+321p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DecimalFormatPattern@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 7
		mov	ecx, [ebp+var_14]
		add	ecx, 358h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_14]
		add	ecx, 2D0h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 5
		mov	ecx, [ebp+var_14]
		add	ecx, 248h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_14]
		add	ecx, 1C0h	; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_14]
		add	ecx, 180h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 140h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 100h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 0C0h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		add	ecx, 48h ; 'H'  ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DecimalFormatPattern@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A774h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000A850o
		mov	ecx, [ebp-14h]
		add	ecx, 48h ; 'H'  ; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$1 proc near
					; DATA XREF: .xdata$x:0000A858o
		mov	ecx, [ebp-14h]
		add	ecx, 0C0h ; '' ; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$2 proc near
					; DATA XREF: .xdata$x:0000A860o
		mov	ecx, [ebp-14h]
		add	ecx, 100h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$3 proc near
					; DATA XREF: .xdata$x:0000A868o
		mov	ecx, [ebp-14h]
		add	ecx, 140h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$4 proc near
					; DATA XREF: .xdata$x:0000A870o
		mov	ecx, [ebp-14h]
		add	ecx, 180h	; this
		mov	esi, esp
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$5 proc near
					; DATA XREF: .xdata$x:0000A878o
		mov	ecx, [ebp-14h]
		add	ecx, 1C0h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$6 proc near
					; DATA XREF: .xdata$x:0000A880o
		mov	ecx, [ebp-14h]
		add	ecx, 248h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$7 proc near
					; DATA XREF: .xdata$x:0000A888o
		mov	ecx, [ebp-14h]
		add	ecx, 2D0h	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$7 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DecimalFormatPattern@icu_56@@QAE@XZ proc	near
					; DATA XREF: icu_56::DecimalFormatPattern::~DecimalFormatPattern(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DecimalFormatPattern@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DecimalFormatPattern@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0A828h
__ehfuncinfo$??1DecimalFormatPattern@icu_56@@QAE@XZ dd 19930522h, 8
					; DATA XREF: __ehhandler$??1DecimalFormatPattern@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1DecimalFormatPattern@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
__unwindtable$??1DecimalFormatPattern@icu_56@@QAE@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000A830o
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$0
		align 8
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$2
		dd 2
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$3
		dd 3
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$4
		dd 4
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$5
		dd 5
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$6
		dd 6
		dd offset __unwindfunclet$??1DecimalFormatPattern@icu_56@@QAE@XZ$7
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A88Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updatePrecision(icu_56::DecimalFormatImpl *__hidden this)
		public ?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ
?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::setMinimumSignificantDigits(int)+3Cp
					; icu_56::DecimalFormatImpl::setMaximumSignificantDigits(int)+3Cp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_A8C7
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecisionForScientific@DecimalFormatImpl@icu_56@@AAEXXZ ; icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)
		jmp	short loc_A8CF
; ---------------------------------------------------------------------------

loc_A8C7:				; CODE XREF: icu_56::DecimalFormatImpl::updatePrecision(void)+2Fj
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecisionForFixed@DecimalFormatImpl@icu_56@@AAEXXZ ; icu_56::DecimalFormatImpl::updatePrecisionForFixed(void)

loc_A8CF:				; CODE XREF: icu_56::DecimalFormatImpl::updatePrecision(void)+39j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A8E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updatePrecisionForScientific(icu_56::DecimalFormatImpl *__hidden this)
		public ?updatePrecisionForScientific@DecimalFormatImpl@icu_56@@AAEXXZ
?updatePrecisionForScientific@DecimalFormatImpl@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecision(void)+34p

var_F8		= byte ptr -0F8h
var_34		= byte ptr -34h
var_24		= byte ptr -24h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F8]
		mov	ecx, 3Eh ; '>'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 4E8h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+89h]
		test	ecx, ecx
		jz	short loc_A96A
		push	0FFFFFFFFh	; int
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		push	1		; int
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		push	0		; int
		mov	ecx, [ebp+var_14] ; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		push	1		; int
		mov	ecx, [ebp+var_14] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		mov	ecx, [ebp+var_14]
		add	ecx, 10h	; this
		call	?clear@SignificantDigitInterval@icu_56@@QAEXXZ ; icu_56::SignificantDigitInterval::clear(void)
		mov	eax, [ebp+var_14]
		add	eax, 10h
		push	eax		; struct icu_56::SignificantDigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?extractSigDigits@DecimalFormatImpl@icu_56@@ABEXAAVSignificantDigitInterval@2@@Z ; icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval	&)
		jmp	short loc_A9AC
; ---------------------------------------------------------------------------

loc_A96A:				; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+3Aj
		lea	ecx, [ebp+var_24] ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		lea	ecx, [ebp+var_34] ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		lea	eax, [ebp+var_24]
		push	eax		; struct icu_56::DigitInterval *
		lea	ecx, [ebp+var_34]
		push	ecx		; struct icu_56::DigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?extractMinMaxDigits@DecimalFormatImpl@icu_56@@ABEXAAVDigitInterval@2@0@Z ; icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)
		mov	eax, [ebp+var_14]
		add	eax, 10h
		push	eax		; icu_56::SignificantDigitInterval *
		mov	ecx, [ebp+var_14]
		add	ecx, 8
		push	ecx		; icu_56::DigitInterval	*
		mov	edx, [ebp+var_14]
		push	edx		; icu_56::DigitInterval	*
		lea	eax, [ebp+var_24]
		push	eax		; icu_56::DigitInterval	*
		lea	ecx, [ebp+var_34]
		push	ecx		; icu_56::DigitInterval	*
		call	?updatePrecisionForScientificMinMax@icu_56@@YAXABVDigitInterval@1@0AAV21@1AAVSignificantDigitInterval@1@@Z ; icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)
		add	esp, 14h

loc_A9AC:				; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+84j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_16
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?updatePrecisionForScientific@DecimalFormatImpl@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN7_16		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+CCo
		dd offset $LN6_16
$LN6_16		dd 0FFFFFFDCh, 8	; DATA XREF: .text:0000A9D8o
		dd offset $LN4_19
		db 0CCh
		db 3 dup(0FFh)
		dd 8
		dd offset $LN5_13
$LN5_13		dd 6E696Dh		; DATA XREF: .text:0000A9F0o
$LN4_19		dd 78616Dh		; DATA XREF: .text:0000A9E4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A9FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval *, icu_56::DigitInterval	*, icu_56::DigitInterval *, icu_56::DigitInterval *, icu_56::SignificantDigitInterval *)
?updatePrecisionForScientificMinMax@icu_56@@YAXABVDigitInterval@1@0AAV21@1AAVSignificantDigitInterval@1@@Z proc	near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+C0p

var_124		= byte ptr -124h
var_121		= byte ptr -121h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		mov	ecx, [ebp+arg_10] ; this
		call	?clear@SignificantDigitInterval@icu_56@@QAEXXZ ; icu_56::SignificantDigitInterval::clear(void)
		mov	ecx, [ebp+arg_C] ; this
		call	?clear@DigitInterval@icu_56@@QAEXXZ ; icu_56::DigitInterval::clear(void)
		mov	ecx, [ebp+arg_4] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_4] ; this
		call	?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	; icu_56::DigitInterval::getFracDigitCount(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	; icu_56::DigitInterval::getFracDigitCount(void)
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_8], 8
		jle	short loc_AA76
		mov	eax, [ebp+var_14]
		mov	[ebp+var_8], eax

loc_AA76:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+72j
		cmp	[ebp+var_8], 1
		jle	short loc_AA8D
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jge	short loc_AA8D
		mov	[ebp+var_121], 1
		jmp	short loc_AA94
; ---------------------------------------------------------------------------

loc_AA8D:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+7Ej
					; icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+86j
		mov	[ebp+var_121], 0

loc_AA94:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+8Fj
		mov	cl, [ebp+var_121]
		mov	[ebp+var_35], cl
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	short loc_AABD
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		push	1		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		jmp	short loc_AAF4
; ---------------------------------------------------------------------------

loc_AABD:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+A7j
		mov	eax, [ebp+var_8]
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0
		jnz	short loc_AADC
		cmp	[ebp+var_2C], 0
		jz	short loc_AAD5
		cmp	[ebp+var_20], 0
		jnz	short loc_AADC

loc_AAD5:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+D1j
		mov	[ebp+var_44], 1

loc_AADC:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+CBj
					; icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+D7j
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)

loc_AAF4:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+BFj
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0
		jle	short loc_AB24
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_5C]
		push	eax		; int
		mov	ecx, [ebp+arg_10] ; this
		call	?setMin@SignificantDigitInterval@icu_56@@QAEXH@Z ; icu_56::SignificantDigitInterval::setMin(int)
		mov	eax, [ebp+var_50]
		push	eax		; int
		mov	ecx, [ebp+arg_10] ; this
		call	?setMax@SignificantDigitInterval@icu_56@@QAEXH@Z ; icu_56::SignificantDigitInterval::setMax(int)

loc_AB24:				; CODE XREF: icu_56::updatePrecisionForScientificMinMax(icu_56::DigitInterval const &,icu_56::DigitInterval const &,icu_56::DigitInterval &,icu_56::DigitInterval &,icu_56::SignificantDigitInterval &)+105j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?updatePrecisionForScientificMinMax@icu_56@@YAXABVDigitInterval@1@0AAV21@1AAVSignificantDigitInterval@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AB38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updatePrecisionForFixed(icu_56::DecimalFormatImpl *__hidden this)
		public ?updatePrecisionForFixed@DecimalFormatImpl@icu_56@@AAEXXZ
?updatePrecisionForFixed@DecimalFormatImpl@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecision(void)+3Ep

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 4E8h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+89h]
		test	ecx, ecx
		jnz	short loc_AB94
		mov	eax, [ebp+var_14]
		add	eax, 8
		push	eax		; struct icu_56::DigitInterval *
		mov	ecx, [ebp+var_14]
		push	ecx		; struct icu_56::DigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?extractMinMaxDigits@DecimalFormatImpl@icu_56@@ABEXAAVDigitInterval@2@0@Z ; icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)
		mov	ecx, [ebp+var_14]
		add	ecx, 10h	; this
		call	?clear@SignificantDigitInterval@icu_56@@QAEXXZ ; icu_56::SignificantDigitInterval::clear(void)
		jmp	short loc_ABC2
; ---------------------------------------------------------------------------

loc_AB94:				; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForFixed(void)+3Aj
		mov	eax, [ebp+var_14]
		add	eax, 10h
		push	eax		; struct icu_56::SignificantDigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?extractSigDigits@DecimalFormatImpl@icu_56@@ABEXAAVSignificantDigitInterval@2@@Z ; icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval	&)
		push	1		; int
		mov	ecx, [ebp+var_14] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		push	0		; int
		mov	ecx, [ebp+var_14] ; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	?clear@DigitInterval@icu_56@@QAEXXZ ; icu_56::DigitInterval::clear(void)

loc_ABC2:				; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForFixed(void)+5Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?updatePrecisionForFixed@DecimalFormatImpl@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ABD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DecimalFormatImpl *this, struct icu_56::DigitInterval *, struct icu_56::DigitInterval *)
		public ?extractMinMaxDigits@DecimalFormatImpl@icu_56@@ABEXAAVDigitInterval@2@0@Z
?extractMinMaxDigits@DecimalFormatImpl@icu_56@@ABEXAAVDigitInterval@2@0@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+A1p
					; icu_56::DecimalFormatImpl::updatePrecisionForFixed(void)+4Ap	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	?getMinimumIntegerDigits@NumberFormat@icu_56@@QBEHXZ ; icu_56::NumberFormat::getMinimumIntegerDigits(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	?getMaximumIntegerDigits@NumberFormat@icu_56@@QBEHXZ ; icu_56::NumberFormat::getMaximumIntegerDigits(void)
		push	eax		; int
		mov	ecx, [ebp+arg_4] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	?getMinimumFractionDigits@NumberFormat@icu_56@@QBEHXZ ;	icu_56::NumberFormat::getMinimumFractionDigits(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	?getMaximumFractionDigits@NumberFormat@icu_56@@QBEHXZ ;	icu_56::NumberFormat::getMaximumFractionDigits(void)
		push	eax		; int
		mov	ecx, [ebp+arg_4] ; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?extractMinMaxDigits@DecimalFormatImpl@icu_56@@ABEXAAVDigitInterval@2@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AC64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::extractSigDigits(icu_56::DecimalFormatImpl	*this, struct icu_56::SignificantDigitInterval *)
		public ?extractSigDigits@DecimalFormatImpl@icu_56@@ABEXAAVSignificantDigitInterval@2@@Z
?extractSigDigits@DecimalFormatImpl@icu_56@@ABEXAAVSignificantDigitInterval@2@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+7Fp
					; icu_56::DecimalFormatImpl::updatePrecisionForFixed(void)+66p	...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+80h], 0
		jge	short loc_AC9F
		mov	[ebp+var_D0], 0
		jmp	short loc_ACAE
; ---------------------------------------------------------------------------

loc_AC9F:				; CODE XREF: icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval &)+2Dj
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+80h]
		mov	[ebp+var_D0], edx

loc_ACAE:				; CODE XREF: icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval &)+39j
		mov	eax, [ebp+var_D0]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?setMin@SignificantDigitInterval@icu_56@@QAEXH@Z ; icu_56::SignificantDigitInterval::setMin(int)
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+84h], 0
		jge	short loc_ACD5
		mov	[ebp+var_D0], 0
		jmp	short loc_ACE4
; ---------------------------------------------------------------------------

loc_ACD5:				; CODE XREF: icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval &)+63j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+84h]
		mov	[ebp+var_D0], edx

loc_ACE4:				; CODE XREF: icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval &)+6Fj
		mov	eax, [ebp+var_D0]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?setMax@SignificantDigitInterval@icu_56@@QAEXH@Z ; icu_56::SignificantDigitInterval::setMax(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?extractSigDigits@DecimalFormatImpl@icu_56@@ABEXAAVSignificantDigitInterval@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AD0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateGrouping(icu_56::DecimalFormatImpl *__hidden	this)
		public ?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ
?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::setGroupingSize(int)+32p
					; icu_56::DecimalFormatImpl::setSecondaryGroupingSize(int)+32p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	?isGroupingUsed@NumberFormat@icu_56@@QBECXZ ; icu_56::NumberFormat::isGroupingUsed(void)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AD64
		mov	eax, [ebp+var_8]
		add	eax, 8Ch ; ''
		mov	ecx, [ebp+var_8]
		add	ecx, 580h
		mov	edx, [eax]
		mov	[ecx], edx
		mov	edx, [eax+4]
		mov	[ecx+4], edx
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		jmp	short loc_AD72
; ---------------------------------------------------------------------------

loc_AD64:				; CODE XREF: icu_56::DecimalFormatImpl::updateGrouping(void)+33j
		mov	ecx, [ebp+var_8]
		add	ecx, 580h	; this
		call	?clear@DigitGrouping@icu_56@@QAEXXZ ; icu_56::DigitGrouping::clear(void)

loc_AD72:				; CODE XREF: icu_56::DecimalFormatImpl::updateGrouping(void)+56j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AD88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateCurrency(icu_56::DecimalFormatImpl *this, enum UErrorCode *)
		public ?updateCurrency@DecimalFormatImpl@icu_56@@QAEXAAW4UErrorCode@@@Z
?updateCurrency@DecimalFormatImpl@icu_56@@QAEXAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	1		; char
		push	20h ; ' '       ; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateCurrency@DecimalFormatImpl@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ADD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormatting(icu_56::DecimalFormatImpl	*this, int, enum UErrorCode *)
		public ?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z
?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::setCurrencyUsage(UCurrencyUsage,UErrorCode &)+38p
					; icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::UnicodeString const &)+77p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		push	1		; char
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AE20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormatting(icu_56::DecimalFormatImpl	*this, int, char, enum UErrorCode *)
		public ?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z
?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateCurrency(UErrorCode &)+2Ep
					; icu_56::DecimalFormatImpl::updateFormatting(int,UErrorCode &)+30p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_AE5D
		jmp	loc_AEE6
; ---------------------------------------------------------------------------

loc_AE5D:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+36j
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingUsesCurrency@DecimalFormatImpl@icu_56@@AAEXAAH@Z ; icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int	&)
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingFixedPointFormatter@DecimalFormatImpl@icu_56@@AAEXAAH@Z ; icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int &)
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingAffixParser@DecimalFormatImpl@icu_56@@AAEXAAH@Z ; icu_56::DecimalFormatImpl::updateFormattingAffixParser(int &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_0]
		push	ecx		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormattingPluralRules(int &,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		movzx	ecx, [ebp+arg_4]
		push	ecx		; signed __int8
		lea	edx, [ebp+arg_0]
		push	edx		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z	; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_0]
		push	ecx		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingLocalizedPositivePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_0]
		push	ecx		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingLocalizedPositiveSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_0]
		push	ecx		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingLocalizedNegativePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativePrefix(int &,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+arg_0]
		push	ecx		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormattingLocalizedNegativeSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativeSuffix(int &,UErrorCode &)

loc_AEE6:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AEFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(icu_56::DecimalFormatImpl *this, int *)
		public ?updateFormattingUsesCurrency@DecimalFormatImpl@icu_56@@AAEXAAH@Z
?updateFormattingUsesCurrency@DecimalFormatImpl@icu_56@@AAEXAAH@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+44p

var_DC		= byte ptr -0DCh
var_D9		= byte ptr -0D9h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 0Fh
		jnz	short loc_AF2E
		jmp	loc_AFC6
; ---------------------------------------------------------------------------

loc_AF2E:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+2Bj
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?usesCurrency@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesCurrency(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_AF8B
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?usesCurrency@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesCurrency(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_AF8B
		mov	ecx, [ebp+var_8]
		add	ecx, 120h	; this
		call	?usesCurrency@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesCurrency(void)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_AF8B
		mov	ecx, [ebp+var_8]
		add	ecx, 230h	; this
		call	?usesCurrency@AffixPattern@icu_56@@QBECXZ ; icu_56::AffixPattern::usesCurrency(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_AF8B
		mov	[ebp+var_D9], 0
		jmp	short loc_AF92
; ---------------------------------------------------------------------------

loc_AF8B:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+45j
					; icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+5Aj ...
		mov	[ebp+var_D9], 1

loc_AF92:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+8Dj
		mov	cl, [ebp+var_D9]
		mov	[ebp+var_11], cl
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+2C4h]
		movsx	edx, [ebp+var_11]
		cmp	ecx, edx
		jz	short loc_AFC6
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+var_11]
		mov	[eax+2C4h], cl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		or	ecx, 40h
		mov	edx, [ebp+arg_0]
		mov	[edx], ecx

loc_AFC6:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+2Dj
					; icu_56::DecimalFormatImpl::updateFormattingUsesCurrency(int &)+AFj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateFormattingUsesCurrency@DecimalFormatImpl@icu_56@@AAEXAAH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AFDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingPluralRules(icu_56::DecimalFormatImpl *this, int *, enum UErrorCode *)
		public ?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+6Cp

var_1DC		= dword	ptr -1DCh
var_1D8		= dword	ptr -1D8h
var_1D0		= dword	ptr -1D0h
var_1C4		= dword	ptr -1C4h
var_1B8		= byte ptr -1B8h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1DC]
		mov	ecx, 74h ; 't'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 50h
		jnz	short loc_B030
		jmp	loc_B153
; ---------------------------------------------------------------------------

loc_B030:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+4Dj
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B04A
		jmp	loc_B153
; ---------------------------------------------------------------------------

loc_B04A:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+67j
		mov	[ebp+var_24], 0
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+2C4h]
		test	ecx, ecx
		jz	short loc_B0D6
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_1B8]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+2B8h]
		call	?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ ; icu_56::DecimalFormatSymbols::getLocale(void)
		mov	[ebp+var_1D8], eax
		mov	eax, [ebp+var_1D8]
		mov	[ebp+var_1DC], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_1DC]
		push	ecx		; struct icu_56::Locale	*
		call	?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z ;	icu_56::PluralRules::forLocale(icu_56::Locale const &,UErrorCode &)
		add	esp, 8
		mov	[ebp+var_24], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_1B8] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B0D6
		jmp	short loc_B153
; ---------------------------------------------------------------------------

loc_B0D6:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+81j
					; icu_56::DecimalFormatImpl::updateFormattingPluralRules(int &,UErrorCode &)+F6j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2C0h]
		cmp	ecx, [ebp+var_24]
		jz	short loc_B153
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2C0h]
		mov	[ebp+var_1C4], ecx
		mov	edx, [ebp+var_1C4]
		mov	[ebp+var_1D0], edx
		cmp	[ebp+var_1D0], 0
		jz	short loc_B12D
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_1D0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_1D0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1D8], eax
		jmp	short loc_B137
; ---------------------------------------------------------------------------

loc_B12D:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+12Aj
		mov	[ebp+var_1D8], 0

loc_B137:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+14Fj
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_24]
		mov	[eax+2C0h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		or	ecx, 80h
		mov	edx, [ebp+arg_0]
		mov	[edx], ecx

loc_B153:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+4Fj
					; icu_56::DecimalFormatImpl::updateFormattingPluralRules(int &,UErrorCode &)+69j ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:0000B1C4o
		mov	esi, esp
		lea	ecx, [ebp-1B8h]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1E0h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B1C0h
__unwindtable$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B1D0o
		dd offset __unwindfunclet$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z$0
__ehfuncinfo$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B1ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(icu_56::DecimalFormatImpl *__hidden this, int *,	signed __int8, enum UErrorCode *)
		public ?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z
?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+81p

var_34C		= dword	ptr -34Ch
var_348		= dword	ptr -348h
var_340		= byte ptr -340h
var_26C		= byte ptr -26Ch
var_D8		= byte ptr -0D8h
var_D0		= byte ptr -0D0h
var_C0		= byte ptr -0C0h
var_3D		= byte ptr -3Dh
var_34		= byte ptr -34h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 340h
		push	ebx
		push	esi		; enum UErrorCode *
		push	edi		; wchar_t *
		push	ecx
		lea	edi, [ebp+var_34C]
		mov	ecx, 0D0h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 0F0h
		jnz	short loc_B243
		jmp	loc_B593
; ---------------------------------------------------------------------------

loc_B243:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+50j
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B25D
		jmp	loc_B593
; ---------------------------------------------------------------------------

loc_B25D:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+6Aj
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+2C4h]
		test	ecx, ecx
		jnz	short loc_B2CC
		mov	ecx, [ebp+var_18]
		add	ecx, 3C8h	; this
		call	?isDefault@CurrencyAffixInfo@icu_56@@QBECXZ ; icu_56::CurrencyAffixInfo::isDefault(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_B285
		jmp	loc_B593
; ---------------------------------------------------------------------------

loc_B285:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+92j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	0		; wchar_t *
		push	0		; struct icu_56::PluralRules *
		push	0		; char *
		mov	ecx, [ebp+var_18]
		add	ecx, 3C8h	; this
		call	?set@CurrencyAffixInfo@icu_56@@QAEXPBDPBVPluralRules@2@PB_WAAW4UErrorCode@@@Z ;	icu_56::CurrencyAffixInfo::set(char const *,icu_56::PluralRules	const *,wchar_t	const *,UErrorCode &)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B2B7
		jmp	loc_B593
; ---------------------------------------------------------------------------

loc_B2B7:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+C4j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		or	ecx, 200h
		mov	edx, [ebp+arg_0]
		mov	[edx], ecx
		jmp	loc_B593
; ---------------------------------------------------------------------------

loc_B2CC:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+7Dj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	?getCurrency@NumberFormat@icu_56@@QBEPB_WXZ ; icu_56::NumberFormat::getCurrency(void)
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		movzx	ecx, word ptr [eax]
		test	ecx, ecx
		jnz	loc_B39A
		mov	eax, [ebp+arg_8]
		push	eax
		push	4
		lea	ecx, [ebp+var_34]
		push	ecx
		lea	edx, [ebp+var_340]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2B8h]
		call	?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ ; icu_56::DecimalFormatSymbols::getLocale(void)
		mov	[ebp+var_348], eax
		mov	ecx, [ebp+var_348]
		mov	[ebp+var_34C], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_34C] ; this
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_ucurr_forLocale_56
		add	esp, 10h
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_340] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B38A
		lea	eax, [ebp+var_34]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_24]
		push	ecx		; wchar_t *
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+4]	; this
		call	?setCurrency@NumberFormat@icu_56@@UAEXPB_WAAW4UErrorCode@@@Z ; icu_56::NumberFormat::setCurrency(wchar_t const *,UErrorCode &)
		jmp	short loc_B39A
; ---------------------------------------------------------------------------

loc_B38A:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+181j
		mov	[ebp+var_24], 0
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_B39A:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+F6j
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+19Cj
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_24]
		push	ecx		; wchar_t *
		mov	edx, [ebp+var_18]
		mov	eax, [edx+2C0h]
		push	eax		; struct icu_56::PluralRules *
		lea	ecx, [ebp+var_26C]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+2B8h]
		call	?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ ; icu_56::DecimalFormatSymbols::getLocale(void)
		mov	[ebp+var_348], eax
		mov	eax, [ebp+var_348]
		mov	[ebp+var_34C], eax
		mov	[ebp+var_4], 1
		mov	esi, esp
		mov	ecx, [ebp+var_34C] ; this
		call	dword ptr ds:__imp_?getName@Locale@icu_56@@QBEPBDXZ ; icu_56::Locale::getName(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; char *
		mov	ecx, [ebp+var_18]
		add	ecx, 3C8h	; this
		call	?set@CurrencyAffixInfo@icu_56@@QAEXPBDPBVPluralRules@2@PB_WAAW4UErrorCode@@@Z ;	icu_56::CurrencyAffixInfo::set(char const *,icu_56::PluralRules	const *,wchar_t	const *,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_26C] ; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B434
		jmp	loc_B593
; ---------------------------------------------------------------------------

loc_B434:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+241j
		mov	[ebp+var_3D], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2B8h]	; this
		call	?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ ; icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(void)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_B470
		push	8
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2B8h]
		call	?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ; icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 3C8h	; this
		call	?setSymbol@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z ; icu_56::CurrencyAffixInfo::setSymbol(icu_56::UnicodeString const &)
		mov	[ebp+var_3D], 1

loc_B470:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+25Fj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2B8h]	; this
		call	?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	; icu_56::DecimalFormatSymbols::isCustomIntlCurrencySymbol(void)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_B4A8
		push	9
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2B8h]
		call	?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ; icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 3C8h	; this
		call	?setISO@CurrencyAffixInfo@icu_56@@QAEXABVUnicodeString@2@@Z ; icu_56::CurrencyAffixInfo::setISO(icu_56::UnicodeString const &)
		mov	[ebp+var_3D], 1

loc_B4A8:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+297j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		or	ecx, 200h
		mov	edx, [ebp+arg_0]
		mov	[edx], ecx
		cmp	[ebp+var_24], 0
		jz	loc_B593
		movsx	eax, [ebp+var_3D]
		test	eax, eax
		jnz	loc_B593
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	loc_B593
		lea	ecx, [ebp+var_D8] ; this
		call	??0FixedPrecision@icu_56@@QAE@XZ ; icu_56::FixedPrecision::FixedPrecision(void)
		mov	[ebp+var_4], 2
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_D8]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	eax, [edx+2BCh]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		call	?adjustPrecision@CurrencyAffixInfo@icu_56@@SAXPB_WW4UCurrencyUsage@@AAVFixedPrecision@2@AAW4UErrorCode@@@Z ; icu_56::CurrencyAffixInfo::adjustPrecision(wchar_t	const *,UCurrencyUsage,icu_56::FixedPrecision &,UErrorCode &)
		add	esp, 10h
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B536
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_D8] ; this
		call	??1FixedPrecision@icu_56@@QAE@XZ ; icu_56::FixedPrecision::~FixedPrecision(void)
		jmp	short loc_B593
; ---------------------------------------------------------------------------

loc_B536:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+334j
		lea	ecx, [ebp+var_D8] ; this
		call	?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	; icu_56::DigitInterval::getFracDigitCount(void)
		push	eax		; int
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	?setMinimumFractionDigits@NumberFormat@icu_56@@UAEXH@Z ; icu_56::NumberFormat::setMinimumFractionDigits(int)
		lea	ecx, [ebp+var_D0] ; this
		call	?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	; icu_56::DigitInterval::getFracDigitCount(void)
		push	eax		; int
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]	; this
		call	?setMaximumFractionDigits@NumberFormat@icu_56@@UAEXH@Z ; icu_56::NumberFormat::setMaximumFractionDigits(int)
		mov	ecx, [ebp+var_18] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		lea	eax, [ebp+var_C0]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 500h
		call	??4DigitList@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::DigitList::operator=(icu_56::DigitList	const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_D8] ; this
		call	??1FixedPrecision@icu_56@@QAE@XZ ; icu_56::FixedPrecision::~FixedPrecision(void)

loc_B593:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+52j
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+6Cj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 34Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN24_0		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+3ABo
		dd offset $LN23_0
$LN23_0		db 0CCh			; DATA XREF: .text:0000B5D4o
		db 3 dup(0FFh)
		dd 8
		dd offset $LN20_0	; "localeCurr"
		dd 0FFFFFF28h, 90h
		dd offset $LN21_0	; "precision"
$LN21_0		db 'precision',0        ; DATA XREF: .text:0000B5ECo
$LN20_0		db 'localeCurr',0       ; DATA XREF: .text:0000B5E0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B608h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000B66Co
		mov	esi, esp
		lea	ecx, [ebp-340h]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000B674o
		mov	esi, esp
		lea	ecx, [ebp-26Ch]	; this
		call	dword ptr ds:__imp_??1Locale@icu_56@@UAE@XZ ; icu_56::Locale::~Locale(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:0000B67Co
		lea	ecx, [ebp-0D8h]	; this
		jmp	??1FixedPrecision@icu_56@@QAE@XZ ; icu_56::FixedPrecision::~FixedPrecision(void)
__unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-350h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B668h
__unwindtable$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B688o
		dd offset __unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z$2
__ehfuncinfo$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z dd	19930522h, 3
					; DATA XREF: __ehhandler$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?updateFormattingCurrencyAffixInfo@DecimalFormatImpl@icu_56@@AAEXAAHCAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B6A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(icu_56::DecimalFormatImpl *this, int *)
		public ?updateFormattingFixedPointFormatter@DecimalFormatImpl@icu_56@@AAEXAAH@Z
?updateFormattingFixedPointFormatter@DecimalFormatImpl@icu_56@@AAEXAAH@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+50p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 50h
		jnz	short loc_B6D3
		jmp	short loc_B713
; ---------------------------------------------------------------------------

loc_B6D3:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int	&)+2Bj
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+2C4h]
		test	ecx, ecx
		jz	short loc_B6FB
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2B8h]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	ecx, [ebp+var_8]
		add	ecx, 590h	; this
		call	?setDecimalFormatSymbolsForMonetary@DigitFormatter@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z ; icu_56::DigitFormatter::setDecimalFormatSymbolsForMonetary(icu_56::DecimalFormatSymbols const &)
		jmp	short loc_B713
; ---------------------------------------------------------------------------

loc_B6FB:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int	&)+3Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2B8h]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	ecx, [ebp+var_8]
		add	ecx, 590h	; this
		call	?setDecimalFormatSymbols@DigitFormatter@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z ; icu_56::DigitFormatter::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols	const &)

loc_B713:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int	&)+2Dj
					; icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int &)+55j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateFormattingFixedPointFormatter@DecimalFormatImpl@icu_56@@AAEXAAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B72Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingAffixParser(icu_56::DecimalFormatImpl *this, int *)
		public ?updateFormattingAffixParser@DecimalFormatImpl@icu_56@@AAEXAAH@Z
?updateFormattingAffixParser@DecimalFormatImpl@icu_56@@AAEXAAH@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+5Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 10h
		jnz	short loc_B75B
		jmp	short loc_B783
; ---------------------------------------------------------------------------

loc_B75B:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingAffixParser(int	&)+2Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2B8h]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	ecx, [ebp+var_8]
		add	ecx, 2C8h	; this
		call	?setDecimalFormatSymbols@AffixPatternParser@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z ; icu_56::AffixPatternParser::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols	const &)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		or	ecx, 100h
		mov	edx, [ebp+arg_0]
		mov	[edx], ecx

loc_B783:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingAffixParser(int	&)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateFormattingAffixParser@DecimalFormatImpl@icu_56@@AAEXAAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B79Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(icu_56::DecimalFormatImpl *this, int *, enum UErrorCode *)
		public ?updateFormattingLocalizedPositivePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
?updateFormattingLocalizedPositivePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+91p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B7D6
		jmp	short loc_B822
; ---------------------------------------------------------------------------

loc_B7D6:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 301h
		jnz	short loc_B7E5
		jmp	short loc_B822
; ---------------------------------------------------------------------------

loc_B7E5:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)+45j
		mov	ecx, [ebp+var_8]
		add	ecx, 7FCh	; this
		call	?remove@PluralAffix@icu_56@@QAEXXZ ; icu_56::PluralAffix::remove(void)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		add	ecx, 7FCh
		push	ecx		; struct icu_56::PluralAffix *
		mov	edx, [ebp+var_8]
		add	edx, 3C8h
		push	edx		; struct icu_56::CurrencyAffixInfo *
		mov	eax, [ebp+var_8]
		add	eax, 98h ; ''
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 2C8h	; this
		call	?parse@AffixPatternParser@icu_56@@QBEAAVPluralAffix@2@ABVAffixPattern@2@ABVCurrencyAffixInfo@2@AAV32@AAW4UErrorCode@@@Z	; icu_56::AffixPatternParser::parse(icu_56::AffixPattern const &,icu_56::CurrencyAffixInfo const &,icu_56::PluralAffix &,UErrorCode &)

loc_B822:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)+38j
					; icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?updateFormattingLocalizedPositivePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B838h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(icu_56::DecimalFormatImpl *this, int *, enum UErrorCode *)
		public ?updateFormattingLocalizedPositiveSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
?updateFormattingLocalizedPositiveSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+A1p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B872
		jmp	short loc_B8BE
; ---------------------------------------------------------------------------

loc_B872:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 304h
		jnz	short loc_B881
		jmp	short loc_B8BE
; ---------------------------------------------------------------------------

loc_B881:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)+45j
		mov	ecx, [ebp+var_8]
		add	ecx, 894h	; this
		call	?remove@PluralAffix@icu_56@@QAEXXZ ; icu_56::PluralAffix::remove(void)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		add	ecx, 894h
		push	ecx		; struct icu_56::PluralAffix *
		mov	edx, [ebp+var_8]
		add	edx, 3C8h
		push	edx		; struct icu_56::CurrencyAffixInfo *
		mov	eax, [ebp+var_8]
		add	eax, 1A8h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 2C8h	; this
		call	?parse@AffixPatternParser@icu_56@@QBEAAVPluralAffix@2@ABVAffixPattern@2@ABVCurrencyAffixInfo@2@AAV32@AAW4UErrorCode@@@Z	; icu_56::AffixPatternParser::parse(icu_56::AffixPattern const &,icu_56::CurrencyAffixInfo const &,icu_56::PluralAffix &,UErrorCode &)

loc_B8BE:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)+38j
					; icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?updateFormattingLocalizedPositiveSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B8D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativePrefix(icu_56::DecimalFormatImpl *this, int *, enum UErrorCode *)
		public ?updateFormattingLocalizedNegativePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
?updateFormattingLocalizedNegativePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+B1p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B90E
		jmp	short loc_B95A
; ---------------------------------------------------------------------------

loc_B90E:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativePrefix(int &,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 302h
		jnz	short loc_B91D
		jmp	short loc_B95A
; ---------------------------------------------------------------------------

loc_B91D:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativePrefix(int &,UErrorCode &)+45j
		mov	ecx, [ebp+var_8]
		add	ecx, 92Ch	; this
		call	?remove@PluralAffix@icu_56@@QAEXXZ ; icu_56::PluralAffix::remove(void)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		add	ecx, 92Ch
		push	ecx		; struct icu_56::PluralAffix *
		mov	edx, [ebp+var_8]
		add	edx, 3C8h
		push	edx		; struct icu_56::CurrencyAffixInfo *
		mov	eax, [ebp+var_8]
		add	eax, 120h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 2C8h	; this
		call	?parse@AffixPatternParser@icu_56@@QBEAAVPluralAffix@2@ABVAffixPattern@2@ABVCurrencyAffixInfo@2@AAV32@AAW4UErrorCode@@@Z	; icu_56::AffixPatternParser::parse(icu_56::AffixPattern const &,icu_56::CurrencyAffixInfo const &,icu_56::PluralAffix &,UErrorCode &)

loc_B95A:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativePrefix(int &,UErrorCode &)+38j
					; icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativePrefix(int &,UErrorCode &)+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?updateFormattingLocalizedNegativePrefix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B970h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativeSuffix(icu_56::DecimalFormatImpl *this, int *, enum UErrorCode *)
		public ?updateFormattingLocalizedNegativeSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z
?updateFormattingLocalizedNegativeSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)+C1p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_B9AA
		jmp	short loc_B9F6
; ---------------------------------------------------------------------------

loc_B9AA:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativeSuffix(int &,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		and	ecx, 308h
		jnz	short loc_B9B9
		jmp	short loc_B9F6
; ---------------------------------------------------------------------------

loc_B9B9:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativeSuffix(int &,UErrorCode &)+45j
		mov	ecx, [ebp+var_8]
		add	ecx, 9C4h	; this
		call	?remove@PluralAffix@icu_56@@QAEXXZ ; icu_56::PluralAffix::remove(void)
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		add	ecx, 9C4h
		push	ecx		; struct icu_56::PluralAffix *
		mov	edx, [ebp+var_8]
		add	edx, 3C8h
		push	edx		; struct icu_56::CurrencyAffixInfo *
		mov	eax, [ebp+var_8]
		add	eax, 230h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_8]
		add	ecx, 2C8h	; this
		call	?parse@AffixPatternParser@icu_56@@QBEAAVPluralAffix@2@ABVAffixPattern@2@ABVCurrencyAffixInfo@2@AAV32@AAW4UErrorCode@@@Z	; icu_56::AffixPatternParser::parse(icu_56::AffixPattern const &,icu_56::CurrencyAffixInfo const &,icu_56::PluralAffix &,UErrorCode &)

loc_B9F6:				; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativeSuffix(int &,UErrorCode &)+38j
					; icu_56::DecimalFormatImpl::updateFormattingLocalizedNegativeSuffix(int &,UErrorCode &)+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?updateFormattingLocalizedNegativeSuffix@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BA0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateForApplyPatternFavorCurrencyPrecision(icu_56::DecimalFormatImpl *this, enum UErrorCode *)
		public ?updateForApplyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z
?updateForApplyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPatternFavorCurrencyPrecision(icu_56::UnicodeString const &,UErrorCode &)+4Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	1		; char
		push	3EFh		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateAll@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::updateAll(int,signed	char,UErrorCode	&)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateForApplyPatternFavorCurrencyPrecision@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BA58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateForApplyPattern(icu_56::DecimalFormatImpl *this, enum UErrorCode *)
		public ?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z
?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,UErrorCode &)+4Ap
					; icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString	const &,UParseError &,UErrorCode &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	0		; char
		push	3EFh		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateAll@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::updateAll(int,signed	char,UErrorCode	&)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateForApplyPattern@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BAA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateAll(icu_56::DecimalFormatImpl *this,	enum UErrorCode	*)
		public ?updateAll@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z
?updateAll@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+24Cp
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+1A9p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	1		; char
		push	3FFh		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateAll@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z ;	icu_56::DecimalFormatImpl::updateAll(int,signed	char,UErrorCode	&)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?updateAll@DecimalFormatImpl@icu_56@@AAEXAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BAF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::DecimalFormatImpl::updateAll(icu_56::DecimalFormatImpl *this,	int, char, enum	UErrorCode *)
		public ?updateAll@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z
?updateAll@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::updateForApplyPatternFavorCurrencyPrecision(UErrorCode &)+31p
					; icu_56::DecimalFormatImpl::updateForApplyPattern(UErrorCode &)+31p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_BB2A
		jmp	short loc_BB60
; ---------------------------------------------------------------------------

loc_BB2A:				; CODE XREF: icu_56::DecimalFormatImpl::updateAll(int,signed char,UErrorCode &)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?updatePrecision@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updatePrecision(void)
		mov	ecx, [ebp+var_8] ; this
		call	?updateGrouping@DecimalFormatImpl@icu_56@@QAEXXZ ; icu_56::DecimalFormatImpl::updateGrouping(void)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		movzx	ecx, [ebp+arg_4]
		push	ecx		; char
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?updateFormatting@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::updateFormatting(int,signed char,UErrorCode &)
		mov	ecx, [ebp+var_8] ; this
		call	?getPatternScale@DecimalFormatImpl@icu_56@@ABEHXZ ; icu_56::DecimalFormatImpl::getPatternScale(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setMultiplierScale@DecimalFormatImpl@icu_56@@AAEXH@Z ;	icu_56::DecimalFormatImpl::setMultiplierScale(int)

loc_BB60:				; CODE XREF: icu_56::DecimalFormatImpl::updateAll(int,signed char,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?updateAll@DecimalFormatImpl@icu_56@@AAEXHCAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BB78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DecimalFormatImpl::computeExponentPatternLength(icu_56::DecimalFormatImpl *__hidden this)
		public ?computeExponentPatternLength@DecimalFormatImpl@icu_56@@ABEHXZ
?computeExponentPatternLength@DecimalFormatImpl@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+20Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_BBC8
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+58Dh]
		neg	ecx
		sbb	ecx, ecx
		neg	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+578h]
		lea	eax, [ecx+eax+1]
		jmp	short loc_BBCA
; ---------------------------------------------------------------------------

loc_BBC8:				; CODE XREF: icu_56::DecimalFormatImpl::computeExponentPatternLength(void)+2Fj
		xor	eax, eax

loc_BBCA:				; CODE XREF: icu_56::DecimalFormatImpl::computeExponentPatternLength(void)+4Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?computeExponentPatternLength@DecimalFormatImpl@icu_56@@ABEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BBD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DecimalFormatImpl::countFractionDigitAndDecimalPatternLength(icu_56::DecimalFormatImpl	*this, int)
		public ?countFractionDigitAndDecimalPatternLength@DecimalFormatImpl@icu_56@@ABEHH@Z
?countFractionDigitAndDecimalPatternLength@DecimalFormatImpl@icu_56@@ABEHH@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+228p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+58Ch]
		test	ecx, ecx
		jnz	short loc_BC0F
		cmp	[ebp+arg_0], 0
		jnz	short loc_BC0F
		xor	eax, eax
		jmp	short loc_BC15
; ---------------------------------------------------------------------------

loc_BC0F:				; CODE XREF: icu_56::DecimalFormatImpl::countFractionDigitAndDecimalPatternLength(int)+2Fj
					; icu_56::DecimalFormatImpl::countFractionDigitAndDecimalPatternLength(int)+35j
		mov	eax, [ebp+arg_0]
		add	eax, 1

loc_BC15:				; CODE XREF: icu_56::DecimalFormatImpl::countFractionDigitAndDecimalPatternLength(int)+39j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?countFractionDigitAndDecimalPatternLength@DecimalFormatImpl@icu_56@@ABEHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BC20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::toNumberPattern(icu_56::DecimalFormatImpl	*this, char, int, struct icu_56::UnicodeString *)
		public ?toNumberPattern@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@CHAAV32@@Z
?toNumberPattern@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@CHAAV32@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+144p
					; icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString &)+2B8p

var_1C8		= byte ptr -1C8h
var_1C1		= byte ptr -1C1h
var_1B5		= byte ptr -1B5h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
var_BC		= dword	ptr -0BCh
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= byte ptr -8Ch
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_2C		= byte ptr -2Ch
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= byte ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 1C8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C8]
		mov	ecx, 72h ; 'r'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_1C1], 0
		mov	[ebp+var_1B5], 0
		mov	eax, [ebp+var_8]
		add	eax, 580h
		mov	ecx, [eax]
		mov	[ebp+var_1C], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_18], edx
		mov	eax, [eax+8]
		mov	[ebp+var_14], eax
		mov	[ebp+var_14], 0
		lea	ecx, [ebp+var_2C] ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		lea	ecx, [ebp+var_3C] ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		lea	ecx, [ebp+var_64] ; this
		call	??0DigitInterval@icu_56@@QAE@XZ	; icu_56::DigitInterval::DigitInterval(void)
		mov	[ebp+var_70], 0
		mov	[ebp+var_7C], 0
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+89h]
		test	ecx, ecx
		jz	short loc_BD1A
		lea	ecx, [ebp+var_8C] ; this
		call	??0SignificantDigitInterval@icu_56@@QAE@XZ ; icu_56::SignificantDigitInterval::SignificantDigitInterval(void)
		lea	eax, [ebp+var_8C]
		push	eax		; struct icu_56::SignificantDigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?extractSigDigits@DecimalFormatImpl@icu_56@@ABEXAAVSignificantDigitInterval@2@@Z ; icu_56::DecimalFormatImpl::extractSigDigits(icu_56::SignificantDigitInterval	&)
		lea	ecx, [ebp+var_8C] ; this
		call	?getMax@SignificantDigitInterval@icu_56@@QBEHXZ	; icu_56::SignificantDigitInterval::getMax(void)
		mov	[ebp+var_1C1], 1
		mov	[ebp+var_54], eax
		lea	ecx, [ebp+var_8C] ; this
		call	?getMin@SignificantDigitInterval@icu_56@@QBEHXZ	; icu_56::SignificantDigitInterval::getMin(void)
		mov	[ebp+var_1B5], 1
		mov	[ebp+var_48], eax
		push	0		; int
		lea	ecx, [ebp+var_64] ; this
		call	?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::setFracDigitCount(int)
		cmp	[ebp+var_1C1], 0
		jnz	short loc_BD09
		push	offset $LN38	; "sigMax"
		call	__RTC_UninitUse
		add	esp, 4

loc_BD09:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+DAj
		mov	eax, [ebp+var_54]
		push	eax		; int
		lea	ecx, [ebp+var_64] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		jmp	loc_BDEA
; ---------------------------------------------------------------------------

loc_BD1A:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+83j
		lea	eax, [ebp+var_3C]
		push	eax		; struct icu_56::DigitInterval *
		lea	ecx, [ebp+var_2C]
		push	ecx		; struct icu_56::DigitInterval *
		mov	ecx, [ebp+var_8] ; this
		call	?extractMinMaxDigits@DecimalFormatImpl@icu_56@@ABEXAAVDigitInterval@2@0@Z ; icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	short loc_BD5D
		lea	ecx, [ebp+var_3C] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		cmp	eax, 8
		jle	short loc_BD5B
		push	1		; int
		lea	ecx, [ebp+var_3C] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		lea	eax, [ebp+var_3C]
		push	eax		; struct icu_56::DigitInterval *
		lea	ecx, [ebp+var_2C] ; this
		call	?shrinkToFitWithin@DigitInterval@icu_56@@QAEXABV12@@Z ;	icu_56::DigitInterval::shrinkToFitWithin(icu_56::DigitInterval const &)

loc_BD5B:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+123j
		jmp	short loc_BD8C
; ---------------------------------------------------------------------------

loc_BD5D:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+116j
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_BD78
		lea	ecx, [ebp+var_2C] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		push	eax		; int
		lea	ecx, [ebp+var_3C] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		jmp	short loc_BD8C
; ---------------------------------------------------------------------------

loc_BD78:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+143j
		lea	ecx, [ebp+var_2C] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		add	eax, 1
		push	eax		; int
		lea	ecx, [ebp+var_3C] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)

loc_BD8C:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &):loc_BD5Bj
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+156j
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_BDDE
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?getLowerExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getLowerExponent(void)
		mov	[ebp+var_70], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?getUpperExponent@DigitList@icu_56@@QBEHXZ ; icu_56::DigitList::getUpperExponent(void)
		mov	[ebp+var_7C], eax
		mov	eax, [ebp+var_70]
		push	eax		; int
		lea	ecx, [ebp+var_3C] ; this
		call	?expandToContainDigit@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::expandToContainDigit(int)
		mov	eax, [ebp+var_7C]
		sub	eax, 1
		push	eax		; int
		lea	ecx, [ebp+var_3C] ; this
		call	?expandToContainDigit@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::expandToContainDigit(int)

loc_BDDE:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+17Fj
		mov	eax, [ebp+var_3C]
		mov	[ebp+var_64], eax
		mov	ecx, [ebp+var_38]
		mov	[ebp+var_60], ecx

loc_BDEA:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+F5j
		lea	eax, [ebp+var_1C]
		push	eax
		call	?getMinimumLengthToDescribeGrouping@icu_56@@YAHABVDigitGrouping@1@@Z ; icu_56::getMinimumLengthToDescribeGrouping(icu_56::DigitGrouping	const &)
		add	esp, 4
		mov	[ebp+var_98], eax
		cmp	[ebp+var_98], 0
		jle	short loc_BE1D
		lea	eax, [ebp+var_1C]
		push	eax
		call	?getMinimumLengthToDescribeGrouping@icu_56@@YAHABVDigitGrouping@1@@Z ; icu_56::getMinimumLengthToDescribeGrouping(icu_56::DigitGrouping	const &)
		add	esp, 4
		sub	eax, 1
		push	eax		; int
		lea	ecx, [ebp+var_64] ; this
		call	?expandToContainDigit@DigitInterval@icu_56@@QAEXH@Z ; icu_56::DigitInterval::expandToContainDigit(int)

loc_BE1D:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+1E3j
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jz	loc_BECC
		mov	ecx, [ebp+var_8] ; this
		call	?computeExponentPatternLength@DecimalFormatImpl@icu_56@@ABEHXZ ; icu_56::DecimalFormatImpl::computeExponentPatternLength(void)
		mov	ecx, [ebp+arg_4]
		sub	ecx, eax
		mov	[ebp+var_A4], ecx
		lea	ecx, [ebp+var_64] ; this
		call	?getFracDigitCount@DigitInterval@icu_56@@QBEHXZ	; icu_56::DigitInterval::getFracDigitCount(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?countFractionDigitAndDecimalPatternLength@DecimalFormatImpl@icu_56@@ABEHH@Z ; icu_56::DecimalFormatImpl::countFractionDigitAndDecimalPatternLength(int)
		mov	ecx, [ebp+var_A4]
		sub	ecx, eax
		mov	[ebp+var_B0], ecx
		lea	eax, [ebp+var_BC]
		push	eax		; int
		lea	ecx, [ebp+var_64] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		push	eax		; int
		mov	ecx, [ebp+var_B0]
		push	ecx		; int
		lea	edx, [ebp+var_1C]
		push	edx		; icu_56::DigitGrouping	*
		call	?getLeftDigitsForLeftLength@icu_56@@YACABVDigitGrouping@1@HHAAH@Z ; icu_56::getLeftDigitsForLeftLength(icu_56::DigitGrouping const &,int,int,int &)
		add	esp, 10h
		movsx	eax, al
		test	eax, eax
		jz	short loc_BE96
		mov	eax, [ebp+var_BC]
		push	eax		; int
		lea	ecx, [ebp+var_64] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)
		jmp	short loc_BECC
; ---------------------------------------------------------------------------

loc_BE96:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+263j
		lea	ecx, [ebp+var_64] ; this
		call	?getIntDigitCount@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getIntDigitCount(void)
		cmp	[ebp+var_BC], eax
		jle	short loc_BECC
		mov	esi, esp
		push	23h ; '#'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_BC]
		sub	eax, 1
		push	eax		; int
		lea	ecx, [ebp+var_64] ; this
		call	?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z	; icu_56::DigitInterval::setIntDigitCount(int)

loc_BECC:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+203j
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+274j ...
		lea	ecx, [ebp+var_64] ; this
		call	?getMostSignificantExclusive@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getMostSignificantExclusive(void)
		mov	[ebp+var_C8], eax
		lea	ecx, [ebp+var_64] ; this
		call	?getLeastSignificantInclusive@DigitInterval@icu_56@@QBEHXZ ; icu_56::DigitInterval::getLeastSignificantInclusive(void)
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+var_C8]
		sub	eax, 1
		mov	[ebp+var_E0], eax
		jmp	short loc_BF08
; ---------------------------------------------------------------------------

loc_BEF9:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &):loc_C0C6j
		mov	eax, [ebp+var_E0]
		sub	eax, 1
		mov	[ebp+var_E0], eax

loc_BF08:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+2D7j
		mov	eax, [ebp+var_E0]
		cmp	eax, [ebp+var_D4]
		jl	loc_C0CB
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+58Ch]
		test	ecx, ecx
		jnz	short loc_BF45
		cmp	[ebp+var_E0], 0FFFFFFFFh
		jnz	short loc_BF45
		mov	esi, esp
		push	2Eh ; '.'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_BF45:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+306j
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+30Fj
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+89h]
		test	ecx, ecx
		jz	loc_BFE1
		cmp	[ebp+var_1C1], 0
		jnz	short loc_BF6D
		push	offset $LN38	; "sigMax"
		call	__RTC_UninitUse
		add	esp, 4

loc_BF6D:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+33Ej
		mov	eax, [ebp+var_E0]
		cmp	eax, [ebp+var_54]
		jge	short loc_BFB2
		cmp	[ebp+var_1C1], 0
		jnz	short loc_BF8E
		push	offset $LN38	; "sigMax"
		call	__RTC_UninitUse
		add	esp, 4

loc_BF8E:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+35Fj
		cmp	[ebp+var_1B5], 0
		jnz	short loc_BFA4
		push	offset $LN42	; "sigMin"
		call	__RTC_UninitUse
		add	esp, 4

loc_BFA4:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+375j
		mov	eax, [ebp+var_54]
		sub	eax, [ebp+var_48]
		cmp	[ebp+var_E0], eax
		jge	short loc_BFC8

loc_BFB2:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+356j
		mov	esi, esp
		push	23h ; '#'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_BFDC
; ---------------------------------------------------------------------------

loc_BFC8:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+390j
		mov	esi, esp
		push	40h ; '@'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_BFDC:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+3A6j
		jmp	loc_C067
; ---------------------------------------------------------------------------

loc_BFE1:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+331j
		mov	eax, [ebp+var_E0]
		cmp	eax, [ebp+var_7C]
		jge	short loc_C027
		mov	eax, [ebp+var_E0]
		cmp	eax, [ebp+var_70]
		jl	short loc_C027
		mov	eax, [ebp+var_E0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 500h	; this
		call	?getDigitByExponent@DigitList@icu_56@@QBEEH@Z ;	icu_56::DigitList::getDigitByExponent(int)
		movzx	ecx, al
		add	ecx, 30h ; '0'
		mov	esi, esp
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z ;	icu_56::UnicodeString::append(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_C067
; ---------------------------------------------------------------------------

loc_C027:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+3CAj
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+3D5j
		mov	eax, [ebp+var_E0]
		push	eax		; int
		lea	ecx, [ebp+var_2C] ; this
		call	?contains@DigitInterval@icu_56@@QBECH@Z	; icu_56::DigitInterval::contains(int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C053
		mov	esi, esp
		push	30h ; '0'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_C067
; ---------------------------------------------------------------------------

loc_C053:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+41Bj
		mov	esi, esp
		push	23h ; '#'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C067:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &):loc_BFDCj
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+405j ...
		mov	eax, [ebp+var_E0]
		push	eax		; int
		mov	ecx, [ebp+var_E0]
		add	ecx, 1
		push	ecx		; int
		lea	ecx, [ebp+var_1C] ; this
		call	?isSeparatorAt@DigitGrouping@icu_56@@QBECHH@Z ;	icu_56::DigitGrouping::isSeparatorAt(int,int)
		movsx	edx, al
		test	edx, edx
		jz	short loc_C09B
		mov	esi, esp
		push	2Ch ; ','       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C09B:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+465j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+58Ch]
		test	ecx, ecx
		jz	short loc_C0C6
		cmp	[ebp+var_E0], 0
		jnz	short loc_C0C6
		mov	esi, esp
		push	2Eh ; '.'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C0C6:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+487j
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+490j
		jmp	loc_BEF9
; ---------------------------------------------------------------------------

loc_C0CB:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+2F4j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+88h]
		test	ecx, ecx
		jz	loc_C15E
		mov	esi, esp
		push	45h ; 'E'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+58Dh]
		test	ecx, ecx
		jz	short loc_C113
		mov	esi, esp
		push	2Bh ; '+'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C113:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+4DDj
		mov	[ebp+var_EC], 0
		jmp	short loc_C12E
; ---------------------------------------------------------------------------

loc_C11F:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+53Cj
		mov	eax, [ebp+var_EC]
		add	eax, 1
		mov	[ebp+var_EC], eax

loc_C12E:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+4FDj
		cmp	[ebp+var_EC], 1
		jl	short loc_C148
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_EC]
		cmp	ecx, [eax+578h]
		jge	short loc_C15E

loc_C148:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+515j
		mov	esi, esp
		push	30h ; '0'       ; wchar_t
		mov	ecx, [ebp+arg_8] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_C11F
; ---------------------------------------------------------------------------

loc_C15E:				; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+4B7j
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+526j
		mov	eax, [ebp+arg_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN50
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?toNumberPattern@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@CHAAV32@@Z endp

; ---------------------------------------------------------------------------
$LN50		dd 6			; DATA XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+545o
		dd offset $LN49
$LN49		dd 0FFFFFFE4h, 0Ch	; DATA XREF: .text:0000C18Co
		dd offset $LN43		; "grouping"
		dd 0FFFFFFD4h, 8
		dd offset $LN44		; "minInterval"
		dd 0FFFFFFC4h, 8
		dd offset $LN45		; "maxInterval"
		dd 0FFFFFF9Ch, 8
		dd offset $LN46		; "fullInterval"
		dd 0FFFFFF74h, 8
		dd offset $LN47		; "sigInterval"
		dd 0FFFFFF44h, 4
		dd offset $LN48		; "digitsNeeded"
$LN48		db 'digitsNeeded',0     ; DATA XREF: .text:0000C1D4o
$LN47		db 'sigInterval',0      ; DATA XREF: .text:0000C1C8o
$LN46		db 'fullInterval',0     ; DATA XREF: .text:0000C1BCo
$LN45		db 'maxInterval',0      ; DATA XREF: .text:0000C1B0o
$LN44		db 'minInterval',0      ; DATA XREF: .text:0000C1A4o
$LN43		db 'grouping',0         ; DATA XREF: .text:0000C198o
$LN42		db 'sigMin',0           ; DATA XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+377o
$LN38		db 'sigMax',0           ; DATA XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+DCo
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+340o ...
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C230h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::getMinimumLengthToDescribeGrouping(class icu_56::DigitGrouping const &)
?getMinimumLengthToDescribeGrouping@icu_56@@YAHABVDigitGrouping@1@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+1CEp
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+1E9p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jg	short loc_C25A
		xor	eax, eax
		jmp	short loc_C27C
; ---------------------------------------------------------------------------

loc_C25A:				; CODE XREF: icu_56::getMinimumLengthToDescribeGrouping(icu_56::DigitGrouping const &)+24j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jg	short loc_C26D
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]
		add	eax, 1
		jmp	short loc_C27C
; ---------------------------------------------------------------------------

loc_C26D:				; CODE XREF: icu_56::getMinimumLengthToDescribeGrouping(icu_56::DigitGrouping const &)+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		lea	eax, [ecx+eax+1]

loc_C27C:				; CODE XREF: icu_56::getMinimumLengthToDescribeGrouping(icu_56::DigitGrouping const &)+28j
					; icu_56::getMinimumLengthToDescribeGrouping(icu_56::DigitGrouping const &)+3Bj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMinimumLengthToDescribeGrouping@icu_56@@YAHABVDigitGrouping@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C284h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::getLeftDigitsForLeftLength(icu_56::DigitGrouping *, int, int, int)
?getLeftDigitsForLeftLength@icu_56@@YACABVDigitGrouping@1@HHAAH@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+256p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [ebp+arg_8]
		mov	[eax], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getSeparatorCount@DigitGrouping@icu_56@@QBEHH@Z ; icu_56::DigitGrouping::getSeparatorCount(int)
		mov	edx, [ebp+arg_C]
		add	eax, [edx]
		mov	[ebp+var_8], eax

loc_C2C0:				; CODE XREF: icu_56::getLeftDigitsForLeftLength(icu_56::DigitGrouping const &,int,int,int &)+7Aj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jge	short loc_C300
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		mov	eax, [edx]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?isSeparatorAt@DigitGrouping@icu_56@@QBECHH@Z ;	icu_56::DigitGrouping::isSeparatorAt(int,int)
		movsx	ecx, al
		neg	ecx
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		add	ecx, 1
		mov	edx, [ebp+arg_C]
		mov	[edx], ecx
		jmp	short loc_C2C0
; ---------------------------------------------------------------------------

loc_C300:				; CODE XREF: icu_56::getLeftDigitsForLeftLength(icu_56::DigitGrouping const &,int,int,int &)+42j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getLeftDigitsForLeftLength@icu_56@@YACABVDigitGrouping@1@HHAAH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::DecimalFormatImpl::toPattern(icu_56::DecimalFormatImpl *this, struct	icu_56::UnicodeString *)
		public ?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_1C0		= byte ptr -1C0h
var_1BC		= dword	ptr -1BCh
var_F0		= byte ptr -0F0h
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1B4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C0]
		mov	ecx, 6Dh ; 'm'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A64h], 0
		jle	short loc_C3CC
		mov	esi, esp
		push	2Ah ; '*'       ; wchar_t
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+0A60h]
		push	ecx		; int
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z ;	icu_56::UnicodeString::append(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C3CC:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+7Aj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 0
		jnz	short loc_C3EE
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C3EE:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+B6j
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 98h ; ''  ; this
		call	?toUserString@AffixPattern@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z ; icu_56::AffixPattern::toUserString(icu_56::UnicodeString &)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 1
		jnz	short loc_C422
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C422:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+EAj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 98h ; ''  ; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		mov	ecx, [ebp+var_18]
		mov	esi, [ecx+0A64h]
		sub	esi, eax
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		sub	esi, eax
		push	esi		; int
		mov	edx, [ebp+var_18]
		cmp	dword ptr [edx+0A64h], 0
		setnle	al
		movzx	ecx, al
		push	ecx		; char
		mov	ecx, [ebp+var_18] ; this
		call	?toNumberPattern@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@CHAAV32@@Z ; icu_56::DecimalFormatImpl::toNumberPattern(signed	char,int,icu_56::UnicodeString &)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 2
		jnz	short loc_C48B
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C48B:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+153j
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h	; this
		call	?toUserString@AffixPattern@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z ; icu_56::AffixPattern::toUserString(icu_56::UnicodeString &)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 3
		jnz	short loc_C4BF
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C4BF:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+187j
		lea	ecx, [ebp+var_F0] ; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	byte ptr [ebp+var_4], 1
		push	4
		lea	ecx, [ebp+var_F0]
		call	?add@AffixPattern@icu_56@@QAEXW4ETokenType@12@@Z ; icu_56::AffixPattern::add(icu_56::AffixPattern::ETokenType)
		mov	eax, [ebp+var_18]
		add	eax, 98h ; ''
		push	eax		; struct icu_56::AffixPattern *
		lea	ecx, [ebp+var_F0] ; this
		call	?append@AffixPattern@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::AffixPattern::append(icu_56::AffixPattern const &)
		mov	eax, [ebp+var_18]
		add	eax, 230h
		push	eax		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h	; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C52C
		mov	eax, [ebp+var_18]
		add	eax, 120h
		push	eax		; struct icu_56::AffixPattern *
		lea	ecx, [ebp+var_F0] ; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_C633

loc_C52C:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+1EBj
		mov	esi, esp
		push	3Bh ; ';'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 0
		jnz	short loc_C562
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C562:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+22Aj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 120h	; this
		call	?toUserString@AffixPattern@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z ; icu_56::AffixPattern::toUserString(icu_56::UnicodeString &)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 1
		jnz	short loc_C596
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C596:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+25Ej
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 120h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		mov	ecx, [ebp+var_18]
		mov	esi, [ecx+0A64h]
		sub	esi, eax
		mov	ecx, [ebp+var_18]
		add	ecx, 230h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		sub	esi, eax
		push	esi		; int
		mov	edx, [ebp+var_18]
		cmp	dword ptr [edx+0A64h], 0
		setnle	al
		movzx	ecx, al
		push	ecx		; char
		mov	ecx, [ebp+var_18] ; this
		call	?toNumberPattern@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@CHAAV32@@Z ; icu_56::DecimalFormatImpl::toNumberPattern(signed	char,int,icu_56::UnicodeString &)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 2
		jnz	short loc_C5FF
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C5FF:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+2C7j
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18]
		add	ecx, 230h	; this
		call	?toUserString@AffixPattern@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z ; icu_56::AffixPattern::toUserString(icu_56::UnicodeString &)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A5Ch], 3
		jnz	short loc_C633
		mov	esi, esp
		lea	eax, [ebp+var_60]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C633:				; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+206j
					; icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString &)+2FBj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_1BC], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_F0] ; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_1BC]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN20_1		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+34Eo
		dd offset $LN19_1
$LN19_1		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:0000C6ACo
		dd offset $LN16		; "padSpec"
		dd 0FFFFFF10h, 88h
		dd offset $LN17		; "withNegative"
$LN17		db 'withNegative',0     ; DATA XREF: .text:0000C6C4o
$LN16		db 'padSpec',0          ; DATA XREF: .text:0000C6B8o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C6E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z$0 proc near
					; DATA XREF: .xdata$x:0000C72Co
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z$1 proc near
					; DATA XREF: .xdata$x:0000C734o
		lea	ecx, [ebp-0F0h]	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z	proc near
					; DATA XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1C4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C728h
__unwindtable$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C740o
		dd offset __unwindfunclet$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z$0
		dd 0
		dd offset __unwindfunclet$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z$1
__ehfuncinfo$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z+1Eo
		dd offset __unwindtable$?toPattern@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C75Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::DecimalFormatImpl::getOldFormatWidth(icu_56::DecimalFormatImpl	*__hidden this)
		public ?getOldFormatWidth@DecimalFormatImpl@icu_56@@ABEHXZ
?getOldFormatWidth@DecimalFormatImpl@icu_56@@ABEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0A64h], 0
		jnz	short loc_C78F
		xor	eax, eax
		jmp	short loc_C7BA
; ---------------------------------------------------------------------------

loc_C78F:				; CODE XREF: icu_56::DecimalFormatImpl::getOldFormatWidth(void)+2Dj
		mov	ecx, [ebp+var_8]
		add	ecx, 1A8h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		mov	ecx, [ebp+var_8]
		mov	esi, [ecx+0A64h]
		sub	esi, eax
		mov	ecx, [ebp+var_8]
		add	ecx, 98h ; ''  ; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		sub	esi, eax
		mov	eax, esi

loc_C7BA:				; CODE XREF: icu_56::DecimalFormatImpl::getOldFormatWidth(void)+31j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getOldFormatWidth@DecimalFormatImpl@icu_56@@ABEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: class icu_56::UnicodeString const & __thiscall icu_56::DecimalFormatImpl::getConstSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getConstSymbol@DecimalFormatImpl@icu_56@@ABEABVUnicodeString@2@W4ENumberFormatSymbol@DecimalFormatSymbols@2@@Z
?getConstSymbol@DecimalFormatImpl@icu_56@@ABEABVUnicodeString@2@W4ENumberFormatSymbol@DecimalFormatSymbols@2@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+2B8h]
		call	?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ; icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getConstSymbol@DecimalFormatImpl@icu_56@@ABEABVUnicodeString@2@W4ENumberFormatSymbol@DecimalFormatSymbols@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C81Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatImpl::isParseFastpath(icu_56::DecimalFormatImpl	*__hidden this)
		public ?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ
?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ proc near

var_17C		= byte ptr -17Ch
var_179		= byte ptr -179h
var_171		= byte ptr -171h
var_A8		= byte ptr -0A8h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 170h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_17C]
		mov	ecx, 5Ch ; '\'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		lea	ecx, [ebp+var_A8] ; this
		call	??0AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::AffixPattern(void)
		mov	[ebp+var_4], 0
		push	4
		lea	ecx, [ebp+var_A8]
		call	?add@AffixPattern@icu_56@@QAEXW4ETokenType@12@@Z ; icu_56::AffixPattern::add(icu_56::AffixPattern::ETokenType)
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+0A64h], 0
		jnz	short loc_C8E7
		mov	ecx, [ebp+var_18]
		add	ecx, 98h ; ''  ; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		test	eax, eax
		jnz	short loc_C8E7
		lea	ecx, [ebp+var_A8]
		push	ecx		; struct icu_56::AffixPattern *
		mov	ecx, [ebp+var_18]
		add	ecx, 120h	; this
		call	?equals@AffixPattern@icu_56@@QBECABV12@@Z ; icu_56::AffixPattern::equals(icu_56::AffixPattern const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_C8E7
		mov	ecx, [ebp+var_18]
		add	ecx, 1A8h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		test	eax, eax
		jnz	short loc_C8E7
		mov	ecx, [ebp+var_18]
		add	ecx, 230h	; this
		call	?countChar32@AffixPattern@icu_56@@QBEHXZ ; icu_56::AffixPattern::countChar32(void)
		test	eax, eax
		jnz	short loc_C8E7
		mov	[ebp+var_179], 1
		jmp	short loc_C8EE
; ---------------------------------------------------------------------------

loc_C8E7:				; CODE XREF: icu_56::DecimalFormatImpl::isParseFastpath(void)+6Ej
					; icu_56::DecimalFormatImpl::isParseFastpath(void)+80j	...
		mov	[ebp+var_179], 0

loc_C8EE:				; CODE XREF: icu_56::DecimalFormatImpl::isParseFastpath(void)+C9j
		mov	al, [ebp+var_179]
		mov	[ebp+var_171], al
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_A8] ; this
		call	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
		mov	al, [ebp+var_171]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 17Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
$LN9_4		dd 1			; DATA XREF: icu_56::DecimalFormatImpl::isParseFastpath(void)+FAo
		dd offset $LN8_7
$LN8_7		dd 0FFFFFF58h, 88h	; DATA XREF: .text:0000C950o
		dd offset $LN6_17	; "negative"
$LN6_17		db 'negative',0         ; DATA XREF: .text:0000C95Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C96Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ$0 proc near
					; DATA XREF: .xdata$x:0000C9A4o
		lea	ecx, [ebp-0A8h]	; this
		jmp	??1AffixPattern@icu_56@@QAE@XZ ; icu_56::AffixPattern::~AffixPattern(void)
__unwindfunclet$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ proc near
					; DATA XREF: icu_56::DecimalFormatImpl::isParseFastpath(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-180h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ
		jmp	___CxxFrameHandler3
__ehhandler$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C9A0h
__unwindtable$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C9B0o
		dd offset __unwindfunclet$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ$0
__ehfuncinfo$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ+1Eo
		dd offset __unwindtable$?isParseFastpath@DecimalFormatImpl@icu_56@@ABECXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(void)
		public ??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	&)
		public ??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::~EnumSet<enum  UNumberFormatAttribute, 4096, 4099>(void)
		public ??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ
??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::clear(void)
		public ?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ
?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CAA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::add(enum  UNumberFormatAttribute)
		public ?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z
?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?add@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CAE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::remove(enum  UNumberFormatAttribute)
		public ?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z
?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?remove@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::contains(enum  UNumberFormatAttribute)const
		public ?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z
?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::get(UNumberFormatAttribute)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::set(enum  UNumberFormatAttribute, int)
		public ?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z
?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::add(UNumberFormatAttribute)+2Cp
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::remove(UNumberFormatAttribute)+2Cp

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jz	short loc_CBB5
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		mov	[ebp+var_D0], eax
		jmp	short loc_CBBF
; ---------------------------------------------------------------------------

loc_CBB5:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+27j
		mov	[ebp+var_D0], 0

loc_CBBF:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+3Bj
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		not	eax
		mov	edx, [ebp+var_8]
		and	eax, [edx]
		or	eax, [ebp+var_D0]
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?set@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEXW4UNumberFormatAttribute@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CBF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::get(enum  UNumberFormatAttribute)const
		public ?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z
?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::contains(UNumberFormatAttribute)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z ; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::flag(UNumberFormatAttribute)
		mov	ecx, [ebp+var_8]
		and	eax, [ecx]
		neg	eax
		sbb	eax, eax
		neg	eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEHW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CC44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::isValidEnum(enum  UNumberFormatAttribute)const
		public ?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z
?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1000h
		jb	short loc_CC82
		cmp	[ebp+arg_0], 1003h
		jnb	short loc_CC82
		mov	[ebp+var_CD], 1
		jmp	short loc_CC89
; ---------------------------------------------------------------------------

loc_CC82:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+2Aj
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+33j
		mov	[ebp+var_CD], 0

loc_CC89:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidEnum(UNumberFormatAttribute)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?isValidEnum@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CC98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::isValidValue(int)const
		public ?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z
?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_CCD0
		cmp	[ebp+arg_0], 1
		jz	short loc_CCD0
		mov	[ebp+var_CD], 0
		jmp	short loc_CCD7
; ---------------------------------------------------------------------------

loc_CCD0:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+27j
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+2Dj
		mov	[ebp+var_CD], 1

loc_CCD7:				; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::isValidValue(int)+36j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?isValidValue@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CCE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	& __thiscall icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099>::operator=(class	icu_56::EnumSet<enum  UNumberFormatAttribute, 4096, 4099> const	&)
		public ??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z
??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QAEABV01@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall icu_56::EnumSet<enum	UNumberFormatAttribute,	4096, 4099>::getAll(void)const
		public ?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ
?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAll@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: unsigned int	__thiscall icu_56::EnumSet<enum	 UNumberFormatAttribute, 4096, 4099>::flag(enum	 UNumberFormatAttribute)const
		public ?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z
?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z proc near
					; CODE XREF: icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+30p
					; icu_56::EnumSet<UNumberFormatAttribute,4096,4099>::set(UNumberFormatAttribute,int)+4Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		sub	ecx, 1000h
		mov	eax, 1
		shl	eax, cl
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?flag@?$EnumSet@W4UNumberFormatAttribute@@$0BAAA@$0BAAD@@icu_56@@ABEIW4UNumberFormatAttribute@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::MaybeStackHeaderAndArray<struct decNumber, char, 40>(void)
		public ??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CDDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::~MaybeStackHeaderAndArray<struct decNumber, char, 40>(void)
		public ??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ
??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CE1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CE4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::getAlias(void)const
		public ?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ
?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CE7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getArrayStart(void)const
		public ?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ
?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayLimit(void)+26p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::operator[](int)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getAlias(void)
		add	eax, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CEC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::getArrayLimit(void)const
		public ?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ
?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ ;	icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayLimit@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber,	char, 40>::operator struct decNumber *(void)const
		public ??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ
??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??B?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPAUdecNumber@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator[](int)
		public ??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z
??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getArrayStart@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QBEPADXZ ;	icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::getArrayStart(void)
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEAADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::aliasInstead(struct decNumber *, int)
		public ?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z
?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_CFCB
		cmp	[ebp+arg_4], 0
		jle	short loc_CFCB
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0

loc_CFCB:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+27j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?aliasInstead@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEXPAUdecNumber@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CFE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::releaseMemory(void)
		public ?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ
?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::~MaybeStackHeaderAndArray<decNumber,char,40>(void)+26p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::aliasInstead(decNumber *,int)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_D020
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_D020:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D034h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator==(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z
??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D064h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator!=(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z
??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??9?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D094h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: __thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::MaybeStackHeaderAndArray<struct decNumber, char, 40>(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char,	40> const &)
		public ??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D0C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40>::operator=(class icu_56::MaybeStackHeaderAndArray<struct decNumber, char, 40> const &)
		public ??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z
??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D0F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::PluralMap<class icu_56::DigitAffix>(void)
		public ??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::PluralAffix::PluralAffix(void)+26p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::DigitAffix(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		call	?initializeNew@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEXXZ ; icu_56::PluralMap<icu_56::DigitAffix>::initializeNew(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000D1A0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D19Ch
__unwindtable$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D1ACo
		dd offset __unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ$0
__ehfuncinfo$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D1C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(struct icu_56::DigitAffix *)
		public ??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z
??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z proc	near
					; CODE XREF: icu_56::PluralAffix::PluralAffix(icu_56::DigitAffix const &)+2Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_14] ; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		call	?initializeNew@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEXXZ ; icu_56::PluralMap<icu_56::DigitAffix>::initializeNew(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z$0 proc near
					; DATA XREF: .xdata$x:0000D27Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z proc near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::DigitAffix const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D278h
__unwindtable$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D288o
		dd offset __unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z$0
__ehfuncinfo$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z+14o
		dd offset __unwindtable$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABVDigitAffix@1@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D2A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(struct icu_56::DigitAffix *)
		public ??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z
??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::PluralAffix::PluralAffix(icu_56::PluralAffix const	&)+2Ap

var_104		= dword	ptr -104h
var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_104]
		mov	ecx, 3Eh ; '>'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_14] ; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	[eax+80h], ecx
		mov	[ebp+var_20], 1
		jmp	short loc_D317
; ---------------------------------------------------------------------------

loc_D30E:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+11Dj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_D317:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+68j
		cmp	[ebp+var_20], 6
		jge	loc_D3C6
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_D3A4
		mov	esi, esp
		push	80h ; ''       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_D37C
		mov	edx, [ebp+var_20]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+edx*4+80h]
		push	ecx		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_EC] ; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	[ebp+var_100], eax
		jmp	short loc_D386
; ---------------------------------------------------------------------------

loc_D37C:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+B5j
		mov	[ebp+var_100], 0

loc_D386:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+D6j
		mov	edx, [ebp+var_100]
		mov	[ebp+var_F8], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_F8]
		mov	[ebp+var_104], eax
		jmp	short loc_D3AE
; ---------------------------------------------------------------------------

loc_D3A4:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+8Bj
		mov	[ebp+var_104], 0

loc_D3AE:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+FEj
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_104]
		mov	[edx+ecx*4+80h], eax
		jmp	loc_D30E
; ---------------------------------------------------------------------------

loc_D3C6:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+77j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 104h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D3F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z$0 proc	near
					; DATA XREF: .xdata$x:0000D438o
		mov	ecx, [ebp-14h]	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z$1 proc	near
					; DATA XREF: .xdata$x:0000D440o
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::PluralMap<icu_56::DigitAffix>	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-108h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D434h
__unwindtable$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D44Co
		dd offset __unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z$0
		align 10h
		dd offset __unwindfunclet$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D468h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PluralMap<class	icu_56::DigitAffix> & __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::operator=(class icu_56::PluralMap<class icu_56::DigitAffix> const	&)
		public ??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z
??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::PluralAffix::operator=(icu_56::PluralAffix	const &)+2Ap

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_D4BA
		mov	eax, [ebp+var_14]
		jmp	loc_D61E
; ---------------------------------------------------------------------------

loc_D4BA:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+48j
		mov	[ebp+var_20], 0
		jmp	short loc_D4CC
; ---------------------------------------------------------------------------

loc_D4C3:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &):loc_D616j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_D4CC:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+59j
		cmp	[ebp+var_20], 6
		jge	loc_D61B
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_D51B
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_D51B
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+80h]
		push	edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+eax*4+80h]
		call	??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::DigitAffix::operator=(icu_56::DigitAffix const &)
		jmp	loc_D616
; ---------------------------------------------------------------------------

loc_D51B:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+7Cj
					; icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+8Cj
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_D588
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4+80h]
		mov	[ebp+var_104], edx
		mov	eax, [ebp+var_104]
		mov	[ebp+var_110], eax
		cmp	[ebp+var_110], 0
		jz	short loc_D568
		push	1
		mov	ecx, [ebp+var_110]
		call	??_GDigitAffix@icu_56@@QAEPAXI@Z ; icu_56::DigitAffix::`scalar deleting	destructor'(uint)
		mov	[ebp+var_118], eax
		jmp	short loc_D572
; ---------------------------------------------------------------------------

loc_D568:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+E9j
		mov	[ebp+var_118], 0

loc_D572:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+FEj
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+80h], 0
		jmp	loc_D616
; ---------------------------------------------------------------------------

loc_D588:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+C1j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_D616
		mov	esi, esp
		push	80h ; ''       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_EC], 0
		jz	short loc_D5E6
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+80h]
		push	edx		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_EC] ; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	[ebp+var_118], eax
		jmp	short loc_D5F0
; ---------------------------------------------------------------------------

loc_D5E6:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+15Bj
		mov	[ebp+var_118], 0

loc_D5F0:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+17Cj
		mov	eax, [ebp+var_118]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_F8]
		mov	[edx+ecx*4+80h], eax

loc_D616:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+AEj
					; icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+11Bj	...
		jmp	loc_D4C3
; ---------------------------------------------------------------------------

loc_D61B:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+68j
		mov	eax, [ebp+var_14]

loc_D61E:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+4Dj
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D640h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z$0	proc near
					; DATA XREF: .xdata$x:0000D67Co
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z proc near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D678h
__unwindtable$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D688o
		dd offset __unwindfunclet$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z+14o
		dd offset __unwindtable$??4?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEAAV01@ABV01@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D6A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::~PluralMap<class icu_56::DigitAffix>(void)
		public ??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::PluralAffix::~PluralAffix(void)+26p

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	[ebp+var_20], 1
		jmp	short loc_D6FF
; ---------------------------------------------------------------------------

loc_D6F6:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void):loc_D74Cj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_D6FF:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)+50j
		cmp	[ebp+var_20], 6
		jge	short loc_D74E
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4+80h]
		mov	[ebp+var_EC], edx
		mov	eax, [ebp+var_EC]
		mov	[ebp+var_F8], eax
		cmp	[ebp+var_F8], 0
		jz	short loc_D742
		push	1
		mov	ecx, [ebp+var_F8]
		call	??_GDigitAffix@icu_56@@QAEPAXI@Z ; icu_56::DigitAffix::`scalar deleting	destructor'(uint)
		mov	[ebp+var_100], eax
		jmp	short loc_D74C
; ---------------------------------------------------------------------------

loc_D742:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)+87j
		mov	[ebp+var_100], 0

loc_D74C:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)+9Cj
		jmp	short loc_D6F6
; ---------------------------------------------------------------------------

loc_D74E:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)+5Fj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D77Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:0000D7A8o
		mov	ecx, [ebp-14h]	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D7A4h
__unwindtable$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D7B4o
		dd offset __unwindfunclet$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ$0
__ehfuncinfo$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D7D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::clear(void)
		public ?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ
?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ proc near

var_190		= dword	ptr -190h
var_18C		= dword	ptr -18Ch
var_184		= dword	ptr -184h
var_178		= dword	ptr -178h
var_16C		= byte ptr -16Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 184h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_190]
		mov	ecx, 61h ; 'a'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		lea	ecx, [ebp+var_16C] ; this
		call	??0DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::DigitAffix(void)
		mov	[ebp+var_18C], eax
		mov	eax, [ebp+var_18C]
		mov	[ebp+var_190], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_190]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+80h]
		call	??4DigitAffix@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::DigitAffix::operator=(icu_56::DigitAffix const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_16C] ; this
		call	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
		mov	[ebp+var_24], 1
		jmp	short loc_D872
; ---------------------------------------------------------------------------

loc_D869:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+100j
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax

loc_D872:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+97j
		cmp	[ebp+var_24], 6
		jge	short loc_D8D2
		mov	eax, [ebp+var_24]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+eax*4+80h]
		mov	[ebp+var_178], edx
		mov	eax, [ebp+var_178]
		mov	[ebp+var_184], eax
		cmp	[ebp+var_184], 0
		jz	short loc_D8B5
		push	1
		mov	ecx, [ebp+var_184]
		call	??_GDigitAffix@icu_56@@QAEPAXI@Z ; icu_56::DigitAffix::`scalar deleting	destructor'(uint)
		mov	[ebp+var_18C], eax
		jmp	short loc_D8BF
; ---------------------------------------------------------------------------

loc_D8B5:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+CEj
		mov	[ebp+var_18C], 0

loc_D8BF:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+E3j
		mov	eax, [ebp+var_24]
		mov	ecx, [ebp+var_18]
		mov	dword ptr [ecx+eax*4+80h], 0
		jmp	short loc_D869
; ---------------------------------------------------------------------------

loc_D8D2:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+A6j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 190h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D8FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ$0 proc near
					; DATA XREF: .xdata$x:0000D934o
		lea	ecx, [ebp-16Ch]	; this
		jmp	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
__unwindfunclet$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ proc	near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-194h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D930h
__unwindtable$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000D940o
		dd offset __unwindfunclet$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ$0
__ehfuncinfo$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ+1Eo
		dd offset __unwindtable$?clear@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEXXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D95Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix const * __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::next(enum  icu_56::PluralMapBase::Category &)const
		public ?next@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEPBVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z
?next@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEPBVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z proc near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::nextMutable(icu_56::PluralMapBase::Category	&)+2Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_D99B
; ---------------------------------------------------------------------------

loc_D992:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::next(icu_56::PluralMapBase::Category &):loc_D9C8j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_D99B:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::next(icu_56::PluralMapBase::Category &)+34j
		cmp	[ebp+var_14], 6
		jge	short loc_D9CA
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_D9C8
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+eax*4+80h]
		jmp	short loc_D9D4
; ---------------------------------------------------------------------------

loc_D9C8:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::next(icu_56::PluralMapBase::Category &)+53j
		jmp	short loc_D992
; ---------------------------------------------------------------------------

loc_D9CA:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::next(icu_56::PluralMapBase::Category &)+43j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		xor	eax, eax

loc_D9D4:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::next(icu_56::PluralMapBase::Category &)+6Aj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?next@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEPBVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D9E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix * __thiscall	icu_56::PluralMap<class	icu_56::DigitAffix>::nextMutable(enum  icu_56::PluralMapBase::Category &)
		public ?nextMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z
?nextMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?next@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEPBVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::next(icu_56::PluralMapBase::Category	&)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?nextMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@AAW4Category@PluralMapBase@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix const & __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::getOther(void)const
		public ?getOther@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@XZ
?getOther@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@XZ proc near
					; CODE XREF: icu_56::PluralAffix::getOtherVariant(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		mov	ecx, [ebp+var_8]
		call	?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@W4Category@PluralMapBase@2@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getOther@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix const & __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::get(enum  icu_56::PluralMapBase::Category)const
		public ?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@W4Category@PluralMapBase@2@@Z
?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@W4Category@PluralMapBase@2@@Z proc near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getOther(void)+28p
					; icu_56::PluralMap<icu_56::DigitAffix>::get(char const	*)+3Dp	...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jl	short loc_DAB5
		cmp	[ebp+var_14], 6
		jge	short loc_DAB5
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jnz	short loc_DAC0

loc_DAB5:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)+2Dj
					; icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)+33j
		mov	eax, [ebp+var_8]
		mov	eax, [eax+80h]
		jmp	short loc_DACD
; ---------------------------------------------------------------------------

loc_DAC0:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)+43j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+eax*4+80h]

loc_DACD:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)+4Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@W4Category@PluralMapBase@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DAD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix const & __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::get(char const *)const
		public ?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@PBD@Z
?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@PBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	dword ptr ds:__imp_?toCategory@PluralMapBase@icu_56@@SA?AW4Category@12@PBD@Z ; icu_56::PluralMapBase::toCategory(char const *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_8]
		call	?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@W4Category@PluralMapBase@2@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@PBD@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DB30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix const & __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::get(class icu_56::UnicodeString const &)const
		public ?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@ABVUnicodeString@2@@Z
?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@ABVUnicodeString@2@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	dword ptr ds:__imp_?toCategory@PluralMapBase@icu_56@@SA?AW4Category@12@ABVUnicodeString@2@@Z ; icu_56::PluralMapBase::toCategory(icu_56::UnicodeString const &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_8]
		call	?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@W4Category@PluralMapBase@2@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::PluralMapBase::Category)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?get@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBEABVDigitAffix@2@ABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DB88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix * __thiscall	icu_56::PluralMap<class	icu_56::DigitAffix>::getMutable(enum  icu_56::PluralMapBase::Category, enum  UErrorCode	&)
		public ?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@W4Category@PluralMapBase@2@AAW4UErrorCode@@@Z
?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@W4Category@PluralMapBase@2@AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		call	?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const *,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@W4Category@PluralMapBase@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DBD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::DigitAffix * __thiscall	icu_56::PluralMap<class	icu_56::DigitAffix>::getMutable(char const *, enum  UErrorCode &)
		public ?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@PBDAAW4UErrorCode@@@Z
?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@PBDAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; struct icu_56::DigitAffix *
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	dword ptr ds:__imp_?toCategory@PluralMapBase@icu_56@@SA?AW4Category@12@PBD@Z ; icu_56::PluralMapBase::toCategory(char const *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+var_8]
		call	?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const *,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@PBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DC34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::PluralMap<icu_56::DigitAffix>::getMutableWithDefault(int, struct icu_56::DigitAffix *, int)
		public ?getMutableWithDefault@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@W4Category@PluralMapBase@2@ABV32@AAW4UErrorCode@@@Z
?getMutableWithDefault@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@W4Category@PluralMapBase@2@ABV32@AAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct icu_56::DigitAffix *
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		call	?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z ; icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const *,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getMutableWithDefault@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QAEPAVDigitAffix@2@W4Category@PluralMapBase@2@ABV32@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DC84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::PluralMap<class icu_56::DigitAffix>::equals(class icu_56::PluralMap<class icu_56::DigitAffix> const &,	signed char (__cdecl *)(class icu_56::DigitAffix const &, class	icu_56::DigitAffix const &))const
		public ?equals@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBECABV12@P6ACABVDigitAffix@2@1@Z@Z
?equals@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBECABV12@P6ACABVDigitAffix@2@1@Z@Z proc near
					; CODE XREF: icu_56::PluralAffix::equals(icu_56::PluralAffix const &)+2Fp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_DCB9
; ---------------------------------------------------------------------------

loc_DCB0:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+57j
					; icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &)):loc_DD37j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_DCB9:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+2Aj
		cmp	[ebp+var_14], 6
		jge	short loc_DD3C
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+arg_0]
		mov	eax, [ecx+eax*4+80h]
		cmp	eax, [esi+edx*4+80h]
		jnz	short loc_DCDD
		jmp	short loc_DCB0
; ---------------------------------------------------------------------------

loc_DCDD:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+55j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jz	short loc_DCFD
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jnz	short loc_DD01

loc_DCFD:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+67j
		xor	al, al
		jmp	short loc_DD3E
; ---------------------------------------------------------------------------

loc_DD01:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+77j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+80h]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4+80h]
		push	edx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_DD37
		xor	al, al
		jmp	short loc_DD3E
; ---------------------------------------------------------------------------

loc_DD37:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+ADj
		jmp	loc_DCB0
; ---------------------------------------------------------------------------

loc_DD3C:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+39j
		mov	al, 1

loc_DD3E:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed	char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+7Bj
					; icu_56::PluralMap<icu_56::DigitAffix>::equals(icu_56::PluralMap<icu_56::DigitAffix> const &,signed char (*)(icu_56::DigitAffix const &,icu_56::DigitAffix const &))+B1j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equals@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@QBECABV12@P6ACABVDigitAffix@2@1@Z@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DD54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::PluralMap<icu_56::DigitAffix>::getMutable(int, struct icu_56::DigitAffix *, int)
		public ?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z
?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,UErrorCode &)+30p
					; icu_56::PluralMap<icu_56::DigitAffix>::getMutable(char const *,UErrorCode &)+43p ...

var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_DDB2
		xor	eax, eax
		jmp	loc_DEFF
; ---------------------------------------------------------------------------

loc_DDB2:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+55j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jl	short loc_DDC4
		cmp	[ebp+var_20], 6
		jl	short loc_DDD4

loc_DDC4:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+68j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_DEFF
; ---------------------------------------------------------------------------

loc_DDD4:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+6Ej
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jnz	loc_DED9
		cmp	[ebp+arg_4], 0
		jnz	short loc_DE59
		mov	esi, esp
		push	80h ; ''       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_DE2E
		mov	ecx, [ebp+var_104] ; this
		call	??0DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::DigitAffix(void)
		mov	[ebp+var_118], eax
		jmp	short loc_DE38
; ---------------------------------------------------------------------------

loc_DE2E:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+C5j
		mov	[ebp+var_118], 0

loc_DE38:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+D8j
		mov	eax, [ebp+var_118]
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_11C], ecx
		jmp	short loc_DEC6
; ---------------------------------------------------------------------------

loc_DE59:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+98j
		mov	esi, esp
		push	80h ; ''       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_DE9D
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::DigitAffix *
		mov	ecx, [ebp+var_EC] ; this
		call	??0DigitAffix@icu_56@@QAE@ABV01@@Z ; icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix const &)
		mov	[ebp+var_120], eax
		jmp	short loc_DEA7
; ---------------------------------------------------------------------------

loc_DE9D:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+130j
		mov	[ebp+var_120], 0

loc_DEA7:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+147j
		mov	eax, [ebp+var_120]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_F8]
		mov	[ebp+var_11C], ecx

loc_DEC6:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+103j
		mov	edx, [ebp+var_20]
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_11C]
		mov	[eax+edx*4+80h], ecx

loc_DED9:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+8Ej
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+eax*4+80h], 0
		jnz	short loc_DEF2
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_DEF2:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+193j
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	eax, [ecx+eax*4+80h]

loc_DEFF:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+59j
					; icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const *,UErrorCode &)+7Bj
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0DF20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000DF74o
		mov	esi, esp
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000DF7Co
		mov	esi, esp
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::getMutable(icu_56::PluralMapBase::Category,icu_56::DigitAffix const	*,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-124h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0DF70h
__unwindtable$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000DF88o
		dd offset __unwindfunclet$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?getMutable@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEPAVDigitAffix@2@W4Category@PluralMapBase@2@PBV32@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DFA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::PluralMap<class icu_56::DigitAffix>::initializeNew(void)
		public ?initializeNew@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEXXZ
?initializeNew@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(void)+54p
					; icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(icu_56::DigitAffix const	&)+58p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	[eax+80h], ecx
		mov	[ebp+var_14], 1
		jmp	short loc_DFE5
; ---------------------------------------------------------------------------

loc_DFDC:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::initializeNew(void)+58j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_DFE5:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::initializeNew(void)+36j
		cmp	[ebp+var_14], 6
		jge	short loc_DFFE
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	dword ptr [ecx+eax*4+80h], 0
		jmp	short loc_DFDC
; ---------------------------------------------------------------------------

loc_DFFE:				; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::initializeNew(void)+45j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?initializeNew@?$PluralMap@VDigitAffix@icu_56@@@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E008h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::DigitAffix::`scalar	deleting destructor'(unsigned int)
		public ??_GDigitAffix@icu_56@@QAEPAXI@Z
??_GDigitAffix@icu_56@@QAEPAXI@Z proc near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::operator=(icu_56::PluralMap<icu_56::DigitAffix> const &)+F3p
					; icu_56::PluralMap<icu_56::DigitAffix>::~PluralMap<icu_56::DigitAffix>(void)+91p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1DigitAffix@icu_56@@QAE@XZ ; icu_56::DigitAffix::~DigitAffix(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E051
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E051:				; CODE XREF: icu_56::DigitAffix::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDigitAffix@icu_56@@QAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E06Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::resize(int, int)
		public ?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z
?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	loc_E13C
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	loc_E135
		cmp	[ebp+arg_4], 0
		jge	short loc_E0C4
		mov	[ebp+arg_4], 0
		jmp	short loc_E0EC
; ---------------------------------------------------------------------------

loc_E0C4:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+4Dj
		cmp	[ebp+arg_4], 0
		jle	short loc_E0EC
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jle	short loc_E0DE
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_4], ecx

loc_E0DE:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+67j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jle	short loc_E0EC
		mov	eax, [ebp+arg_0]
		mov	[ebp+arg_4], eax

loc_E0EC:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+56j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+5Cj ...
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_4]
		add	edx, 0Ch
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	ecx, [ebp+var_8]
		call	?releaseMemory@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@AAEXXZ ; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_E135:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+43j
		mov	eax, [ebp+Dst]
		jmp	short loc_E13E
; ---------------------------------------------------------------------------
		jmp	short loc_E13E
; ---------------------------------------------------------------------------

loc_E13C:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+27j
		xor	eax, eax

loc_E13E:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+CCj
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+CEj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E154h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct decNumber * __thiscall	icu_56::MaybeStackHeaderAndArray<struct	decNumber, char, 40>::orphanOrClone(int, int &)
		public ?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z
?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_E18C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+Dst], ecx
		jmp	short loc_E1F4
; ---------------------------------------------------------------------------

loc_E18C:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+2Cj
		cmp	[ebp+arg_0], 0
		jge	short loc_E19B
		mov	[ebp+arg_0], 0
		jmp	short loc_E1AF
; ---------------------------------------------------------------------------

loc_E19B:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_E1AF
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_E1AF:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+45j
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+50j
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_E1CB
		xor	eax, eax
		jmp	short loc_E21B
; ---------------------------------------------------------------------------

loc_E1CB:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+71j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_0]
		add	edx, 0Ch
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_E1F4:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+36j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+Dst]

loc_E21B:				; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int	&)+75j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?orphanOrClone@?$MaybeStackHeaderAndArray@UdecNumber@@D$0CI@@icu_56@@QAEPAUdecNumber@@HAAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E234h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int, struct icu_56::UnicodeString *, struct icu_56::FieldPositionHandler *, enum UErrorCode *)
		public ??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z
??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+55p

var_1E4		= byte ptr -1E4h
var_1DD		= byte ptr -1DDh
var_1D1		= byte ptr -1D1h
var_108		= byte ptr -108h
var_90		= byte ptr -90h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1E4]
		mov	ecx, 76h ; 'v'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	ecx, [ebp+var_18]
		add	ecx, 8		; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jnz	loc_E314
		lea	ecx, [ebp+var_90] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		push	eax		; int
		lea	ecx, [ebp+var_90] ; this
		call	?set@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::set(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18]
		add	ecx, 8
		push	ecx		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_90] ; this
		call	?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+78h]
		push	ecx		; int
		lea	ecx, [ebp+var_90] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_90]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_1DD], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1DD]
		jmp	short loc_E38E
; ---------------------------------------------------------------------------

loc_E314:				; CODE XREF: icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+55j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+78h], 0
		jz	short loc_E38C
		lea	ecx, [ebp+var_108] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		push	eax		; int
		lea	ecx, [ebp+var_108] ; this
		call	?set@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::set(int)
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+78h]
		push	ecx		; int
		lea	ecx, [ebp+var_108] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::FieldPositionHandler *
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		lea	eax, [ebp+var_108]
		push	eax		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?formatAdjustedDigitList@DecimalFormatImpl@icu_56@@ABEAAVUnicodeString@2@AAVDigitList@2@AAV32@AAVFieldPositionHandler@2@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)
		mov	[ebp+var_1D1], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_108] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1D1]
		jmp	short loc_E38E
; ---------------------------------------------------------------------------

loc_E38C:				; CODE XREF: icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+E7j
		xor	al, al

loc_E38E:				; CODE XREF: icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+DEj
					; icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+156j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN11		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+15Eo
		dd offset $LN10_0
$LN10_0		dd 0FFFFFF70h, 70h	; DATA XREF: .text:0000E3D0o
		dd offset $LN7_17	; "digits"
		dd 0FFFFFEF8h, 70h
		dd offset $LN8_8	; "digits"
$LN8_8		db 'digits',0           ; DATA XREF: .text:0000E3E8o
$LN7_17		db 'digits',0           ; DATA XREF: .text:0000E3DCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0E3FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000E440o
		lea	ecx, [ebp-90h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000E448o
		lea	ecx, [ebp-108h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0E43Ch
__unwindtable$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000E454o
		dd offset __unwindfunclet$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??$maybeFormatWithDigitList@H@DecimalFormatImpl@icu_56@@ABECHAAVUnicodeString@1@AAVFieldPositionHandler@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E470h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64, struct	icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		public ??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+36p

var_1E4		= byte ptr -1E4h
var_1DD		= byte ptr -1DDh
var_1D1		= byte ptr -1D1h
var_108		= byte ptr -108h
var_90		= byte ptr -90h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1E4]
		mov	ecx, 76h ; 'v'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	ecx, [ebp+var_18]
		add	ecx, 8		; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jnz	loc_E550
		lea	ecx, [ebp+var_90] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 0
		mov	eax, dword ptr [ebp+arg_0+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_0]
		push	ecx		; __int64
		lea	ecx, [ebp+var_90] ; this
		call	?set@DigitList@icu_56@@QAEX_J@Z	; icu_56::DigitList::set(__int64)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18]
		add	ecx, 8
		push	ecx		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_90] ; this
		call	?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+78h]
		push	ecx		; int
		lea	ecx, [ebp+var_90] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		lea	edx, [ebp+var_90]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		mov	[ebp+var_1DD], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1DD]
		jmp	short loc_E5CA
; ---------------------------------------------------------------------------

loc_E550:				; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+55j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+78h], 0
		jz	short loc_E5C8
		lea	ecx, [ebp+var_108] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 1
		mov	eax, dword ptr [ebp+arg_0+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_0]
		push	ecx		; __int64
		lea	ecx, [ebp+var_108] ; this
		call	?set@DigitList@icu_56@@QAEX_J@Z	; icu_56::DigitList::set(__int64)
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+78h]
		push	ecx		; int
		lea	ecx, [ebp+var_108] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		lea	edx, [ebp+var_108]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		mov	[ebp+var_1D1], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_108] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1D1]
		jmp	short loc_E5CA
; ---------------------------------------------------------------------------

loc_E5C8:				; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+E7j
		xor	al, al

loc_E5CA:				; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+DEj
					; icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+156j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN11_0		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+15Eo
		dd offset $LN10_1
$LN10_1		dd 0FFFFFF70h, 70h	; DATA XREF: .text:0000E60Co
		dd offset $LN7_18	; "digits"
		dd 0FFFFFEF8h, 70h
		dd offset $LN8_9	; "digits"
$LN8_9		db 'digits',0           ; DATA XREF: .text:0000E624o
$LN7_18		db 'digits',0           ; DATA XREF: .text:0000E618o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0E638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000E67Co
		lea	ecx, [ebp-90h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000E684o
		lea	ecx, [ebp-108h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0E678h
__unwindtable$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000E690o
		dd offset __unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??$maybeInitVisibleDigitsFromDigitList@_J@DecimalFormatImpl@icu_56@@ABEC_JAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E6ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double, struct icu_56::VisibleDigitsWithExponent	*, enum	UErrorCode *)
		public ??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+37p

var_1FC		= qword	ptr -1FCh
var_1E4		= byte ptr -1E4h
var_1DD		= byte ptr -1DDh
var_1D1		= byte ptr -1D1h
var_108		= byte ptr -108h
var_90		= byte ptr -90h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1E4]
		mov	ecx, 76h ; 'v'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	ecx, [ebp+var_18]
		add	ecx, 8		; this
		call	?isZero@DigitList@icu_56@@QBECXZ ; icu_56::DigitList::isZero(void)
		movsx	eax, al
		test	eax, eax
		jnz	loc_E78D
		lea	ecx, [ebp+var_90] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 0
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+1FCh+var_1FC] ; double
		lea	ecx, [ebp+var_90] ; this
		call	?set@DigitList@icu_56@@QAEXN@Z ; icu_56::DigitList::set(double)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18]
		add	ecx, 8
		push	ecx		; struct icu_56::DigitList *
		lea	ecx, [ebp+var_90] ; this
		call	?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z ; icu_56::DigitList::mult(icu_56::DigitList const &,UErrorCode &)
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+78h]
		push	ecx		; int
		lea	ecx, [ebp+var_90] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		lea	edx, [ebp+var_90]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		mov	[ebp+var_1DD], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_90] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1DD]
		jmp	short loc_E808
; ---------------------------------------------------------------------------

loc_E78D:				; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+55j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+78h], 0
		jz	short loc_E806
		lea	ecx, [ebp+var_108] ; this
		call	??0DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::DigitList(void)
		mov	[ebp+var_4], 1
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+1FCh+var_1FC] ; double
		lea	ecx, [ebp+var_108] ; this
		call	?set@DigitList@icu_56@@QAEXN@Z ; icu_56::DigitList::set(double)
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+78h]
		push	ecx		; int
		lea	ecx, [ebp+var_108] ; this
		call	?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z ; icu_56::DigitList::shiftDecimalRight(int)
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::VisibleDigitsWithExponent *
		lea	edx, [ebp+var_108]
		push	edx		; struct icu_56::DigitList *
		mov	ecx, [ebp+var_18] ; this
		call	?initVisibleDigitsFromAdjusted@DecimalFormatImpl@icu_56@@ABEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z ; icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)
		mov	[ebp+var_1D1], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_108] ; this
		call	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
		mov	al, [ebp+var_1D1]
		jmp	short loc_E808
; ---------------------------------------------------------------------------

loc_E806:				; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+E8j
		xor	al, al

loc_E808:				; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+DFj
					; icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+158j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN11_1		dd 2			; DATA XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+160o
		dd offset $LN10_2
$LN10_2		dd 0FFFFFF70h, 70h	; DATA XREF: .text:0000E848o
		dd offset $LN7_19	; "digits"
		dd 0FFFFFEF8h, 70h
		dd offset $LN8_10	; "digits"
$LN8_10		db 'digits',0           ; DATA XREF: .text:0000E860o
$LN7_19		db 'digits',0           ; DATA XREF: .text:0000E854o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0E874h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000E8B8o
		lea	ecx, [ebp-90h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000E8C0o
		lea	ecx, [ebp-108h]	; this
		jmp	??1DigitList@icu_56@@QAE@XZ ; icu_56::DigitList::~DigitList(void)
__unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<double>(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0E8B4h
__unwindtable$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000E8CCo
		dd offset __unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??$maybeInitVisibleDigitsFromDigitList@N@DecimalFormatImpl@icu_56@@ABECNAAVVisibleDigitsWithExponent@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; public: signed char __thiscall icu_56::Formattable::operator==(class icu_56::Formattable const &)const
		extrn ??8Formattable@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+2Ap
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+42p
					; icu_56::Formattable::getString(icu_56::UnicodeString &)+37p ...
		extrn __fltused:near
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::Formattable::getString(icu_56::UnicodeString &)+2Fp
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+80p ...
; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this, enum UErrorCode *)
		extrn ?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Formattable::getLong(UErrorCode *)+2Ap
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(void)+28p
					; icu_56::FieldPosition::FieldPosition(int)+28p ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::FieldPosition `RTTI Type Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::FieldPosition::getDynamicClassID(void)const
		extrn ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000005FCo
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this, const struct icu_56::UObject *)
		extrn __imp_??0UObject@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition	const &)+2Cp
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+2Cp
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+39p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+81p ...
; _DWORD __thiscall icu_56::FieldPosition::~FieldPosition(icu_56::FieldPosition	*__hidden this)
		extrn ??1FieldPosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+26p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+53p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+53p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+3Dp
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+3Dp ...
; public: signed char __thiscall icu_56::FieldPositionIterator::operator==(class icu_56::FieldPositionIterator const &)const
		extrn ??8FieldPositionIterator@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator!=(icu_56::FieldPositionIterator const &)+2Ap
; __declspec(dllimport)	public:	class icu_56::UObject &	__thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		extrn __imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator=(icu_56::FieldPositionIterator const &)+2Cp
					; icu_56::NumberFormatFactory::operator=(icu_56::NumberFormatFactory const &)+2Cp ...
; public: virtual void * __thiscall icu_56::MeasureUnit::getDynamicClassID(void)const
		extrn ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000D7Co
; public: virtual class	icu_56::UObject	* __thiscall icu_56::MeasureUnit::clone(void)const
		extrn ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ:near
					; DATA XREF: .rdata:00000D80o
; public: virtual signed char __thiscall icu_56::MeasureUnit::operator==(class icu_56::UObject const &)const
		extrn ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z:near
					; DATA XREF: .rdata:00000D84o
; _DWORD __thiscall icu_56::MeasureUnit::~MeasureUnit(icu_56::MeasureUnit *__hidden this)
		extrn ??1MeasureUnit@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+26p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000010F0o
					; .rdata:00001420o ...
		extrn __purecall:near	; DATA XREF: .rdata:000010F4o
					; .rdata:000010F8o ...
; _DWORD __thiscall icu_56::NumberFormatFactory::~NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		extrn ??1NumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+26p
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)+6Ep ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+79p
					; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+59p ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+2Er
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+19j
					; __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+23j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+Fp
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+1A1p ...
; public: virtual signed char __thiscall icu_56::SimpleNumberFormatFactory::visible(void)const
		extrn ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001424o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::SimpleNumberFormatFactory::getSupportedIDs(int	&, enum	 UErrorCode &)const
		extrn ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00001428o
; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *__hidden this)
		extrn ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+26p
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator==(class	icu_56::DecimalFormatSymbols const &)const
		extrn ??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+2Ap
					; icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const	&)+2A6p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+17Cp
					; __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0+8p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString &&)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160r
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@H@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120r
		extrn _u_charDigitValue_56:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+E0p
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCr
; int __thiscall icu_56::UnicodeString::countChar32(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFp
					; icu_56::DigitAffix::countChar32(void)+2Fp ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	struct icu_56::Locale *)
		extrn __imp_??0Locale@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Bp
					; DATA XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Br
; public: signed char __thiscall icu_56::DigitList::operator==(class icu_56::DigitList const &)const
		extrn ??8DigitList@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DigitList::operator!=(icu_56::DigitList const &)+2Ap
					; icu_56::FixedPrecision::equals(icu_56::FixedPrecision	const &)+79p ...
		extrn _uprv_decNumberZero_56:near
					; CODE XREF: icu_56::DigitList::setToZero(void)+2Ap
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DigitAffix::equals(icu_56::DigitAffix const &)+2Cp
					; icu_56::DigitAffix::equals(icu_56::DigitAffix	const &)+4Fp ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::AffixPattern::AffixPattern(void)+47p
					; icu_56::AffixPattern::AffixPattern(void)+63p	...
; struct icu_56::UnicodeString *__thiscall icu_56::DigitAffix::format(icu_56::DigitAffix *__hidden this, struct	icu_56::FieldPositionHandler *,	struct icu_56::UnicodeString *)
		extrn ?format@DigitAffix@icu_56@@QBEAAVUnicodeString@2@AAVFieldPositionHandler@2@AAV32@@Z:near
					; CODE XREF: icu_56::DigitFormatter::formatNaN(icu_56::FieldPositionHandler &,icu_56::UnicodeString &)+34p
					; icu_56::DigitFormatter::formatInfinity(icu_56::FieldPositionHandler &,icu_56::UnicodeString &)+34p
; _DWORD __thiscall icu_56::DigitList::~DigitList(icu_56::DigitList *__hidden this)
		extrn ??1DigitList@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FixedPrecision::~FixedPrecision(void)+29p
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$1+6j ...
; _DWORD __thiscall icu_56::DigitList::DigitList(icu_56::DigitList *__hidden this, const struct	icu_56::DigitList *)
		extrn ??0DigitList@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::FixedPrecision::FixedPrecision(icu_56::FixedPrecision const &)+64p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl	const &,UErrorCode &)+7Ap ...
; public: class	icu_56::DigitList & __thiscall icu_56::DigitList::operator=(class icu_56::DigitList const &)
		extrn ??4DigitList@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::FixedPrecision::operator=(icu_56::FixedPrecision const &)+64p
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+8Ap ...
; public: virtual void __thiscall icu_56::FieldPositionHandler::addAttribute(int, int, int)
		extrn ?addAttribute@FieldPositionHandler@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00004DB4o
; public: virtual void __thiscall icu_56::FieldPositionHandler::shiftLast(int)
		extrn ?shiftLast@FieldPositionHandler@icu_56@@UAEXH@Z:near
					; DATA XREF: .rdata:00004DB8o
; public: virtual signed char __thiscall icu_56::FieldPositionHandler::isRecording(void)const
		extrn ?isRecording@FieldPositionHandler@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00004DBCo
; _DWORD __thiscall icu_56::FieldPositionHandler::~FieldPositionHandler(icu_56::FieldPositionHandler *__hidden this)
		extrn ??1FieldPositionHandler@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FieldPositionHandler::`scalar deleting destructor'(uint)+26p
					; icu_56::FieldPositionHandler::`vector	deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration *__hidden this, const struct	icu_56::StringEnumeration *)
		extrn __imp_??0StringEnumeration@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration const &)+2Cp
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration const &)+2Cr
; public: virtual class	icu_56::StringEnumeration * __thiscall icu_56::StringEnumeration::clone(void)const
		extrn ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00005098o
; public: virtual int __thiscall icu_56::PluralAvailableLocalesEnumeration::count(enum	UErrorCode &)const
		extrn ?count@PluralAvailableLocalesEnumeration@icu_56@@UBEHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000509Co
; public: virtual char const * __thiscall icu_56::PluralAvailableLocalesEnumeration::next(int *, enum  UErrorCode &)
		extrn ?next@PluralAvailableLocalesEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000050A0o
; public: virtual wchar_t const	* __thiscall icu_56::StringEnumeration::unext(int *, enum  UErrorCode &)
		extrn ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000050A4o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::StringEnumeration::snext(enum	UErrorCode &)
		extrn ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000050A8o
; public: virtual void __thiscall icu_56::PluralAvailableLocalesEnumeration::reset(enum	 UErrorCode &)
		extrn ?reset@PluralAvailableLocalesEnumeration@icu_56@@UAEXAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000050ACo
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator==(class icu_56::StringEnumeration const &)const
		extrn ??8StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:000050B0o
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator!=(class icu_56::StringEnumeration const &)const
		extrn ??9StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:000050B4o
; __declspec(dllimport)	public:	class icu_56::StringEnumeration	& __thiscall icu_56::StringEnumeration::operator=(class	icu_56::StringEnumeration const	&)
		extrn __imp_??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::operator=(icu_56::PluralAvailableLocalesEnumeration const &)+2Cp
					; DATA XREF: icu_56::PluralAvailableLocalesEnumeration::operator=(icu_56::PluralAvailableLocalesEnumeration const &)+2Cr
; _DWORD __thiscall icu_56::PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration(icu_56::PluralAvailableLocalesEnumeration *__hidden this)
		extrn ??1PluralAvailableLocalesEnumeration@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::PluralAvailableLocalesEnumeration::`scalar	deleting destructor'(uint)+26p
					; icu_56::PluralAvailableLocalesEnumeration::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; _DWORD __thiscall icu_56::ValueFormatter::~ValueFormatter(icu_56::ValueFormatter *__hidden this)
		extrn ??1ValueFormatter@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ValueFormatter::`scalar deleting destructor'(uint)+26p
					; icu_56::ValueFormatter::`vector deleting destructor'(uint)+6Ep ...
; _DWORD __thiscall icu_56::CharString::~CharString(icu_56::CharString *__hidden this)
		extrn __imp_??1CharString@icu_56@@QAE@XZ:near
					; CODE XREF: __unwindfunclet$??0VisibleDigits@icu_56@@QAE@XZ$0+5p
					; icu_56::VisibleDigits::~VisibleDigits(void)+28p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this)
		extrn __imp_??0CharString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::VisibleDigits::VisibleDigits(void)+47p
					; DATA XREF: icu_56::VisibleDigits::VisibleDigits(void)+47r
; void __thiscall icu_56::VisibleDigits::clear(icu_56::VisibleDigits *__hidden this)
		extrn ?clear@VisibleDigits@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::clear(void)+26p
					; icu_56::VisibleDigitsWithExponent::clear(void)+31p
; signed __int8	__thiscall icu_56::VisibleDigits::isNegative(icu_56::VisibleDigits *__hidden this)
		extrn ?isNegative@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::isNegative(void)+26p
					; icu_56::initFixedDecimal(icu_56::VisibleDigits const &,icu_56::FixedDecimal &)+28p
; signed __int8	__thiscall icu_56::VisibleDigits::isNaN(icu_56::VisibleDigits *__hidden	this)
		extrn ?isNaN@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::isNaN(void)+26p
; signed __int8	__thiscall icu_56::VisibleDigits::isInfinite(icu_56::VisibleDigits *__hidden this)
		extrn ?isInfinite@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::VisibleDigitsWithExponent::isInfinite(void)+26p
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn __imp_??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVLocale@1@ABVUnicodeString@1@AAW4UErrorCode@@@Z$0+5p
					; __unwindfunclet$??0DecimalFormatImpl@icu_56@@QAE@PAVNumberFormat@1@ABVUnicodeString@1@PAVDecimalFormatSymbols@1@AAUUParseError@@AAW4UErrorCode@@@Z$0+5p ...
; _DWORD __thiscall icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::DecimalFormatSymbols *__hidden this, const struct icu_56::Locale	*, enum	UErrorCode *)
		extrn ??0DecimalFormatSymbols@icu_56@@QAE@ABVLocale@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+1E2p
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+1B1p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl	const &,UErrorCode &)+276p ...
; _DWORD __thiscall icu_56::DigitFormatter::DigitFormatter(icu_56::DigitFormatter *__hidden this)
		extrn ??0DigitFormatter@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+175p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+171p
; _DWORD __thiscall icu_56::ScientificPrecision::ScientificPrecision(icu_56::ScientificPrecision *__hidden this)
		extrn ??0ScientificPrecision@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+147p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+143p
; _DWORD __thiscall icu_56::CurrencyAffixInfo::CurrencyAffixInfo(icu_56::CurrencyAffixInfo *__hidden this)
		extrn ??0CurrencyAffixInfo@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+135p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+131p
; _DWORD __thiscall icu_56::AffixPatternParser::AffixPatternParser(icu_56::AffixPatternParser *__hidden	this)
		extrn ??0AffixPatternParser@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+123p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+11Fp
; _DWORD __thiscall icu_56::DigitList::DigitList(icu_56::DigitList *__hidden this)
		extrn ??0DigitList@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+76p
					; icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::UnicodeString const &,icu_56::DecimalFormatSymbols *,UParseError &,UErrorCode &)+73p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::Locale	const &,icu_56::UnicodeString const &,UErrorCode &)+265p
					; icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+92p ...
; public: virtual void * __thiscall icu_56::DecimalFormatImpl::`scalar deleting	destructor'(unsigned int)
		extrn ??_GDecimalFormatImpl@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::DecimalFormatImpl::`vector deleting	destructor'(unsigned int)
		extrn ??_EDecimalFormatImpl@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::DecimalFormatImpl::`vftable'o
; _DWORD __thiscall icu_56::PluralRules::PluralRules(icu_56::PluralRules *__hidden this, const struct icu_56::PluralRules *)
		extrn ??0PluralRules@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+350p
					; icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+334p
; _DWORD __thiscall icu_56::DecimalFormatSymbols::DecimalFormatSymbols(icu_56::DecimalFormatSymbols *__hidden this, const struct icu_56::DecimalFormatSymbols *)
		extrn ??0DecimalFormatSymbols@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::DecimalFormatImpl(icu_56::NumberFormat *,icu_56::DecimalFormatImpl const &,UErrorCode &)+2A9p
; public: class	icu_56::PluralRules & __thiscall icu_56::PluralRules::operator=(class icu_56::PluralRules const	&)
		extrn ??4PluralRules@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+27Bp
; public: class	icu_56::DecimalFormatSymbols & __thiscall icu_56::DecimalFormatSymbols::operator=(class	icu_56::DecimalFormatSymbols const &)
		extrn ??4DecimalFormatSymbols@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::assign(icu_56::DecimalFormatImpl const &,UErrorCode &)+24Bp
; signed __int8	__thiscall icu_56::DigitFormatter::equals(icu_56::DigitFormatter *__hidden this, const struct icu_56::DigitFormatter *)
		extrn ?equals@DigitFormatter@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::operator==(icu_56::DecimalFormatImpl const &)+260p
; void __thiscall icu_56::ValueFormatter::prepareFixedDecimalFormatting(icu_56::ValueFormatter *__hidden this, const struct icu_56::DigitFormatter *, const struct icu_56::DigitGrouping *, const struct icu_56::FixedPrecision	*, const struct	icu_56::DigitFormatterOptions *)
		extrn ?prepareFixedDecimalFormatting@ValueFormatter@icu_56@@QAEXABVDigitFormatter@2@ABVDigitGrouping@2@ABVFixedPrecision@2@ABVDigitFormatterOptions@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)+84p
; void __thiscall icu_56::ValueFormatter::prepareScientificFormatting(icu_56::ValueFormatter *__hidden this, const struct icu_56::DigitFormatter *, const struct icu_56::ScientificPrecision *,	const struct icu_56::SciFormatterOptions *)
		extrn ?prepareScientificFormatting@ValueFormatter@icu_56@@QAEXABVDigitFormatter@2@ABVScientificPrecision@2@ABVSciFormatterOptions@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::prepareValueFormatter(icu_56::ValueFormatter &)+51p
; void __thiscall icu_56::DigitList::shiftDecimalRight(icu_56::DigitList *__hidden this, int)
		extrn ?shiftDecimalRight@DigitList@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::setMultiplierScale(int)+4Fp
					; icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+6Ap ...
; void __thiscall icu_56::DigitList::set(icu_56::DigitList *__hidden this, int)
		extrn ?set@DigitList@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::setMultiplierScale(int)+31p
					; icu_56::DecimalFormatImpl::setMultiplierScale(int)+40p ...
; _DWORD __thiscall icu_56::FieldPositionOnlyHandler::~FieldPositionOnlyHandler(icu_56::FieldPositionOnlyHandler *__hidden this)
		extrn ??1FieldPositionOnlyHandler@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+7Dp
					; __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@AAVFieldPosition@2@AAW4UErrorCode@@@Z$0+3j ...
; _DWORD __thiscall icu_56::FieldPositionOnlyHandler::FieldPositionOnlyHandler(icu_56::FieldPositionOnlyHandler	*__hidden this,	struct icu_56::FieldPosition *)
		extrn ??0FieldPositionOnlyHandler@icu_56@@QAE@AAVFieldPosition@1@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+49p
					; icu_56::DecimalFormatImpl::format(double,icu_56::UnicodeString &,icu_56::FieldPosition &,UErrorCode &)+49p ...
; _DWORD __thiscall icu_56::FieldPositionIteratorHandler::~FieldPositionIteratorHandler(icu_56::FieldPositionIteratorHandler *__hidden this)
		extrn ??1FieldPositionIteratorHandler@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+81p
					; __unwindfunclet$?format@DecimalFormatImpl@icu_56@@QBEAAVUnicodeString@2@HAAV32@PAVFieldPositionIterator@2@AAW4UErrorCode@@@Z$0+3j ...
; _DWORD __thiscall icu_56::FieldPositionIteratorHandler::FieldPositionIteratorHandler(icu_56::FieldPositionIteratorHandler *__hidden this, struct icu_56::FieldPositionIterator *, enum UErrorCode *)
		extrn ??0FieldPositionIteratorHandler@icu_56@@QAE@PAVFieldPositionIterator@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::format(int,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+4Dp
					; icu_56::DecimalFormatImpl::format(__int64,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+4Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::DigitAffixesAndPadding::formatInt32(icu_56::DigitAffixesAndPadding *__hidden	this, int, const struct	icu_56::ValueFormatter *, struct icu_56::FieldPositionHandler *, const struct icu_56::PluralRules *, struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ?formatInt32@DigitAffixesAndPadding@icu_56@@QBEAAVUnicodeString@2@HABVValueFormatter@2@AAVFieldPositionHandler@2@PBVPluralRules@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::formatInt32(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+A5p
; void __thiscall icu_56::DigitList::set(icu_56::DigitList *__hidden this, const struct	icu_56::StringPiece *, enum UErrorCode *, unsigned int)
		extrn ?set@DigitList@icu_56@@QAEXABVStringPiece@2@AAW4UErrorCode@@I@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::format(icu_56::StringPiece const &,icu_56::UnicodeString &,icu_56::FieldPositionIterator *,UErrorCode &)+67p
; void __thiscall icu_56::DigitList::reduce(icu_56::DigitList *__hidden	this)
		extrn ?reduce@DigitList@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+72p
; void __thiscall icu_56::DigitList::mult(icu_56::DigitList *__hidden this, const struct icu_56::DigitList *, enum UErrorCode *)
		extrn ?mult@DigitList@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+52p
					; icu_56::DecimalFormatImpl::maybeFormatWithDigitList<int>(int,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+8Dp ...
; signed __int8	__thiscall icu_56::DigitList::isZero(icu_56::DigitList *__hidden this)
		extrn ?isZero@DigitList@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+38p
					; icu_56::DecimalFormatImpl::getMultiplier(void)+29p ...
; void __thiscall __high icu_56::DigitList::setRoundingMode(enum icu_56::DecimalFormat::ERoundingMode)
		extrn ?setRoundingMode@DigitList@icu_56@@QAEXW4ERoundingMode@DecimalFormat@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::adjustDigitList(icu_56::DigitList &,UErrorCode &)+2Dp
; struct icu_56::UnicodeString *__thiscall icu_56::DigitAffixesAndPadding::format(icu_56::DigitAffixesAndPadding *__hidden this, struct	icu_56::DigitList *, const struct icu_56::ValueFormatter *, struct icu_56::FieldPositionHandler	*, const struct	icu_56::PluralRules *, struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ?format@DigitAffixesAndPadding@icu_56@@QBEAAVUnicodeString@2@AAVDigitList@2@ABVValueFormatter@2@AAVFieldPositionHandler@2@PBVPluralRules@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::formatAdjustedDigitList(icu_56::DigitList &,icu_56::UnicodeString &,icu_56::FieldPositionHandler &,UErrorCode &)+81p
; struct icu_56::UnicodeString *__thiscall icu_56::DigitAffixesAndPadding::format(icu_56::DigitAffixesAndPadding *__hidden this, const struct icu_56::VisibleDigitsWithExponent	*, const struct	icu_56::ValueFormatter *, struct icu_56::FieldPositionHandler *, const struct icu_56::PluralRules *, struct icu_56::UnicodeString *, enum UErrorCode *)
		extrn ?format@DigitAffixesAndPadding@icu_56@@QBEAAVUnicodeString@2@ABVVisibleDigitsWithExponent@2@ABVValueFormatter@2@AAVFieldPositionHandler@2@PBVPluralRules@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::formatVisibleDigitsWithExponent(icu_56::VisibleDigitsWithExponent const	&,icu_56::UnicodeString	&,icu_56::FieldPositionHandler &,UErrorCode &)+81p
; struct icu_56::VisibleDigits *__thiscall icu_56::FixedPrecision::initVisibleDigits(icu_56::FixedPrecision *__hidden this, double, struct icu_56::VisibleDigits *, enum UErrorCode *)
		extrn ?initVisibleDigits@FixedPrecision@icu_56@@QBEAAVVisibleDigits@2@NAAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(double,icu_56::FixedDecimal &,UErrorCode &)+8Ep
; void __thiscall icu_56::VisibleDigits::getFixedDecimal(icu_56::VisibleDigits *__hidden this, double *, __int64 *, __int64 *, __int64 *, int *, signed	__int8 *)
		extrn ?getFixedDecimal@VisibleDigits@icu_56@@QBEXAANAA_J11AAHAAC@Z:near
					; CODE XREF: icu_56::initFixedDecimal(icu_56::VisibleDigits const &,icu_56::FixedDecimal &)+6Bp
; signed __int8	__thiscall icu_56::VisibleDigits::isNaNOrInfinity(icu_56::VisibleDigits	*__hidden this)
		extrn ?isNaNOrInfinity@VisibleDigits@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::initFixedDecimal(icu_56::VisibleDigits const &,icu_56::FixedDecimal &)+36p
; struct icu_56::VisibleDigits *__thiscall icu_56::FixedPrecision::initVisibleDigits(icu_56::FixedPrecision *__hidden this, struct icu_56::DigitList *,	struct icu_56::VisibleDigits *,	enum UErrorCode	*)
		extrn ?initVisibleDigits@FixedPrecision@icu_56@@QBEAAVVisibleDigits@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::getFixedDecimal(icu_56::DigitList &,icu_56::FixedDecimal &,UErrorCode &)+89p
; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::FixedPrecision::initVisibleDigitsWithExponent(icu_56::FixedPrecision *__hidden this, __int64, struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		extrn ?initVisibleDigitsWithExponent@FixedPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+8Ep
; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::ScientificPrecision::initVisibleDigitsWithExponent(icu_56::ScientificPrecision *__hidden	this, __int64, struct icu_56::VisibleDigitsWithExponent	*, enum	UErrorCode *)
		extrn ?initVisibleDigitsWithExponent@ScientificPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@_JAAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(__int64,icu_56::VisibleDigitsWithExponent	&,UErrorCode &)+6Ep
; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::FixedPrecision::initVisibleDigitsWithExponent(icu_56::FixedPrecision *__hidden this, double, struct icu_56::VisibleDigitsWithExponent *,	enum UErrorCode	*)
		extrn ?initVisibleDigitsWithExponent@FixedPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+91p
; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::ScientificPrecision::initVisibleDigitsWithExponent(icu_56::ScientificPrecision *__hidden	this, double, struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		extrn ?initVisibleDigitsWithExponent@ScientificPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@NAAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsWithExponent(double,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+70p
; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::FixedPrecision::initVisibleDigitsWithExponent(icu_56::FixedPrecision *__hidden this, struct icu_56::DigitList *,	struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		extrn ?initVisibleDigitsWithExponent@FixedPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+62p
; struct icu_56::VisibleDigitsWithExponent *__thiscall icu_56::ScientificPrecision::initVisibleDigitsWithExponent(icu_56::ScientificPrecision *__hidden	this, struct icu_56::DigitList *, struct icu_56::VisibleDigitsWithExponent *, enum UErrorCode *)
		extrn ?initVisibleDigitsWithExponent@ScientificPrecision@icu_56@@QBEAAVVisibleDigitsWithExponent@2@AAVDigitList@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::initVisibleDigitsFromAdjusted(icu_56::DigitList	&,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+46p
; struct icu_56::DigitList *__thiscall icu_56::ValueFormatter::round(icu_56::ValueFormatter *__hidden this, struct icu_56::DigitList *,	enum UErrorCode	*)
		extrn ?round@ValueFormatter@icu_56@@QBEAAVDigitList@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::round(icu_56::DigitList	&,UErrorCode &)+9Bp
; void __thiscall icu_56::DigitList::set(icu_56::DigitList *__hidden this, double)
		extrn ?set@DigitList@icu_56@@QAEXN@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::setRoundingIncrement(double)+41p
					; icu_56::DecimalFormatImpl::setRoundingIncrement(double)+59p ...
; double __thiscall icu_56::DigitList::getDouble(icu_56::DigitList *__hidden this)
		extrn ?getDouble@DigitList@icu_56@@QBENXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::getRoundingIncrement(void)+2Cp
					; icu_56::DecimalFormatImpl::getMultiplier(void)+42p
		extrn __ftol2_sse:near	; CODE XREF: icu_56::DecimalFormatImpl::getMultiplier(void)+47p
; void __thiscall icu_56::AffixPattern::addLiteral(icu_56::AffixPattern	*__hidden this,	const wchar_t *, int, int)
		extrn ?addLiteral@AffixPattern@icu_56@@QAEXPB_WHH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::UnicodeString	const &)+62p
					; icu_56::DecimalFormatImpl::setPositiveSuffix(icu_56::UnicodeString const &)+62p ...
; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		extrn __imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::UnicodeString	const &)+4Bp
					; icu_56::DecimalFormatImpl::setPositiveSuffix(icu_56::UnicodeString const &)+4Bp ...
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::UnicodeString	const &)+36p
					; icu_56::DecimalFormatImpl::setPositiveSuffix(icu_56::UnicodeString const &)+36p ...
; void __thiscall icu_56::AffixPattern::remove(icu_56::AffixPattern *__hidden this)
		extrn ?remove@AffixPattern@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::setPositivePrefix(icu_56::UnicodeString	const &)+2Cp
					; icu_56::DecimalFormatImpl::setPositiveSuffix(icu_56::UnicodeString const &)+2Cp ...
; void __thiscall icu_56::DigitList::clear(icu_56::DigitList *__hidden this)
		extrn ?clear@DigitList@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+203p
; void __thiscall icu_56::NumberFormat::setGroupingUsed(icu_56::NumberFormat *__hidden this, signed __int8)
		extrn ?setGroupingUsed@NumberFormat@icu_56@@UAEXC@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+1A6p
; void __thiscall icu_56::NumberFormat::setMaximumFractionDigits(icu_56::NumberFormat *__hidden	this, int)
		extrn ?setMaximumFractionDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+157p
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+373p
; void __thiscall icu_56::NumberFormat::setMinimumFractionDigits(icu_56::NumberFormat *__hidden	this, int)
		extrn ?setMinimumFractionDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+145p
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+35Cp
; void __thiscall icu_56::NumberFormat::setMaximumIntegerDigits(icu_56::NumberFormat *__hidden this, int)
		extrn ?setMaximumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+133p
; void __thiscall icu_56::NumberFormat::setMinimumIntegerDigits(icu_56::NumberFormat *__hidden this, int)
		extrn ?setMinimumIntegerDigits@NumberFormat@icu_56@@UAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+121p
; void __thiscall icu_56::DecimalFormatPatternParser::applyPatternWithoutExpandAffix(icu_56::DecimalFormatPatternParser	*__hidden this,	const struct icu_56::UnicodeString *, struct icu_56::DecimalFormatPattern *, struct UParseError	*, enum	UErrorCode *)
		extrn ?applyPatternWithoutExpandAffix@DecimalFormatPatternParser@icu_56@@QAEXABVUnicodeString@2@AAUDecimalFormatPattern@2@AAUUParseError@@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+B6p
; _DWORD __thiscall icu_56::DecimalFormatPattern::DecimalFormatPattern(icu_56::DecimalFormatPattern *__hidden this)
		extrn ??0DecimalFormatPattern@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+94p
; void __thiscall icu_56::DecimalFormatPatternParser::useSymbols(icu_56::DecimalFormatPatternParser *__hidden this, const struct icu_56::DecimalFormatSymbols *)
		extrn ?useSymbols@DecimalFormatPatternParser@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+89p
; _DWORD __thiscall icu_56::DecimalFormatPatternParser::DecimalFormatPatternParser(icu_56::DecimalFormatPatternParser *__hidden	this)
		extrn ??0DecimalFormatPatternParser@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::applyPattern(icu_56::UnicodeString const &,signed char,UParseError &,UErrorCode	&)+65p
; void __thiscall icu_56::DigitInterval::setIntDigitCount(icu_56::DigitInterval	*__hidden this,	int)
		extrn ?setIntDigitCount@DigitInterval@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+51p
					; icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+65p ...
; void __thiscall icu_56::DigitInterval::setFracDigitCount(icu_56::DigitInterval *__hidden this, int)
		extrn ?setFracDigitCount@DigitInterval@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+44p
					; icu_56::DecimalFormatImpl::updatePrecisionForScientific(void)+5Bp ...
; int __thiscall icu_56::NumberFormat::getMaximumFractionDigits(icu_56::NumberFormat *__hidden this)
		extrn ?getMaximumFractionDigits@NumberFormat@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)+65p
; int __thiscall icu_56::NumberFormat::getMinimumFractionDigits(icu_56::NumberFormat *__hidden this)
		extrn ?getMinimumFractionDigits@NumberFormat@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)+51p
; int __thiscall icu_56::NumberFormat::getMaximumIntegerDigits(icu_56::NumberFormat *__hidden this)
		extrn ?getMaximumIntegerDigits@NumberFormat@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)+3Dp
; int __thiscall icu_56::NumberFormat::getMinimumIntegerDigits(icu_56::NumberFormat *__hidden this)
		extrn ?getMinimumIntegerDigits@NumberFormat@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::extractMinMaxDigits(icu_56::DigitInterval &,icu_56::DigitInterval &)+29p
; void __thiscall icu_56::DigitGrouping::clear(icu_56::DigitGrouping *__hidden this)
		extrn ?clear@DigitGrouping@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateGrouping(void)+61p
; signed __int8	__thiscall icu_56::NumberFormat::isGroupingUsed(icu_56::NumberFormat *__hidden this)
		extrn ?isGroupingUsed@NumberFormat@icu_56@@QBECXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateGrouping(void)+29p
; _DWORD __thiscall icu_56::Locale::~Locale(icu_56::Locale *__hidden this)
		extrn __imp_??1Locale@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+D6p
					; __unwindfunclet$?updateFormattingPluralRules@DecimalFormatImpl@icu_56@@AAEXAAHAAW4UErrorCode@@@Z$0+8p ...
; struct icu_56::PluralRules *__cdecl static icu_56::PluralRules::forLocale(const struct icu_56::Locale	*, enum	UErrorCode *)
		extrn ?forLocale@PluralRules@icu_56@@SAPAV12@ABVLocale@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingPluralRules(int	&,UErrorCode &)+BCp
; void __cdecl __high static icu_56::CurrencyAffixInfo::adjustPrecision(const wchar_t *, enum UCurrencyUsage, struct icu_56::FixedPrecision *, enum UErrorCode *)
		extrn ?adjustPrecision@CurrencyAffixInfo@icu_56@@SAXPB_WW4UCurrencyUsage@@AAVFixedPrecision@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+319p
; _DWORD __thiscall icu_56::FixedPrecision::FixedPrecision(icu_56::FixedPrecision *__hidden this)
		extrn ??0FixedPrecision@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+2F4p
; void __thiscall icu_56::NumberFormat::setCurrency(icu_56::NumberFormat *__hidden this, const wchar_t *, enum UErrorCode *)
		extrn ?setCurrency@NumberFormat@icu_56@@UAEXPB_WAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+197p
		extrn _ucurr_forLocale_56:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+14Ap
; const	char *__thiscall icu_56::Locale::getName(icu_56::Locale	*__hidden this)
		extrn __imp_?getName@Locale@icu_56@@QBEPBDXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+13Cp
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+1F6p
					; DATA XREF: ...
; const	wchar_t	*__thiscall icu_56::NumberFormat::getCurrency(icu_56::NumberFormat *__hidden this)
		extrn ?getCurrency@NumberFormat@icu_56@@QBEPB_WXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+E6p
; void __thiscall icu_56::CurrencyAffixInfo::set(icu_56::CurrencyAffixInfo *__hidden this, const char *, const struct icu_56::PluralRules *, const wchar_t *, enum UErrorCode *)
		extrn ?set@CurrencyAffixInfo@icu_56@@QAEXPBDPBVPluralRules@2@PB_WAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+ACp
					; icu_56::DecimalFormatImpl::updateFormattingCurrencyAffixInfo(int &,signed char,UErrorCode &)+20Dp
; void __thiscall icu_56::DigitFormatter::setDecimalFormatSymbols(icu_56::DigitFormatter *__hidden this, const struct icu_56::DecimalFormatSymbols *)
		extrn ?setDecimalFormatSymbols@DigitFormatter@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int	&)+6Ap
; void __thiscall icu_56::DigitFormatter::setDecimalFormatSymbolsForMonetary(icu_56::DigitFormatter *__hidden this, const struct icu_56::DecimalFormatSymbols *)
		extrn ?setDecimalFormatSymbolsForMonetary@DigitFormatter@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingFixedPointFormatter(int	&)+50p
; void __thiscall icu_56::AffixPatternParser::setDecimalFormatSymbols(icu_56::AffixPatternParser *__hidden this, const struct icu_56::DecimalFormatSymbols *)
		extrn ?setDecimalFormatSymbols@AffixPatternParser@icu_56@@QAEXABVDecimalFormatSymbols@2@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingAffixParser(int	&)+42p
; struct icu_56::PluralAffix *__thiscall icu_56::AffixPatternParser::parse(icu_56::AffixPatternParser *__hidden	this, const struct icu_56::AffixPattern	*, const struct	icu_56::CurrencyAffixInfo *, struct icu_56::PluralAffix	*, enum	UErrorCode *)
		extrn ?parse@AffixPatternParser@icu_56@@QBEAAVPluralAffix@2@ABVAffixPattern@2@ABVCurrencyAffixInfo@2@AAV32@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)+81p
					; icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)+81p ...
; void __thiscall icu_56::PluralAffix::remove(icu_56::PluralAffix *__hidden this)
		extrn ?remove@PluralAffix@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::updateFormattingLocalizedPositivePrefix(int &,UErrorCode &)+52p
					; icu_56::DecimalFormatImpl::updateFormattingLocalizedPositiveSuffix(int &,UErrorCode &)+52p ...
; signed __int8	__thiscall icu_56::DigitGrouping::isSeparatorAt(icu_56::DigitGrouping *__hidden	this, int, int)
		extrn ?isSeparatorAt@DigitGrouping@icu_56@@QBECHH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+45Bp
					; icu_56::getLeftDigitsForLeftLength(icu_56::DigitGrouping const &,int,int,int &)+56p
; signed __int8	__thiscall icu_56::DigitInterval::contains(icu_56::DigitInterval *__hidden this, int)
		extrn ?contains@DigitInterval@icu_56@@QBECH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+411p
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+3F8p
					; icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString &)+9Fp
					; DATA XREF: ...
; unsigned __int8 __thiscall icu_56::DigitList::getDigitByExponent(icu_56::DigitList *__hidden this, int)
		extrn ?getDigitByExponent@DigitList@icu_56@@QBEEH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+3E7p
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, wchar_t)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+28Dp
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+318p ...
; void __thiscall icu_56::DigitInterval::expandToContainDigit(icu_56::DigitInterval *__hidden this, int)
		extrn ?expandToContainDigit@DigitInterval@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+1AAp
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+1B9p ...
; int __thiscall icu_56::DigitList::getUpperExponent(icu_56::DigitList *__hidden this)
		extrn ?getUpperExponent@DigitList@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+19Bp
; void __thiscall icu_56::DigitInterval::shrinkToFitWithin(icu_56::DigitInterval *__hidden this, const struct icu_56::DigitInterval *)
		extrn ?shrinkToFitWithin@DigitInterval@icu_56@@QAEXABV12@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+136p
		extrn __RTC_UninitUse:near
					; CODE XREF: icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+E1p
					; icu_56::DecimalFormatImpl::toNumberPattern(signed char,int,icu_56::UnicodeString &)+345p ...
; int __thiscall icu_56::DigitGrouping::getSeparatorCount(icu_56::DigitGrouping	*__hidden this,	int)
		extrn ?getSeparatorCount@DigitGrouping@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::getLeftDigitsForLeftLength(icu_56::DigitGrouping const &,int,int,int &)+2Fp
; struct icu_56::AffixPattern *__thiscall icu_56::AffixPattern::append(icu_56::AffixPattern *__hidden this, const struct icu_56::AffixPattern *)
		extrn ?append@AffixPattern@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+1CAp
; void __thiscall __high icu_56::AffixPattern::add(enum	icu_56::AffixPattern::ETokenType)
		extrn ?add@AffixPattern@icu_56@@QAEXW4ETokenType@12@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+1B6p
					; icu_56::DecimalFormatImpl::isParseFastpath(void)+5Fp
; struct icu_56::UnicodeString *__thiscall icu_56::AffixPattern::toUserString(icu_56::AffixPattern *__hidden this, struct icu_56::UnicodeString	*)
		extrn ?toUserString@AffixPattern@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+DBp
					; icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString &)+178p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+C1p
					; icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString &)+F5p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		extrn __imp_?remove@UnicodeString@icu_56@@QAEAAV12@XZ:near
					; CODE XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+4Ap
					; DATA XREF: icu_56::DecimalFormatImpl::toPattern(icu_56::UnicodeString	&)+4Ar
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::releaseMemory(void)+34p
; _DWORD __thiscall icu_56::DigitAffix::DigitAffix(icu_56::DigitAffix *__hidden	this)
		extrn ??0DigitAffix@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::PluralMap<icu_56::DigitAffix>(void)+45p
					; icu_56::PluralMap<icu_56::DigitAffix>::clear(void)+4Bp ...
; enum icu_56::PluralMapBase::Category __cdecl __high static icu_56::PluralMapBase::toCategory(const char *)
		extrn __imp_?toCategory@PluralMapBase@icu_56@@SA?AW4Category@12@PBD@Z:near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::get(char const *)+29p
					; icu_56::PluralMap<icu_56::DigitAffix>::getMutable(char const *,UErrorCode &)+2Fp
					; DATA XREF: ...
; enum icu_56::PluralMapBase::Category __cdecl __high static icu_56::PluralMapBase::toCategory(const struct icu_56::UnicodeString *)
		extrn __imp_?toCategory@PluralMapBase@icu_56@@SA?AW4Category@12@ABVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::UnicodeString const &)+29p
					; DATA XREF: icu_56::PluralMap<icu_56::DigitAffix>::get(icu_56::UnicodeString const &)+29r
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+A1p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+98p
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+88p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+7Fp
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::resize(int,int)+34p
					; icu_56::MaybeStackHeaderAndArray<decNumber,char,40>::orphanOrClone(int,int &)+62p
; void __thiscall icu_56::DigitList::set(icu_56::DigitList *__hidden this, __int64)
		extrn ?set@DigitList@icu_56@@QAEX_J@Z:near
					; CODE XREF: icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+7Bp
					; icu_56::DecimalFormatImpl::maybeInitVisibleDigitsFromDigitList<__int64>(__int64,icu_56::VisibleDigitsWithExponent &,UErrorCode &)+109p


		end
