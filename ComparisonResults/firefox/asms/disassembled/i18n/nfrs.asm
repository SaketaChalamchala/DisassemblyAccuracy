;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B28A726F6D2DF554D210A7FD257D6C2F
; Input	CRC32 :	32926ED1

; File Name   :	D:\compspace\objfiles\firefox\i18n\nfrs.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset _gNoparse ; "@noparse"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .text:00003D10o
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
; wchar_t gPercentPercent
_gPercentPercent:			; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+271o
		unicode	0, <%%>,0
		align 10h
; wchar_t gNoparse
_gNoparse:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
					; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat *,icu_56::UnicodeString *,int,UErrorCode &)+295o
		unicode	0, <@noparse>,0
		align 4
_asciiDigits	db 30h			; DATA XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char):loc_4295r
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+162r
		db 31h,	32h, 33h
		dd 37363534h, 62613938h, 66656463h, 6A696867h, 6E6D6C6Bh
		dd 7271706Fh, 76757473h, 7A797877h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 170h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 174h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator!=(class	icu_56::DecimalFormatSymbols const &)const
		public ??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]

loc_1BF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z ; icu_56::DecimalFormatSymbols::operator==(icu_56::DecimalFormatSymbols const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9DecimalFormatSymbols@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_1FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD0h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 230h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::DecimalFormatSymbols::isCustomIntlCurrencySymbol(icu_56::DecimalFormatSymbols *__hidden this)
		public ?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0AD1h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isCustomIntlCurrencySymbol@DecimalFormatSymbols@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 264h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::DecimalFormatSymbols::getSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near
					; CODE XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+9Fp

var_E4		= byte ptr -0E4h
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_E0], 0
		cmp	[ebp+arg_4], 1Ch
		jge	short loc_2A9
		mov	eax, [ebp+arg_4]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_2B4
; ---------------------------------------------------------------------------

loc_2A9:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+31j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_2B4:				; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+43j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		or	ecx, 1
		mov	[ebp+var_E0], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString const & __thiscall icu_56::DecimalFormatSymbols::getConstSymbol(enum  icu_56::DecimalFormatSymbols::ENumberFormatSymbol)const
		public ?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_32F
		mov	eax, [ebp+arg_0]
		shl	eax, 6
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax+4]
		mov	[ebp+var_14], edx
		jmp	short loc_33A
; ---------------------------------------------------------------------------

loc_32F:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+27j
		mov	eax, [ebp+var_8]
		add	eax, 704h
		mov	[ebp+var_14], eax

loc_33A:				; CODE XREF: icu_56::DecimalFormatSymbols::getConstSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+39j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getConstSymbol@DecimalFormatSymbols@icu_56@@QBEABVUnicodeString@2@W4ENumberFormatSymbol@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 348h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::DecimalFormatSymbols::setSymbol(enum	icu_56::DecimalFormatSymbols::ENumberFormatSymbol, class icu_56::UnicodeString const &,	signed char)
		public ?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z proc near

var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_138		= byte ptr -138h
var_2D		= byte ptr -2Dh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_144]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_0], 8
		jnz	short loc_39F
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD0h], 1
		jmp	short loc_3AF
; ---------------------------------------------------------------------------

loc_39F:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+49j
		cmp	[ebp+arg_0], 9
		jnz	short loc_3AF
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+0AD1h], 1

loc_3AF:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+55j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+5Bj
		cmp	[ebp+arg_0], 1Ch
		jge	short loc_3D5
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 6
		mov	edx, [ebp+var_18]
		lea	ecx, [edx+ecx+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3D5:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+6Bj
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_4D6
		cmp	[ebp+arg_0], 4
		jnz	loc_4D6
		mov	esi, esp
		push	7FFFFFFFh	; int
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z ; icu_56::UnicodeString::countChar32(int,int)
		cmp	esi, esp

loc_3FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	loc_4D6
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_4] ; this
		call	dword ptr ds:__imp_?char32At@UnicodeString@icu_56@@QBEHH@Z ; icu_56::UnicodeString::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax
		call	_u_charDigitValue_56
		add	esp, 4
		test	eax, eax
		jnz	loc_4D6
		mov	[ebp+var_2D], 1
		jmp	short loc_446
; ---------------------------------------------------------------------------

loc_43E:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+189j
		mov	al, [ebp+var_2D]
		add	al, 1
		mov	[ebp+var_2D], al

loc_446:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+F4j
		movsx	eax, [ebp+var_2D]
		cmp	eax, 9
		jg	loc_4D6
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@H@Z ; icu_56::UnicodeString::UnicodeString(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_140], eax
		mov	ecx, [ebp+var_140]
		mov	[ebp+var_144], ecx
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	edx, [ebp+var_144]
		push	edx
		movsx	eax, [ebp+var_2D]
		add	eax, 11h
		shl	eax, 6
		mov	ecx, [ebp+var_18]
		lea	ecx, [ecx+eax+4]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z	; icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_138] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_43E
; ---------------------------------------------------------------------------

loc_4D6:				; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+93j
					; icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const	&,signed char)+9Dj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 504h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 proc near
					; DATA XREF: .xdata$x:00000548o
		mov	esi, esp
		lea	ecx, [ebp-138h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	proc near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-148h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 544h
__unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000554o
		dd offset __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0
__ehfuncinfo$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+1Eo
		dd offset __unwindtable$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Locale __thiscall icu_56::DecimalFormatSymbols::getLocale(void)const
		public ?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+var_8]
		add	eax, 744h
		mov	esi, esp
		push	eax		; struct icu_56::Locale	*
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_??0Locale@icu_56@@QAE@ABV01@@Z ; icu_56::Locale::Locale(icu_56::Locale const	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_D4]
		or	ecx, 1
		mov	[ebp+var_D4], ecx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLocale@DecimalFormatSymbols@icu_56@@QBE?AVLocale@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::DecimalFormatSymbols::getCurrencyPattern(icu_56::DecimalFormatSymbols *__hidden this)
		public ?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+94Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCurrencyPattern@DecimalFormatSymbols@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Formattable::operator!=(class icu_56::Formattable const &)const
		public ??9Formattable@icu_56@@QBECABV01@@Z
??9Formattable@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Formattable@icu_56@@QBECABV01@@Z ; icu_56::Formattable::operator==(icu_56::Formattable const	&)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Formattable@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDouble(icu_56::Formattable *__hidden this)
		public ?getDouble@Formattable@icu_56@@QBENXZ
?getDouble@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDouble@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 694h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this)
		public ?getLong@Formattable@icu_56@@QBEHXZ
?getLong@Formattable@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLong@Formattable@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::Formattable::getInt64(icu_56::Formattable *__hidden this)
		public ?getInt64@Formattable@icu_56@@QBE_JXZ
?getInt64@Formattable@icu_56@@QBE_JXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx+8]
		mov	edx, [ecx+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getInt64@Formattable@icu_56@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *__hidden this)
		public ?getDate@Formattable@icu_56@@QBENXZ
?getDate@Formattable@icu_56@@QBENXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDate@Formattable@icu_56@@QBENXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 728h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *this, struct icu_56::UnicodeString *)
		public ?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getString@Formattable@icu_56@@QBEAAVUnicodeString@2@AAV32@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Formattable::getArray(icu_56::Formattable *this,	int *)
		public ?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax], edx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getArray@Formattable@icu_56@@QBEPBV12@AAH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator[](int)
		public ??AFormattable@icu_56@@QAEAAV01@H@Z
??AFormattable@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		imul	eax, 0E0h
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??AFormattable@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::DigitList *__thiscall icu_56::Formattable::getDigitList(icu_56::Formattable *__hidden this)
		public ?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_7FF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDigitList@Formattable@icu_56@@QBEPAVDigitList@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 82Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::Formattable::getDate(icu_56::Formattable *this, enum UErrorCode *)
		public ?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+98h], 0
		jz	short loc_87D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_879
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 3

loc_879:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+42j
		fldz
		jmp	short loc_883
; ---------------------------------------------------------------------------

loc_87D:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+2Dj
		mov	eax, [ebp+var_8]
		fld	qword ptr [eax+8]

loc_883:				; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getDate@Formattable@icu_56@@QBENAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 89Ch
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::Formattable::getDate(UErrorCode &)+35p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden this)
		public ?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QBEABVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 900h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::Formattable::getString(icu_56::Formattable *__hidden	this)
		public ?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getString@Formattable@icu_56@@QAEAAVUnicodeString@2@XZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 930h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *this, enum UErrorCode *)
		public ?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8] ; this
		call	?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z ; icu_56::Formattable::getLong(UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLong@Formattable@icu_56@@QBEHPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 978h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QAEPAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *const *__thiscall icu_56::Formattable::toUFormattable(icu_56::Formattable *__hidden this)
		public ?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUFormattable@Formattable@icu_56@@QBEPBQAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void **)
		public ?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPAV12@PAPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__cdecl icu_56::Formattable::fromUFormattable(void *const *)
		public ?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUFormattable@Formattable@icu_56@@SAPBV12@PBQAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *__hidden this)
		public ??0FieldPosition@icu_56@@QAE@XZ
??0FieldPosition@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0FieldPosition@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A9Ch
		dd offset ??_R4FieldPosition@icu_56@@6B@ ; const icu_56::FieldPosition::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`vftable'
??_7FieldPosition@icu_56@@6B@ dd offset	??_EFieldPosition@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::FieldPosition::FieldPosition(void)+38o
					; icu_56::FieldPosition::FieldPosition(int)+38o ...
					; icu_56::FieldPosition::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ ; icu_56::FieldPosition::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AA8h
		public ??_R4FieldPosition@icu_56@@6B@
; const	icu_56::FieldPosition::`RTTI Complete Object Locator'
??_R4FieldPosition@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00000A9Co
		dd offset ??_R0?AVFieldPosition@icu_56@@@8 ; icu_56::FieldPosition `RTTI Type Descriptor'
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0ABCh
		public ??_R0?AVFieldPosition@icu_56@@@8
; class	icu_56::FieldPosition `RTTI Type Descriptor'
??_R0?AVFieldPosition@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000AB4o
					; .rdata$r:icu_56::FieldPosition::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avfieldposit	db '.?AVFieldPosition@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AE0h
		public ??_R3FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
??_R3FieldPosition@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00000AB8o
					; .rdata$r:00000B18o
		dd 3
		dd offset ??_R2FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AF0h
		public ??_R2FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Array'
??_R2FieldPosition@icu_56@@8 dd	offset ??_R1A@?0A@EA@FieldPosition@icu_56@@8
					; DATA XREF: .rdata$r:00000AECo
					; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B00h
		public ??_R1A@?0A@EA@FieldPosition@icu_56@@8
; icu_56::FieldPosition::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@FieldPosition@icu_56@@8 dd offset	??_R0?AVFieldPosition@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::FieldPosition::`RTTI Base	Class Array'o
					; icu_56::FieldPosition	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3FieldPosition@icu_56@@8 ; icu_56::FieldPosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B1Ch
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000AF4o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B38h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B58h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B34o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B68h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000B64o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B74h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000AF8o
					; .rdata$r:00000B6Co ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B90h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BB0h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B8Co
					; .rdata$r:00000BE0o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC0h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000BBCo
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC8h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, int)
		public ??0FieldPosition@icu_56@@QAE@H@Z
??0FieldPosition@icu_56@@QAE@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition *this, const struct icu_56::FieldPosition *)
		public ??0FieldPosition@icu_56@@QAE@ABV01@@Z
??0FieldPosition@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7FieldPosition@icu_56@@6B@ ;	const icu_56::FieldPosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0FieldPosition@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getField(icu_56::FieldPosition *__hidden this)
		public ?getField@FieldPosition@icu_56@@QBEHXZ
?getField@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getField@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getBeginIndex(icu_56::FieldPosition *__hidden this)
		public ?getBeginIndex@FieldPosition@icu_56@@QBEHXZ
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBeginIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FieldPosition::getEndIndex(icu_56::FieldPosition *__hidden this)
		public ?getEndIndex@FieldPosition@icu_56@@QBEHXZ
?getEndIndex@FieldPosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getEndIndex@FieldPosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setField(icu_56::FieldPosition	*this, int)
		public ?setField@FieldPosition@icu_56@@QAEXH@Z
?setField@FieldPosition@icu_56@@QAEXH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setField@FieldPosition@icu_56@@QAEXH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setBeginIndex(icu_56::FieldPosition *this, int)
		public ?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setBeginIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::FieldPosition::setEndIndex(icu_56::FieldPosition *this, int)
		public ?setEndIndex@FieldPosition@icu_56@@QAEXH@Z
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]

loc_DFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setEndIndex@FieldPosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`scalar deleting destructor'(unsigned int)
		public ??_GFieldPosition@icu_56@@UAEPAXI@Z
??_GFieldPosition@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E59
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E59:				; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::FieldPosition::`vector deleting destructor'(unsigned int)
		public ??_EFieldPosition@icu_56@@UAEPAXI@Z
??_EFieldPosition@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::FieldPosition::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_EDF
		push	offset ??1FieldPosition@icu_56@@UAE@XZ ; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_ED7
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_ED7:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F08
; ---------------------------------------------------------------------------

loc_EDF:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1FieldPosition@icu_56@@UAE@XZ	; icu_56::FieldPosition::~FieldPosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F05
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F05:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_F08:				; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EFieldPosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPosition &	__thiscall icu_56::FieldPosition::operator=(class icu_56::FieldPosition	const &)
		public ??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPosition@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator==(class icu_56::FieldPosition const &)const
		public ??8FieldPosition@icu_56@@QBECABV01@@Z
??8FieldPosition@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::FieldPosition::operator!=(icu_56::FieldPosition const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_FCA
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		cmp	edx, [ecx+0Ch]
		jnz	short loc_FCA
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jnz	short loc_FCA
		mov	[ebp+var_CD], 1
		jmp	short loc_FD1
; ---------------------------------------------------------------------------

loc_FCA:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+2Fj
					; icu_56::FieldPosition::operator==(icu_56::FieldPosition const	&)+3Dj	...
		mov	[ebp+var_CD], 0

loc_FD1:				; CODE XREF: icu_56::FieldPosition::operator==(icu_56::FieldPosition const &)+54j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8FieldPosition@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPosition::operator!=(class icu_56::FieldPosition const &)const
		public ??9FieldPosition@icu_56@@QBECABV01@@Z
??9FieldPosition@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx

loc_1000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPosition@icu_56@@QBECABV01@@Z ;	icu_56::FieldPosition::operator==(icu_56::FieldPosition	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPosition@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1030h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::FieldPositionIterator::operator!=(class icu_56::FieldPositionIterator const &)const
		public ??9FieldPositionIterator@icu_56@@QBECABV01@@Z
??9FieldPositionIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8FieldPositionIterator@icu_56@@QBECABV01@@Z ;	icu_56::FieldPositionIterator::operator==(icu_56::FieldPositionIterator	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9FieldPositionIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1080h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::FieldPositionIterator &	__thiscall icu_56::FieldPositionIterator::operator=(class icu_56::FieldPositionIterator	const &)
		public ??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4FieldPositionIterator@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Format::operator!=(class icu_56::Format const &)const
		public ??9Format@icu_56@@QBECABV01@@Z
??9Format@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Format@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1148h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::Formattable *__thiscall icu_56::Measure::getNumber(icu_56::Measure *__hidden this)
		public ?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 8
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getNumber@Measure@icu_56@@QBEABVFormattable@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::MeasureUnit *__thiscall icu_56::Measure::getUnit(icu_56::Measure	*__hidden this)
		public ?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	proc near
					; CODE XREF: icu_56::CurrencyAmount::getCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0E8h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *__hidden this)
		public ??0MeasureUnit@icu_56@@QAE@XZ
??0MeasureUnit@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MeasureUnit@icu_56@@QAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 121Ch
		dd offset ??_R4MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`vftable'
??_7MeasureUnit@icu_56@@6B@ dd offset ??_EMeasureUnit@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::MeasureUnit::MeasureUnit(void)+38o
					; icu_56::MeasureUnit::MeasureUnit(int,int)+38o
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ ; icu_56::MeasureUnit::getDynamicClassID(void)
		dd offset ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ	; icu_56::MeasureUnit::clone(void)
		dd offset ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z ; icu_56::MeasureUnit::operator==(icu_56::UObject const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1230h
		public ??_R4MeasureUnit@icu_56@@6B@
; const	icu_56::MeasureUnit::`RTTI Complete Object Locator'
??_R4MeasureUnit@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:0000121Co
		dd offset ??_R0?AVMeasureUnit@icu_56@@@8 ; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1244h
		public ??_R0?AVMeasureUnit@icu_56@@@8
; class	icu_56::MeasureUnit `RTTI Type Descriptor'
??_R0?AVMeasureUnit@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:0000123Co
					; .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avmeasureuni	db '.?AVMeasureUnit@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1268h
		public ??_R3MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Class Hierarchy Descriptor'
??_R3MeasureUnit@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00001240o
					; .rdata$r:000012A0o
		dd 3
		dd offset ??_R2MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1278h
		public ??_R2MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Array'
??_R2MeasureUnit@icu_56@@8 dd offset ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
					; DATA XREF: .rdata$r:00001274o
					; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1288h
		public ??_R1A@?0A@EA@MeasureUnit@icu_56@@8
; icu_56::MeasureUnit::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@MeasureUnit@icu_56@@8 dd offset ??_R0?AVMeasureUnit@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::MeasureUnit::`RTTI Base Class Array'o
					; icu_56::MeasureUnit `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3MeasureUnit@icu_56@@8 ; icu_56::MeasureUnit::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MeasureUnit::operator!=(class icu_56::UObject const &)const
		public ??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9MeasureUnit@icu_56@@QBECABVUObject@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1300h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MeasureUnit::MeasureUnit(icu_56::MeasureUnit *this,	int, int)
		public ??0MeasureUnit@icu_56@@AAE@HH@Z
??0MeasureUnit@icu_56@@AAE@HH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7MeasureUnit@icu_56@@6B@ ; const icu_56::MeasureUnit::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+0Ch], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0MeasureUnit@icu_56@@AAE@HH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`scalar deleting destructor'(unsigned int)
		public ??_GMeasureUnit@icu_56@@UAEPAXI@Z
??_GMeasureUnit@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_13B9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_13B9:				; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MeasureUnit::`vector deleting destructor'(unsigned int)
		public ??_EMeasureUnit@icu_56@@UAEPAXI@Z
??_EMeasureUnit@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::MeasureUnit::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_143F
		push	offset ??1MeasureUnit@icu_56@@UAE@XZ ; icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	10h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1437
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1437:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1468
; ---------------------------------------------------------------------------

loc_143F:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1MeasureUnit@icu_56@@UAE@XZ ;	icu_56::MeasureUnit::~MeasureUnit(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1465
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1465:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1468:				; CODE XREF: icu_56::MeasureUnit::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EMeasureUnit@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1480h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyUnit::getISOCurrency(icu_56::CurrencyUnit *__hidden	this)
		public ?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+2Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::CurrencyUnit *__thiscall	icu_56::CurrencyAmount::getCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ proc near
					; CODE XREF: icu_56::CurrencyAmount::getISOCurrency(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getUnit@Measure@icu_56@@QBEABVMeasureUnit@2@XZ	; icu_56::Measure::getUnit(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::CurrencyAmount::getISOCurrency(icu_56::CurrencyAmount *__hidden this)
		public ?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?getCurrency@CurrencyAmount@icu_56@@QBEABVCurrencyUnit@2@XZ ; icu_56::CurrencyAmount::getCurrency(void)
		mov	ecx, eax	; this
		call	?getISOCurrency@CurrencyUnit@icu_56@@QBEPB_WXZ ; icu_56::CurrencyUnit::getISOCurrency(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getISOCurrency@CurrencyAmount@icu_56@@QBEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1538h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		public ??0NumberFormatFactory@icu_56@@QAE@XZ
??0NumberFormatFactory@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0NumberFormatFactory@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1590h
		dd offset ??_R4NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`vftable'
??_7NumberFormatFactory@icu_56@@6B@ dd offset ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::NumberFormatFactory::NumberFormatFactory(void)+38o
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+3Co
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15A8h
		public ??_R4NumberFormatFactory@icu_56@@6B@
; const	icu_56::NumberFormatFactory::`RTTI Complete Object Locator'
??_R4NumberFormatFactory@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00001590o
		dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8 ; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 15BCh
		public ??_R0?AVNumberFormatFactory@icu_56@@@8
; class	icu_56::NumberFormatFactory `RTTI Type Descriptor'
??_R0?AVNumberFormatFactory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000015B4o
					; .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avnumberform	db '.?AVNumberFormatFactory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15E8h
		public ??_R3NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3NumberFormatFactory@icu_56@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:000015B8o
					; .rdata$r:00001620o
		dd 3
		dd offset ??_R2NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 15F8h
		public ??_R2NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Array'
??_R2NumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:000015F4o
					; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1608h
		public ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8
; icu_56::NumberFormatFactory::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 dd offset ??_R0?AVNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::NumberFormatFactory::`RTTI Base Class Array'o
					; .rdata$r:0000195Co
					; icu_56::NumberFormatFactory `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3NumberFormatFactory@icu_56@@8 ; icu_56::NumberFormatFactory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory *this,	const struct icu_56::NumberFormatFactory *)
		public ??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0UObject@icu_56@@QAE@ABV01@@Z ; icu_56::UObject::UObject(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7NumberFormatFactory@icu_56@@6B@ ; const icu_56::NumberFormatFactory::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::NumberFormatFactory & __thiscall icu_56::NumberFormatFactory::operator=(class icu_56::NumberFormatFactory const	&)
		public ??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UObject::operator=(icu_56::UObject const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4NumberFormatFactory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`scalar deleting destructor'(unsigned int)
		public ??_GNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_171D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_171D:				; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1738h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::NumberFormatFactory::`vector deleting destructor'(unsigned int)
		public ??_ENumberFormatFactory@icu_56@@UAEPAXI@Z
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::NumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_17A3
		push	offset ??1NumberFormatFactory@icu_56@@UAE@XZ ; icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_179B
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_179B:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_17CC
; ---------------------------------------------------------------------------

loc_17A3:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_17C9
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_17C9:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_17CC:				; CODE XREF: icu_56::NumberFormatFactory::`vector deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ENumberFormatFactory@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *this, const	struct icu_56::SimpleNumberFormatFactory *)
		public ??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NumberFormatFactory *
		mov	ecx, [ebp+var_14] ; this
		call	??0NumberFormatFactory@icu_56@@QAE@ABV01@@Z ; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+4]
		mov	[eax+4], dl
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	esi, esp
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1898h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000018DCo
		mov	ecx, [ebp-14h]	; this
		jmp	??1NumberFormatFactory@icu_56@@UAE@XZ ;	icu_56::NumberFormatFactory::~NumberFormatFactory(void)
__unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18C0h
		dd offset ??_R4SimpleNumberFormatFactory@icu_56@@6B@ ; const icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`vftable'
??_7SimpleNumberFormatFactory@icu_56@@6B@ dd offset ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+58o
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ ; icu_56::SimpleNumberFormatFactory::visible(void)
		dd offset ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z ; icu_56::SimpleNumberFormatFactory::getSupportedIDs(int &,UErrorCode &)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 18D8h
__unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000018E8o
		dd offset __unwindfunclet$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1904h
		public ??_R4SimpleNumberFormatFactory@icu_56@@6B@
; const	icu_56::SimpleNumberFormatFactory::`RTTI Complete Object Locator'
??_R4SimpleNumberFormatFactory@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:000018C0o
		dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 ; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1918h
		public ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
; class	icu_56::SimpleNumberFormatFactory `RTTI	Type Descriptor'
??_R0?AVSimpleNumberFormatFactory@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001910o
					; .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avsimplenumb	db '.?AVSimpleNumberFormatFactory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1948h
		public ??_R3SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
??_R3SimpleNumberFormatFactory@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00001914o
					; .rdata$r:00001984o
		dd 4
		dd offset ??_R2SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1958h
		public ??_R2SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Array'
??_R2SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
					; DATA XREF: .rdata$r:00001954o
					; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@NumberFormatFactory@icu_56@@8 ;	icu_56::NumberFormatFactory::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 196Ch
		public ??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8
; icu_56::SimpleNumberFormatFactory::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@SimpleNumberFormatFactory@icu_56@@8 dd offset ??_R0?AVSimpleNumberFormatFactory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SimpleNumberFormatFactory::`RTTI Base Class Array'o
					; icu_56::SimpleNumberFormatFactory `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SimpleNumberFormatFactory@icu_56@@8 ; icu_56::SimpleNumberFormatFactory::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1988h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`scalar deleting	destructor'(unsigned int)
		public ??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_19D1
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_19D1:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SimpleNumberFormatFactory::`vector deleting	destructor'(unsigned int)
		public ??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::SimpleNumberFormatFactory::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1A57
		push	offset ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	48h ; 'H'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A4F
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax		; void *
		call	dword ptr ds:__imp_??_VUMemory@icu_56@@SAXPAX@Z	; icu_56::UMemory::operator delete[](void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1A4F:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1A80
; ---------------------------------------------------------------------------

loc_1A57:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SimpleNumberFormatFactory@icu_56@@UAE@XZ ; icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1A7D
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1A7D:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+79j
		mov	eax, [ebp+var_8]

loc_1A80:				; CODE XREF: icu_56::SimpleNumberFormatFactory::`vector	deleting destructor'(uint)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESimpleNumberFormatFactory@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isParseIntegerOnly(icu_56::NumberFormat *__hidden this)
		public ?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+154h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isParseIntegerOnly@NumberFormat@icu_56@@QBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ACCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NumberFormat::isLenient(icu_56::NumberFormat	*__hidden this)
		public ?isLenient@NumberFormat@icu_56@@UBECXZ
?isLenient@NumberFormat@icu_56@@UBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+155h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@NumberFormat@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedNumberFormat::isLenient(icu_56::RuleBasedNumberFormat *__hidden this)
		public ?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ
?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+250h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isLenient@RuleBasedNumberFormat@icu_56@@UBECXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRuleSet *__thiscall icu_56::RuleBasedNumberFormat::getDefaultRuleSet(icu_56::RuleBasedNumberFormat *__hidden	this)
		public ?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ
?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+170h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDefaultRuleSet@RuleBasedNumberFormat@icu_56@@ABEPAVNFRuleSet@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NFRuleSet::NFRuleSet(icu_56::NFRuleSet *this, struct icu_56::RuleBasedNumberFormat *, struct icu_56::UnicodeString *, int, enum UErrorCode *)
		public ??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z
??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z proc	near

var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
var_144		= byte ptr -144h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_150]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		push	0		; unsigned int
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'  ; this
		call	??0NFRuleList@icu_56@@QAE@I@Z ;	icu_56::NFRuleList::NFRuleList(uint)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	[eax+64h], ecx
		push	0Ah		; unsigned int
		mov	ecx, [ebp+var_18]
		add	ecx, 68h ; 'h'  ; this
		call	??0NFRuleList@icu_56@@QAE@I@Z ;	icu_56::NFRuleList::NFRuleList(uint)
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+74h], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+75h], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+76h], 1
		mov	[ebp+var_24], 0
		jmp	short loc_1C18
; ---------------------------------------------------------------------------

loc_1C0F:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+C4j
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax

loc_1C18:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+A5j
		cmp	[ebp+var_24], 6
		jge	short loc_1C2E
		mov	eax, [ebp+var_24]
		mov	ecx, [ebp+var_18]
		mov	dword ptr [ecx+eax*4+4Ch], 0
		jmp	short loc_1C0F
; ---------------------------------------------------------------------------

loc_1C2E:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+B4j
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1C48
		jmp	loc_1E48
; ---------------------------------------------------------------------------

loc_1C48:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+D9j
		mov	eax, [ebp+arg_8]
		shl	eax, 6
		add	eax, [ebp+arg_4]
		mov	[ebp+var_30], eax
		mov	esi, esp
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_1C78
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 9
		jmp	loc_1E48
; ---------------------------------------------------------------------------

loc_1C78:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+100j
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, ax
		cmp	eax, 25h ; '%'
		jnz	loc_1D4E
		mov	esi, esp
		push	3Ah ; ':'       ; wchar_t
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEH_W@Z ; icu_56::UnicodeString::indexOf(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_3C], eax
		cmp	[ebp+var_3C], 0FFFFFFFFh
		jnz	short loc_1CC3
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 9
		jmp	loc_1D4C
; ---------------------------------------------------------------------------

loc_1CC3:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+14Bj
		mov	esi, esp
		mov	eax, [ebp+var_3C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_30]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1CDF:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1CAj
		mov	esi, esp
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_3C], eax
		jge	short loc_1D34
		mov	eax, [ebp+var_3C]
		add	eax, 1
		mov	[ebp+var_3C], eax
		mov	esi, esp
		mov	ecx, [ebp+var_3C]
		push	ecx		; int
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, ax
		mov	esi, esp
		push	edx		; int
		call	dword ptr ds:__imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z ; icu_56::PatternProps::isWhiteSpace(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D34
		jmp	short loc_1CDF
; ---------------------------------------------------------------------------

loc_1D34:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+18Cj
					; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat *,icu_56::UnicodeString *,int,UErrorCode &)+1C8j
		mov	esi, esp
		mov	eax, [ebp+var_3C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z ; icu_56::UnicodeString::remove(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1D4C:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+156j
		jmp	short loc_1DB4
; ---------------------------------------------------------------------------

loc_1D4E:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+12Aj
		mov	esi, esp
		push	0FFFFFFFFh	; int
		push	offset ??_C@_1BC@ECMHAIJJ@?$AA?$CF?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@ ; "%default"
		push	1		; signed __int8
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z ; icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14C], eax
		mov	eax, [ebp+var_14C]
		mov	[ebp+var_150], eax
		mov	byte ptr [ebp+var_4], 3
		mov	esi, esp
		mov	ecx, [ebp+var_150]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1DB4:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &):loc_1D4Cj
		mov	esi, esp
		mov	ecx, [ebp+var_30] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_1DD3
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 9

loc_1DD3:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+260j
		mov	esi, esp
		push	0		; int
		push	2		; int
		push	offset _gPercentPercent	; "%%"
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z ; icu_56::UnicodeString::indexOf(wchar_t	const *,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		setnz	al
		mov	ecx, [ebp+var_18]
		mov	[ecx+75h], al
		mov	esi, esp
		push	8		; int
		push	offset _gNoparse ; "@noparse"
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z ; icu_56::UnicodeString::endsWith(wchar_t const *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_1E48
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+76h], 0
		mov	esi, esp
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, 8
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_?truncate@UnicodeString@icu_56@@QAECH@Z ; icu_56::UnicodeString::truncate(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1E48:				; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+DBj
					; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat *,icu_56::UnicodeString *,int,UErrorCode &)+10Bj ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 150h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1E80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00001F00o
		mov	esi, esp
		mov	ecx, [ebp-18h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00001F08o
		mov	ecx, [ebp-18h]
		add	ecx, 40h ; '@'  ; this
		jmp	??1NFRuleList@icu_56@@QAE@XZ ; icu_56::NFRuleList::~NFRuleList(void)
__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00001F10o
		mov	ecx, [ebp-18h]
		add	ecx, 68h ; 'h'  ; this
		jmp	??1NFRuleList@icu_56@@QAE@XZ ; icu_56::NFRuleList::~NFRuleList(void)
__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00001F18o
		mov	esi, esp
		lea	ecx, [ebp-144h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-154h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1EE8h
		public ??_C@_1BC@ECMHAIJJ@?$AA?$CF?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1BC@ECMHAIJJ@?$AA?$CF?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AA?$AA@:
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1EAo
		unicode	0, <%default>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 1EFCh
__unwindtable$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00001F24o
		dd offset __unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$0
		align 8
		dd offset __unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$3
__ehfuncinfo$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z	dd 19930522h, 4
					; DATA XREF: __ehhandler$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+CCp
					; icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+4Bp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NFRuleList::NFRuleList(icu_56::NFRuleList *this, unsigned int)
		public ??0NFRuleList@icu_56@@QAE@I@Z
??0NFRuleList@icu_56@@QAE@I@Z proc near	; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+66p
					; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat *,icu_56::UnicodeString *,int,UErrorCode &)+80p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_1FAC
		mov	eax, [ebp+arg_0]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_1FB6
; ---------------------------------------------------------------------------

loc_1FAC:				; CODE XREF: icu_56::NFRuleList::NFRuleList(uint)+27j
		mov	[ebp+var_D0], 0

loc_1FB6:				; CODE XREF: icu_56::NFRuleList::NFRuleList(uint)+3Ej
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_D0]
		mov	[ecx], edx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0NFRuleList@icu_56@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NFRuleList::~NFRuleList(icu_56::NFRuleList *__hidden this)
		public ??1NFRuleList@icu_56@@QAE@XZ
??1NFRuleList@icu_56@@QAE@XZ proc near	; CODE XREF: __unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$1+6j
					; __unwindfunclet$??0NFRuleSet@icu_56@@QAE@PAVRuleBasedNumberFormat@1@PAVUnicodeString@1@HAAW4UErrorCode@@@Z$2+6j ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_1FFD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jz	short loc_208D
		mov	[ebp+var_14], 0
		jmp	short loc_202D
; ---------------------------------------------------------------------------

loc_2024:				; CODE XREF: icu_56::NFRuleList::~NFRuleList(void):loc_207Dj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_202D:				; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jnb	short loc_207F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_2073
		push	1
		mov	ecx, [ebp+var_EC]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_F4], eax
		jmp	short loc_207D
; ---------------------------------------------------------------------------

loc_2073:				; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+6Cj
		mov	[ebp+var_F4], 0

loc_207D:				; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+81j
		jmp	short loc_2024
; ---------------------------------------------------------------------------

loc_207F:				; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+46j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_208D:				; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+29j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1NFRuleList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::NFRule::`scalar deleting destructor'(unsigned int)
		public ??_GNFRule@icu_56@@QAEPAXI@Z
??_GNFRule@icu_56@@QAEPAXI@Z proc near	; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+76p
					; icu_56::NFRuleList::deleteAll(void)+8Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1NFRule@icu_56@@QAE@XZ ; icu_56::NFRule::~NFRule(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_20ED
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_20ED:				; CODE XREF: icu_56::NFRule::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GNFRule@icu_56@@QAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2108h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::parseRules(icu_56::NFRuleSet *this, struct	icu_56::UnicodeString *, enum UErrorCode *)
		public ?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z
?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z	proc near

var_180		= byte ptr -180h
var_BC		= dword	ptr -0BCh
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= qword	ptr -88h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 174h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_180]
		mov	ecx, 5Dh ; ']'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2167
		jmp	loc_238F
; ---------------------------------------------------------------------------

loc_2167:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+58j
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'  ; this
		call	?deleteAll@NFRuleList@icu_56@@QAEXXZ ; icu_56::NFRuleList::deleteAll(void)
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_6C], 0

loc_2192:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+133j
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_6C], eax
		jge	loc_2240
		mov	esi, esp
		mov	eax, [ebp+var_6C]
		push	eax		; int
		push	3Bh ; ';'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?indexOf@UnicodeString@icu_56@@QBEH_WH@Z ; icu_56::UnicodeString::indexOf(wchar_t,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], eax
		cmp	[ebp+var_78], 0FFFFFFFFh
		jnz	short loc_21E3
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_78], eax

loc_21E3:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+C4j
		mov	eax, [ebp+var_78]
		sub	eax, [ebp+var_6C]
		mov	esi, esp
		push	eax		; int
		mov	ecx, [ebp+var_6C]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'
		push	ecx		; struct icu_56::NFRuleList *
		mov	edx, [ebp+var_18]
		mov	eax, [edx+64h]
		push	eax		; struct icu_56::RuleBasedNumberFormat *
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'  ; this
		call	?last@NFRuleList@icu_56@@QBEPAVNFRule@2@XZ ; icu_56::NFRuleList::last(void)
		push	eax		; struct icu_56::NFRule	*
		mov	ecx, [ebp+var_18]
		push	ecx		; struct icu_56::NFRuleSet *
		lea	edx, [ebp+var_60]
		push	edx		; struct icu_56::UnicodeString *
		call	?makeRules@NFRule@icu_56@@SAXAAVUnicodeString@2@PAVNFRuleSet@2@PBV12@PBVRuleBasedNumberFormat@2@AAVNFRuleList@2@AAW4UErrorCode@@@Z ; icu_56::NFRule::makeRules(icu_56::UnicodeString &,icu_56::NFRuleSet *,icu_56::NFRule const	*,icu_56::RuleBasedNumberFormat	const *,icu_56::NFRuleList &,UErrorCode	&)
		add	esp, 18h
		mov	eax, [ebp+var_78]
		add	eax, 1
		mov	[ebp+var_6C], eax
		jmp	loc_2192
; ---------------------------------------------------------------------------

loc_2240:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+9Fj
		mov	dword ptr [ebp+var_88],	0
		mov	dword ptr [ebp+var_88+4], 0
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		mov	[ebp+var_94], eax
		mov	[ebp+var_A0], 0
		jmp	short loc_2280
; ---------------------------------------------------------------------------

loc_2271:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &):loc_2371j
		mov	eax, [ebp+var_A0]
		add	eax, 1
		mov	[ebp+var_A0], eax

loc_2280:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+167j
		mov	eax, [ebp+var_A0]
		cmp	eax, [ebp+var_94]
		jge	loc_2376
		mov	eax, [ebp+var_A0]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	[ebp+var_AC], eax
		mov	ecx, [ebp+var_AC] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_BC], eax
		mov	[ebp+var_B8], edx
		mov	eax, [ebp+var_BC]
		or	eax, [ebp+var_B8]
		jnz	short loc_22EE
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, dword ptr [ebp+var_88+4]
		push	ecx
		mov	edx, dword ptr [ebp+var_88]
		push	edx		; __int64
		mov	ecx, [ebp+var_AC] ; this
		call	?setBaseValue@NFRule@icu_56@@QAEX_JAAW4UErrorCode@@@Z ;	icu_56::NFRule::setBaseValue(__int64,UErrorCode	&)
		jmp	short loc_2348
; ---------------------------------------------------------------------------

loc_22EE:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+1C5j
		mov	eax, [ebp+var_B8]
		cmp	eax, dword ptr [ebp+var_88+4]
		jg	short loc_2330
		jl	short loc_230C
		mov	ecx, [ebp+var_BC]
		cmp	ecx, dword ptr [ebp+var_88]
		jnb	short loc_2330

loc_230C:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+1F4j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 9
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_238F
; ---------------------------------------------------------------------------

loc_2330:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+1F2j
					; icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+202j
		mov	eax, [ebp+var_BC]
		mov	dword ptr [ebp+var_88],	eax
		mov	ecx, [ebp+var_B8]
		mov	dword ptr [ebp+var_88+4], ecx

loc_2348:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+1E4j
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+74h]
		test	ecx, ecx
		jnz	short loc_2371
		mov	eax, dword ptr [ebp+var_88]
		add	eax, 1
		mov	ecx, dword ptr [ebp+var_88+4]
		adc	ecx, 0
		mov	dword ptr [ebp+var_88],	eax
		mov	dword ptr [ebp+var_88+4], ecx

loc_2371:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+249j
		jmp	loc_2271
; ---------------------------------------------------------------------------

loc_2376:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+184j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_60] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_238F:				; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+5Aj
					; icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+226j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 180h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN19		dd 1			; DATA XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+28Bo
		dd offset $LN18
$LN18		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:000023D0o
		dd offset $LN16		; "currentDescription"
$LN16		db 'currentDescription',0 ; DATA XREF: .text:000023DCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 23F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00002434o
		mov	esi, esp
		lea	ecx, [ebp-60h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-184h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2430h
__unwindtable$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002440o
		dd offset __unwindfunclet$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?parseRules@NFRuleSet@icu_56@@QAEXAAVUnicodeString@2@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 245Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::NFRule::getBaseValue(icu_56::NFRule *__hidden this)
		public ?getBaseValue@NFRule@icu_56@@QBE_JXZ
?getBaseValue@NFRule@icu_56@@QBE_JXZ proc near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+1A8p
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+26p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		mov	eax, [ecx]
		mov	edx, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBaseValue@NFRule@icu_56@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2490h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::NFRule * __thiscall icu_56::NFRuleList::operator[](unsigned int)const
		public ??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z
??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z proc near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+197p
					; icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const	&)+E9p	...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jz	short loc_24CE
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+eax*4]
		mov	[ebp+var_D0], ecx
		jmp	short loc_24D8
; ---------------------------------------------------------------------------

loc_24CE:				; CODE XREF: icu_56::NFRuleList::operator[](uint)+29j
		mov	[ebp+var_D0], 0

loc_24D8:				; CODE XREF: icu_56::NFRuleList::operator[](uint)+3Cj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __thiscall icu_56::NFRuleList::size(icu_56::NFRuleList *__hidden	this)
		public ?size@NFRuleList@icu_56@@QBEIXZ
?size@NFRuleList@icu_56@@QBEIXZ	proc near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+152p
					; icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const	&)+29p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@NFRuleList@icu_56@@QBEIXZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2518h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRule	*__thiscall icu_56::NFRuleList::last(icu_56::NFRuleList	*__hidden this)
		public ?last@NFRuleList@icu_56@@QBEPAVNFRule@2@XZ
?last@NFRuleList@icu_56@@QBEPAVNFRule@2@XZ proc	near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+114p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jbe	short loc_2563
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx], 0
		jz	short loc_2563
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	eax, [edx+eax*4-4]
		mov	[ebp+var_D0], eax
		jmp	short loc_256D
; ---------------------------------------------------------------------------

loc_2563:				; CODE XREF: icu_56::NFRuleList::last(void)+2Aj
					; icu_56::NFRuleList::last(void)+32j
		mov	[ebp+var_D0], 0

loc_256D:				; CODE XREF: icu_56::NFRuleList::last(void)+49j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?last@NFRuleList@icu_56@@QBEPAVNFRule@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 257Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleList::deleteAll(icu_56::NFRuleList *__hidden this)
		public ?deleteAll@NFRuleList@icu_56@@QAEXXZ
?deleteAll@NFRuleList@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+65p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		cmp	[ebp+var_20], 0
		jle	short loc_2631
		mov	ecx, [ebp+var_8] ; this
		call	?release@NFRuleList@icu_56@@QAEPAPAVNFRule@2@XZ	; icu_56::NFRuleList::release(void)
		mov	[ebp+var_14], eax
		mov	[ebp+var_2C], 0
		jmp	short loc_25D2
; ---------------------------------------------------------------------------

loc_25C9:				; CODE XREF: icu_56::NFRuleList::deleteAll(void):loc_261Dj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_25D2:				; CODE XREF: icu_56::NFRuleList::deleteAll(void)+4Bj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	short loc_261F
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_F8], edx
		mov	eax, [ebp+var_F8]
		mov	[ebp+var_104], eax
		cmp	[ebp+var_104], 0
		jz	short loc_2613
		push	1
		mov	ecx, [ebp+var_104]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_10C], eax
		jmp	short loc_261D
; ---------------------------------------------------------------------------

loc_2613:				; CODE XREF: icu_56::NFRuleList::deleteAll(void)+80j
		mov	[ebp+var_10C], 0

loc_261D:				; CODE XREF: icu_56::NFRuleList::deleteAll(void)+95j
		jmp	short loc_25C9
; ---------------------------------------------------------------------------

loc_261F:				; CODE XREF: icu_56::NFRuleList::deleteAll(void)+5Cj
		cmp	[ebp+var_14], 0
		jz	short loc_2631
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_2631:				; CODE XREF: icu_56::NFRuleList::deleteAll(void)+37j
					; icu_56::NFRuleList::deleteAll(void)+A7j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?deleteAll@NFRuleList@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::NFRule	**__thiscall icu_56::NFRuleList::release(icu_56::NFRuleList *__hidden this)
		public ?release@NFRuleList@icu_56@@QAEPAPAVNFRule@2@XZ
?release@NFRuleList@icu_56@@QAEPAPAVNFRule@2@XZ	proc near
					; CODE XREF: icu_56::NFRuleList::deleteAll(void)+3Cp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; struct icu_56::NFRule	*
		mov	ecx, [ebp+var_8] ; this
		call	?add@NFRuleList@icu_56@@QAEXPAVNFRule@2@@Z ; icu_56::NFRuleList::add(icu_56::NFRule *)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?release@NFRuleList@icu_56@@QAEPAPAVNFRule@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleList::add(icu_56::NFRuleList *this, struct icu_56::NFRule *)
		public ?add@NFRuleList@icu_56@@QAEXPAVNFRule@2@@Z
?add@NFRuleList@icu_56@@QAEXPAVNFRule@2@@Z proc	near
					; CODE XREF: icu_56::NFRuleList::release(void)+28p
					; icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed char)+57p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4]
		cmp	edx, [ecx+8]
		jnz	short loc_2711
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 0Ah
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		shl	ecx, 2
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax

loc_2711:				; CODE XREF: icu_56::NFRuleList::add(icu_56::NFRule *)+2Fj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jz	short loc_273B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	edx, [ebp+arg_0]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_274F
; ---------------------------------------------------------------------------

loc_273B:				; CODE XREF: icu_56::NFRuleList::add(icu_56::NFRule *)+63j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_274F:				; CODE XREF: icu_56::NFRuleList::add(icu_56::NFRule *)+85j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?add@NFRuleList@icu_56@@QAEXPAVNFRule@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2768h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRuleSet *this, struct icu_56::NFRule	*)
		public ?setNonNumericalRule@NFRuleSet@icu_56@@QAEXPAVNFRule@2@@Z
?setNonNumericalRule@NFRuleSet@icu_56@@QAEXPAVNFRule@2@@Z proc near

var_128		= dword	ptr -128h
var_120		= dword	ptr -120h
var_114		= dword	ptr -114h
var_108		= dword	ptr -108h
var_FC		= dword	ptr -0FCh
var_F0		= dword	ptr -0F0h
var_E4		= dword	ptr -0E4h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 128h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_128]
		mov	ecx, 4Ah ; 'J'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_18]
		and	eax, [ebp+var_14]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_27F2
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4Ch]
		mov	[ebp+var_114], ecx
		mov	edx, [ebp+var_114]
		mov	[ebp+var_120], edx
		cmp	[ebp+var_120], 0
		jz	short loc_27DA
		push	1
		mov	ecx, [ebp+var_120]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_128], eax
		jmp	short loc_27E4
; ---------------------------------------------------------------------------

loc_27DA:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+5Bj
		mov	[ebp+var_128], 0

loc_27E4:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+70j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4Ch], ecx
		jmp	loc_2901
; ---------------------------------------------------------------------------

loc_27F2:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+3Aj
		cmp	[ebp+var_18], 0FFFFFFFEh
		jnz	short loc_2813
		cmp	[ebp+var_14], 0FFFFFFFFh
		jnz	short loc_2813
		push	1		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NFRule	*
		push	1		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z ; icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule	*,signed char)
		jmp	loc_2901
; ---------------------------------------------------------------------------

loc_2813:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+8Ej
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+94j
		cmp	[ebp+var_18], 0FFFFFFFDh
		jnz	short loc_2834
		cmp	[ebp+var_14], 0FFFFFFFFh
		jnz	short loc_2834
		push	1		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NFRule	*
		push	2		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z ; icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule	*,signed char)
		jmp	loc_2901
; ---------------------------------------------------------------------------

loc_2834:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+AFj
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+B5j
		cmp	[ebp+var_18], 0FFFFFFFCh
		jnz	short loc_2855
		cmp	[ebp+var_14], 0FFFFFFFFh
		jnz	short loc_2855
		push	1		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::NFRule	*
		push	3		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z ; icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule	*,signed char)
		jmp	loc_2901
; ---------------------------------------------------------------------------

loc_2855:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+D0j
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+D6j
		cmp	[ebp+var_18], 0FFFFFFFBh
		jnz	short loc_28AC
		cmp	[ebp+var_14], 0FFFFFFFFh
		jnz	short loc_28AC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+5Ch]
		mov	[ebp+var_FC], ecx
		mov	edx, [ebp+var_FC]
		mov	[ebp+var_108], edx
		cmp	[ebp+var_108], 0
		jz	short loc_2897
		push	1
		mov	ecx, [ebp+var_108]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_128], eax
		jmp	short loc_28A1
; ---------------------------------------------------------------------------

loc_2897:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+118j
		mov	[ebp+var_128], 0

loc_28A1:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+12Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+5Ch], ecx
		jmp	short loc_2901
; ---------------------------------------------------------------------------

loc_28AC:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+F1j
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+F7j
		cmp	[ebp+var_18], 0FFFFFFFAh
		jnz	short loc_2901
		cmp	[ebp+var_14], 0FFFFFFFFh
		jnz	short loc_2901
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+60h]
		mov	[ebp+var_E4], ecx
		mov	edx, [ebp+var_E4]
		mov	[ebp+var_F0], edx
		cmp	[ebp+var_F0], 0
		jz	short loc_28EE
		push	1
		mov	ecx, [ebp+var_F0]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_128], eax
		jmp	short loc_28F8
; ---------------------------------------------------------------------------

loc_28EE:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+16Fj
		mov	[ebp+var_128], 0

loc_28F8:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+184j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+60h], ecx

loc_2901:				; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+85j
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+A6j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 128h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setNonNumericalRule@NFRuleSet@icu_56@@QAEXPAVNFRule@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2918h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::setBestFractionRule(icu_56::NFRuleSet *this, int, struct icu_56::NFRule *,	signed __int8)
		public ?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z
?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z proc near
					; CODE XREF: icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule *)+A1p
					; icu_56::NFRuleSet::setNonNumericalRule(icu_56::NFRule	*)+C2p	...

var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
var_144		= byte ptr -144h
var_F9		= byte ptr -0F9h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 144h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_150]
		mov	ecx, 51h ; 'Q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_2974
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::NFRule	*
		mov	ecx, [ebp+var_18]
		add	ecx, 68h ; 'h'  ; this
		call	?add@NFRuleList@icu_56@@QAEXPAVNFRule@2@@Z ; icu_56::NFRuleList::add(icu_56::NFRule *)

loc_2974:				; CODE XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+4Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+eax*4+4Ch]
		mov	[ebp+var_24], edx
		cmp	[ebp+var_24], 0
		jnz	short loc_2999
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+arg_4]
		mov	[ecx+eax*4+4Ch], edx
		jmp	loc_2A37
; ---------------------------------------------------------------------------

loc_2999:				; CODE XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+6Dj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+64h]	; this
		call	?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ ; icu_56::RuleBasedNumberFormat::getDecimalFormatSymbols(void)
		mov	[ebp+var_30], eax
		mov	esi, esp
		push	0		; int
		push	0
		lea	eax, [ebp+var_144]
		push	eax
		mov	ecx, [ebp+var_30]
		call	?getSymbol@DecimalFormatSymbols@icu_56@@QBE?AVUnicodeString@2@W4ENumberFormatSymbol@12@@Z ; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)
		mov	[ebp+var_14C], eax
		mov	ecx, [ebp+var_14C]
		mov	[ebp+var_150], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_150] ; this
		call	dword ptr ds:__imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	esi, ax
		mov	ecx, [ebp+arg_4] ; this
		call	?getDecimalPoint@NFRule@icu_56@@QBE_WXZ	; icu_56::NFRule::getDecimalPoint(void)
		movzx	edx, ax
		xor	eax, eax
		cmp	esi, edx
		setz	al
		mov	[ebp+var_F9], al
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_144] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	ecx, [ebp+var_F9]
		test	ecx, ecx
		jz	short loc_2A37
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+arg_4]
		mov	[ecx+eax*4+4Ch], edx

loc_2A37:				; CODE XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+7Cj
					; icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed char)+110j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 150h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2A64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z$0 proc near
					; DATA XREF: .xdata$x:00002AA8o
		mov	esi, esp
		lea	ecx, [ebp-144h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z	proc near
					; DATA XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-154h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2AA4h
__unwindtable$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002AB4o
		dd offset __unwindfunclet$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z$0
__ehfuncinfo$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z+1Eo
		dd offset __unwindtable$?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::NFRule::getDecimalPoint(icu_56::NFRule *__hidden this)
		public ?getDecimalPoint@NFRule@icu_56@@QBE_WXZ
?getDecimalPoint@NFRule@icu_56@@QBE_WXZ	proc near
					; CODE XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+D6p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ax, [eax+0Eh]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDecimalPoint@NFRule@icu_56@@QBE_WXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::NFRuleSet::~NFRuleSet(icu_56::NFRuleSet *__hidden this)
		public ??1NFRuleSet@icu_56@@QAE@XZ
??1NFRuleSet@icu_56@@QAE@XZ proc near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1NFRuleSet@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 2
		mov	[ebp+var_20], 0
		jmp	short loc_2B5F
; ---------------------------------------------------------------------------

loc_2B56:				; CODE XREF: icu_56::NFRuleSet::~NFRuleSet(void):loc_2BBBj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_2B5F:				; CODE XREF: icu_56::NFRuleSet::~NFRuleSet(void)+50j
		cmp	[ebp+var_20], 6
		jge	short loc_2BBD
		cmp	[ebp+var_20], 1
		jz	short loc_2BBB
		cmp	[ebp+var_20], 2
		jz	short loc_2BBB
		cmp	[ebp+var_20], 3
		jz	short loc_2BBB
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4+4Ch]
		mov	[ebp+var_EC], edx
		mov	eax, [ebp+var_EC]
		mov	[ebp+var_F8], eax
		cmp	[ebp+var_F8], 0
		jz	short loc_2BB1
		push	1
		mov	ecx, [ebp+var_F8]
		call	??_GNFRule@icu_56@@QAEPAXI@Z ; icu_56::NFRule::`scalar deleting	destructor'(uint)
		mov	[ebp+var_100], eax
		jmp	short loc_2BBB
; ---------------------------------------------------------------------------

loc_2BB1:				; CODE XREF: icu_56::NFRuleSet::~NFRuleSet(void)+96j
		mov	[ebp+var_100], 0

loc_2BBB:				; CODE XREF: icu_56::NFRuleSet::~NFRuleSet(void)+65j
					; icu_56::NFRuleSet::~NFRuleSet(void)+6Bj ...
		jmp	short loc_2B56
; ---------------------------------------------------------------------------

loc_2BBD:				; CODE XREF: icu_56::NFRuleSet::~NFRuleSet(void)+5Fj
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		add	ecx, 68h ; 'h'  ; this
		call	??1NFRuleList@icu_56@@QAE@XZ ; icu_56::NFRuleList::~NFRuleList(void)
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 40h ; '@'  ; this
		call	??1NFRuleList@icu_56@@QAE@XZ ; icu_56::NFRuleList::~NFRuleList(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1NFRuleSet@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2C14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$0 proc near	; DATA XREF: .xdata$x:00002C60o
		mov	esi, esp
		mov	ecx, [ebp-14h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$1 proc near	; DATA XREF: .xdata$x:00002C68o
		mov	ecx, [ebp-14h]
		add	ecx, 40h ; '@'  ; this
		jmp	??1NFRuleList@icu_56@@QAE@XZ ; icu_56::NFRuleList::~NFRuleList(void)
__unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$2 proc near	; DATA XREF: .xdata$x:00002C70o
		mov	ecx, [ebp-14h]
		add	ecx, 68h ; 'h'  ; this
		jmp	??1NFRuleList@icu_56@@QAE@XZ ; icu_56::NFRuleList::~NFRuleList(void)
__unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1NFRuleSet@icu_56@@QAE@XZ	proc near
					; DATA XREF: icu_56::NFRuleSet::~NFRuleSet(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1NFRuleSet@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1NFRuleSet@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2C5Ch
__unwindtable$??1NFRuleSet@icu_56@@QAE@XZ dd 0FFFFFFFFh	; DATA XREF: .xdata$x:00002C7Co
		dd offset __unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$0
		align 8
		dd offset __unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1NFRuleSet@icu_56@@QAE@XZ$2
__ehfuncinfo$??1NFRuleSet@icu_56@@QAE@XZ dd 19930522h, 3
					; DATA XREF: __ehhandler$??1NFRuleSet@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1NFRuleSet@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::NFRuleSet::operator==(class icu_56::NFRuleSet const &)const
		public ??8NFRuleSet@icu_56@@QBECABV01@@Z
??8NFRuleSet@icu_56@@QBECABV01@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	esi, eax
		jnz	loc_2DAE
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+74h]
		mov	edx, [ebp+arg_0]
		movsx	eax, byte ptr [edx+74h]
		cmp	ecx, eax
		jnz	loc_2DAE
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_??8UnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_2DAE
		mov	[ebp+var_14], 0
		jmp	short loc_2D24
; ---------------------------------------------------------------------------

loc_2D1B:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &):loc_2D53j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_2D24:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+81j
		cmp	[ebp+var_14], 6
		jge	short loc_2D55
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+4Ch]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4+4Ch]
		push	edx
		call	?util_equalRules@icu_56@@YACPBVNFRule@1@0@Z ; icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule const *)
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2D53
		xor	al, al
		jmp	short loc_2DB0
; ---------------------------------------------------------------------------

loc_2D53:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+B5j
		jmp	short loc_2D1B
; ---------------------------------------------------------------------------

loc_2D55:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+90j
		mov	[ebp+var_20], 0
		jmp	short loc_2D67
; ---------------------------------------------------------------------------

loc_2D5E:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &):loc_2DA8j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_2D67:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+C4j
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_20], eax
		jnb	short loc_2DAA
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax
		call	??9NFRule@icu_56@@QBECABV01@@Z ; icu_56::NFRule::operator!=(icu_56::NFRule const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_2DA8
		xor	al, al
		jmp	short loc_2DB0
; ---------------------------------------------------------------------------

loc_2DA8:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+10Aj
		jmp	short loc_2D5E
; ---------------------------------------------------------------------------

loc_2DAA:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+DDj
		mov	al, 1
		jmp	short loc_2DB0
; ---------------------------------------------------------------------------

loc_2DAE:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+3Dj
					; icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const	&)+53j	...
		xor	al, al

loc_2DB0:				; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+B9j
					; icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const	&)+10Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8NFRuleSet@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::NFRule::operator!=(class icu_56::NFRule const &)const
		public ??9NFRule@icu_56@@QBECABV01@@Z
??9NFRule@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+100p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8NFRule@icu_56@@QBECABV01@@Z ; icu_56::NFRule::operator==(icu_56::NFRule const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9NFRule@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl icu_56::util_equalRules(class icu_56::NFRule const *, class icu_56::NFRule const *)
?util_equalRules@icu_56@@YACPBVNFRule@1@0@Z proc near
					; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+A8p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_2E52
		cmp	[ebp+arg_4], 0
		jz	short loc_2E50
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??8NFRule@icu_56@@QBECABV01@@Z ; icu_56::NFRule::operator==(icu_56::NFRule const &)
		jmp	short loc_2E5E
; ---------------------------------------------------------------------------

loc_2E50:				; CODE XREF: icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule const *)+28j
		jmp	short loc_2E5C
; ---------------------------------------------------------------------------

loc_2E52:				; CODE XREF: icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule const *)+22j
		cmp	[ebp+arg_4], 0
		jnz	short loc_2E5C
		mov	al, 1
		jmp	short loc_2E5E
; ---------------------------------------------------------------------------

loc_2E5C:				; CODE XREF: icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule const *):loc_2E50j
					; icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule	const *)+3Ej
		xor	al, al

loc_2E5E:				; CODE XREF: icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule const *)+36j
					; icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule	const *)+42j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?util_equalRules@icu_56@@YACPBVNFRule@1@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::NFRuleSet *this, const struct icu_56::DecimalFormatSymbols	*, enum	UErrorCode *)
		public ?setDecimalFormatSymbols@NFRuleSet@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z
?setDecimalFormatSymbols@NFRuleSet@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z proc near

var_124		= dword	ptr -124h
var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_2EA9
; ---------------------------------------------------------------------------

loc_2EA0:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+63j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_2EA9:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+2Aj
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_14], eax
		jnb	short loc_2ED9
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	edx, [ebp+var_14]
		push	edx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?setDecimalFormatSymbols@NFRule@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z ; icu_56::NFRule::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols	const &,UErrorCode &)
		jmp	short loc_2EA0
; ---------------------------------------------------------------------------

loc_2ED9:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+43j
		mov	[ebp+var_20], 1
		jmp	short loc_2EEB
; ---------------------------------------------------------------------------

loc_2EE2:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&):loc_2FA0j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_2EEB:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+6Cj
		cmp	[ebp+var_20], 3
		jg	loc_2FA5
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+eax*4+4Ch], 0
		jz	loc_2FA0
		mov	[ebp+var_2C], 0
		jmp	short loc_2F18
; ---------------------------------------------------------------------------

loc_2F0F:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&):loc_2F9Bj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_2F18:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+99j
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_2C], eax
		jnb	short loc_2FA0
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+eax*4+4Ch] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	esi, eax
		mov	edi, edx
		mov	ecx, [ebp+var_38] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_11C], esi
		mov	[ebp+var_118], edi
		mov	[ebp+var_124], eax
		mov	[ebp+var_120], edx
		mov	edx, [ebp+var_11C]
		cmp	edx, [ebp+var_124]
		jnz	short loc_2F9B
		mov	eax, [ebp+var_118]
		cmp	eax, [ebp+var_120]
		jnz	short loc_2F9B
		push	0		; signed __int8
		mov	eax, [ebp+var_38]
		push	eax		; struct icu_56::NFRule	*
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setBestFractionRule@NFRuleSet@icu_56@@QAEXHPAVNFRule@2@C@Z ; icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule	*,signed char)

loc_2F9B:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+105j
					; icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const	&,UErrorCode &)+113j
		jmp	loc_2F0F
; ---------------------------------------------------------------------------

loc_2FA0:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+8Cj
					; icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const	&,UErrorCode &)+B2j
		jmp	loc_2EE2
; ---------------------------------------------------------------------------

loc_2FA5:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+7Bj
		mov	[ebp+var_44], 0
		jmp	short loc_2FB7
; ---------------------------------------------------------------------------

loc_2FAE:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&):loc_2FE0j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_2FB7:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+138j
		cmp	[ebp+var_44], 6
		jnb	short loc_2FE2
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4+4Ch]
		mov	[ebp+var_50], edx
		cmp	[ebp+var_50], 0
		jz	short loc_2FE0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::DecimalFormatSymbols *
		mov	ecx, [ebp+var_50] ; this
		call	?setDecimalFormatSymbols@NFRule@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z ; icu_56::NFRule::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols	const &,UErrorCode &)

loc_2FE0:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+15Aj
		jmp	short loc_2FAE
; ---------------------------------------------------------------------------

loc_2FE2:				; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+147j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setDecimalFormatSymbols@NFRuleSet@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::format(icu_56::NFRuleSet *this, __int64, struct icu_56::UnicodeString *, int, int,	enum UErrorCode	*)
		public ?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z
?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp

loc_2FFB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_10], 40h ; '@'
		jl	short loc_302C
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1Bh
		jmp	short loc_306E
; ---------------------------------------------------------------------------

loc_302C:				; CODE XREF: icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)+27j
		mov	eax, dword ptr [ebp+arg_0+4]
		push	eax
		mov	ecx, dword ptr [ebp+arg_0]
		push	ecx		; __int64
		mov	ecx, [ebp+var_8] ; this
		call	?findNormalRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@_J@Z ;	icu_56::NFRuleSet::findNormalRule(__int64)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_306E
		mov	eax, [ebp+arg_10]
		add	eax, 1
		mov	[ebp+arg_10], eax
		mov	ecx, [ebp+arg_14]
		push	ecx		; enum UErrorCode *
		mov	edx, [ebp+arg_10]
		push	edx		; int
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, dword ptr [ebp+arg_0+4]
		push	edx
		mov	eax, dword ptr [ebp+arg_0]
		push	eax		; __int64
		mov	ecx, [ebp+var_14] ; this
		call	?doFormat@NFRule@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z ; icu_56::NFRule::doFormat(__int64,icu_56::UnicodeString	&,int,int,UErrorCode &)

loc_306E:				; CODE XREF: icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)+32j
					; icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)+4Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?format@NFRuleSet@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::format(icu_56::NFRuleSet *this, double, struct icu_56::UnicodeString *, int, int, enum UErrorCode *)
		public ?format@NFRuleSet@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z
?format@NFRuleSet@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z proc near

var_FC		= qword	ptr -0FCh
var_EC		= qword	ptr -0ECh
var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_10], 40h ; '@'
		jl	short loc_30B8
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1Bh
		jmp	short loc_30FC
; ---------------------------------------------------------------------------

loc_30B8:				; CODE XREF: icu_56::NFRuleSet::format(double,icu_56::UnicodeString &,int,int,UErrorCode &)+27j
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0ECh+var_EC] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findDoubleRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z ; icu_56::NFRuleSet::findDoubleRule(double)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_30FC
		mov	eax, [ebp+arg_10]
		add	eax, 1
		mov	[ebp+arg_10], eax
		mov	ecx, [ebp+arg_14]
		push	ecx		; enum UErrorCode *
		mov	edx, [ebp+arg_10]
		push	edx		; int
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	[esp+0FCh+var_FC] ; double
		mov	ecx, [ebp+var_14] ; this
		call	?doFormat@NFRule@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z ;	icu_56::NFRule::doFormat(double,icu_56::UnicodeString &,int,int,UErrorCode &)

loc_30FC:				; CODE XREF: icu_56::NFRuleSet::format(double,icu_56::UnicodeString &,int,int,UErrorCode &)+32j
					; icu_56::NFRuleSet::format(double,icu_56::UnicodeString &,int,int,UErrorCode &)+4Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?format@NFRuleSet@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3114h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::NFRule *__thiscall icu_56::NFRuleSet::findDoubleRule(icu_56::NFRuleSet *this, double)
		public ?findDoubleRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z
?findDoubleRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z proc near
					; CODE XREF: icu_56::NFRuleSet::format(double,icu_56::UnicodeString &,int,int,UErrorCode &)+40p

var_108		= dword	ptr -108h
var_F4		= byte ptr -0F4h
var_30		= qword	ptr -30h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx		; double
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFractionRuleSet@NFRuleSet@icu_56@@QBECXZ ; icu_56::NFRuleSet::isFractionRuleSet(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_315C
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	qword ptr [esp+108h+var_108] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findFractionRuleSetRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z ;	icu_56::NFRuleSet::findFractionRuleSetRule(double)
		jmp	loc_328B
; ---------------------------------------------------------------------------

loc_315C:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+30j
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	qword ptr [esp+108h+var_108]
		call	_uprv_isNaN_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jz	short loc_3199
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+60h]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jnz	short loc_3191
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+64h]	; this
		call	?getDefaultNaNRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ ; icu_56::RuleBasedNumberFormat::getDefaultNaNRule(void)
		mov	[ebp+var_14], eax

loc_3191:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+6Dj
		mov	eax, [ebp+var_14]
		jmp	loc_328B
; ---------------------------------------------------------------------------

loc_3199:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+5Ej
		fldz
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_31C3
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	short loc_31BB
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4Ch]
		jmp	loc_328B
; ---------------------------------------------------------------------------
		jmp	short loc_31C3
; ---------------------------------------------------------------------------

loc_31BB:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+98j
		fld	[ebp+arg_0]
		fchs
		fstp	[ebp+arg_0]

loc_31C3:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+8Fj
					; icu_56::NFRuleSet::findDoubleRule(double)+A5j
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	qword ptr [esp+108h+var_108]
		call	_uprv_isInfinite_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jz	short loc_3200
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+5Ch]
		mov	[ebp+var_20], ecx
		cmp	[ebp+var_20], 0
		jnz	short loc_31F8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+64h]	; this
		call	?getDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ	; icu_56::RuleBasedNumberFormat::getDefaultInfinityRule(void)
		mov	[ebp+var_20], eax

loc_31F8:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+D4j
		mov	eax, [ebp+var_20]
		jmp	loc_328B
; ---------------------------------------------------------------------------

loc_3200:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+C5j
		sub	esp, 8
		fld	[ebp+arg_0]
		fstp	qword ptr [esp+108h+var_108]
		call	_uprv_floor_56
		add	esp, 8
		fld	[ebp+arg_0]
		fucompp
		fnstsw	ax
		test	ah, 44h
		jnp	short loc_324D
		fld1
		fcomp	[ebp+arg_0]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_323C
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jz	short loc_323C
		mov	eax, [ebp+var_8]
		mov	eax, [eax+54h]
		jmp	short loc_328B
; ---------------------------------------------------------------------------
		jmp	short loc_324D
; ---------------------------------------------------------------------------

loc_323C:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+113j
					; icu_56::NFRuleSet::findDoubleRule(double)+11Cj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		jz	short loc_324D
		mov	eax, [ebp+var_8]
		mov	eax, [eax+50h]
		jmp	short loc_328B
; ---------------------------------------------------------------------------

loc_324D:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+107j
					; icu_56::NFRuleSet::findDoubleRule(double)+126j ...
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+58h], 0
		jz	short loc_325E
		mov	eax, [ebp+var_8]
		mov	eax, [eax+58h]
		jmp	short loc_328B
; ---------------------------------------------------------------------------

loc_325E:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+140j
		fld	[ebp+arg_0]
		fadd	ds:__real@3fe0000000000000
		sub	esp, 8
		fstp	qword ptr [esp+108h+var_108] ; this
		call	?util64_fromDouble@icu_56@@YA_JN@Z ; icu_56::util64_fromDouble(double)
		add	esp, 8
		mov	dword ptr [ebp+var_30],	eax
		mov	dword ptr [ebp+var_30+4], edx
		mov	eax, dword ptr [ebp+var_30+4]
		push	eax
		mov	ecx, dword ptr [ebp+var_30]
		push	ecx		; __int64
		mov	ecx, [ebp+var_8] ; this
		call	?findNormalRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@_J@Z ;	icu_56::NFRuleSet::findNormalRule(__int64)

loc_328B:				; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+43j
					; icu_56::NFRuleSet::findDoubleRule(double)+80j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findDoubleRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 32A4h
		public __real@3fe0000000000000
__real@3fe0000000000000	dq 0.5		; DATA XREF: icu_56::NFRuleSet::findDoubleRule(double)+14Dr
					; icu_56::NFRuleSet::findFractionRuleSetRule(double)+95r ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 32ACh
		public __real@3ff0000000000000
__real@3ff0000000000000	dd 0
		dd 3FF00000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NFRuleSet::isFractionRuleSet(icu_56::NFRuleSet *__hidden this)
		public ?isFractionRuleSet@NFRuleSet@icu_56@@QBECXZ
?isFractionRuleSet@NFRuleSet@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+74h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isFractionRuleSet@NFRuleSet@icu_56@@QBECXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::NFRule *__thiscall icu_56::NFRuleSet::findNormalRule(icu_56::NFRuleSet *this, __int64)
		public ?findNormalRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@_J@Z
?findNormalRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@_J@Z proc near
					; CODE XREF: icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)+3Fp
					; icu_56::NFRuleSet::findDoubleRule(double)+172p

var_118		= qword	ptr -118h
var_104		= dword	ptr -104h
var_100		= dword	ptr -100h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 104h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_104]
		mov	ecx, 41h ; 'A'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+74h]
		test	ecx, ecx
		jz	short loc_3328
		fild	[ebp+arg_0]
		sub	esp, 8
		fstp	[esp+118h+var_118] ; double
		mov	ecx, [ebp+var_8] ; this
		call	?findFractionRuleSetRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z ;	icu_56::NFRuleSet::findFractionRuleSetRule(double)
		jmp	loc_3497
; ---------------------------------------------------------------------------

loc_3328:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+2Cj
		cmp	dword ptr [ebp+arg_0+4], 0
		jg	short loc_335F
		jl	short loc_3336
		cmp	dword ptr [ebp+arg_0], 0
		jnb	short loc_335F

loc_3336:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+4Aj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		jz	short loc_334C
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4Ch]
		jmp	loc_3497
; ---------------------------------------------------------------------------
		jmp	short loc_335F
; ---------------------------------------------------------------------------

loc_334C:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+59j
		mov	eax, dword ptr [ebp+arg_0]
		neg	eax
		mov	ecx, dword ptr [ebp+arg_0+4]
		adc	ecx, 0
		neg	ecx
		mov	dword ptr [ebp+arg_0], eax
		mov	dword ptr [ebp+arg_0+4], ecx

loc_335F:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+48j
					; icu_56::NFRuleSet::findNormalRule(__int64)+50j ...
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jle	loc_3491
		mov	[ebp+var_20], 0

loc_337E:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64):loc_3431j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	loc_3436
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_14]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		mov	ecx, [ebp+var_104]
		cmp	ecx, dword ptr [ebp+arg_0]
		jnz	short loc_33E6
		mov	edx, [ebp+var_100]
		cmp	edx, dword ptr [ebp+arg_0+4]
		jnz	short loc_33E6
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		jmp	loc_3497
; ---------------------------------------------------------------------------
		jmp	short loc_3431
; ---------------------------------------------------------------------------

loc_33E6:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+DFj
					; icu_56::NFRuleSet::findNormalRule(__int64)+EAj
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		mov	ecx, [ebp+var_100]
		cmp	ecx, dword ptr [ebp+arg_0+4]
		jl	short loc_3428
		jg	short loc_3420
		mov	edx, [ebp+var_104]
		cmp	edx, dword ptr [ebp+arg_0]
		jbe	short loc_3428

loc_3420:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+12Fj
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax
		jmp	short loc_3431
; ---------------------------------------------------------------------------

loc_3428:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+12Dj
					; icu_56::NFRuleSet::findNormalRule(__int64)+13Aj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_3431:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+100j
					; icu_56::NFRuleSet::findNormalRule(__int64)+142j
		jmp	loc_337E
; ---------------------------------------------------------------------------

loc_3436:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+A0j
		cmp	[ebp+var_14], 0
		jnz	short loc_3440
		xor	eax, eax
		jmp	short loc_3497
; ---------------------------------------------------------------------------

loc_3440:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+156j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	[ebp+var_38], eax
		fild	[ebp+arg_0]
		sub	esp, 8
		fstp	[esp+118h+var_118] ; double
		mov	ecx, [ebp+var_38] ; this
		call	?shouldRollBack@NFRule@icu_56@@QBECN@Z ; icu_56::NFRule::shouldRollBack(double)
		movsx	eax, al
		test	eax, eax
		jz	short loc_348C
		cmp	[ebp+var_14], 1
		jnz	short loc_3477
		xor	eax, eax
		jmp	short loc_3497
; ---------------------------------------------------------------------------

loc_3477:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+18Dj
		mov	eax, [ebp+var_14]
		sub	eax, 2
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	[ebp+var_38], eax

loc_348C:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+187j
		mov	eax, [ebp+var_38]
		jmp	short loc_3497
; ---------------------------------------------------------------------------

loc_3491:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+8Dj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+58h]

loc_3497:				; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+3Fj
					; icu_56::NFRuleSet::findNormalRule(__int64)+61j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 104h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findNormalRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@_J@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::NFRule *__thiscall icu_56::NFRuleSet::findFractionRuleSetRule(icu_56::NFRuleSet *this, double)
		public ?findFractionRuleSetRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z
?findFractionRuleSetRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z proc near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+3Ep
					; icu_56::NFRuleSet::findNormalRule(__int64)+3Ap

var_164		= dword	ptr -164h
var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
var_148		= qword	ptr -148h
var_7C		= qword	ptr -7Ch
var_6C		= dword	ptr -6Ch
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_34		= dword	ptr -34h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_18		= qword	ptr -18h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 150h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_150]
		mov	ecx, 54h ; 'T'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	dword ptr [ebp+var_18],	eax
		mov	dword ptr [ebp+var_18+4], edx
		mov	[ebp+var_34], 1
		jmp	short loc_34FF
; ---------------------------------------------------------------------------

loc_34F6:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+8Dj
		mov	eax, [ebp+var_34]
		add	eax, 1
		mov	[ebp+var_34], eax

loc_34FF:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+44j
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_34], eax
		jnb	short loc_353F
		mov	eax, [ebp+var_34]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		push	edx		; double
		push	eax
		mov	ecx, dword ptr [ebp+var_18+4]
		push	ecx
		mov	edx, dword ptr [ebp+var_18]
		push	edx
		call	?util_lcm@icu_56@@YA_J_J0@Z ; icu_56::util_lcm(__int64,__int64)
		add	esp, 10h
		mov	dword ptr [ebp+var_18],	eax
		mov	dword ptr [ebp+var_18+4], edx
		jmp	short loc_34F6
; ---------------------------------------------------------------------------

loc_353F:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+5Dj
		fild	[ebp+var_18]
		fmul	[ebp+arg_0]
		fadd	ds:__real@3fe0000000000000
		sub	esp, 8
		fstp	qword ptr [esp+164h+var_164] ; this
		call	?util64_fromDouble@icu_56@@YA_JN@Z ; icu_56::util64_fromDouble(double)
		add	esp, 8
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], edx
		call	_uprv_maxMantissa_56
		sub	esp, 8
		fstp	qword ptr [esp+164h+var_164] ; this
		call	?util64_fromDouble@icu_56@@YA_JN@Z ; icu_56::util64_fromDouble(double)
		add	esp, 8
		mov	[ebp+var_54], eax
		mov	[ebp+var_50], edx
		mov	[ebp+var_60], 0
		mov	[ebp+var_6C], 0
		jmp	short loc_3591
; ---------------------------------------------------------------------------

loc_3588:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double):loc_364Fj
		mov	eax, [ebp+var_6C]
		add	eax, 1
		mov	[ebp+var_6C], eax

loc_3591:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+D6j
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_6C], eax
		jnb	loc_3654
		mov	eax, [ebp+var_6C]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		push	edx
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		mov	edx, [ebp+var_28]
		push	edx
		call	__allmul
		mov	ecx, dword ptr [ebp+var_18+4]
		push	ecx
		mov	ecx, dword ptr [ebp+var_18]
		push	ecx
		push	edx
		push	eax
		call	__allrem
		mov	[ebp+var_44], eax
		mov	[ebp+var_40], edx
		mov	eax, dword ptr [ebp+var_18]
		sub	eax, [ebp+var_44]
		mov	ecx, dword ptr [ebp+var_18+4]
		sbb	ecx, [ebp+var_40]
		mov	dword ptr [ebp+var_148], eax
		mov	dword ptr [ebp+var_148+4], ecx
		mov	edx, dword ptr [ebp+var_148+4]
		cmp	edx, [ebp+var_40]
		jg	short loc_3621
		jl	short loc_360F
		mov	eax, dword ptr [ebp+var_148]
		cmp	eax, [ebp+var_44]
		jnb	short loc_3621

loc_360F:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+152j
		mov	eax, dword ptr [ebp+var_18]
		sub	eax, [ebp+var_44]
		mov	ecx, dword ptr [ebp+var_18+4]
		sbb	ecx, [ebp+var_40]
		mov	[ebp+var_44], eax
		mov	[ebp+var_40], ecx

loc_3621:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+150j
					; icu_56::NFRuleSet::findFractionRuleSetRule(double)+15Dj
		mov	eax, [ebp+var_40]
		cmp	eax, [ebp+var_50]
		jg	short loc_364F
		jl	short loc_3633
		mov	ecx, [ebp+var_44]
		cmp	ecx, [ebp+var_54]
		jnb	short loc_364F

loc_3633:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+179j
		mov	eax, [ebp+var_44]
		mov	[ebp+var_54], eax
		mov	ecx, [ebp+var_40]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_54]
		or	eax, [ebp+var_50]
		jnz	short loc_364F
		jmp	short loc_3654
; ---------------------------------------------------------------------------

loc_364F:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+177j
					; icu_56::NFRuleSet::findFractionRuleSetRule(double)+181j ...
		jmp	loc_3588
; ---------------------------------------------------------------------------

loc_3654:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+EFj
					; icu_56::NFRuleSet::findFractionRuleSetRule(double)+19Dj
		mov	esi, [ebp+var_60]
		add	esi, 1
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	esi, eax
		jnb	loc_372B
		mov	eax, [ebp+var_60]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	esi, eax
		mov	edi, edx
		mov	ecx, [ebp+var_60]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	dword ptr [ebp+var_148], esi
		mov	dword ptr [ebp+var_148+4], edi
		mov	[ebp+var_150], eax
		mov	[ebp+var_14C], edx
		mov	edx, dword ptr [ebp+var_148]
		cmp	edx, [ebp+var_150]
		jnz	short loc_372B
		mov	eax, dword ptr [ebp+var_148+4]
		cmp	eax, [ebp+var_14C]
		jnz	short loc_372B
		mov	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	dword ptr [ebp+var_148], eax
		mov	dword ptr [ebp+var_148+4], edx
		fild	[ebp+var_148]
		fmul	[ebp+arg_0]
		fstp	[ebp+var_7C]
		fld	ds:__real@3fe0000000000000
		fcomp	[ebp+var_7C]
		fnstsw	ax
		test	ah, 41h
		jz	short loc_3722
		fld	ds:__real@4000000000000000
		fcomp	[ebp+var_7C]
		fnstsw	ax
		test	ah, 41h
		jp	short loc_372B

loc_3722:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+260j
		mov	eax, [ebp+var_60]
		add	eax, 1
		mov	[ebp+var_60], eax

loc_372B:				; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+1B7j
					; icu_56::NFRuleSet::findFractionRuleSetRule(double)+214j ...
		mov	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 150h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findFractionRuleSetRule@NFRuleSet@icu_56@@ABEPBVNFRule@2@N@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3750h
		public __real@4000000000000000
__real@4000000000000000	dq 2.0		; DATA XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+262r
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3758h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __cdecl icu_56::util_lcm(__int64, __int64)
?util_lcm@icu_56@@YA_J_J0@Z proc near	; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+7Fp

var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_28		= dword	ptr -28h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_1C], eax
		mov	ecx, [ebp+arg_C]
		mov	[ebp+var_18], ecx
		mov	[ebp+var_28], 0

loc_3795:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+B8j
		mov	eax, [ebp+var_C]
		and	eax, 1
		mov	ecx, [ebp+var_8]
		and	ecx, 0
		mov	[ebp+var_114], eax
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_114]
		or	edx, [ebp+var_110]
		jnz	short loc_3812
		mov	eax, [ebp+var_1C]
		and	eax, 1
		mov	ecx, [ebp+var_18]
		and	ecx, 0
		mov	[ebp+var_114], eax
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_114]
		or	edx, [ebp+var_110]
		jnz	short loc_3812
		mov	eax, [ebp+var_28]
		add	eax, 1
		mov	[ebp+var_28], eax
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		mov	cl, 1
		call	__allshr
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_1C]
		mov	edx, [ebp+var_18]
		mov	cl, 1
		call	__allshr
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], edx
		jmp	short loc_3795
; ---------------------------------------------------------------------------

loc_3812:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+61j
					; icu_56::util_lcm(__int64,__int64)+87j
		mov	eax, [ebp+var_C]
		and	eax, 1
		mov	ecx, [ebp+var_8]
		and	ecx, 0
		mov	[ebp+var_114], eax
		mov	[ebp+var_110], ecx
		cmp	[ebp+var_114], 1
		jnz	short loc_3851
		cmp	[ebp+var_110], 0
		jnz	short loc_3851
		mov	eax, [ebp+var_1C]
		neg	eax
		mov	ecx, [ebp+var_18]
		adc	ecx, 0
		neg	ecx
		mov	[ebp+var_38], eax
		mov	[ebp+var_34], ecx
		jmp	short loc_385D
; ---------------------------------------------------------------------------

loc_3851:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+D9j
					; icu_56::util_lcm(__int64,__int64)+E2j
		mov	eax, [ebp+var_C]
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_8]
		mov	[ebp+var_34], ecx

loc_385D:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+F7j
					; icu_56::util_lcm(__int64,__int64)+18Dj
		mov	eax, [ebp+var_38]
		or	eax, [ebp+var_34]
		jz	loc_38EA

loc_3869:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+14Aj
		mov	eax, [ebp+var_38]
		and	eax, 1
		mov	ecx, [ebp+var_34]
		and	ecx, 0
		mov	[ebp+var_114], eax
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_114]
		or	edx, [ebp+var_110]
		jnz	short loc_38A4
		mov	eax, [ebp+var_38]
		mov	edx, [ebp+var_34]
		mov	cl, 1
		call	__allshr
		mov	[ebp+var_38], eax
		mov	[ebp+var_34], edx
		jmp	short loc_3869
; ---------------------------------------------------------------------------

loc_38A4:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+135j
		cmp	[ebp+var_34], 0
		jl	short loc_38C0
		jg	short loc_38B2
		cmp	[ebp+var_38], 0
		jbe	short loc_38C0

loc_38B2:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+152j
		mov	eax, [ebp+var_38]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+var_34]
		mov	[ebp+var_8], ecx
		jmp	short loc_38D3
; ---------------------------------------------------------------------------

loc_38C0:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+150j
					; icu_56::util_lcm(__int64,__int64)+158j
		mov	eax, [ebp+var_38]
		neg	eax
		mov	ecx, [ebp+var_34]
		adc	ecx, 0
		neg	ecx
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], ecx

loc_38D3:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+166j
		mov	eax, [ebp+var_C]
		sub	eax, [ebp+var_1C]
		mov	ecx, [ebp+var_8]
		sbb	ecx, [ebp+var_18]
		mov	[ebp+var_38], eax
		mov	[ebp+var_34], ecx
		jmp	loc_385D
; ---------------------------------------------------------------------------

loc_38EA:				; CODE XREF: icu_56::util_lcm(__int64,__int64)+10Bj
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		mov	ecx, [ebp+var_28]
		call	__allshl
		mov	[ebp+var_48], eax
		mov	[ebp+var_44], edx
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_48]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	__alldiv
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	edx
		push	eax
		call	__allmul
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?util_lcm@icu_56@@YA_J_J0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3938h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::NFRuleSet::parse(icu_56::NFRuleSet *this, const struct icu_56::UnicodeString	*, struct icu_56::ParsePosition	*, double, struct icu_56::Formattable *)
		public ?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z
?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z	proc near

var_340		= dword	ptr -340h
var_328		= dword	ptr -328h
var_324		= dword	ptr -324h
var_319		= byte ptr -319h
var_24D		= byte ptr -24Dh
var_244		= byte ptr -244h
var_15C		= dword	ptr -15Ch
var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
var_13D		= byte ptr -13Dh
var_134		= byte ptr -134h
var_4C		= dword	ptr -4Ch
var_40		= byte ptr -40h
var_2C		= byte ptr -2Ch
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= qword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 31Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_328]
		mov	ecx, 0C7h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		push	0		; int
		mov	ecx, [ebp+arg_10] ; this
		call	?setLong@Formattable@icu_56@@QAEXH@Z ; icu_56::Formattable::setLong(int)
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_39A4
		xor	al, al
		jmp	loc_3CAE
; ---------------------------------------------------------------------------

loc_39A4:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+63j
		mov	esi, esp
		lea	ecx, [ebp+var_2C] ; this
		call	dword ptr ds:__imp_??0ParsePosition@icu_56@@QAE@XZ ; icu_56::ParsePosition::ParsePosition(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::ParsePosition *
		lea	ecx, [ebp+var_40] ; this
		call	dword ptr ds:__imp_??0ParsePosition@icu_56@@QAE@ABV01@@Z ; icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	[ebp+var_4C], 0
		jmp	short loc_39E9
; ---------------------------------------------------------------------------

loc_39E0:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &):loc_3AC1j
		mov	eax, [ebp+var_4C]
		add	eax, 1
		mov	[ebp+var_4C], eax

loc_39E9:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+A6j
		cmp	[ebp+var_4C], 6
		jge	loc_3AC6
		mov	eax, [ebp+var_4C]
		mov	ecx, [ebp+var_18]
		cmp	dword ptr [ecx+eax*4+4Ch], 0
		jz	loc_3AC1
		lea	ecx, [ebp+var_134] ; this
		call	??0Formattable@icu_56@@QAE@XZ ;	icu_56::Formattable::Formattable(void)
		mov	byte ptr [ebp+var_4], 2
		lea	eax, [ebp+var_134]
		push	eax		; struct icu_56::Formattable *
		sub	esp, 8
		fld	[ebp+arg_8]
		fstp	qword ptr [esp+340h+var_340] ; double
		push	0		; signed __int8
		lea	ecx, [ebp+var_40]
		push	ecx		; struct icu_56::ParsePosition *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+var_4C]
		mov	ecx, [ebp+var_18]
		mov	ecx, [ecx+eax*4+4Ch] ; this
		call	?doParse@NFRule@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@CNAAVFormattable@2@@Z	; icu_56::NFRule::doParse(icu_56::UnicodeString	const &,icu_56::ParsePosition &,signed char,double,icu_56::Formattable &)
		mov	[ebp+var_13D], al
		movsx	eax, [ebp+var_13D]
		test	eax, eax
		jz	short loc_3A9C
		mov	esi, esp
		lea	ecx, [ebp+var_40] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		lea	ecx, [ebp+var_2C] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jle	short loc_3A9C
		lea	eax, [ebp+var_134]
		push	eax
		mov	ecx, [ebp+arg_10]
		call	??4Formattable@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::Formattable::operator=(icu_56::Formattable const &)
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax
		lea	ecx, [ebp+var_2C]
		call	dword ptr ds:__imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::ParsePosition::operator=(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3A9C:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+113j
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+13Dj
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; double
		lea	ecx, [ebp+var_40]
		call	dword ptr ds:__imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::ParsePosition::operator=(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_134] ; this
		call	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)

loc_3AC1:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+C6j
		jmp	loc_39E0
; ---------------------------------------------------------------------------

loc_3AC6:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+B5j
		sub	esp, 8
		fld	[ebp+arg_8]
		fstp	qword ptr [esp+33Ch+var_340+4] ; this
		call	?util64_fromDouble@icu_56@@YA_JN@Z ; icu_56::util64_fromDouble(double)
		add	esp, 8
		mov	[ebp+var_150], eax
		mov	[ebp+var_14C], edx
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		mov	[ebp+var_15C], eax

loc_3AF4:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &):loc_3B85j
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+31Fj
		mov	eax, [ebp+var_15C]
		sub	eax, 1
		mov	[ebp+var_15C], eax
		js	loc_3C5C
		mov	esi, esp
		lea	ecx, [ebp+var_2C] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jge	loc_3C5C
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+74h]
		test	ecx, ecx
		jnz	short loc_3B8A
		mov	eax, [ebp+var_15C]
		push	eax
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_328], eax
		mov	[ebp+var_324], edx
		mov	ecx, [ebp+var_324]
		cmp	ecx, [ebp+var_14C]
		jl	short loc_3B8A
		jg	short loc_3B85
		mov	edx, [ebp+var_328]
		cmp	edx, [ebp+var_150]
		jb	short loc_3B8A

loc_3B85:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+23Dj
		jmp	loc_3AF4
; ---------------------------------------------------------------------------

loc_3B8A:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+208j
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+23Bj ...
		lea	ecx, [ebp+var_244] ; this
		call	??0Formattable@icu_56@@QAE@XZ ;	icu_56::Formattable::Formattable(void)
		mov	byte ptr [ebp+var_4], 3
		lea	eax, [ebp+var_244]
		push	eax		; struct icu_56::Formattable *
		sub	esp, 8
		fld	[ebp+arg_8]
		fstp	qword ptr [esp+340h+var_340] ; double
		mov	ecx, [ebp+var_18]
		movzx	edx, byte ptr [ecx+74h]
		push	edx		; signed __int8
		lea	eax, [ebp+var_40]
		push	eax		; struct icu_56::ParsePosition *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+var_15C]
		push	edx
		mov	ecx, [ebp+var_18]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?doParse@NFRule@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@CNAAVFormattable@2@@Z	; icu_56::NFRule::doParse(icu_56::UnicodeString	const &,icu_56::ParsePosition &,signed char,double,icu_56::Formattable &)
		mov	[ebp+var_24D], al
		movsx	eax, [ebp+var_24D]
		test	eax, eax
		jz	short loc_3C32
		mov	esi, esp
		lea	ecx, [ebp+var_40] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		lea	ecx, [ebp+var_2C] ; this
		call	dword ptr ds:__imp_?getIndex@ParsePosition@icu_56@@QBEHXZ ; icu_56::ParsePosition::getIndex(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jle	short loc_3C32
		lea	eax, [ebp+var_244]
		push	eax
		mov	ecx, [ebp+arg_10]
		call	??4Formattable@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::Formattable::operator=(icu_56::Formattable const &)
		mov	esi, esp
		lea	eax, [ebp+var_40]
		push	eax
		lea	ecx, [ebp+var_2C]
		call	dword ptr ds:__imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::ParsePosition::operator=(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3C32:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+2A9j
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+2D3j
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+var_40]
		call	dword ptr ds:__imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::ParsePosition::operator=(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_244] ; this
		call	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
		jmp	loc_3AF4
; ---------------------------------------------------------------------------

loc_3C5C:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+1CBj
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+1F9j
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+arg_4]
		call	dword ptr ds:__imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::ParsePosition::operator=(icu_56::ParsePosition const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_319], 1
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_40] ; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_2C] ; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, [ebp+var_319]

loc_3CAE:				; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+67j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN25
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 328h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN25		dd 4			; DATA XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+37Ao
		dd offset $LN24
$LN24		dd 0FFFFFFD4h, 0Ch	; DATA XREF: .text:00003CF0o
		dd offset $LN19_0	; "highWaterMark"
		dd 0FFFFFFC0h, 0Ch
		dd offset $LN20		; "workingPos"
		db 0CCh
		db 0FEh, 2 dup(0FFh)
		dd offset ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B ;	std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreate
		dd offset $LN21		; "tempResult"
		dd 0FFFFFDBCh, 0E0h
		dd offset $LN22		; "tempResult"
$LN22		db 'tempResult',0       ; DATA XREF: .text:00003D20o
$LN21		db 'tempResult',0       ; DATA XREF: .text:00003D14o
$LN20		db 'workingPos',0       ; DATA XREF: .text:00003D08o
$LN19_0		db 'highWaterMark',0    ; DATA XREF: .text:00003CFCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3D54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$0 proc near
					; DATA XREF: .xdata$x:00003DBCo
		mov	esi, esp
		lea	ecx, [ebp-2Ch]	; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$1 proc near
					; DATA XREF: .xdata$x:00003DC4o
		mov	esi, esp
		lea	ecx, [ebp-40h]	; this
		call	dword ptr ds:__imp_??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$2 proc near
					; DATA XREF: .xdata$x:00003DCCo
		lea	ecx, [ebp-134h]	; this
		jmp	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$3 proc near
					; DATA XREF: .xdata$x:00003DD4o
		lea	ecx, [ebp-244h]	; this
		jmp	??1Formattable@icu_56@@UAE@XZ ;	icu_56::Formattable::~Formattable(void)
__unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z proc near
					; DATA XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-32Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 3DB8h
__unwindtable$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00003DE0o
		dd offset __unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$0
		dd 0
		dd offset __unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$1
		dd 1
		dd offset __unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$2
		dd 1
		dd offset __unwindfunclet$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z$3
__ehfuncinfo$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z dd	19930522h, 4
					; DATA XREF: __ehhandler$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z+1Eo
		dd offset __unwindtable$?parse@NFRuleSet@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@NAAVFormattable@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::NFRuleSet::appendRules(icu_56::NFRuleSet *this, struct icu_56::UnicodeString *)
		public ?appendRules@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z
?appendRules@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z proc near

var_10C		= dword	ptr -10Ch
var_108		= dword	ptr -108h
var_104		= dword	ptr -104h
var_100		= dword	ptr -100h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	3Ah ; ':'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0Ah		; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], 0
		jmp	short loc_3E6F
; ---------------------------------------------------------------------------

loc_3E66:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+B1j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_3E6F:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+68j
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_14], eax
		jnb	short loc_3EAF
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 40h ; '@'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	ecx, eax	; this
		call	?_appendRuleText@NFRule@icu_56@@QBEXAAVUnicodeString@2@@Z ; icu_56::NFRule::_appendRuleText(icu_56::UnicodeString &)
		mov	esi, esp
		push	0Ah		; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_3E66
; ---------------------------------------------------------------------------

loc_3EAF:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+81j
		mov	[ebp+var_14], 0
		jmp	short loc_3EC1
; ---------------------------------------------------------------------------

loc_3EB8:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &):loc_4026j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_3EC1:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+BAj
		cmp	[ebp+var_14], 6
		jnb	loc_402B
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4+4Ch]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+eax*4+4Ch], 0
		jz	loc_4026
		mov	ecx, [ebp+var_20] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		cmp	[ebp+var_104], 0FFFFFFFEh
		jnz	short loc_3F0F
		cmp	[ebp+var_100], 0FFFFFFFFh
		jz	short loc_3F63

loc_3F0F:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+108j
		mov	ecx, [ebp+var_20] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		cmp	[ebp+var_104], 0FFFFFFFDh
		jnz	short loc_3F35
		cmp	[ebp+var_100], 0FFFFFFFFh
		jz	short loc_3F63

loc_3F35:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+12Ej
		mov	ecx, [ebp+var_20] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		cmp	[ebp+var_104], 0FFFFFFFCh
		jnz	loc_4006
		cmp	[ebp+var_100], 0FFFFFFFFh
		jnz	loc_4006

loc_3F63:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+111j
					; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+137j
		mov	[ebp+var_2C], 0
		jmp	short loc_3F75
; ---------------------------------------------------------------------------

loc_3F6C:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &):loc_3FFFj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_3F75:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+16Ej
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'  ; this
		call	?size@NFRuleList@icu_56@@QBEIXZ	; icu_56::NFRuleList::size(void)
		cmp	[ebp+var_2C], eax
		jnb	short loc_4004
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 68h ; 'h'
		call	??ANFRuleList@icu_56@@QBEPAVNFRule@1@I@Z ; icu_56::NFRuleList::operator[](uint)
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_38] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	esi, eax
		mov	edi, edx
		mov	ecx, [ebp+var_20] ; this
		call	?getBaseValue@NFRule@icu_56@@QBE_JXZ ; icu_56::NFRule::getBaseValue(void)
		mov	[ebp+var_104], esi
		mov	[ebp+var_100], edi
		mov	[ebp+var_10C], eax
		mov	[ebp+var_108], edx
		mov	eax, [ebp+var_104]
		cmp	eax, [ebp+var_10C]
		jnz	short loc_3FFF
		mov	ecx, [ebp+var_100]
		cmp	ecx, [ebp+var_108]
		jnz	short loc_3FFF
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_38] ; this
		call	?_appendRuleText@NFRule@icu_56@@QBEXAAVUnicodeString@2@@Z ; icu_56::NFRule::_appendRuleText(icu_56::UnicodeString &)
		mov	esi, esp
		push	0Ah		; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3FFF:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+1D3j
					; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+1E1j
					; DATA XREF: ...
		jmp	loc_3F6C
; ---------------------------------------------------------------------------

loc_4004:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+187j
		jmp	short loc_4026
; ---------------------------------------------------------------------------

loc_4006:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+154j
					; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+161j
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_20] ; this
		call	?_appendRuleText@NFRule@icu_56@@QBEXAAVUnicodeString@2@@Z ; icu_56::NFRule::_appendRuleText(icu_56::UnicodeString &)
		mov	esi, esp
		push	0Ah		; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4026:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+E7j
					; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &):loc_4004j
		jmp	loc_3EB8
; ---------------------------------------------------------------------------

loc_402B:				; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+C9j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?appendRules@NFRuleSet@icu_56@@QBEXAAVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __cdecl icu_56::util64_fromDouble(icu_56 *this, double)
		public ?util64_fromDouble@icu_56@@YA_JN@Z
?util64_fromDouble@icu_56@@YA_JN@Z proc	near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+159p
					; icu_56::NFRuleSet::findFractionRuleSetRule(double)+A1p ...

var_104		= qword	ptr -104h
var_F0		= byte ptr -0F0h
var_ED		= byte ptr -0EDh
var_25		= byte ptr -25h
var_1C		= qword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
this		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_C], 0
		mov	[ebp+var_8], 0
		sub	esp, 8
		fld	qword ptr [ebp+this]
		fstp	[esp+104h+var_104]
		call	_uprv_isNaN_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	loc_412C
		call	_uprv_maxMantissa_56
		fstp	[ebp+var_1C]
		fld	[ebp+var_1C]
		fchs
		fcomp	qword ptr [ebp+this]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_40AD
		fld	[ebp+var_1C]
		fchs
		fstp	qword ptr [ebp+this]
		jmp	short loc_40C0
; ---------------------------------------------------------------------------

loc_40AD:				; CODE XREF: icu_56::util64_fromDouble(double)+5Dj
		fld	[ebp+var_1C]
		fcomp	qword ptr [ebp+this]
		fnstsw	ax
		test	ah, 5
		jp	short loc_40C0
		fld	[ebp+var_1C]
		fstp	qword ptr [ebp+this]

loc_40C0:				; CODE XREF: icu_56::util64_fromDouble(double)+67j
					; icu_56::util64_fromDouble(double)+74j
		fldz
		fcomp	qword ptr [ebp+this]
		fnstsw	ax
		test	ah, 41h
		jnz	short loc_40D5
		mov	[ebp+var_ED], 1
		jmp	short loc_40DC
; ---------------------------------------------------------------------------

loc_40D5:				; CODE XREF: icu_56::util64_fromDouble(double)+86j
		mov	[ebp+var_ED], 0

loc_40DC:				; CODE XREF: icu_56::util64_fromDouble(double)+8Fj
		mov	al, [ebp+var_ED]
		mov	[ebp+var_25], al
		movsx	eax, [ebp+var_25]
		test	eax, eax
		jz	short loc_40F5
		fld	qword ptr [ebp+this]
		fchs
		fstp	qword ptr [ebp+this]

loc_40F5:				; CODE XREF: icu_56::util64_fromDouble(double)+A7j
		sub	esp, 8
		fld	qword ptr [ebp+this]
		fstp	[esp+104h+var_104]
		call	_uprv_floor_56
		add	esp, 8
		call	__ftol2
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		movsx	eax, [ebp+var_25]
		test	eax, eax
		jz	short loc_412C
		mov	eax, [ebp+var_C]
		neg	eax
		mov	ecx, [ebp+var_8]
		adc	ecx, 0
		neg	ecx
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], ecx

loc_412C:				; CODE XREF: icu_56::util64_fromDouble(double)+42j
					; icu_56::util64_fromDouble(double)+D3j
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?util64_fromDouble@icu_56@@YA_JN@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4148h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __cdecl icu_56::util64_pow(icu_56 *this, int,	unsigned int)
		public ?util64_pow@icu_56@@YA_JHI@Z
?util64_pow@icu_56@@YA_JHI@Z proc near

var_D0		= byte ptr -0D0h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+this], 0
		jnz	short loc_4174
		xor	eax, eax
		xor	edx, edx
		jmp	short loc_41BB
; ---------------------------------------------------------------------------
		jmp	short loc_41BB
; ---------------------------------------------------------------------------

loc_4174:				; CODE XREF: icu_56::util64_pow(int,uint)+22j
		cmp	[ebp+arg_4], 0
		jnz	short loc_4185
		mov	eax, 1
		xor	edx, edx
		jmp	short loc_41BB
; ---------------------------------------------------------------------------
		jmp	short loc_41BB
; ---------------------------------------------------------------------------

loc_4185:				; CODE XREF: icu_56::util64_pow(int,uint)+30j
		mov	eax, [ebp+this]
		cdq
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx

loc_418F:				; CODE XREF: icu_56::util64_pow(int,uint)+6Bj
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		jz	short loc_41B5
		mov	eax, [ebp+this]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		call	__allmul
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		jmp	short loc_418F
; ---------------------------------------------------------------------------

loc_41B5:				; CODE XREF: icu_56::util64_pow(int,uint)+50j
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]

loc_41BB:				; CODE XREF: icu_56::util64_pow(int,uint)+28j
					; icu_56::util64_pow(int,uint)+2Aj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?util64_pow@icu_56@@YA_JHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl icu_56::util64_tou(icu_56 *this,	__int64, wchar_t *, unsigned int, char,	signed __int8)
		public ?util64_tou@icu_56@@YAI_JPA_WIIC@Z
?util64_tou@icu_56@@YAI_JPA_WIIC@Z proc	near

var_118		= dword	ptr -118h
var_50		= word ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
this		= dword	ptr  8
arg_4		= qword	ptr  0Ch
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= byte ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 24h ; '$'
		jbe	short loc_41FD
		mov	[ebp+arg_10], 24h ; '$'
		jmp	short loc_420A
; ---------------------------------------------------------------------------

loc_41FD:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+22j
		cmp	[ebp+arg_10], 2
		jnb	short loc_420A
		mov	[ebp+arg_10], 2

loc_420A:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+2Bj
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+31j
		mov	eax, [ebp+arg_10]
		xor	ecx, ecx
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], ecx
		mov	eax, dword ptr [ebp+arg_4+4]
		mov	[ebp+var_18], eax
		cmp	[ebp+arg_C], 0
		jz	short loc_426F
		cmp	dword ptr [ebp+arg_4], 0
		jg	short loc_426F
		jl	short loc_422F
		cmp	[ebp+this], 0
		jnb	short loc_426F

loc_422F:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+57j
		cmp	[ebp+arg_10], 0Ah
		jnz	short loc_426F
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jnz	short loc_426F
		mov	eax, [ebp+this]
		neg	eax
		mov	ecx, dword ptr [ebp+arg_4]
		adc	ecx, 0
		neg	ecx
		mov	[ebp+this], eax
		mov	dword ptr [ebp+arg_4], ecx
		mov	eax, 2Dh ; '-'
		mov	ecx, [ebp+var_18]
		mov	[ecx], ax
		mov	edx, [ebp+var_18]
		add	edx, 2
		mov	[ebp+var_18], edx
		mov	eax, [ebp+arg_C]
		sub	eax, 1
		mov	[ebp+arg_C], eax
		jmp	short loc_42C1
; ---------------------------------------------------------------------------

loc_426F:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+4Fj
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+55j ...
		cmp	[ebp+arg_C], 0
		jz	short loc_42C1
		mov	eax, [ebp+this]
		or	eax, dword ptr [ebp+arg_4]
		jnz	short loc_42C1
		movsx	ax, [ebp+arg_14]
		movzx	ecx, ax
		test	ecx, ecx
		jz	short loc_4295
		mov	[ebp+var_118], 0
		jmp	short loc_42A2
; ---------------------------------------------------------------------------

loc_4295:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+B7j
		movzx	edx, ds:_asciiDigits
		mov	[ebp+var_118], edx

loc_42A2:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+C3j
		mov	eax, [ebp+var_18]
		mov	cx, word ptr [ebp+var_118]
		mov	[eax], cx
		mov	edx, [ebp+var_18]
		add	edx, 2
		mov	[ebp+var_18], edx
		mov	eax, [ebp+arg_C]
		sub	eax, 1
		mov	[ebp+arg_C], eax

loc_42C1:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+9Dj
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+A3j ...
		cmp	[ebp+arg_C], 0
		jz	loc_436F
		mov	eax, [ebp+this]
		or	eax, dword ptr [ebp+arg_4]
		jz	loc_436F
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	edx, dword ptr [ebp+arg_4]
		push	edx
		mov	eax, [ebp+this]
		push	eax
		call	__alldiv
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], edx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_28]
		push	eax
		call	__allmul
		mov	[ebp+var_38], eax
		mov	[ebp+var_34], edx
		mov	eax, [ebp+this]
		sub	eax, [ebp+var_38]
		mov	ecx, dword ptr [ebp+arg_4]
		sbb	ecx, [ebp+var_34]
		mov	[ebp+var_44], eax
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	short loc_432F
		mov	ecx, [ebp+var_44]
		mov	[ebp+var_118], ecx
		jmp	short loc_433F
; ---------------------------------------------------------------------------

loc_432F:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+152j
		mov	edx, [ebp+var_44]
		movzx	eax, ds:_asciiDigits[edx]
		mov	[ebp+var_118], eax

loc_433F:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+15Dj
		mov	ecx, [ebp+var_18]
		mov	dx, word ptr [ebp+var_118]
		mov	[ecx], dx
		mov	eax, [ebp+var_18]
		add	eax, 2
		mov	[ebp+var_18], eax
		mov	eax, [ebp+var_28]
		mov	[ebp+this], eax
		mov	ecx, [ebp+var_24]
		mov	dword ptr [ebp+arg_4], ecx
		mov	eax, [ebp+arg_C]
		sub	eax, 1
		mov	[ebp+arg_C], eax
		jmp	loc_42C1
; ---------------------------------------------------------------------------

loc_436F:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+F5j
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+101j
		cmp	[ebp+arg_C], 0
		jz	short loc_437D
		xor	eax, eax
		mov	ecx, [ebp+var_18]
		mov	[ecx], ax

loc_437D:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+1A3j
		mov	eax, [ebp+var_18]
		sub	eax, dword ptr [ebp+arg_4+4]
		sar	eax, 1
		mov	[ebp+arg_C], eax
		mov	eax, dword ptr [ebp+arg_4+4]
		movzx	ecx, word ptr [eax]
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_439C
		mov	eax, dword ptr [ebp+arg_4+4]
		add	eax, 2
		mov	dword ptr [ebp+arg_4+4], eax

loc_439C:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+1C1j
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+206j
		mov	eax, [ebp+var_18]
		sub	eax, 2
		mov	[ebp+var_18], eax
		mov	ecx, [ebp+var_18]
		cmp	ecx, dword ptr [ebp+arg_4+4]
		jbe	short loc_43D8
		mov	eax, [ebp+var_18]
		mov	cx, [eax]
		mov	[ebp+var_50], cx
		mov	eax, [ebp+var_18]
		mov	ecx, dword ptr [ebp+arg_4+4]
		mov	dx, [ecx]
		mov	[eax], dx
		mov	eax, dword ptr [ebp+arg_4+4]
		mov	cx, [ebp+var_50]
		mov	[eax], cx
		mov	eax, dword ptr [ebp+arg_4+4]
		add	eax, 2
		mov	dword ptr [ebp+arg_4+4], eax
		jmp	short loc_439C
; ---------------------------------------------------------------------------

loc_43D8:				; CODE XREF: icu_56::util64_tou(__int64,wchar_t	*,uint,uint,signed char)+1DBj
		mov	eax, [ebp+arg_C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?util64_tou@icu_56@@YAI_JPA_WIIC@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; public: signed char __thiscall icu_56::DecimalFormatSymbols::operator==(class	icu_56::DecimalFormatSymbols const &)const
		extrn ??8DecimalFormatSymbols@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+2Ap
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::DecimalFormatSymbols::operator!=(icu_56::DecimalFormatSymbols const &)+42p
					; icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+61p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol)+59p
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+79p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+17Cp
					; __unwindfunclet$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z$0+8p ...
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString &&)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+160r
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@H@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120p
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+120r
		extrn _u_charDigitValue_56:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+E0p
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+CCr
; int __thiscall icu_56::UnicodeString::countChar32(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?countChar32@UnicodeString@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFp
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+AFr
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+80p
					; icu_56::Formattable::getString(icu_56::UnicodeString &)+2Fp
					; DATA XREF: ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+2Er
					; icu_56::SimpleNumberFormatFactory::SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory const &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+23j
					; __ehhandler$??0SimpleNumberFormatFactory@icu_56@@QAE@ABV01@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: icu_56::DecimalFormatSymbols::setSymbol(icu_56::DecimalFormatSymbols::ENumberFormatSymbol,icu_56::UnicodeString const &,signed char)+1A1p
					; __ehhandler$?setSymbol@DecimalFormatSymbols@icu_56@@QAEXW4ENumberFormatSymbol@12@ABVUnicodeString@2@C@Z+Fp ...
; _DWORD __thiscall icu_56::Locale::Locale(icu_56::Locale *__hidden this, const	struct icu_56::Locale *)
		extrn __imp_??0Locale@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Bp
					; DATA XREF: icu_56::DecimalFormatSymbols::getLocale(void)+3Br
; public: signed char __thiscall icu_56::Formattable::operator==(class icu_56::Formattable const &)const
		extrn ??8Formattable@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::Formattable::operator!=(icu_56::Formattable const &)+2Ap
		extrn __fltused:near
; int __thiscall icu_56::Formattable::getLong(icu_56::Formattable *__hidden this, enum UErrorCode *)
		extrn ?getLong@Formattable@icu_56@@QBEHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::Formattable::getLong(UErrorCode *)+2Ap
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		extrn __imp_??0UObject@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(void)+28p
					; icu_56::FieldPosition::FieldPosition(int)+28p ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::FieldPosition `RTTI Type Descriptor'o
					; .data:icu_56::UObject	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::FieldPosition::getDynamicClassID(void)const
		extrn ?getDynamicClassID@FieldPosition@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000AA4o
; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this, const struct icu_56::UObject *)
		extrn __imp_??0UObject@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPosition::FieldPosition(icu_56::FieldPosition	const &)+2Cp
					; icu_56::NumberFormatFactory::NumberFormatFactory(icu_56::NumberFormatFactory const &)+2Cp
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+39p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+81p ...
; _DWORD __thiscall icu_56::FieldPosition::~FieldPosition(icu_56::FieldPosition	*__hidden this)
		extrn ??1FieldPosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::FieldPosition::`scalar deleting destructor'(uint)+26p
					; icu_56::FieldPosition::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn __imp_??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+53p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+53p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::FieldPosition::`vector deleting destructor'(uint)+3Dp
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+3Dp ...
; public: signed char __thiscall icu_56::FieldPositionIterator::operator==(class icu_56::FieldPositionIterator const &)const
		extrn ??8FieldPositionIterator@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator!=(icu_56::FieldPositionIterator const &)+2Ap
; __declspec(dllimport)	public:	class icu_56::UObject &	__thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		extrn __imp_??4UObject@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::FieldPositionIterator::operator=(icu_56::FieldPositionIterator const &)+2Cp
					; icu_56::NumberFormatFactory::operator=(icu_56::NumberFormatFactory const &)+2Cp
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::MeasureUnit::getDynamicClassID(void)const
		extrn ?getDynamicClassID@MeasureUnit@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001224o
; public: virtual class	icu_56::UObject	* __thiscall icu_56::MeasureUnit::clone(void)const
		extrn ?clone@MeasureUnit@icu_56@@UBEPAVUObject@2@XZ:near
					; DATA XREF: .rdata:00001228o
; public: virtual signed char __thiscall icu_56::MeasureUnit::operator==(class icu_56::UObject const &)const
		extrn ??8MeasureUnit@icu_56@@UBECABVUObject@1@@Z:near
					; DATA XREF: .rdata:0000122Co
; _DWORD __thiscall icu_56::MeasureUnit::~MeasureUnit(icu_56::MeasureUnit *__hidden this)
		extrn ??1MeasureUnit@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::MeasureUnit::`scalar deleting destructor'(uint)+26p
					; icu_56::MeasureUnit::`vector deleting	destructor'(uint)+6Ep
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001598o
					; .rdata:000018C8o
		extrn __purecall:near	; DATA XREF: .rdata:0000159Co
					; .rdata:000015A0o ...
; _DWORD __thiscall icu_56::NumberFormatFactory::~NumberFormatFactory(icu_56::NumberFormatFactory *__hidden this)
		extrn ??1NumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NumberFormatFactory::`scalar deleting destructor'(uint)+26p
					; icu_56::NumberFormatFactory::`vector deleting	destructor'(uint)+6Ep ...
; public: virtual signed char __thiscall icu_56::SimpleNumberFormatFactory::visible(void)const
		extrn ?visible@SimpleNumberFormatFactory@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:000018CCo
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::SimpleNumberFormatFactory::getSupportedIDs(int	&, enum	 UErrorCode &)const
		extrn ?getSupportedIDs@SimpleNumberFormatFactory@icu_56@@UBEPBVUnicodeString@2@AAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:000018D0o
; _DWORD __thiscall icu_56::SimpleNumberFormatFactory::~SimpleNumberFormatFactory(icu_56::SimpleNumberFormatFactory *__hidden this)
		extrn ??1SimpleNumberFormatFactory@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SimpleNumberFormatFactory::`scalar	deleting destructor'(uint)+26p
					; icu_56::SimpleNumberFormatFactory::`vector deleting destructor'(uint)+6Ep
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?truncate@UnicodeString@icu_56@@QAECH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+2D3p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+2D3r
; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *__hidden this, const wchar_t *, int)
		extrn __imp_?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+29Dp
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+29Dr
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+279p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+279r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *__hidden	this, const struct icu_56::UnicodeString *)
		extrn __imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+226p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+226r
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn __imp_??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1F7p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1F7r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this, int, int)
		extrn __imp_?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1D7p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1D7r
; signed __int8	__cdecl	static icu_56::PatternProps::isWhiteSpace(int)
		extrn __imp_?isWhiteSpace@PatternProps@icu_56@@SACH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1B3p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+1B3r
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *__hidden	this, const struct icu_56::UnicodeString *, int, int)
		extrn __imp_?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+16Ap
					; icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+EFp
					; DATA XREF: ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, wchar_t)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEH_W@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+137p
					; DATA XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+137r
; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?charAt@UnicodeString@icu_56@@QBE_WH@Z:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+117p
					; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat *,icu_56::UnicodeString *,int,UErrorCode &)+1A0p ...
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+F1p
					; icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat *,icu_56::UnicodeString *,int,UErrorCode &)+17Cp ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::NFRuleSet::NFRuleSet(icu_56::RuleBasedNumberFormat	*,icu_56::UnicodeString	*,int,UErrorCode &)+4Ap
					; icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+6Fp
					; DATA XREF: ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::NFRuleList::NFRuleList(uint)+30p
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::NFRuleList::~NFRuleList(void)+95p
					; icu_56::NFRuleList::deleteAll(void)+ADp
; _DWORD __thiscall icu_56::NFRule::~NFRule(icu_56::NFRule *__hidden this)
		extrn ??1NFRule@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::NFRule::`scalar deleting destructor'(uint)+26p
; void __thiscall icu_56::NFRule::setBaseValue(icu_56::NFRule *__hidden	this, __int64, enum UErrorCode *)
		extrn ?setBaseValue@NFRule@icu_56@@QAEX_JAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+1DFp
; void __cdecl static icu_56::NFRule::makeRules(struct icu_56::UnicodeString *,	struct icu_56::NFRuleSet *, const struct icu_56::NFRule	*, const struct	icu_56::RuleBasedNumberFormat *, struct	icu_56::NFRuleList *, enum UErrorCode *)
		extrn ?makeRules@NFRule@icu_56@@SAXAAVUnicodeString@2@PAVNFRuleSet@2@PBV12@PBVRuleBasedNumberFormat@2@AAVNFRuleList@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+122p
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, wchar_t, int)
		extrn __imp_?indexOf@UnicodeString@icu_56@@QBEH_WH@Z:near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+B0p
					; DATA XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+B0r
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::NFRuleSet::parseRules(icu_56::UnicodeString &,UErrorCode &)+291p
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+380p
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::NFRuleList::add(icu_56::NFRule *)+50p
; const	struct icu_56::DecimalFormatSymbols *__thiscall	icu_56::RuleBasedNumberFormat::getDecimalFormatSymbols(icu_56::RuleBasedNumberFormat *__hidden this)
		extrn ?getDecimalFormatSymbols@RuleBasedNumberFormat@icu_56@@ABEPBVDecimalFormatSymbols@2@XZ:near
					; CODE XREF: icu_56::NFRuleSet::setBestFractionRule(int,icu_56::NFRule *,signed	char)+87p
; __declspec(dllimport)	public:	signed char __thiscall icu_56::UnicodeString::operator==(class icu_56::UnicodeString const &)const
		extrn __imp_??8UnicodeString@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+62p
					; DATA XREF: icu_56::NFRuleSet::operator==(icu_56::NFRuleSet const &)+62r
; public: signed char __thiscall icu_56::NFRule::operator==(class icu_56::NFRule const &)const
		extrn ??8NFRule@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::NFRule::operator!=(icu_56::NFRule const &)+2Ap
					; icu_56::util_equalRules(icu_56::NFRule const *,icu_56::NFRule	const *)+31p
; void __thiscall icu_56::NFRule::setDecimalFormatSymbols(icu_56::NFRule *__hidden this, const struct icu_56::DecimalFormatSymbols *, enum UErrorCode *)
		extrn ?setDecimalFormatSymbols@NFRule@icu_56@@QAEXABVDecimalFormatSymbols@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const &,UErrorCode	&)+5Ep
					; icu_56::NFRuleSet::setDecimalFormatSymbols(icu_56::DecimalFormatSymbols const	&,UErrorCode &)+167p
; void __thiscall icu_56::NFRule::doFormat(icu_56::NFRule *__hidden this, __int64, struct icu_56::UnicodeString	*, int,	int, enum UErrorCode *)
		extrn ?doFormat@NFRule@icu_56@@QBEX_JAAVUnicodeString@2@HHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::NFRuleSet::format(__int64,icu_56::UnicodeString &,int,int,UErrorCode &)+71p
; void __thiscall icu_56::NFRule::doFormat(icu_56::NFRule *__hidden this, double, struct icu_56::UnicodeString *, int, int, enum UErrorCode *)
		extrn ?doFormat@NFRule@icu_56@@QBEXNAAVUnicodeString@2@HHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::NFRuleSet::format(double,icu_56::UnicodeString &,int,int,UErrorCode &)+73p
		extrn _uprv_floor_56:near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+F5p
					; icu_56::util64_fromDouble(double)+BAp
; const	struct icu_56::NFRule *__thiscall icu_56::RuleBasedNumberFormat::getDefaultInfinityRule(icu_56::RuleBasedNumberFormat *__hidden	this)
		extrn ?getDefaultInfinityRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ:near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+DCp
		extrn _uprv_isInfinite_56:near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+B8p
; const	struct icu_56::NFRule *__thiscall icu_56::RuleBasedNumberFormat::getDefaultNaNRule(icu_56::RuleBasedNumberFormat *__hidden this)
		extrn ?getDefaultNaNRule@RuleBasedNumberFormat@icu_56@@ABEPBVNFRule@2@XZ:near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+75p
		extrn _uprv_isNaN_56:near
					; CODE XREF: icu_56::NFRuleSet::findDoubleRule(double)+51p
					; icu_56::util64_fromDouble(double)+35p
; signed __int8	__thiscall icu_56::NFRule::shouldRollBack(icu_56::NFRule *__hidden this, double)
		extrn ?shouldRollBack@NFRule@icu_56@@QBECN@Z:near
					; CODE XREF: icu_56::NFRuleSet::findNormalRule(__int64)+17Dp
		extrn _uprv_maxMantissa_56:near
					; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+AFp
					; icu_56::util64_fromDouble(double)+48p
		extrn __allrem:near	; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+124p
		extrn __allmul:near	; CODE XREF: icu_56::NFRuleSet::findFractionRuleSetRule(double)+115p
					; icu_56::util_lcm(__int64,__int64)+1C5p ...
		extrn __alldiv:near	; CODE XREF: icu_56::util_lcm(__int64,__int64)+1B6p
					; icu_56::util64_tou(__int64,wchar_t *,uint,uint,signed	char)+117p
		extrn __allshl:near	; CODE XREF: icu_56::util_lcm(__int64,__int64)+19Bp
		extrn __allshr:near	; CODE XREF: icu_56::util_lcm(__int64,__int64)+9Ap
					; icu_56::util_lcm(__int64,__int64)+ADp ...
; _DWORD __thiscall icu_56::ParsePosition::~ParsePosition(icu_56::ParsePosition	*__hidden this)
		extrn __imp_??1ParsePosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+34Ap
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+363p ...
; _DWORD __thiscall icu_56::Formattable::~Formattable(icu_56::Formattable *__hidden this)
		extrn ??1Formattable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+184p
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+31Ap ...
; __declspec(dllimport)	public:	class icu_56::ParsePosition & __thiscall icu_56::ParsePosition::operator=(class	icu_56::ParsePosition const &)
		extrn __imp_??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+157p
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+16Dp ...
; public: class	icu_56::Formattable & __thiscall icu_56::Formattable::operator=(class icu_56::Formattable const	&)
		extrn ??4Formattable@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+149p
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+2DFp
; int __thiscall icu_56::ParsePosition::getIndex(icu_56::ParsePosition *__hidden this)
		extrn __imp_?getIndex@ParsePosition@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+11Ap
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+12Ep ...
; signed __int8	__thiscall icu_56::NFRule::doParse(icu_56::NFRule *__hidden this, const	struct icu_56::UnicodeString *,	struct icu_56::ParsePosition *,	signed __int8, double, struct icu_56::Formattable *)
		extrn ?doParse@NFRule@icu_56@@QBECABVUnicodeString@2@AAVParsePosition@2@CNAAVFormattable@2@@Z:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+FFp
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+295p
; _DWORD __thiscall icu_56::Formattable::Formattable(icu_56::Formattable *__hidden this)
		extrn ??0Formattable@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+D2p
					; icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+258p
; _DWORD __thiscall icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition *__hidden this, const struct icu_56::ParsePosition *)
		extrn __imp_??0ParsePosition@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+8Ep
					; DATA XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+8Er
; _DWORD __thiscall icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition *__hidden this)
		extrn __imp_??0ParsePosition@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+71p
					; DATA XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+71r
; void __thiscall icu_56::Formattable::setLong(icu_56::Formattable *__hidden this, int)
		extrn ?setLong@Formattable@icu_56@@QAEXH@Z:near
					; CODE XREF: icu_56::NFRuleSet::parse(icu_56::UnicodeString const &,icu_56::ParsePosition &,double,icu_56::Formattable &)+4Ap
; void __thiscall icu_56::NFRule::_appendRuleText(icu_56::NFRule *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?_appendRuleText@NFRule@icu_56@@QBEXAAVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+98p
					; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+1EAp	...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, wchar_t)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z:near
					; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+40p
					; icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+54p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z:near
					; CODE XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+2Cp
					; DATA XREF: icu_56::NFRuleSet::appendRules(icu_56::UnicodeString &)+2Cr
		extrn __ftol2:near	; CODE XREF: icu_56::util64_fromDouble(double)+C2p


		end
