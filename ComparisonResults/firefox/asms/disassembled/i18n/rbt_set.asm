;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	DA4EC423F1FF1E145249DB121DCD6E19
; Input	CRC32 :	833DD9D9

; File Name   :	D:\compspace\objfiles\firefox\i18n\rbt_set.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd 2000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	3000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FB:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 130h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 134h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet *this, enum UErrorCode *)
		public ??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z
??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7TransliterationRuleSet@icu_56@@6B@ ; const icu_56::TransliterationRuleSet::`vftable'
		mov	esi, esp
		push	18h		; unsigned int

loc_1BB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_21B
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	0		; signed __int8	(__cdecl __high	*)(union UElement, union UElement)
		push	offset __deleteRule ; void (__cdecl *)(void *)
		mov	ecx, [ebp+var_E0] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z	; icu_56::UVector::UVector(void	(*)(void *),signed char	(*)(UElement,UElement),UErrorCode &)
		cmp	esi, esp

loc_1FC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_E0]
		mov	dword ptr [ecx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_F4], edx
		jmp	short loc_225
; ---------------------------------------------------------------------------

loc_21B:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+73j
		mov	[ebp+var_F4], 0

loc_225:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+ADj
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_EC]
		mov	[ecx+4], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_25B
		jmp	short loc_284
; ---------------------------------------------------------------------------

loc_25B:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+EBj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_26D
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7

loc_26D:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+F6j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+410h], 0

loc_284:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+EDj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00000308o
		mov	esi, esp
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2E0h
		dd offset ??_R4UVector@icu_56@@6B@ ; const icu_56::UVector::`RTTI Complete Object Locator'
		public ??_SUVector@icu_56@@6B@
; const	icu_56::UVector::`local	vftable'
??_SUVector@icu_56@@6B@	dd offset ??_EUVector@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+9Bo
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+115o
					; icu_56::UVector::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UVector@icu_56@@UBEPAXXZ ;	icu_56::UVector::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2ECh
		dd offset ??_R4TransliterationRuleSet@icu_56@@6B@ ; const icu_56::TransliterationRuleSet::`RTTI	Complete Object	Locator'
		public ??_7TransliterationRuleSet@icu_56@@6B@
; const	icu_56::TransliterationRuleSet::`vftable'
??_7TransliterationRuleSet@icu_56@@6B@ dd offset ??_ETransliterationRuleSet@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+45o
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+66o ...
					; icu_56::TransliterationRuleSet::`vector deleting destructor'(uint)
		dd offset ?getMaximumContextLength@TransliterationRuleSet@icu_56@@UBEHXZ ; icu_56::TransliterationRuleSet::getMaximumContextLength(void)
		dd offset ?addRule@TransliterationRuleSet@icu_56@@UAEXPAVTransliterationRule@2@AAW4UErrorCode@@@Z ; icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule	*,UErrorCode &)
		dd offset ?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z	; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)
		dd offset ?toRules@TransliterationRuleSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z ; icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 304h
__unwindtable$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000314o
		dd offset __unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 330h
		public ??_R4TransliterationRuleSet@icu_56@@6B@
; const	icu_56::TransliterationRuleSet::`RTTI Complete Object Locator'
??_R4TransliterationRuleSet@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:000002ECo
		dd offset ??_R0?AVTransliterationRuleSet@icu_56@@@8 ; icu_56::TransliterationRuleSet `RTTI Type	Descriptor'
		dd offset ??_R3TransliterationRuleSet@icu_56@@8	; icu_56::TransliterationRuleSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 344h
		public ??_R0?AVTransliterationRuleSet@icu_56@@@8
; class	icu_56::TransliterationRuleSet `RTTI Type Descriptor'
??_R0?AVTransliterationRuleSet@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000033Co
					; .rdata$r:icu_56::TransliterationRuleSet::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avtransliter	db '.?AVTransliterationRuleSet@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 370h
		public ??_R3TransliterationRuleSet@icu_56@@8
; icu_56::TransliterationRuleSet::`RTTI	Class Hierarchy	Descriptor'
??_R3TransliterationRuleSet@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00000340o
					; .rdata$r:000003A4o
		dd 2
		dd offset ??_R2TransliterationRuleSet@icu_56@@8	; icu_56::TransliterationRuleSet::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 380h
		public ??_R2TransliterationRuleSet@icu_56@@8
; icu_56::TransliterationRuleSet::`RTTI	Base Class Array'
??_R2TransliterationRuleSet@icu_56@@8 dd offset	??_R1A@?0A@EA@TransliterationRuleSet@icu_56@@8
					; DATA XREF: .rdata$r:0000037Co
					; icu_56::TransliterationRuleSet::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 38Ch
		public ??_R1A@?0A@EA@TransliterationRuleSet@icu_56@@8
; icu_56::TransliterationRuleSet::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@TransliterationRuleSet@icu_56@@8 dd offset ??_R0?AVTransliterationRuleSet@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::TransliterationRuleSet::`RTTI Base Class Array'o
					; icu_56::TransliterationRuleSet `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3TransliterationRuleSet@icu_56@@8	; icu_56::TransliterationRuleSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3A8h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000384o
					; .rdata$r:00000464o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 3C4h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3E4h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000003C0o
					; .rdata$r:00000414o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3F4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000003F0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3FCh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
dword_400	dd 2 dup(0)		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 418h
		public ??_R4UVector@icu_56@@6B@
; const	icu_56::UVector::`RTTI Complete	Object Locator'
??_R4UVector@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000002E0o
		dd offset ??_R0?AVUVector@icu_56@@@8 ; icu_56::UVector `RTTI Type Descriptor'
		dd offset ??_R3UVector@icu_56@@8 ; icu_56::UVector::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 42Ch
		public ??_R0?AVUVector@icu_56@@@8
; class	icu_56::UVector	`RTTI Type Descriptor'
??_R0?AVUVector@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000424o
					; .rdata$r:icu_56::UVector::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuvector@ic	db '.?AVUVector@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 44Ch
		public ??_R3UVector@icu_56@@8
; icu_56::UVector::`RTTI Class Hierarchy Descriptor'
??_R3UVector@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000428o
					; .rdata$r:00000484o
		dd 3
		dd offset ??_R2UVector@icu_56@@8 ; icu_56::UVector::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 45Ch
		public ??_R2UVector@icu_56@@8
; icu_56::UVector::`RTTI Base Class Array'
??_R2UVector@icu_56@@8 dd offset ??_R1A@?0A@EA@UVector@icu_56@@8
					; DATA XREF: .rdata$r:00000458o
					; icu_56::UVector::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 46Ch
		public ??_R1A@?0A@EA@UVector@icu_56@@8
; icu_56::UVector::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UVector@icu_56@@8	dd offset ??_R0?AVUVector@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UVector::`RTTI Base Class	Array'o
					; icu_56::UVector `RTTI	Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UVector@icu_56@@8 ; icu_56::UVector::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 488h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:00000460o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Array'o
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4A4h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4C4h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000004A0o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4D4h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000004D0o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+DEp
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+27Dp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 50Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl _deleteRule(void *)
__deleteRule	proc near		; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+7Do
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+F7o

var_DC		= dword	ptr -0DCh
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+var_C8]
		mov	[ebp+var_D4], ecx
		cmp	[ebp+var_D4], 0
		jz	short loc_56D
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_D4]
		mov	eax, [edx]
		mov	ecx, [ebp+var_D4]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_DC], eax
		jmp	short loc_577
; ---------------------------------------------------------------------------

loc_56D:				; CODE XREF: __deleteRule+3Aj
		mov	[ebp+var_DC], 0

loc_577:				; CODE XREF: __deleteRule+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__deleteRule	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 58Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::TransliterationRuleSet::`scalar deleting destructor'(unsigned int)
		public ??_GTransliterationRuleSet@icu_56@@UAEPAXI@Z
??_GTransliterationRuleSet@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1TransliterationRuleSet@icu_56@@UAE@XZ ; icu_56::TransliterationRuleSet::~TransliterationRuleSet(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5D5
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5D5:				; CODE XREF: icu_56::TransliterationRuleSet::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GTransliterationRuleSet@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector::`scalar deleting destructor'(unsigned int)
		public ??_GUVector@icu_56@@UAEPAXI@Z
??_GUVector@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_643
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_643:				; CODE XREF: icu_56::UVector::`scalar deleting destructor'(uint)+3Bj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUVector@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 65Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet *this, const struct icu_56::TransliterationRuleSet *)
		public ??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z
??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z proc near

var_190		= dword	ptr -190h
var_188		= dword	ptr -188h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_164		= dword	ptr -164h
var_98		= byte ptr -98h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 184h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_190]
		mov	ecx, 61h ; 'a'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_6B5
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_190], eax
		jmp	short loc_6BF
; ---------------------------------------------------------------------------

loc_6B5:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+49j
		mov	[ebp+var_190], 0

loc_6BF:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+57j
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax], offset	??_7TransliterationRuleSet@icu_56@@6B@ ; const icu_56::TransliterationRuleSet::`vftable'
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+410h]
		mov	[eax+410h], edx
		push	1
		mov	eax, [ebp+arg_0]
		add	eax, 0Ch
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	404h		; Size
		mov	ecx, [ebp+arg_0]
		add	ecx, 0Ch
		push	ecx		; Src
		mov	edx, [ebp+var_18]
		add	edx, 0Ch
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[ebp+var_3C], 0
		mov	esi, esp
		push	18h		; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_17C], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_17C], 0
		jz	short loc_785
		mov	esi, esp
		lea	eax, [ebp+var_3C]
		push	eax		; enum UErrorCode *
		push	0		; signed __int8	(__cdecl __high	*)(union UElement, union UElement)
		push	offset __deleteRule ; void (__cdecl *)(void *)
		mov	ecx, [ebp+var_17C] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z	; icu_56::UVector::UVector(void	(*)(void *),signed char	(*)(UElement,UElement),UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_17C]
		mov	dword ptr [ecx], offset	??_SUVector@icu_56@@6B@	; const	icu_56::UVector::`local	vftable'
		mov	edx, [ebp+var_17C]
		mov	[ebp+var_190], edx
		jmp	short loc_78F
; ---------------------------------------------------------------------------

loc_785:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+EDj
		mov	[ebp+var_190], 0

loc_78F:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+127j
		mov	eax, [ebp+var_190]
		mov	[ebp+var_188], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_188]
		mov	[ecx+4], edx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jz	loc_8EF
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4], 0
		jz	loc_8EF
		mov	eax, [ebp+var_3C]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_8EF
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_30], eax
		mov	[ebp+var_24], 0
		jmp	short loc_809
; ---------------------------------------------------------------------------

loc_800:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &):loc_8EAj
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax

loc_809:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+1A2j
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_30]
		jge	loc_8EF
		mov	eax, [ebp+var_3C]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_8EF
		mov	esi, esp
		push	6Ch ; 'l'       ; unsigned int
		call	dword ptr ds:__imp_??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator new(uint)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_164], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_164], 0
		jz	short loc_883
		mov	esi, esp
		mov	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; struct icu_56::TransliterationRule *
		mov	ecx, [ebp+var_164] ; this
		call	??0TransliterationRule@icu_56@@QAE@AAV01@@Z ; icu_56::TransliterationRule::TransliterationRule(icu_56::TransliterationRule &)
		mov	[ebp+var_190], eax
		jmp	short loc_88D
; ---------------------------------------------------------------------------

loc_883:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+1F8j
		mov	[ebp+var_190], 0

loc_88D:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+225j
		mov	edx, [ebp+var_190]
		mov	[ebp+var_170], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_170]
		mov	[ebp+var_48], eax
		cmp	[ebp+var_48], 0
		jnz	short loc_8B8
		mov	[ebp+var_3C], 7
		jmp	short loc_8EF
; ---------------------------------------------------------------------------

loc_8B8:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+251j
		mov	esi, esp
		lea	eax, [ebp+var_3C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_48]
		push	ecx		; void *
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+4]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_3C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8EA
		jmp	short loc_8EF
; ---------------------------------------------------------------------------

loc_8EA:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+28Aj
		jmp	loc_800
; ---------------------------------------------------------------------------

loc_8EF:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+159j
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+166j ...
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_91E
		mov	eax, [ebp+var_3C]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_91E
		lea	eax, [ebp+var_3C]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_98]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_18] ; this
		call	?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z ;	icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode	&)

loc_91E:				; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+29Aj
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+2ADj
		mov	eax, [ebp+var_18]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 190h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN22		dd 2			; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+2C9o
		dd offset $LN21
$LN21		dd 0FFFFFFC4h, 4	; DATA XREF: .text:00000964o
		dd offset $LN18		; "status"
		dd 0FFFFFF68h, 48h
		dd offset $LN19
$LN19		db 70h,	0		; DATA XREF: .text:0000097Co
$LN18		db 'status',0           ; DATA XREF: .text:00000970o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 98Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:000009ECo
		mov	esi, esp
		mov	eax, [ebp-17Ch]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:000009F4o
		mov	esi, esp
		mov	eax, [ebp-164h]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z proc	near
					; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-194h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9E8h
__unwindtable$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00000A00o
		dd offset __unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z+1Eo
		dd offset __unwindtable$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+170p
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+1BDp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::TransliterationRuleSet::~TransliterationRuleSet(icu_56::TransliterationRuleSet *__hidden this)
		public ??1TransliterationRuleSet@icu_56@@UAE@XZ
??1TransliterationRuleSet@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::TransliterationRuleSet::`scalar deleting destructor'(uint)+26p

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7TransliterationRuleSet@icu_56@@6B@ ; const icu_56::TransliterationRuleSet::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_D4], ecx
		mov	edx, [ebp+var_D4]
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jz	short loc_ABA
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_E0]
		mov	edx, [eax]
		mov	ecx, [ebp+var_E0]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_AC4
; ---------------------------------------------------------------------------

loc_ABA:				; CODE XREF: icu_56::TransliterationRuleSet::~TransliterationRuleSet(void)+4Bj
		mov	[ebp+var_E8], 0

loc_AC4:				; CODE XREF: icu_56::TransliterationRuleSet::~TransliterationRuleSet(void)+70j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1TransliterationRuleSet@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::TransliterationRuleSet::setData(icu_56::TransliterationRuleSet *this,	const struct icu_56::TransliterationRuleData *)
		public ?setData@TransliterationRuleSet@icu_56@@QAEXPBVTransliterationRuleData@2@@Z
?setData@TransliterationRuleSet@icu_56@@QAEXPBVTransliterationRuleData@2@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+40Ch]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		jmp	short loc_B29
; ---------------------------------------------------------------------------

loc_B20:				; CODE XREF: icu_56::TransliterationRuleSet::setData(icu_56::TransliterationRuleData const *)+5Ej
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_B29:				; CODE XREF: icu_56::TransliterationRuleSet::setData(icu_56::TransliterationRuleData const *)+36j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_B48
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::TransliterationRuleData *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	eax, [ebp+var_20]
		mov	ecx, [edx+eax*4] ; this
		call	?setData@TransliterationRule@icu_56@@QAEXPBVTransliterationRuleData@2@@Z ; icu_56::TransliterationRule::setData(icu_56::TransliterationRuleData	const *)
		jmp	short loc_B20
; ---------------------------------------------------------------------------

loc_B48:				; CODE XREF: icu_56::TransliterationRuleSet::setData(icu_56::TransliterationRuleData const *)+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setData@TransliterationRuleSet@icu_56@@QAEXPBVTransliterationRuleData@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::TransliterationRuleSet::getMaximumContextLength(icu_56::TransliterationRuleSet	*__hidden this)
		public ?getMaximumContextLength@TransliterationRuleSet@icu_56@@UBEHXZ
?getMaximumContextLength@TransliterationRuleSet@icu_56@@UBEHXZ proc near
					; DATA XREF: .rdata:000002F4o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+410h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getMaximumContextLength@TransliterationRuleSet@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRuleSet *this,	struct icu_56::TransliterationRule *, enum UErrorCode *)
		public ?addRule@TransliterationRuleSet@icu_56@@UAEXPAVTransliterationRule@2@AAW4UErrorCode@@@Z
?addRule@TransliterationRuleSet@icu_56@@UAEXPAVTransliterationRule@2@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: .rdata:000002F8o

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_C1B
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_E0], eax
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_EC], ecx
		cmp	[ebp+var_EC], 0
		jz	short loc_C0F
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_EC]
		mov	eax, [edx]
		mov	ecx, [ebp+var_EC]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_C19
; ---------------------------------------------------------------------------

loc_C0F:				; CODE XREF: icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &)+54j
		mov	[ebp+var_F4], 0

loc_C19:				; CODE XREF: icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &)+79j
		jmp	short loc_C84
; ---------------------------------------------------------------------------

loc_C1B:				; CODE XREF: icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &)+36j
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+4]	; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_14]
		cmp	edx, [ecx+410h]
		jle	short loc_C6B
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+410h], ecx

loc_C6B:				; CODE XREF: icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &)+C9j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0

loc_C84:				; CODE XREF: icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &):loc_C19j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?addRule@TransliterationRuleSet@icu_56@@UAEXPAVTransliterationRule@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::TransliterationRuleSet::freeze(icu_56::TransliterationRuleSet	*this, struct UParseError *, enum UErrorCode *)
		public ?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z
?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+2BDp
					; DATA XREF: .rdata:000002FCo

var_168		= dword	ptr -168h
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= dword	ptr -64h
var_58		= byte ptr -58h
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 15Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_168]
		mov	ecx, 57h ; 'W'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax		; enum UErrorCode *
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_20]
		shl	ecx, 1
		push	ecx		; int
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z ;	icu_56::UVector::UVector(int,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_D4C
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1149
; ---------------------------------------------------------------------------

loc_D4C:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+90j
		cmp	[ebp+var_20], 0
		jle	short loc_D5D
		mov	eax, [ebp+var_20]
		mov	[ebp+var_168], eax
		jmp	short loc_D67
; ---------------------------------------------------------------------------

loc_D5D:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+B4j
		mov	[ebp+var_168], 1

loc_D67:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+BFj
		mov	ecx, [ebp+var_168]
		shl	ecx, 1
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_64], eax
		cmp	[ebp+var_64], 0
		jnz	short loc_DA8
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1149
; ---------------------------------------------------------------------------

loc_DA8:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+E3j
		mov	[ebp+var_2C], 0
		jmp	short loc_DBA
; ---------------------------------------------------------------------------

loc_DB1:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+154j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_DBA:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+113j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	short loc_DF2
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_70], eax
		mov	ecx, [ebp+var_70] ; this
		call	?getIndexValue@TransliterationRule@icu_56@@QBEFXZ ; icu_56::TransliterationRule::getIndexValue(void)
		mov	ecx, [ebp+var_2C]
		mov	edx, [ebp+var_64]
		mov	[edx+ecx*2], ax
		jmp	short loc_DB1
; ---------------------------------------------------------------------------

loc_DF2:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+124j
		xor	eax, eax
		mov	[ebp+var_38], ax
		jmp	short loc_E06
; ---------------------------------------------------------------------------

loc_DFA:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &):loc_EF1j
		mov	ax, [ebp+var_38]

loc_DFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		add	ax, 1
		mov	[ebp+var_38], ax

loc_E06:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+15Cj
		movsx	eax, [ebp+var_38]
		cmp	eax, 100h
		jge	loc_EF6
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, [ebp+var_38]
		mov	edx, [ebp+var_14]
		mov	[edx+ecx*4+0Ch], eax
		mov	[ebp+var_2C], 0
		jmp	short loc_E44
; ---------------------------------------------------------------------------

loc_E3B:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &):loc_EECj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_E44:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+19Dj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	loc_EF1
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_64]
		movsx	edx, word ptr [ecx+eax*2]
		test	edx, edx
		jl	short loc_EA2
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_64]
		movsx	edx, word ptr [ecx+eax*2]
		movsx	eax, [ebp+var_38]
		cmp	edx, eax
		jnz	short loc_EA0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	edi, esp
		mov	ecx, [ebp+var_2C]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+4]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax		; void *
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_EA0:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+1D2j
		jmp	short loc_EEC
; ---------------------------------------------------------------------------

loc_EA2:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+1C0j
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7C], eax
		movzx	eax, byte ptr [ebp+var_38]
		push	eax		; unsigned __int8
		mov	ecx, [ebp+var_7C] ; this
		call	?matchesIndexValue@TransliterationRule@icu_56@@QBECE@Z ; icu_56::TransliterationRule::matchesIndexValue(uchar)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_EEC
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_7C]
		push	ecx		; void *
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(void *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_EEC:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &):loc_EA0j
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+234j
		jmp	loc_E3B
; ---------------------------------------------------------------------------

loc_EF1:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+1AEj
		jmp	loc_DFA
; ---------------------------------------------------------------------------

loc_EF6:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+173j
		mov	eax, [ebp+var_64]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		mov	[ecx+40Ch], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_F6A
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1149
; ---------------------------------------------------------------------------

loc_F6A:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+2A4j
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_FBE
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_1149
; ---------------------------------------------------------------------------

loc_FBE:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+2F9j
		mov	[ebp+var_2C], 0
		jmp	short loc_FD0
; ---------------------------------------------------------------------------

loc_FC7:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+36Dj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_FD0:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+329j
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_2C], eax
		jge	short loc_100B
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax		; int
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]

loc_1000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	edx, [ecx+8]
		mov	ecx, [ebp+var_2C]
		mov	[edx+ecx*4], eax
		jmp	short loc_FC7
; ---------------------------------------------------------------------------

loc_100B:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+349j
		xor	eax, eax
		mov	[ebp+var_38], ax
		jmp	short loc_101F
; ---------------------------------------------------------------------------

loc_1013:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &):loc_112Bj
		mov	ax, [ebp+var_38]
		add	ax, 1
		mov	[ebp+var_38], ax

loc_101F:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+375j
		movsx	eax, [ebp+var_38]
		cmp	eax, 100h
		jge	loc_1130
		movsx	eax, [ebp+var_38]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4+0Ch]
		mov	[ebp+var_2C], edx
		jmp	short loc_1047
; ---------------------------------------------------------------------------

loc_103E:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &):loc_1126j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1047:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+3A0j
		movsx	eax, [ebp+var_38]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+eax*4+10h]
		sub	edx, 1
		cmp	[ebp+var_2C], edx
		jge	loc_112B
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_2C]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_88], eax
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_94], eax
		jmp	short loc_108D
; ---------------------------------------------------------------------------

loc_107E:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &):loc_1121j
		mov	eax, [ebp+var_94]
		add	eax, 1
		mov	[ebp+var_94], eax

loc_108D:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+3E0j
		movsx	eax, [ebp+var_38]
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_94]
		cmp	edx, [ecx+eax*4+10h]
		jge	loc_1126
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_94]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_A0], eax
		mov	esi, esp
		mov	eax, [ebp+var_A0]
		push	eax
		mov	ecx, [ebp+var_88]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_88]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1121
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 10015h
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_A0]
		push	ecx
		mov	edx, [ebp+var_88]
		push	edx
		call	?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z ; maskingError(icu_56::TransliterationRule	const &,icu_56::TransliterationRule const &,UParseError	&)
		add	esp, 0Ch
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_1149
; ---------------------------------------------------------------------------

loc_1121:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+445j
		jmp	loc_107E
; ---------------------------------------------------------------------------

loc_1126:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+402j
		jmp	loc_103E
; ---------------------------------------------------------------------------

loc_112B:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+3BCj
		jmp	loc_1013
; ---------------------------------------------------------------------------

loc_1130:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+38Cj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1149:				; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+ABj
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+107j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN39
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 168h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN39		dd 1			; DATA XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+4B1o
		dd offset $LN38
$LN38		dd 0FFFFFFA8h, 18h	; DATA XREF: .text:00001180o
		dd offset $LN36
$LN36		db 76h,	0		; DATA XREF: .text:0000118Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1194h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:000011C8o
		mov	esi, esp
		lea	ecx, [ebp-58h]	; this
		call	dword ptr ds:__imp_??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-16Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 11C4h
__unwindtable$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000011D4o
		dd offset __unwindfunclet$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?freeze@TransliterationRuleSet@icu_56@@UAEXAAUUParseError@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl maskingError(class icu_56::TransliterationRule const &, class icu_56::TransliterationRule const &, struct UParseError &)
?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z proc near
					; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+462p

var_124		= byte ptr -124h
var_60		= dword	ptr -60h
var_54		= byte ptr -54h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	ecx, [ebp+arg_8]
		mov	dword ptr [ecx], 0FFFFFFFFh
		mov	esi, esp
		push	0
		lea	eax, [ebp+var_54]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0Fh
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_uprv_min_56
		add	esp, 8
		mov	[ebp+var_60], eax
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+arg_8]
		add	eax, 8
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_60]
		push	ecx		; int
		push	0		; int
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z	; icu_56::UnicodeString::extract(int,int,wchar_t *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+arg_8]
		mov	[edx+ecx*2+8], ax
		mov	esi, esp
		push	0		; int
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?truncate@UnicodeString@icu_56@@QAECH@Z ; icu_56::UnicodeString::truncate(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0
		lea	eax, [ebp+var_54]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_4]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0Fh
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_uprv_min_56
		add	esp, 8
		mov	[ebp+var_60], eax
		mov	esi, esp
		push	0		; int
		mov	eax, [ebp+arg_8]
		add	eax, 28h ; '('
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_60]
		push	ecx		; int
		push	0		; int
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z	; icu_56::UnicodeString::extract(int,int,wchar_t *,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		mov	ecx, [ebp+var_60]
		mov	edx, [ebp+arg_8]
		mov	[edx+ecx*2+28h], ax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_54] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7		dd 1			; DATA XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+171o
		dd offset $LN6
$LN6		dd 0FFFFFFACh, 40h	; DATA XREF: .text:0000139Co
		dd offset $LN4
$LN4		db 72h,	0		; DATA XREF: .text:000013A8o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 13B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z$0 proc near
					; DATA XREF: .xdata$x:000013F0o
		mov	esi, esp
		lea	ecx, [ebp-54h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z proc near
					; DATA XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-128h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 13ECh
__unwindtable$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000013FCo
		dd offset __unwindfunclet$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z$0
__ehfuncinfo$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z+1Eo
		dd offset __unwindtable$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1418h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::TransliterationRuleSet::transliterate(icu_56::TransliterationRuleSet	*this, struct icu_56::Replaceable *, struct UTransPosition *, signed __int8)
		public ?transliterate@TransliterationRuleSet@icu_56@@QAECAAVReplaceable@2@AAUUTransPosition@@C@Z
?transliterate@TransliterationRuleSet@icu_56@@QAECAAVReplaceable@2@AAUUTransPosition@@C@Z proc near

var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?char32At@Replaceable@icu_56@@QBEHH@Z ; icu_56::Replaceable::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		and	eax, 0FFh
		mov	[ebp+var_14], ax
		movsx	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4+0Ch]
		mov	[ebp+var_20], edx
		jmp	short loc_1476
; ---------------------------------------------------------------------------

loc_146D:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char):loc_14CCj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_1476:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+53j
		movsx	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_20]
		cmp	edx, [ecx+eax*4+10h]
		jge	short loc_14CE
		movzx	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_20]
		mov	ecx, [ecx+edx*4]
		call	?matchAndReplace@TransliterationRule@icu_56@@QBE?AW4UMatchDegree@2@AAVReplaceable@2@AAUUTransPosition@@C@Z ; icu_56::TransliterationRule::matchAndReplace(icu_56::Replaceable &,UTransPosition &,signed	char)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_F4], eax
		cmp	[ebp+var_F4], 1
		jz	short loc_14C8
		cmp	[ebp+var_F4], 2
		jz	short loc_14C4
		jmp	short loc_14CC
; ---------------------------------------------------------------------------

loc_14C4:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+A8j
		mov	al, 1
		jmp	short loc_1503
; ---------------------------------------------------------------------------

loc_14C8:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+9Fj
		xor	al, al
		jmp	short loc_1503
; ---------------------------------------------------------------------------

loc_14CC:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+AAj
		jmp	short loc_146D
; ---------------------------------------------------------------------------

loc_14CE:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+6Cj
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?char32At@Replaceable@icu_56@@QBEHH@Z ; icu_56::Replaceable::char32At(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, 0FFFFh
		cmp	edx, eax
		sbb	eax, eax
		neg	eax
		add	eax, 1
		mov	ecx, [ebp+arg_4]
		add	eax, [ecx+8]
		mov	edx, [ebp+arg_4]
		mov	[edx+8], eax
		mov	al, 1

loc_1503:				; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+AEj
					; icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition &,signed char)+B2j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?transliterate@TransliterationRuleSet@icu_56@@QAECAAVReplaceable@2@AAUUTransPosition@@C@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 151Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::TransliterationRuleSet::toRules(icu_56::TransliterationRuleSet *this, struct	icu_56::UnicodeString *, signed	__int8)
		public ?toRules@TransliterationRuleSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z
?toRules@TransliterationRuleSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z	proc near
					; DATA XREF: .rdata:00000300o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	esi, esp
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?truncate@UnicodeString@icu_56@@QAECH@Z ; icu_56::UnicodeString::truncate(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], 0
		jmp	short loc_157D
; ---------------------------------------------------------------------------

loc_1574:				; CODE XREF: icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)+BEj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_157D:				; CODE XREF: icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)+56j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jge	short loc_15DC
		cmp	[ebp+var_14], 0
		jz	short loc_159F
		mov	esi, esp
		push	0Ah		; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_159F:				; CODE XREF: icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)+6Dj
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	esi, esp
		movzx	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_2C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_2C]
		mov	edx, [eax+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_1574
; ---------------------------------------------------------------------------

loc_15DC:				; CODE XREF: icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)+67j
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?toRules@TransliterationRuleSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::TransliterationRuleSet *this, struct	icu_56::UnicodeSet *, signed __int8)
		public ?getSourceTargetSet@TransliterationRuleSet@icu_56@@QBEAAVUnicodeSet@2@AAV32@C@Z
?getSourceTargetSet@TransliterationRuleSet@icu_56@@QBEAAVUnicodeSet@2@AAV32@C@Z	proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]	; this
		call	dword ptr ds:__imp_?size@UVector@icu_56@@QBEHXZ	; icu_56::UVector::size(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		jmp	short loc_165B
; ---------------------------------------------------------------------------

loc_1652:				; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char):loc_16A1j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_165B:				; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char)+58j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_16A3
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+4]	; this
		call	dword ptr ds:__imp_?elementAt@UVector@icu_56@@QBEPAXH@Z	; icu_56::UVector::elementAt(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1695
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_2C] ; this
		call	?addTargetSetTo@TransliterationRule@icu_56@@QBEXAAVUnicodeSet@2@@Z ; icu_56::TransliterationRule::addTargetSetTo(icu_56::UnicodeSet &)
		jmp	short loc_16A1
; ---------------------------------------------------------------------------

loc_1695:				; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char)+8Dj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_2C] ; this
		call	?addSourceSetTo@TransliterationRule@icu_56@@QBEXAAVUnicodeSet@2@@Z ; icu_56::TransliterationRule::addSourceSetTo(icu_56::UnicodeSet &)

loc_16A1:				; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char)+9Bj
		jmp	short loc_1652
; ---------------------------------------------------------------------------

loc_16A3:				; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char)+69j
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSourceTargetSet@TransliterationRuleSet@icu_56@@QBEAAVUnicodeSet@2@AAV32@C@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: __unwindfunclet$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z$0+9p
					; icu_56::TransliterationRuleSet::`scalar deleting destructor'(uint)+39p ...
; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *__hidden this, void (__cdecl *)(void *), signed __int8 (__cdecl __high *)(union UElement,	union UElement), enum UErrorCode *)
		extrn __imp_??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+88p
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+102p
					; DATA XREF: ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn __imp_??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &):loc_1BBp
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+C9p ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+2Er
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z+19j
					; __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@ABV01@@Z+23j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0TransliterationRuleSet@icu_56@@QAE@AAW4UErrorCode@@@Z+Fp
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet	const &)+2E9p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &)+5Ap
					; icu_56::TransliterationRuleSet::TransliterationRuleSet(UErrorCode &):loc_1FCp ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::TransliterationRuleSet `RTTI	Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::TransliterationRuleSet::`scalar deleting destructor'(unsigned int)
		extrn ??_GTransliterationRuleSet@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::TransliterationRuleSet::`vector deleting destructor'(unsigned int)
		extrn ??_ETransliterationRuleSet@icu_56@@UAEPAXI@Z:near	; weak
					; DATA XREF: .rdata:const icu_56::TransliterationRuleSet::`vftable'o
; public: virtual void * __thiscall icu_56::UVector::`scalar deleting destructor'(unsigned int)
		extrn ??_GUVector@icu_56@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall icu_56::UVector::`vector deleting destructor'(unsigned int)
		extrn ??_EUVector@icu_56@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const icu_56::UVector::`local vftable'o
; public: virtual void * __thiscall icu_56::UVector::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UVector@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000002E8o
; _DWORD __thiscall icu_56::UVector::~UVector(icu_56::UVector *__hidden	this)
		extrn __imp_??1UVector@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UVector::`scalar deleting destructor'(uint)+28p
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+9Ep ...
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, void *, enum UErrorCode *)
		extrn __imp_?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+26Cp
					; icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &)+97p ...
; _DWORD __thiscall icu_56::TransliterationRule::TransliterationRule(icu_56::TransliterationRule *__hidden this, struct	icu_56::TransliterationRule *)
		extrn ??0TransliterationRule@icu_56@@QAE@AAV01@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+21Ap
; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *__hidden	this, int)
		extrn __imp_?elementAt@UVector@icu_56@@QBEPAXH@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+206p
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+132p ...
; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		extrn __imp_?size@UVector@icu_56@@QBEHXZ:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+18Bp
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+4Ap ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+B6p
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+9Bp
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::TransliterationRuleSet::TransliterationRuleSet(icu_56::TransliterationRuleSet const &)+2CFp
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+4B7p ...
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::TransliterationRuleSet::~TransliterationRuleSet(void)+83p
					; icu_56::TransliterationRuleSet::addRule(icu_56::TransliterationRule *,UErrorCode &)+DEp ...
; void __thiscall icu_56::TransliterationRule::setData(icu_56::TransliterationRule *__hidden this, const struct	icu_56::TransliterationRuleData	*)
		extrn ?setData@TransliterationRule@icu_56@@QAEXPBVTransliterationRuleData@2@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::setData(icu_56::TransliterationRuleData const *)+59p
; signed __int8	__thiscall icu_56::TransliterationRule::matchesIndexValue(icu_56::TransliterationRule *__hidden	this, unsigned __int8)
		extrn ?matchesIndexValue@TransliterationRule@icu_56@@QBECE@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+22Ap
; __int16 __thiscall icu_56::TransliterationRule::getIndexValue(icu_56::TransliterationRule *__hidden this)
		extrn ?getIndexValue@TransliterationRule@icu_56@@QBEFXZ:near
					; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+145p
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+D4p
					; icu_56::TransliterationRuleSet::freeze(UParseError &,UErrorCode &)+2E4p
; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *__hidden this, int, enum UErrorCode *)
		extrn __imp_??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+69p
					; DATA XREF: icu_56::TransliterationRuleSet::freeze(UParseError	&,UErrorCode &)+69r
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+160p
					; __unwindfunclet$?maskingError@@YAXABVTransliterationRule@icu_56@@0AAUUParseError@@@Z$0+5p
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *__hidden this, int)
		extrn __imp_?truncate@UnicodeString@icu_56@@QAECH@Z:near
					; CODE XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+DDp
					; icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString	&,signed char)+42p
					; DATA XREF: ...
; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn __imp_?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z:near
					; CODE XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+BCp
					; maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const &,UParseError &)+13Ap
					; DATA XREF: ...
		extrn _uprv_min_56:near	; CODE XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+9Dp
					; maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const &,UParseError &)+11Bp
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+8Fp
					; maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const &,UParseError &)+10Dp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+45p
					; DATA XREF: maskingError(icu_56::TransliterationRule const &,icu_56::TransliterationRule const	&,UParseError &)+45r
; enum icu_56::UMatchDegree __thiscall __high icu_56::TransliterationRule::matchAndReplace(struct icu_56::Replaceable *, struct	UTransPosition *, signed __int8)
		extrn ?matchAndReplace@TransliterationRule@icu_56@@QBE?AW4UMatchDegree@2@AAVReplaceable@2@AAUUTransPosition@@C@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+87p
; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *__hidden this, int)
		extrn __imp_?char32At@Replaceable@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition	&,signed char)+2Fp
					; icu_56::TransliterationRuleSet::transliterate(icu_56::Replaceable &,UTransPosition &,signed char)+C2p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, wchar_t)
		extrn __imp_?append@UnicodeString@icu_56@@QAEAAV12@_W@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)+76p
					; DATA XREF: icu_56::TransliterationRuleSet::toRules(icu_56::UnicodeString &,signed char)+76r
; void __thiscall icu_56::TransliterationRule::addSourceSetTo(icu_56::TransliterationRule *__hidden this, struct icu_56::UnicodeSet *)
		extrn ?addSourceSetTo@TransliterationRule@icu_56@@QBEXAAVUnicodeSet@2@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char)+A4p
; void __thiscall icu_56::TransliterationRule::addTargetSetTo(icu_56::TransliterationRule *__hidden this, struct icu_56::UnicodeSet *)
		extrn ?addTargetSetTo@TransliterationRule@icu_56@@QBEXAAVUnicodeSet@2@@Z:near
					; CODE XREF: icu_56::TransliterationRuleSet::getSourceTargetSet(icu_56::UnicodeSet &,signed char)+96p


		end
