;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6853FCC98C2479374839627EDD52314E
; Input	CRC32 :	9BB548AB

; File Name   :	D:\compspace\objfiles\firefox\genrb\rbutil.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl get_dirname(char *, char *)
		public _get_dirname
_get_dirname	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		push	5Ch ; '\'       ; int
		mov	eax, [ebp+arg_4]
		push	eax		; char *
		call	dword ptr ds:__imp__strrchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jbe	short loc_82
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_8]
		sub	ecx, [ebp+arg_4]
		mov	esi, esp
		push	ecx		; size_t
		mov	edx, [ebp+arg_4]
		push	edx		; char *
		mov	eax, [ebp+arg_0]
		push	eax		; char *
		call	dword ptr ds:__imp__strncpy
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	byte ptr [ecx+eax], 0
		jmp	short loc_88
; ---------------------------------------------------------------------------

loc_82:					; CODE XREF: _get_dirname+42j
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax],	0

loc_88:					; CODE XREF: _get_dirname+80j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_get_dirname	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 9Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 0A0h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl get_basename(char	*, char	*)
		public _get_basename
_get_basename	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		push	5Ch ; '\'       ; int
		mov	eax, [ebp+arg_4]
		push	eax		; char *
		call	dword ptr ds:__imp__strrchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jbe	short loc_FA
		mov	eax, [ebp+var_8]
		push	eax		; char *
		mov	ecx, [ebp+arg_0]
		push	ecx		; char *
		call	_strcpy
		add	esp, 8
		jmp	short loc_10A
; ---------------------------------------------------------------------------

loc_FA:					; CODE XREF: _get_basename+42j
		mov	eax, [ebp+arg_4]
		push	eax		; char *
		mov	ecx, [ebp+arg_0]
		push	ecx		; char *
		call	_strcpy
		add	esp, 8

loc_10A:				; CODE XREF: _get_basename+54j
		mov	esi, esp
		push	2Eh ; '.'       ; int
		mov	eax, [ebp+arg_0]
		push	eax		; char *
		call	dword ptr ds:__imp__strrchr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_131
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax],	0

loc_131:				; CODE XREF: _get_basename+85j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_get_basename	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 148h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _itostr
_itostr		proc near

var_128		= dword	ptr -128h
var_5D		= byte ptr -5Dh
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= byte ptr -18h
var_17		= byte ptr -17h
var_16		= byte ptr -16h
var_15		= byte ptr -15h
var_14		= byte ptr -14h
var_13		= byte ptr -13h
var_12		= byte ptr -12h
var_11		= byte ptr -11h
var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_A		= byte ptr -0Ah
var_9		= byte ptr -9
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 128h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_128]
		mov	ecx, 4Ah ; 'J'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_18], 30h ; '0'
		mov	[ebp+var_17], 31h ; '1'
		mov	[ebp+var_16], 32h ; '2'
		mov	[ebp+var_15], 33h ; '3'
		mov	[ebp+var_14], 34h ; '4'
		mov	[ebp+var_13], 35h ; '5'
		mov	[ebp+var_12], 36h ; '6'
		mov	[ebp+var_11], 37h ; '7'
		mov	[ebp+var_10], 38h ; '8'
		mov	[ebp+var_F], 39h ; '9'
		mov	[ebp+var_E], 61h ; 'a'
		mov	[ebp+var_D], 62h ; 'b'
		mov	[ebp+var_C], 63h ; 'c'
		mov	[ebp+var_B], 64h ; 'd'
		mov	[ebp+var_A], 65h ; 'e'
		mov	[ebp+var_9], 66h ; 'f'
		mov	[ebp+var_24], 0
		mov	[ebp+var_30], 0
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_3C], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_1D2
		mov	eax, [ebp+arg_4]
		neg	eax
		mov	[ebp+arg_4], eax

loc_1D2:				; CODE XREF: _itostr+80j _itostr+BCj
		mov	eax, [ebp+arg_4]
		xor	edx, edx
		div	[ebp+arg_8]
		mov	[ebp+var_48], edx
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_24]
		mov	ecx, [ebp+var_48]
		mov	dl, [ebp+ecx+var_18]
		mov	[eax], dl
		mov	eax, [ebp+var_24]
		add	eax, 1
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_4]
		xor	edx, edx
		div	[ebp+arg_8]
		mov	[ebp+arg_4], eax
		cmp	[ebp+arg_4], 0
		jnz	short loc_1D2

loc_206:				; CODE XREF: _itostr+D8j
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+arg_C]
		jge	short loc_222
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_24]
		mov	byte ptr [eax],	30h ; '0'
		mov	ecx, [ebp+var_24]
		add	ecx, 1
		mov	[ebp+var_24], ecx
		jmp	short loc_206
; ---------------------------------------------------------------------------

loc_222:				; CODE XREF: _itostr+C4j
		cmp	[ebp+var_3C], 0
		jge	short loc_23A
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_24]
		mov	byte ptr [eax],	2Dh ; '-'
		mov	ecx, [ebp+var_24]
		add	ecx, 1
		mov	[ebp+var_24], ecx

loc_23A:				; CODE XREF: _itostr+DEj
		cmp	[ebp+var_24], 0Ah
		jge	short loc_249
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_24]
		mov	byte ptr [eax],	0

loc_249:				; CODE XREF: _itostr+F6j
		mov	eax, [ebp+arg_C]
		cmp	eax, [ebp+var_24]
		jl	short loc_25C
		mov	ecx, [ebp+arg_C]
		mov	[ebp+var_128], ecx
		jmp	short loc_265
; ---------------------------------------------------------------------------

loc_25C:				; CODE XREF: _itostr+107j
		mov	edx, [ebp+var_24]
		mov	[ebp+var_128], edx

loc_265:				; CODE XREF: _itostr+112j
		mov	eax, [ebp+var_128]
		mov	[ebp+var_30], eax
		mov	[ebp+var_54], 0
		jmp	short loc_280
; ---------------------------------------------------------------------------

loc_277:				; CODE XREF: _itostr+179j
		mov	eax, [ebp+var_54]
		add	eax, 1
		mov	[ebp+var_54], eax

loc_280:				; CODE XREF: _itostr+12Dj
		mov	eax, [ebp+var_30]
		cdq
		sub	eax, edx
		sar	eax, 1
		cmp	[ebp+var_54], eax
		jge	short loc_2C3
		mov	eax, [ebp+var_24]
		sub	eax, 1
		sub	eax, [ebp+var_54]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+eax]
		mov	[ebp+var_5D], dl
		mov	eax, [ebp+var_24]
		sub	eax, 1
		sub	eax, [ebp+var_54]
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_54]
		mov	edx, [ebp+arg_0]
		mov	cl, [ecx]
		mov	[edx+eax], cl
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+var_54]
		mov	cl, [ebp+var_5D]
		mov	[eax], cl
		jmp	short loc_277
; ---------------------------------------------------------------------------

loc_2C3:				; CODE XREF: _itostr+143j
		mov	eax, [ebp+var_24]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18
		call	@_RTC_CheckStackVars@8
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4
		mov	esp, ebp
		pop	ebp
		retn
_itostr		endp

; ---------------------------------------------------------------------------
$LN18		dd 1			; DATA XREF: _itostr+182o
		dd offset $LN17
$LN17		dd 0FFFFFFE8h, 10h	; DATA XREF: .text:000002ECo
		dd offset $LN16		; "digits"
$LN16		db 'digits',0           ; DATA XREF: .text:000002F8o
_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; char *__cdecl	_strncpy(char *, const char *, size_t)
		extrn __imp__strncpy:near ; CODE XREF: _get_dirname+63p
					; DATA XREF: _get_dirname+63r
		extrn _uprv_checkValidMemory:near ; CODE XREF: _get_dirname+4Ap
; char *__cdecl	_strrchr(const char *, int)
		extrn __imp__strrchr:near ; CODE XREF: _get_dirname+26p
					; _get_basename+26p ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _get_dirname+31p
					; _get_dirname+6Ep ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; char *__cdecl	strcpy(char *, const char *)
		extrn _strcpy:near	; CODE XREF: _get_basename+4Cp
					; _get_basename+5Ep
		extrn ___security_cookie:near ;	DATA XREF: _itostr+1Er
		extrn @__security_check_cookie@4:near ;	CODE XREF: _itostr+197p
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _itostr+188p


		end
