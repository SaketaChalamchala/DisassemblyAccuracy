;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	734FE72F9C41CFBC70081B09528F9C02
; Input	CRC32 :	7E7176D7

; File Name   :	D:\compspace\objfiles\firefox\genrb\parse.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public ??_C@_07NBCGADJA@Unknown?$AA@
; `string'
??_C@_07NBCGADJA@Unknown?$AA@ db 'Unknown',0 ; DATA XREF: .data:_gResourceTypeso
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ??_C@_1CI@MPEKLJOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAe?$AAn?$AAc?$AAy?$AA?$CJ?$AA?$AA@
; `string'
??_C@_1CI@MPEKLJOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAe?$AAn?$AAc?$AAy?$AA?$CJ?$AA?$AA@:
					; DATA XREF: .data:_k_type_plugin_dependencyo
		unicode	0, <process(dependency)>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@
; `string'
??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@:
					; DATA XREF: .data:_k_type_plugin_transliteratoro
					; .rdata:int const std::_Locbase<int>::allo
		unicode	0, <process(transliterator)>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ??_C@_1CG@EBMHPNKP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAc?$AAo?$AAl?$AAl?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CJ?$AA?$AA@
; `string'
??_C@_1CG@EBMHPNKP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAc?$AAo?$AAl?$AAl?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CJ?$AA?$AA@:
					; DATA XREF: .data:_k_type_plugin_collationo
		unicode	0, <process(collation)>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ??_C@_1CG@CLFLHNGO@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAu?$AAc?$AAa?$AA_?$AAr?$AAu?$AAl?$AAe?$AAs?$AA?$CJ?$AA?$AA@
; `string'
??_C@_1CG@CLFLHNGO@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAu?$AAc?$AAa?$AA_?$AAr?$AAu?$AAl?$AAe?$AAs?$AA?$CJ?$AA?$AA@:
					; DATA XREF: .data:_k_type_plugin_uca_ruleso
		unicode	0, <process(uca_rules)>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ??_C@_1BA@FPACGCNF@?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?$AA@
; `string'
??_C@_1BA@FPACGCNF@?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?$AA@:
					; DATA XREF: .data:_k_type_includeo
		unicode	0, <include>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ??_C@_1O@OHAHDHDJ@?$AAi?$AAm?$AAp?$AAo?$AAr?$AAt?$AA?$AA@
; `string'
??_C@_1O@OHAHDHDJ@?$AAi?$AAm?$AAp?$AAo?$AAr?$AAt?$AA?$AA@:
					; DATA XREF: .data:_k_type_importo
		unicode	0, <import>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ??_C@_1BE@FKCBEKLG@?$AAi?$AAn?$AAt?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$AA@
; `string'
??_C@_1BE@FKCBEKLG@?$AAi?$AAn?$AAt?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$AA@:
					; DATA XREF: .data:_k_type_intvectoro
		unicode	0, <intvector>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ??_C@_1M@IJIAJFBE@?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?$AA@
; `string'
??_C@_1M@IJIAJFBE@?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?$AA@: ;	DATA XREF: .data:_k_type_aliaso
		unicode	0, <alias>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ??_C@_1M@POILOJFG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
; `string'
??_C@_1M@POILOJFG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@: ;	DATA XREF: .data:_k_type_arrayo
		unicode	0, <array>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
		public ??_C@_1BA@ODJLMHLJ@?$AAi?$AAn?$AAt?$AAe?$AAg?$AAe?$AAr?$AA?$AA@
; `string'
??_C@_1BA@ODJLMHLJ@?$AAi?$AAn?$AAt?$AAe?$AAg?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: .data:_k_type_integero
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		unicode	0, <integer>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10Ch
		public ??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@
; `string'
??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@: ; DATA XREF:	.data:_k_type_into
		unicode	0, <int>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 114h
		public ??_C@_1CE@PKHPIGGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$CI?$AAn?$AAo?$AAf?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?$CJ?$AA?$AA@
; `string'
??_C@_1CE@PKHPIGGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$CI?$AAn?$AAo?$AAf?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?$CJ?$AA?$AA@:
					; DATA XREF: .data:_k_type_table_no_fallbacko
		unicode	0, <table(nofallback)>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 138h
		public ??_C@_1M@HMEDIDID@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
; `string'
??_C@_1M@HMEDIDID@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@: ;	DATA XREF: .data:_k_type_tableo
		unicode	0, <table>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 144h
		public ??_C@_17PMBBFJPC@?$AAb?$AAi?$AAn?$AA?$AA@
; `string'
??_C@_17PMBBFJPC@?$AAb?$AAi?$AAn?$AA?$AA@: ; DATA XREF:	.data:_k_type_bino
		unicode	0, <bin>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14Ch
		public ??_C@_1O@HFLOEMBP@?$AAb?$AAi?$AAn?$AAa?$AAr?$AAy?$AA?$AA@
; `string'
??_C@_1O@HFLOEMBP@?$AAb?$AAi?$AAn?$AAa?$AAr?$AAy?$AA?$AA@:
					; DATA XREF: .data:_k_type_binaryo
		unicode	0, <binary>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 15Ch
		public ??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
; `string'
??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@:
					; DATA XREF: .data:_k_type_stringo
		unicode	0, <string>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 16Ch
		public ??_C@_0O@LHFPPFNO@?$DMend?5of?5line?$DO?$AA@
; `string'
??_C@_0O@LHFPPFNO@?$DMend?5of?5line?$DO?$AA@ db	'<end of line>',0
					; DATA XREF: .data:000002B4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 17Ch
		public ??_C@_0O@LMMNBODD@?$DMend?5of?5file?$DO?$AA@
; `string'
??_C@_0O@LMMNBODD@?$DMend?5of?5file?$DO?$AA@ db	'<end of file>',0
					; DATA XREF: .data:000002B0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18Ch
		public ??_C@_03BAGHGFEH@?8?3?8?$AA@
; `string'
??_C@_03BAGHGFEH@?8?3?8?$AA@ dd	273A27h	; DATA XREF: .data:000002ACo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 190h
		public ??_C@_03IMMLKIF@?8?0?8?$AA@
; `string'
??_C@_03IMMLKIF@?8?0?8?$AA@ dd 272C27h	; DATA XREF: .data:000002A8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 194h
		public ??_C@_03GFLCPOAC@?8?$HN?8?$AA@
; `string'
??_C@_03GFLCPOAC@?8?$HN?8?$AA@ dd 277D27h ; DATA XREF: .data:000002A4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 198h
		public ??_C@_03GBDPICLA@?8?$HL?8?$AA@
; `string'
??_C@_03GBDPICLA@?8?$HL?8?$AA@ dd 277B27h ; DATA XREF: .data:000002A0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 19Ch
		public ??_C@_06ICGJLFIM@string?$AA@
; `string'
??_C@_06ICGJLFIM@string?$AA@ db	'string',0 ; DATA XREF: .data:char const * * tokenNameso
					; .data:00000308o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 1A4h
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 1A8h
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1ACh
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B0h
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B4h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B8h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1BCh
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1C0h
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1C4h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1C8h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1CCh
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D0h
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D4h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D8h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DCh
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E0h
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E4h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E8h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1ECh
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F0h
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F4h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F8h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1FCh
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 200h
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ??_C@_1CI@MPEKLJOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAe?$AAn?$AAc?$AAy?$AA?$CJ?$AA?$AA@+18h
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
_rdata		ends			; "ndency)"

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 204h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+0Fh ; "_____________"...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 208h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20Ch
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 210h
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 214h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 218h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 21Ch
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 220h
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_1CI@MPEKLJOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAe?$AAn?$AAc?$AAy?$AA?$CJ?$AA?$AA@+18h ; "ndency)"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 224h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h ; "transliterator)"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 228h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ??_C@_1CG@EBMHPNKP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAc?$AAo?$AAl?$AAl?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CJ?$AA?$AA@+20h ; "n)"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 22Ch
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??_C@_1BA@ODJLMHLJ@?$AAi?$AAn?$AAt?$AAe?$AAg?$AAe?$AAr?$AA?$AA@+4 ; "teger"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 230h
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	?messages@?$_Locbase@H@std@@2HB	; int const std::_Locbase<int>::messages
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 234h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 238h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 23Ch
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 240h
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ??_C@_0CO@BFNMPOJB@parse?5error?4?5Stopped?5parsing?5res@+2Ch	; "s"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 244h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 248h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24Ch
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 250h
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	?_Rank@?$_Arithmetic_traits@F@std@@2HB ; int const std::_Arithmetic_traits<short>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 254h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset locret_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 258h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 25Ch
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 260h
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 264h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 268h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26Ch
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 270h
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 274h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 278h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 27Ch
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 280h
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 284h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h	; "transliterator)"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 288h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ??_C@_1CG@EBMHPNKP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAc?$AAo?$AAl?$AAl?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CJ?$AA?$AA@+20h	; "n)"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28Ch
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ??_C@_1CI@MPEKLJOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAe?$AAn?$AAc?$AAy?$AA?$CJ?$AA?$AA@+18h ; "ndency)"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 290h
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 294h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 298h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 29Ch
		public ?tokenNames@@3PAPBDA
; char const * * tokenNames
?tokenNames@@3PAPBDA dd	offset ??_C@_06ICGJLFIM@string?$AA@
					; DATA XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+76r
					; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)+81r ...
					; "string"
		dd offset ??_C@_03GBDPICLA@?8?$HL?8?$AA@ ; `string'
		dd offset ??_C@_03GFLCPOAC@?8?$HN?8?$AA@ ; `string'
		dd offset ??_C@_03IMMLKIF@?8?0?8?$AA@ ;	`string'
		dd offset ??_C@_03BAGHGFEH@?8?3?8?$AA@ ; `string'
		dd offset ??_C@_0O@LMMNBODD@?$DMend?5of?5file?$DO?$AA@ ; "<end of file>"
		dd offset ??_C@_0O@LHFPPFNO@?$DMend?5of?5line?$DO?$AA@ ; "<end of line>"
_k_type_string	dd offset ??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1Er
					; "string"
_k_type_binary	dd offset ??_C@_1O@HFLOEMBP@?$AAb?$AAi?$AAn?$AAa?$AAr?$AAy?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+3Cr
					; "binary"
_k_type_bin	dd offset ??_C@_17PMBBFJPC@?$AAb?$AAi?$AAn?$AA?$AA@
					; DATA XREF: parseResourceType(ParseState *,UErrorCode *):loc_21EFr
					; "bin"
_k_type_table	dd offset ??_C@_1M@HMEDIDID@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+5Ar
					; "table"
_k_type_table_no_fallback dd offset ??_C@_1CE@PKHPIGGG@?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$CI?$AAn?$AAo?$AAf?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?$CJ?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+78r
					; "table(nofallback)"
_k_type_int	dd offset ??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@
					; DATA XREF: parseResourceType(ParseState *,UErrorCode *):loc_21CEr
					; "int"
_k_type_integer	dd offset ??_C@_1BA@ODJLMHLJ@?$AAi?$AAn?$AAt?$AAe?$AAg?$AAe?$AAr?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+96r
					; "integer"
_k_type_array	dd offset ??_C@_1M@POILOJFG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+B4r
					; "array"
_k_type_alias	dd offset ??_C@_1M@IJIAJFBE@?$AAa?$AAl?$AAi?$AAa?$AAs?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+D2r
					; "alias"
_k_type_intvector dd offset ??_C@_1BE@FKCBEKLG@?$AAi?$AAn?$AAt?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+F0r
					; "intvector"
_k_type_import	dd offset ??_C@_1O@OHAHDHDJ@?$AAi?$AAm?$AAp?$AAo?$AAr?$AAt?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+10Er
					; "import"
_k_type_include	dd offset ??_C@_1BA@FPACGCNF@?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+12Cr
					; "include"
_k_type_plugin_uca_rules dd offset ??_C@_1CG@CLFLHNGO@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAu?$AAc?$AAa?$AA_?$AAr?$AAu?$AAl?$AAe?$AAs?$AA?$CJ?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+14Ar
					; "process(uca_rules)"
_k_type_plugin_collation dd offset ??_C@_1CG@EBMHPNKP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAc?$AAo?$AAl?$AAl?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CJ?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+168r
					; "process(collation)"
_k_type_plugin_transliterator dd offset	??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+186r
					; "process(transliterator)"
_k_type_plugin_dependency dd offset ??_C@_1CI@MPEKLJOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAe?$AAn?$AAc?$AAy?$AA?$CJ?$AA?$AA@
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1A4r
					; "process(dependency)"
		dd 0
_gResourceTypes	dd offset ??_C@_07NBCGADJA@Unknown?$AA@
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+2B6r
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+31Dr
					; "Unknown"
dword_300	dd 0			; DATA XREF: parseResourceType(ParseState *,UErrorCode *)+A1r
dword_304	dd 0			; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+2D8r
		dd offset ??_C@_06ICGJLFIM@string?$AA@ ; "string"
dword_30C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+23w
dword_310	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+28w
dword_314	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+32w
dword_318	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+41w
dword_31C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+46w
dword_320	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+50w
dword_324	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+5Fw
dword_328	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+64w
dword_32C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+6Ew
dword_330	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+7Dw
dword_334	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+82w
dword_338	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+8Cw
dword_33C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+9Bw
dword_340	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+A0w
dword_344	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+AAw
dword_348	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+B9w
dword_34C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+BEw
dword_350	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+C8w
dword_354	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+D7w
dword_358	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+DCw
dword_35C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+E6w
dword_360	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+F5w
dword_364	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+FAw
dword_368	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+104w
dword_36C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+113w
dword_370	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+118w
dword_374	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+122w
dword_378	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+131w
dword_37C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+136w
dword_380	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+140w
dword_384	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+14Fw
dword_388	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+154w
dword_38C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+15Ew
dword_390	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+16Dw
dword_394	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+172w
dword_398	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+17Cw
dword_39C	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+18Bw
dword_3A0	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+190w
dword_3A4	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+19Aw
dword_3A8	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1A9w
dword_3AC	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1AEw
dword_3B0	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1B8w
dword_3B4	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1C2w
dword_3B8	dd 0			; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1CCw
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 3BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; unsigned int `void __cdecl initLookahead(struct ParseState *,	struct UCHARBUF	*, enum	 UErrorCode *)'::`2'::initTypeStrings
?initTypeStrings@?1??initLookahead@@YAXPAUParseState@@PAUUCHARBUF@@PAW4UErrorCode@@@Z@4IA dd ?
					; DATA XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+1Er
					; initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+27w
; struct SResource *dependencyArray
_dependencyArray dd ?			; DATA XREF: _parse+3A3r _parse+3B2r ...
_bss		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_isInvariantUnicodeString(icu_56::UnicodeString *)
		public _uprv_isInvariantUnicodeString
_uprv_isInvariantUnicodeString proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	esi, esp
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ;	icu_56::UnicodeString::getBuffer(void)

loc_400:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_uprv_isInvariantUString_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_isInvariantUnicodeString endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 424h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 428h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall `anonymous	namespace'::GenrbImporter::~GenrbImporter(void)
		public ??1GenrbImporter@?A0x82188031@@UAE@XZ
??1GenrbImporter@?A0x82188031@@UAE@XZ proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::`scalar deleting destructor'(uint)+26p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+61Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7GenrbImporter@?A0x82188031@@6B@ ; const `anonymous namespace'::GenrbImporter::`vftable'
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??1Importer@CollationRuleParser@icu_56@@UAE@XZ ; icu_56::CollationRuleParser::Importer::~Importer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1GenrbImporter@?A0x82188031@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 480h
		dd offset ??_R4GenrbImporter@?A0x82188031@@6B@ ; const `anonymous namespace'::GenrbImporter::`RTTI Complete Object Locator'
		public ??_7GenrbImporter@?A0x82188031@@6B@
; const	`anonymous namespace'::GenrbImporter::`vftable'
??_7GenrbImporter@?A0x82188031@@6B@ dd offset ??_EGenrbImporter@?A0x82188031@@UAEPAXI@Z
					; DATA XREF: `anonymous	namespace'::GenrbImporter::~GenrbImporter(void)+26o
					; `anonymous namespace'::GenrbImporter::GenrbImporter(char const *,char const *)+38o
					; `anonymous namespace'::GenrbImporter::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z ; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 490h
		public ??_R4GenrbImporter@?A0x82188031@@6B@
; const	`anonymous namespace'::GenrbImporter::`RTTI Complete Object Locator'
??_R4GenrbImporter@?A0x82188031@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000480o
		dd offset ??_R0?AVGenrbImporter@?A0x82188031@@@8 ; `anonymous namespace'::GenrbImporter `RTTI Type Descriptor'
		dd offset ??_R3GenrbImporter@?A0x82188031@@8 ; `anonymous namespace'::GenrbImporter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4A4h
		public ??_R0?AVGenrbImporter@?A0x82188031@@@8
; class	`anonymous namespace'::GenrbImporter `RTTI Type Descriptor'
??_R0?AVGenrbImporter@?A0x82188031@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000049Co
					; .rdata$r:`anonymous namespace'::GenrbImporter::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avgenrbimpor	db '.?AVGenrbImporter@?A0x82188031@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4D0h
		public ??_R3GenrbImporter@?A0x82188031@@8
; `anonymous namespace'::GenrbImporter::`RTTI Class Hierarchy Descriptor'
??_R3GenrbImporter@?A0x82188031@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:000004A0o
					; .rdata$r:0000050Co
		dd 4
		dd offset ??_R2GenrbImporter@?A0x82188031@@8 ; `anonymous namespace'::GenrbImporter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E0h
		public ??_R2GenrbImporter@?A0x82188031@@8
; `anonymous namespace'::GenrbImporter::`RTTI Base Class Array'
??_R2GenrbImporter@?A0x82188031@@8 dd offset ??_R1A@?0A@EA@GenrbImporter@?A0x82188031@@8
					; DATA XREF: .rdata$r:000004DCo
					; `anonymous namespace'::GenrbImporter::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Importer@CollationRuleParser@icu_56@@8 ; icu_56::CollationRuleParser::Importer::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4F4h
		public ??_R1A@?0A@EA@GenrbImporter@?A0x82188031@@8
; `anonymous namespace'::GenrbImporter::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@GenrbImporter@?A0x82188031@@8 dd offset ??_R0?AVGenrbImporter@?A0x82188031@@@8
					; DATA XREF: .rdata$r:`anonymous namespace'::GenrbImporter::`RTTI Base Class Array'o
					; `anonymous namespace'::GenrbImporter `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h ; "transliterator)"
		dd offset ??_R3GenrbImporter@?A0x82188031@@8 ; `anonymous namespace'::GenrbImporter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 510h
		public ??_R1A@?0A@EA@Importer@CollationRuleParser@icu_56@@8
; icu_56::CollationRuleParser::Importer::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@Importer@CollationRuleParser@icu_56@@8 dd	offset ??_R0?AVImporter@CollationRuleParser@icu_56@@@8
					; DATA XREF: .rdata$r:000004E4o
					; .rdata$r:icu_56::CollationRuleParser::Importer::`RTTI	Base Class Array'o
					; icu_56::CollationRuleParser::Importer	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h ; "transliterator)"
		dd offset ??_R3Importer@CollationRuleParser@icu_56@@8 ;	icu_56::CollationRuleParser::Importer::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 52Ch
		public ??_R0?AVImporter@CollationRuleParser@icu_56@@@8
; class	icu_56::CollationRuleParser::Importer `RTTI Type Descriptor'
??_R0?AVImporter@CollationRuleParser@icu_56@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::CollationRuleParser::Importer::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avimporter@c	db '.?AVImporter@CollationRuleParser@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 560h
		public ??_R3Importer@CollationRuleParser@icu_56@@8
; icu_56::CollationRuleParser::Importer::`RTTI Class Hierarchy Descriptor'
??_R3Importer@CollationRuleParser@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000528o
		dd 3
		dd offset ??_R2Importer@CollationRuleParser@icu_56@@8 ;	icu_56::CollationRuleParser::Importer::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 570h
		public ??_R2Importer@CollationRuleParser@icu_56@@8
; icu_56::CollationRuleParser::Importer::`RTTI Base Class Array'
??_R2Importer@CollationRuleParser@icu_56@@8 dd offset ??_R1A@?0A@EA@Importer@CollationRuleParser@icu_56@@8
					; DATA XREF: .rdata$r:0000056Co
					; icu_56::CollationRuleParser::Importer::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 580h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:000004E8o
					; .rdata$r:00000574o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h ; "transliterator)"
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 59Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5BCh
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000598o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5CCh
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:000005C8o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5D8h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:000004ECo
					; .rdata$r:00000578o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h ; "transliterator)"
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5F4h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 614h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000005F0o
					; .rdata$r:00000644o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 624h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000620o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 62Ch
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ??_C@_1DA@BLPBAOOP@?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$CI?$AAt?$AAr?$AAa?$AAn?$AAs?$AAl?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@+10h ; "transliterator)"
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall `anonymous namespace'::GenrbImporter::`scalar deleting destructor'(unsigned int)
		public ??_GGenrbImporter@?A0x82188031@@UAEPAXI@Z
??_GGenrbImporter@?A0x82188031@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_691
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	dword ptr ds:__imp_??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete(void *)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_691:				; CODE XREF: `anonymous	namespace'::GenrbImporter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GGenrbImporter@?A0x82188031@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	`anonymous namespace'::GenrbImporter::getRules(char *, char *Str2, int, int, enum UErrorCode *)
		public ?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z
?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:0000048Co

var_25C		= byte ptr -25Ch
var_258		= byte ptr -258h
var_248		= byte ptr -248h
var_178		= dword	ptr -178h
var_16C		= dword	ptr -16Ch
var_160		= dword	ptr -160h
var_154		= dword	ptr -154h
var_148		= dword	ptr -148h
var_13C		= dword	ptr -13Ch
var_130		= byte ptr -130h
var_124		= dword	ptr -124h
var_118		= dword	ptr -118h
var_10C		= dword	ptr -10Ch
var_100		= byte ptr -100h
var_F0		= dword	ptr -0F0h
var_E4		= byte ptr -0E4h
var_A4		= byte ptr -0A4h
var_64		= dword	ptr -64h
var_58		= byte ptr -58h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str2		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 250h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_25C]
		mov	ecx, 94h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax		; char *
		lea	ecx, [ebp+var_258] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+arg_10]
		push	ecx		; enum UErrorCode *
		lea	edx, [ebp+var_258]
		push	edx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z ; icu_56::CharString::CharString(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_64], 0
		jmp	short loc_740
; ---------------------------------------------------------------------------

loc_737:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &):loc_78Ej
		mov	eax, [ebp+var_64]
		add	eax, 1
		mov	[ebp+var_64], eax

loc_740:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+89j
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?length@CharString@icu_56@@QBEHXZ ; icu_56::CharString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_64], eax
		jge	short loc_790
		mov	esi, esp
		mov	eax, [ebp+var_64]
		push	eax
		lea	ecx, [ebp+var_58]
		call	dword ptr ds:__imp_??ACharString@icu_56@@QBEDH@Z ; icu_56::CharString::operator[](int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		cmp	ecx, 2Dh ; '-'
		jnz	short loc_78E
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_64]
		mov	byte ptr [eax+ecx], 5Fh	; '_'

loc_78E:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+C7j
		jmp	short loc_737
; ---------------------------------------------------------------------------

loc_790:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+A9j
		mov	esi, esp
		push	offset ??_C@_04LCMACLFG@?4txt?$AA@ ; ".txt"
		lea	ecx, [ebp+var_248] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_248]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7FA
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_DC6
; ---------------------------------------------------------------------------

loc_7FA:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+12Ej
		mov	esi, esp

loc_7FC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+4], 0
		jnz	loc_912
		push	5Ch ; '\'       ; int
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; Str
		call	?strrchr@@YAPADPADH@Z ;	strrchr(char *,int)
		add	esp, 8
		mov	[ebp+var_F0], eax
		cmp	[ebp+var_F0], 0
		jz	loc_90D
		mov	esi, esp
		lea	eax, [ebp+var_100]
		push	eax
		lea	ecx, [ebp+var_58]
		call	dword ptr ds:__imp_?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ ; icu_56::CharString::toStringPiece(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?length@CharString@icu_56@@QBEHXZ ; icu_56::CharString::length(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	esi, eax
		mov	[ebp+var_10C], esi
		mov	eax, [ebp+var_10C]
		sub	eax, [ebp+var_F0]
		mov	esi, esp
		push	eax		; int
		lea	ecx, [ebp+var_100] ; this
		call	dword ptr ds:__imp_?remove_suffix@StringPiece@icu_56@@QAEXH@Z ;	icu_56::StringPiece::remove_suffix(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_100]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_18]
		mov	[ecx+4], eax

loc_90D:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+1B7j
		jmp	loc_9B1
; ---------------------------------------------------------------------------

loc_912:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+187j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		push	ecx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_118], eax
		mov	esi, esp
		push	0
		lea	ecx, [ebp+var_58]
		call	dword ptr ds:__imp_??ACharString@icu_56@@QBEDH@Z ; icu_56::CharString::operator[](int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		cmp	eax, 5Ch ; '\'
		jz	short loc_9B1
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_118]
		movsx	eax, byte ptr [ecx+edx-1]
		cmp	eax, 2Eh ; '.'
		jz	short loc_9B1
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_118]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		mov	eax, [edx+4]
		push	eax		; char *
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ;	icu_56::CharString::append(char	const *,int,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_118]
		movsx	eax, byte ptr [ecx+edx-1]
		cmp	eax, 5Ch ; '\'
		jz	short loc_9B1
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		push	5Ch ; '\'       ; char
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@DAAW4UErrorCode@@@Z ; icu_56::CharString::append(char,UErrorCode	&)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9B1:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &):loc_90Dj
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+295j ...
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_58]
		push	ecx		; struct icu_56::CharString *
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z	; icu_56::CharString::append(icu_56::CharString	const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A33
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_DC6
; ---------------------------------------------------------------------------

loc_A33:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+335j
		mov	[ebp+var_124], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [ebp+arg_10]
		push	eax
		push	1
		call	_getShowWarning
		movzx	ecx, al
		push	ecx
		lea	edx, [ebp+var_124]
		push	edx
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_ucbuf_open
		add	esp, 14h
		push	eax		; struct UCHARBUF *
		lea	ecx, [ebp+var_130] ; this
		call	??0LocalUCHARBUFPointer@icu_56@@QAE@PAUUCHARBUF@@@Z ; icu_56::LocalUCHARBUFPointer::LocalUCHARBUFPointer(UCHARBUF *)
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 4
		jnz	loc_B2C
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		push	offset ??_C@_0BH@FJJHPLCK@couldn?8t?5open?5file?5?$CFs?6?$AA@ ;	"couldn't open file %s\n"
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_130] ; this
		call	??1LocalUCHARBUFPointer@icu_56@@QAE@XZ ; icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_DC6
; ---------------------------------------------------------------------------

loc_B2C:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+3DBj
		lea	ecx, [ebp+var_130]
		call	?isNull@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBECXZ ;	icu_56::LocalPointerBase<UCHARBUF>::isNull(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_B57
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_C05

loc_B57:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+490j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	edi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		push	offset ??_C@_0DA@IMFPMJAF@An?5error?5occured?5processing?5file@	; "An error occured processing file %s.	Er"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_130] ; this
		call	??1LocalUCHARBUFPointer@icu_56@@QAE@XZ ; icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_DC6
; ---------------------------------------------------------------------------

loc_C05:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+4A5j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		push	0		; char
		push	0		; char
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+8]
		push	edx		; int
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		push	ecx		; int
		lea	ecx, [ebp+var_130]
		call	?getAlias@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBEPAUUCHARBUF@@XZ ; icu_56::LocalPointerBase<UCHARBUF>::getAlias(void)
		push	eax		; int
		call	_parse
		add	esp, 1Ch
		mov	[ebp+var_13C], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_CBC
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_130] ; this
		call	??1LocalUCHARBUFPointer@icu_56@@QAE@XZ ; icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_DC6
; ---------------------------------------------------------------------------

loc_CBC:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+5AFj
		mov	eax, [ebp+var_13C]
		mov	ecx, [eax]
		mov	[ebp+var_148], ecx
		push	offset ??_C@_0L@EMPPBAGD@collations?$AA@ ; "collations"
		mov	eax, [ebp+var_148]
		push	eax		; SResource *
		call	?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z
		add	esp, 8
		mov	[ebp+var_154], eax
		cmp	[ebp+var_154], 0
		jz	short loc_D6C
		mov	eax, [ebp+Str2]
		push	eax		; Str2
		mov	ecx, [ebp+var_154]
		push	ecx		; SResource *
		call	?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z
		add	esp, 8
		mov	[ebp+var_160], eax
		cmp	[ebp+var_160], 0
		jz	short loc_D6C
		push	offset ??_C@_08DOCONEG@Sequence?$AA@ ; "Sequence"
		mov	eax, [ebp+var_160]
		push	eax		; SResource *
		call	?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z
		add	esp, 8
		mov	[ebp+var_16C], eax
		cmp	[ebp+var_16C], 0
		jz	short loc_D6C
		mov	ecx, [ebp+var_16C] ; this
		call	?isString@SResource@@QBECXZ ; SResource::isString(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_D6C
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_178], eax
		mov	eax, [ebp+var_178]
		add	eax, 2Ch ; ','
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_8]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D6C:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+63Fj
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+661j ...
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_130] ; this
		call	??1LocalUCHARBUFPointer@icu_56@@QAE@XZ ; icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_E4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_A4] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_58] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_DC6:				; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+149j
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+382j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN33
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 25Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp

locret_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		retn	14h
?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN33		dd 6			; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+71Eo
		dd offset $LN32
$LN32		dd 0FFFFFFA8h, 38h	; DATA XREF: .text:00000E08o
		dd offset $LN25		; "filename"
		dd 0FFFFFF5Ch, 38h
		dd offset $LN26		; "inputDirBuf"
		dd 0FFFFFF1Ch, 38h
		dd offset $LN27		; "openFileName"
		dd 0FFFFFF00h, 8
		dd offset $LN28		; "dir"
		dd 0FFFFFEDCh, 4
		dd offset $LN29		; "cp"
		dd 0FFFFFED0h, 4
		dd offset $LN30		; "ucbuf"
$LN30		db 'ucbuf',0            ; DATA XREF: .text:00000E50o
$LN29		db 'cp',0               ; DATA XREF: .text:00000E44o
$LN28		db 'dir',0              ; DATA XREF: .text:00000E38o
$LN27		db 'openFileName',0     ; DATA XREF: .text:00000E2Co
$LN26		db 'inputDirBuf',0      ; DATA XREF: .text:00000E20o
$LN25		db 'filename',0         ; DATA XREF: .text:00000E14o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0E84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000F64o
		mov	esi, esp
		lea	ecx, [ebp-58h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00000F6Co
		mov	esi, esp
		lea	ecx, [ebp-0A4h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00000F74o
		mov	esi, esp
		lea	ecx, [ebp-0E4h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$3 proc near
					; DATA XREF: .xdata$x:00000F7Co
		lea	ecx, [ebp-130h]	; this
		jmp	??1LocalUCHARBUFPointer@icu_56@@QAE@XZ ; icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)
__unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z proc	near
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-260h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EF4h
		public ??_C@_08DOCONEG@Sequence?$AA@
; char `string'[]
??_C@_08DOCONEG@Sequence?$AA@ db 'Sequence',0
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+663o
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *):loc_4757o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F00h
		public ??_C@_0L@EMPPBAGD@collations?$AA@
; char `string'[]
??_C@_0L@EMPPBAGD@collations?$AA@ db 'collations',0
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+61Eo
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+5Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0Ch
		public ??_C@_0DA@IMFPMJAF@An?5error?5occured?5processing?5file@
; char `string'[]
??_C@_0DA@IMFPMJAF@An?5error?5occured?5processing?5file@ db 'An error occured processing file %s. Error: %s',0Ah,0
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+4D2o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F3Ch
		public ??_C@_0BH@FJJHPLCK@couldn?8t?5open?5file?5?$CFs?6?$AA@
; char `string'[]
??_C@_0BH@FJJHPLCK@couldn?8t?5open?5file?5?$CFs?6?$AA@ db 'couldn',27h,'t open file %s',0Ah,0
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+3F9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 0F54h
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &):loc_A33o
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+746o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F58h
		public ??_C@_04LCMACLFG@?4txt?$AA@
; char `string'[]
??_C@_04LCMACLFG@?4txt?$AA@ db '.txt',0 ; DATA XREF: `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+E6o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0F60h
__unwindtable$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00000F88o
		dd offset __unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z$3
__ehfuncinfo$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z dd 19930522h, 4
					; DATA XREF: __ehhandler$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+121p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+328p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strrchr(char *Str, int)
		public ?strrchr@@YAPADPADH@Z
?strrchr@@YAPADPADH@Z proc near		; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+1A2p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strrchr

loc_FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strrchr@@YAPADPADH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 101Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocalUCHARBUFPointer::LocalUCHARBUFPointer(icu_56::LocalUCHARBUFPointer *this, struct UCHARBUF *)
		public ??0LocalUCHARBUFPointer@icu_56@@QAE@PAUUCHARBUF@@@Z
??0LocalUCHARBUFPointer@icu_56@@QAE@PAUUCHARBUF@@@Z proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+3CCp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@PAUUCHARBUF@@@Z ;	icu_56::LocalPointerBase<UCHARBUF>::LocalPointerBase<UCHARBUF>(UCHARBUF	*)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0LocalUCHARBUFPointer@icu_56@@QAE@PAUUCHARBUF@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1064h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(icu_56::LocalUCHARBUFPointer *__hidden this)
		public ??1LocalUCHARBUFPointer@icu_56@@QAE@XZ
??1LocalUCHARBUFPointer@icu_56@@QAE@XZ proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+42Bp
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+504p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_ucbuf_close
		add	esp, 4
		mov	ecx, [ebp+var_8]
		call	??1?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<UCHARBUF>::~LocalPointerBase<UCHARBUF>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1LocalUCHARBUFPointer@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall SResource::isString(SResource *__hidden this)
		public ?isString@SResource@@QBECXZ
?isString@SResource@@QBECXZ proc near	; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+68Cp
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+254p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+4]
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isString@SResource@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl `anonymous namespace'::resLookup(SResource *, char *Str2)
?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+62Ap
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+64Cp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		call	_res_none
		cmp	[ebp+arg_0], eax
		jz	short loc_1123
		mov	ecx, [ebp+arg_0] ; this
		call	?isTable@SResource@@QBECXZ ; SResource::isTable(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1127

loc_1123:				; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+26j
		xor	eax, eax
		jmp	short loc_116E
; ---------------------------------------------------------------------------

loc_1127:				; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+35j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		mov	[ebp+var_14], ecx

loc_1136:				; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+7Ej
		cmp	[ebp+var_14], 0
		jz	short loc_116C
		mov	eax, [ebp+Str2]
		push	eax		; Str2
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+38h]
		mov	eax, [edx+14h]
		mov	ecx, [ebp+var_14]
		add	eax, [ecx+10h]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_1161
		mov	eax, [ebp+var_14]
		jmp	short loc_116E
; ---------------------------------------------------------------------------

loc_1161:				; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+6Ej
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_14], ecx
		jmp	short loc_1136
; ---------------------------------------------------------------------------

loc_116C:				; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+4Ej
		xor	eax, eax

loc_116E:				; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+39j
					; ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1184h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall SResource::isTable(SResource	*__hidden this)
		public ?isTable@SResource@@QBECXZ
?isTable@SResource@@QBECXZ proc	near	; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+2Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+4]
		cmp	ecx, 2
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isTable@SResource@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _initParser
_initParser	proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_initParser	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl parse(int, int, int, int,	char, char, enum UErrorCode *)
		public _parse
_parse		proc near		; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+58Ep

var_218		= dword	ptr -218h
var_210		= dword	ptr -210h
var_204		= dword	ptr -204h
var_1F8		= dword	ptr -1F8h
var_1EC		= dword	ptr -1ECh
var_1E0		= dword	ptr -1E0h
var_1D4		= dword	ptr -1D4h
var_108		= dword	ptr -108h
var_FC		= dword	ptr -0FCh
var_F0		= dword	ptr -0F0h
var_EC		= byte ptr -0ECh
var_E0		= byte ptr -0E0h
var_68		= dword	ptr -68h
Str		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= byte ptr -50h
var_4F		= byte ptr -4Fh
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= byte ptr -20h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= byte ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 218h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_218]
		mov	ecx, 86h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_FC], 0
		jmp	short loc_1227
; ---------------------------------------------------------------------------

loc_1218:				; CODE XREF: _parse+7Ej
		mov	eax, [ebp+var_FC]
		add	eax, 1
		mov	[ebp+var_FC], eax

loc_1227:				; CODE XREF: _parse+32j
		cmp	[ebp+var_FC], 4
		jnb	short loc_1264
		mov	eax, [ebp+var_FC]
		shl	eax, 5
		lea	ecx, [ebp+eax+var_EC]
		push	ecx
		call	_ustr_init
		add	esp, 4
		mov	eax, [ebp+var_FC]
		shl	eax, 5
		lea	ecx, [ebp+eax+var_E0]
		push	ecx
		call	_ustr_init
		add	esp, 4
		jmp	short loc_1218
; ---------------------------------------------------------------------------

loc_1264:				; CODE XREF: _parse+4Aj
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_F0]
		push	edx
		call	?initLookahead@@YAXPAUParseState@@PAUUCHARBUF@@PAW4UErrorCode@@@Z ; initLookahead(ParseState *,UCHARBUF	*,UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		mov	[ebp+Str], eax
		cmp	[ebp+Str], 0
		jz	short loc_129B
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_218], eax
		jmp	short loc_12A5
; ---------------------------------------------------------------------------

loc_129B:				; CODE XREF: _parse+A1j
		mov	[ebp+var_218], 0

loc_12A5:				; CODE XREF: _parse+B5j
		mov	ecx, [ebp+var_218]
		mov	[ebp+var_60], ecx
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_5C], eax
		cmp	[ebp+var_5C], 0
		jz	short loc_12CE
		mov	eax, [ebp+var_5C]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_218], eax
		jmp	short loc_12D8
; ---------------------------------------------------------------------------

loc_12CE:				; CODE XREF: _parse+D4j
		mov	[ebp+var_218], 0

loc_12D8:				; CODE XREF: _parse+E8j
		mov	ecx, [ebp+var_218]
		mov	[ebp+var_58], ecx
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_54], eax
		mov	al, [ebp+arg_10]
		mov	[ebp+var_50], al
		mov	al, [ebp+arg_14]
		mov	[ebp+var_4F], al
		lea	eax, [ebp+var_20]
		push	eax
		call	_ustr_init
		add	esp, 4
		mov	eax, [ebp+arg_18]
		push	eax
		push	0
		lea	ecx, [ebp+var_20]
		push	ecx
		lea	edx, [ebp+var_C]
		push	edx
		push	0
		lea	eax, [ebp+var_F0]
		push	eax
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		push	88h ; ''       ; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_204], eax
		cmp	[ebp+var_204], 0
		jz	short loc_1357
		mov	eax, [ebp+arg_18]
		push	eax
		push	0
		lea	ecx, [ebp+var_20]
		push	ecx
		mov	ecx, [ebp+var_204]
		call	??0SRBRoot@@QAE@PBUUString@@CAAW4UErrorCode@@@Z	; SRBRoot::SRBRoot(UString const *,signed char,UErrorCode &)
		mov	[ebp+var_218], eax
		jmp	short loc_1361
; ---------------------------------------------------------------------------

loc_1357:				; CODE XREF: _parse+154j
		mov	[ebp+var_218], 0

loc_1361:				; CODE XREF: _parse+171j
		mov	edx, [ebp+var_218]
		mov	[ebp+var_210], edx
		mov	eax, [ebp+var_210]
		mov	[ebp+var_68], eax
		cmp	[ebp+var_68], 0
		jz	short loc_1391
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1398

loc_1391:				; CODE XREF: _parse+196j
		xor	eax, eax
		jmp	loc_167E
; ---------------------------------------------------------------------------

loc_1398:				; CODE XREF: _parse+1ABj
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_68] ; this
		call	?setLocale@SRBRoot@@QAEXPA_WAAW4UErrorCode@@@Z ; SRBRoot::setLocale(wchar_t *,UErrorCode &)
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		push	0
		push	0
		lea	edx, [ebp+var_F0]
		push	edx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 4
		jnz	short loc_144A
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_F0]
		push	ecx
		call	?parseResourceType@@YA?AW4EResourceType@@PAUParseState@@PAW4UErrorCode@@@Z ; parseResourceType(ParseState *,UErrorCode *)
		add	esp, 8
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		push	eax
		call	?isTable@@YACW4EResourceType@@@Z ; isTable(EResourceType)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_141F
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		push	0
		push	0
		push	1
		lea	edx, [ebp+var_F0]
		push	edx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		jmp	short loc_1448
; ---------------------------------------------------------------------------

loc_141F:				; CODE XREF: _parse+21Aj
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 9
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		push	eax
		push	offset ??_C@_0CF@HALJCGFB@parse?5error?4?5Stopped?5parsing?5wit@ ; "parse error. Stopped parsing with %s"
		mov	edx, [ebp+var_2C]
		push	edx
		call	_error
		add	esp, 0Ch

loc_1448:				; CODE XREF: _parse+239j
		jmp	short loc_1492
; ---------------------------------------------------------------------------

loc_144A:				; CODE XREF: _parse+1E8j
		cmp	[ebp+var_44], 1
		jnz	short loc_1462
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0
		mov	[ebp+var_38], 3
		jmp	short loc_1492
; ---------------------------------------------------------------------------

loc_1462:				; CODE XREF: _parse+26Aj
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 9
		mov	[ebp+var_38], 0
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		push	eax
		push	offset ??_C@_0EH@EIEEPILF@parse?5error?0?5did?5not?5find?5open?9b@ ; "parse error, did not find	open-brace '{"...
		mov	edx, [ebp+var_2C]
		push	edx
		call	_error
		add	esp, 0Ch

loc_1492:				; CODE XREF: _parse:loc_1448j
					; _parse+27Cj
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_14EB
		mov	eax, [ebp+var_68]
		mov	[ebp+var_1EC], eax
		mov	ecx, [ebp+var_1EC]
		mov	[ebp+var_1F8], ecx
		cmp	[ebp+var_1F8], 0
		jz	short loc_14DA
		push	1
		mov	ecx, [ebp+var_1F8]
		call	??_GSRBRoot@@QAEPAXI@Z ; SRBRoot::`scalar deleting destructor'(uint)
		mov	[ebp+var_218], eax
		jmp	short loc_14E4
; ---------------------------------------------------------------------------

loc_14DA:				; CODE XREF: _parse+2DFj
		mov	[ebp+var_218], 0

loc_14E4:				; CODE XREF: _parse+2F4j
		xor	eax, eax
		jmp	loc_167E
; ---------------------------------------------------------------------------

loc_14EB:				; CODE XREF: _parse+2C1j
		cmp	[ebp+var_38], 4
		jnz	short loc_14F8
		mov	eax, [ebp+var_68]
		mov	byte ptr [eax+10h], 1

loc_14F8:				; CODE XREF: _parse+30Bj
		mov	eax, [ebp+var_68]
		movsx	ecx, byte ptr [eax+12h]
		test	ecx, ecx
		jz	short loc_1529
		mov	edx, ds:?__LINE__Var@?1??parse@@9@4JA ;	long `parse'::`2'::__LINE__Var
		add	edx, 57h ; 'W'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1GC@JGFNCEAK@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAt?$AAo?$AAo?$AAl?$AAs@ ; "d:\\mozilla\\intl\\icu\\source\\tools\\"...
		push	offset ??_C@_1DK@KPPKJLPF@?$AA?$CB?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?4?$AAb?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?9?$AA?$DO?$AAf?$AAI?$AAs?$AAP?$AAo?$AAo?$AAl?$AAB?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?$AA@	; "!state.bundle->fIsPoolBundle"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1529:				; CODE XREF: _parse+31Dj
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		movsx	edx, byte ptr [ecx+4]
		cmp	edx, 2
		jz	short loc_155C
		mov	eax, ds:?__LINE__Var@?1??parse@@9@4JA ;	long `parse'::`2'::__LINE__Var
		add	eax, 58h ; 'X'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1GC@JGFNCEAK@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAt?$AAo?$AAo?$AAl?$AAs@ ; "d:\\mozilla\\intl\\icu\\source\\tools\\"...
		push	offset ??_C@_1FC@CNANBCHM@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?4?$AAb?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?9?$AA?$DO?$AAf?$AAR?$AAo?$AAo?$AAt?$AA?9?$AA?$DO?$AAf?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAU?$AAR@ ; "state.bundle->fRoot->fType == URES_TABL"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_155C:				; CODE XREF: _parse+351j
		mov	eax, [ebp+var_68]
		mov	ecx, [eax]
		mov	[ebp+var_108], ecx
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_2C]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+var_108]
		push	edx		; TableResource	*
		lea	eax, [ebp+var_F0]
		push	eax		; int
		call	?realParseTable@@YAPAUSResource@@PAUParseState@@PAVTableResource@@PADIPAW4UErrorCode@@@Z ; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)
		add	esp, 14h
		cmp	ds:_dependencyArray, 0
		jz	short loc_15B2
		mov	eax, [ebp+arg_18]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	ecx, ds:_dependencyArray
		push	ecx		; struct SResource *
		mov	ecx, [ebp+var_108] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		mov	ds:_dependencyArray, 0

loc_15B2:				; CODE XREF: _parse+3AAj
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1616
		mov	eax, [ebp+var_68]
		mov	[ebp+var_1D4], eax
		mov	ecx, [ebp+var_1D4]
		mov	[ebp+var_1E0], ecx
		cmp	[ebp+var_1E0], 0
		jz	short loc_15FA
		push	1
		mov	ecx, [ebp+var_1E0]
		call	??_GSRBRoot@@QAEPAXI@Z ; SRBRoot::`scalar deleting destructor'(uint)
		mov	[ebp+var_218], eax
		jmp	short loc_1604
; ---------------------------------------------------------------------------

loc_15FA:				; CODE XREF: _parse+3FFj
		mov	[ebp+var_218], 0

loc_1604:				; CODE XREF: _parse+414j
		mov	eax, ds:_dependencyArray
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_167E
; ---------------------------------------------------------------------------

loc_1616:				; CODE XREF: _parse+3E1j
		mov	eax, [ebp+arg_18]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		push	0
		push	0
		lea	edx, [ebp+var_F0]
		push	edx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		cmp	eax, 5
		jz	short loc_1660
		push	offset ??_C@_0EB@HEMGLBM@extraneous?5text?5after?5resource?5b@ ; "extraneous text after	resource bundle	("...
		mov	eax, [ebp+var_2C]
		push	eax
		call	_warning
		add	esp, 8
		call	_isStrict
		movsx	eax, al
		test	eax, eax
		jz	short loc_1660
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 3
		xor	eax, eax
		jmp	short loc_167E
; ---------------------------------------------------------------------------

loc_1660:				; CODE XREF: _parse+450j _parse+46Dj
		lea	eax, [ebp+var_F0]
		push	eax
		call	?cleanupLookahead@@YAXPAUParseState@@@Z	; cleanupLookahead(ParseState *)
		add	esp, 4
		lea	eax, [ebp+var_20]
		push	eax
		call	_ustr_deinit
		add	esp, 4
		mov	eax, [ebp+var_68]

loc_167E:				; CODE XREF: _parse+1AFj _parse+302j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN37
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 218h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_parse		endp

; ---------------------------------------------------------------------------
		align 10h
$LN37		dd 4			; DATA XREF: _parse+49Eo
		dd offset $LN36
$LN36		dd 0FFFFFFF4h, 4	; DATA XREF: .text:000016B4o
		dd offset $LN32_0	; "tokenValue"
		dd 0FFFFFFE0h, 0Ch
		dd offset $LN33_0	; "comment"
		dd 0FFFFFFD4h, 4
		dd offset $LN34		; "line"
		dd 0FFFFFF10h, 0A4h
		dd offset $LN35		; "state"
$LN35		db 'state',0            ; DATA XREF: .text:000016E4o
$LN34		db 'line',0             ; DATA XREF: .text:000016D8o
$LN33_0		db 'comment',0          ; DATA XREF: .text:000016CCo
$LN32_0		db 'tokenValue',0       ; DATA XREF: .text:000016C0o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1708h
		public ??_C@_0EB@HEMGLBM@extraneous?5text?5after?5resource?5b@
; `string'
??_C@_0EB@HEMGLBM@extraneous?5text?5after?5resource?5b@	db 'extraneous text after resource bundle (perhaps unmatched braces)',0
					; DATA XREF: _parse+452o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 174Ch
		public ??_C@_1FC@CNANBCHM@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?4?$AAb?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?9?$AA?$DO?$AAf?$AAR?$AAo?$AAo?$AAt?$AA?9?$AA?$DO?$AAf?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAU?$AAR@
; wchar_t `string'
??_C@_1FC@CNANBCHM@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?4?$AAb?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?9?$AA?$DO?$AAf?$AAR?$AAo?$AAo?$AAt?$AA?9?$AA?$DO?$AAf?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAU?$AAR@:
					; DATA XREF: _parse+363o
		unicode	0, <state.bundle->
		dw 3Eh
		unicode	0, <fRoot->
		dw 3Eh
		unicode	0, <fType == URES_TABLE>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 17A0h
		public ??_C@_1DK@KPPKJLPF@?$AA?$CB?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?4?$AAb?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?9?$AA?$DO?$AAf?$AAI?$AAs?$AAP?$AAo?$AAo?$AAl?$AAB?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?$AA@
; wchar_t `string'
??_C@_1DK@KPPKJLPF@?$AA?$CB?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?4?$AAb?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?9?$AA?$DO?$AAf?$AAI?$AAs?$AAP?$AAo?$AAo?$AAl?$AAB?$AAu?$AAn?$AAd?$AAl?$AAe?$AA?$AA@:
					; DATA XREF: _parse+330o
		unicode	0, <!state.bundle->
		dw 3Eh
		unicode	0, <fIsPoolBundle>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 17DCh
		public ??_C@_1GC@JGFNCEAK@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAt?$AAo?$AAo?$AAl?$AAs@
; wchar_t `string'
??_C@_1GC@JGFNCEAK@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAt?$AAo?$AAo?$AAl?$AAs@:
					; DATA XREF: _parse+32Bo _parse+35Eo
		unicode	0, <d:\mozilla\intl\icu\source\tools\genrb\parse.cpp>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1840h
		public ?__LINE__Var@?1??parse@@9@4JA
; long `parse'::`2'::__LINE__Var
?__LINE__Var@?1??parse@@9@4JA dd 7ABh	; DATA XREF: _parse+31Fr _parse+353r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1844h
		public ??_C@_0EH@EIEEPILF@parse?5error?0?5did?5not?5find?5open?9b@
; `string'
??_C@_0EH@EIEEPILF@parse?5error?0?5did?5not?5find?5open?9b@ db 'parse error, did not find open-brace ',27h,'{',27h,' or colon ',27h,':',27h,','
					; DATA XREF: _parse+29Do
		db ' stopped with %s',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 188Ch
		public ??_C@_0CF@HALJCGFB@parse?5error?4?5Stopped?5parsing?5wit@
; `string'
??_C@_0CF@HALJCGFB@parse?5error?4?5Stopped?5parsing?5wit@ db 'parse error. Stopped parsing with %s',0
					; DATA XREF: _parse+253o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl initLookahead(struct ParseState *, struct UCHARBUF *, enum  UErrorCode *)
?initLookahead@@YAXPAUParseState@@PAUUCHARBUF@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: _parse+8Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	ds:?initTypeStrings@?1??initLookahead@@YAXPAUParseState@@PAUUCHARBUF@@PAW4UErrorCode@@@Z@4IA, 0	; uint `initLookahead(ParseState *,UCHARBUF *,UErrorCode *)'::`2'::initTypeStrings
		jnz	short loc_18E5
		mov	ds:?initTypeStrings@?1??initLookahead@@YAXPAUParseState@@PAUUCHARBUF@@PAW4UErrorCode@@@Z@4IA, 1	; uint `initLookahead(ParseState *,UCHARBUF *,UErrorCode *)'::`2'::initTypeStrings

loc_18E5:				; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+25j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+80h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+84h], ecx
		call	_resetLineNumber
		mov	[ebp+var_8], 0
		jmp	short loc_1915
; ---------------------------------------------------------------------------

loc_190C:				; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *):loc_197Ej
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_1915:				; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+56j
		cmp	[ebp+var_8], 3
		jnb	short loc_1980
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+10h]
		push	eax
		mov	ecx, [ebp+var_8]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+1Ch]
		push	eax
		mov	ecx, [ebp+var_8]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+84h]
		push	edx
		call	_getNextToken
		add	esp, 14h
		mov	ecx, [ebp+var_8]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_197E
		jmp	short loc_1989
; ---------------------------------------------------------------------------

loc_197E:				; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+C6j
		jmp	short loc_190C
; ---------------------------------------------------------------------------

loc_1980:				; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+65j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0

loc_1989:				; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+C8j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initLookahead@@YAXPAUParseState@@PAUUCHARBUF@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl cleanupLookahead(struct ParseState *)
?cleanupLookahead@@YAXPAUParseState@@@Z	proc near ; CODE XREF: _parse+483p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		jmp	short loc_19D0
; ---------------------------------------------------------------------------

loc_19C7:				; CODE XREF: cleanupLookahead(ParseState *)+62j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_19D0:				; CODE XREF: cleanupLookahead(ParseState *)+25j
		cmp	[ebp+var_8], 3
		ja	short loc_1A04
		mov	eax, [ebp+var_8]
		shl	eax, 5
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax+4]
		push	edx
		call	_ustr_deinit
		add	esp, 4
		mov	eax, [ebp+var_8]
		shl	eax, 5
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax+10h]
		push	edx
		call	_ustr_deinit
		add	esp, 4
		jmp	short loc_19C7
; ---------------------------------------------------------------------------

loc_1A04:				; CODE XREF: cleanupLookahead(ParseState *)+34j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?cleanupLookahead@@YAXPAUParseState@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	ETokenType __cdecl getToken(struct ParseState *, struct	UString	* *, struct UString *, unsigned	int *, enum  UErrorCode	*)
?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z proc near
					; CODE XREF: _parse+1D9p _parse+445p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+ecx]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_4], 0
		jz	short loc_1A69
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+4]
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax

loc_1A69:				; CODE XREF: getToken(ParseState *,UString * *,UString *,uint *,UErrorCode *)+37j
		cmp	[ebp+arg_C], 0
		jz	short loc_1A87
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+80h]
		shl	ecx, 5
		mov	edx, [ebp+arg_C]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+ecx+1Ch]
		mov	[edx], ecx

loc_1A87:				; CODE XREF: getToken(ParseState *,UString * *,UString *,uint *,UErrorCode *)+55j
		cmp	[ebp+arg_8], 0
		jz	short loc_1AB1
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		shl	edx, 5
		mov	eax, [ebp+arg_0]
		lea	ecx, [eax+edx+10h]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		call	_ustr_cpy
		add	esp, 0Ch

loc_1AB1:				; CODE XREF: getToken(ParseState *,UString * *,UString *,uint *,UErrorCode *)+73j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+80h]
		add	eax, 3
		xor	edx, edx
		mov	ecx, 4
		div	ecx
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+80h]
		add	eax, 1
		xor	edx, edx
		mov	ecx, 4
		div	ecx
		mov	eax, [ebp+arg_0]
		mov	[eax+80h], edx
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_14]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+10h]
		push	eax
		call	_ustr_setlen
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_14]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+4]
		push	eax
		call	_ustr_setlen
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_14]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+10h]
		push	eax
		mov	ecx, [ebp+var_14]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+1Ch]
		push	eax
		mov	ecx, [ebp+var_14]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+84h]
		push	edx
		call	_getNextToken
		add	esp, 14h
		mov	ecx, [ebp+var_14]
		shl	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl expect(struct ParseState	*, enum	 ETokenType, struct UString * *, struct	UString	*, unsigned int	*, enum	 UErrorCode *)
?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z proc near
					; CODE XREF: _parse+132p _parse+231p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_10], 0
		jz	short loc_1BCF
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx

loc_1BCF:				; CODE XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+41j
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1BE6
		jmp	short loc_1C29
; ---------------------------------------------------------------------------

loc_1BE6:				; CODE XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+5Ej
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jz	short loc_1C20
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 3
		mov	eax, [ebp+var_14]
		mov	ecx, ds:?tokenNames@@3PAPBDA[eax*4] ; char const * * tokenNames
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, ds:?tokenNames@@3PAPBDA[edx*4] ; char const * * tokenNames
		push	eax
		push	offset ??_C@_0BF@BMMFKKLI@expecting?5?$CFs?0?5got?5?$CFs?$AA@ ;	"expecting %s, got %s"
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_error
		add	esp, 10h
		jmp	short loc_1C29
; ---------------------------------------------------------------------------

loc_1C20:				; CODE XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+68j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 0

loc_1C29:				; CODE XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+60j
					; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)+9Aj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN9		dd 1			; DATA XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+A9o
		dd offset $LN8
$LN8		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00001C54o
		dd offset $LN7		; "line"
$LN7		db 'line',0             ; DATA XREF: .text:00001C60o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1C6Ch
		public ??_C@_0BF@BMMFKKLI@expecting?5?$CFs?0?5got?5?$CFs?$AA@
; `string'
??_C@_0BF@BMMFKKLI@expecting?5?$CFs?0?5got?5?$CFs?$AA@ db 'expecting %s, got %s',0
					; DATA XREF: expect(ParseState *,ETokenType,UString * *,UString	*,uint *,UErrorCode *)+89o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl realParseTable(int, TableResource	*, int,	int, enum UErrorCode *)
?realParseTable@@YAPAUSResource@@PAUParseState@@PAVTableResource@@PADIPAW4UErrorCode@@@Z proc near
					; CODE XREF: _parse+39Bp
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+12Fp

var_520		= dword	ptr -520h
var_455		= byte ptr -455h
var_44C		= dword	ptr -44Ch
var_440		= byte ptr -440h
var_38		= dword	ptr -38h
var_2C		= byte ptr -2Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 520h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_520]
		mov	ecx, 148h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0
		mov	[ebp+var_18], 0
		mov	[ebp+var_455], 0
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D0A
		cmp	[ebp+arg_8], 0
		jnz	short loc_1CDF
		mov	[ebp+var_520], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_1CE8
; ---------------------------------------------------------------------------

loc_1CDF:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+4Dj
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_520], eax

loc_1CE8:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+59j
		mov	esi, esp
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_520]
		push	edx
		push	offset ??_C@_0BP@FFJCAGKI@?5parsing?5table?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	parsing	table %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1D0A:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+47j
					; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)+295j
		lea	eax, [ebp+var_2C]
		push	eax
		call	_ustr_init
		add	esp, 4
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_44C]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		lea	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_38], eax
		cmp	[ebp+var_38], 2
		jnz	short loc_1D62
		movsx	eax, [ebp+var_455]
		test	eax, eax
		jnz	short loc_1D5A
		push	offset ??_C@_0BI@INNGNFHE@Encountered?5empty?5table?$AA@ ; "Encountered	empty table"
		mov	eax, [ebp+arg_C]
		push	eax
		call	_warning
		add	esp, 8

loc_1D5A:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+C3j
		mov	eax, [ebp+arg_4]
		jmp	loc_1F1E
; ---------------------------------------------------------------------------

loc_1D62:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+B8j
		cmp	[ebp+var_38], 0
		jz	short loc_1DB0
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		cmp	[ebp+var_38], 5
		jnz	short loc_1D8A
		push	offset ??_C@_0BD@LJADOCP@unterminated?5table?$AA@ ; "unterminated table"
		mov	eax, [ebp+arg_C]
		push	eax
		call	_error
		add	esp, 8
		jmp	short loc_1DA9
; ---------------------------------------------------------------------------

loc_1D8A:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+F1j
		mov	eax, [ebp+var_38]
		mov	ecx, ds:?tokenNames@@3PAPBDA[eax*4] ; char const * * tokenNames
		push	ecx
		push	offset ??_C@_0BE@JICBCMFC@unexpected?5token?5?$CFs?$AA@	; "unexpected token %s"
		mov	edx, [ebp+var_44C]
		push	edx
		call	_error
		add	esp, 0Ch

loc_1DA9:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+104j
		xor	eax, eax
		jmp	loc_1F1E
; ---------------------------------------------------------------------------

loc_1DB0:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+E2j
		push	0FFFFFFFFh
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_isInvariantUString_56
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_1DF0
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx
		call	_u_strlen_56
		add	esp, 4
		add	eax, 1
		push	eax
		lea	edx, [ebp+var_440]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		jmp	short loc_1E14
; ---------------------------------------------------------------------------

loc_1DF0:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+141j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		push	offset ??_C@_0CN@CIOKGMEH@invariant?5characters?5required?5fo@ ; "invariant characters required	for table"...
		mov	eax, [ebp+var_44C]
		push	eax
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	loc_1F1E
; ---------------------------------------------------------------------------

loc_1E14:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+16Aj
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1E53
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		push	eax
		push	offset ??_C@_0CM@KGNPMHKO@parse?5error?4?5Stopped?5parsing?5tok@ ; "parse error. Stopped parsing tokens	wit"...
		mov	edx, [ebp+var_44C]
		push	edx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	loc_1F1E
; ---------------------------------------------------------------------------

loc_1E53:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+1A3j
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		lea	edx, [ebp+var_440]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z ; parseResource(ParseState *,char *,UString const *,UErrorCode	*)
		add	esp, 10h
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jz	short loc_1E8C
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1EB3

loc_1E8C:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+1F1j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		push	eax
		push	offset ??_C@_0CO@BFNMPOJB@parse?5error?4?5Stopped?5parsing?5res@ ; "parse error. Stopped parsing resource w"...
		mov	edx, [ebp+var_44C]
		push	edx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	short loc_1F1E
; ---------------------------------------------------------------------------

loc_1EB3:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+206j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_44C]
		push	ecx		; int
		mov	edx, [ebp+var_C]
		push	edx		; struct SResource *
		mov	ecx, [ebp+arg_4] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1F06
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		push	eax
		push	offset ??_C@_0CL@MDHBFJKC@parse?5error?4?5Stopped?5parsing?5tab@ ; "parse error. Stopped parsing table with"...
		mov	edx, [ebp+var_44C]
		push	edx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	short loc_1F1E
; ---------------------------------------------------------------------------

loc_1F06:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+259j
		mov	[ebp+var_455], 1
		lea	eax, [ebp+var_2C]
		push	eax
		call	_ustr_deinit
		add	esp, 4
		jmp	loc_1D0A
; ---------------------------------------------------------------------------

loc_1F1E:				; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+D9j
					; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)+127j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 520h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?realParseTable@@YAPAUSResource@@PAUParseState@@PAVTableResource@@PADIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN24		dd 4			; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+29Eo
		dd offset $LN23
$LN23		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00001F54o
		dd offset $LN19		; "tokenValue"
		dd 0FFFFFFD4h, 0Ch
		dd offset $LN20		; "comment"
		dd 0FFFFFBC0h, 400h
		dd offset $LN21		; "subtag"
		dd 0FFFFFBB4h, 4
		dd offset $LN22		; "line"
$LN22		db 'line',0             ; DATA XREF: .text:00001F84o
$LN21		db 'subtag',0           ; DATA XREF: .text:00001F78o
$LN20		db 'comment',0          ; DATA XREF: .text:00001F6Co
$LN19		db 'tokenValue',0       ; DATA XREF: .text:00001F60o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1FA8h
		public ??_C@_0CL@MDHBFJKC@parse?5error?4?5Stopped?5parsing?5tab@
; `string'
??_C@_0CL@MDHBFJKC@parse?5error?4?5Stopped?5parsing?5tab@ db 'parse error. Stopped parsing table with %s',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+26Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1FD4h
		public ??_C@_0CO@BFNMPOJB@parse?5error?4?5Stopped?5parsing?5res@
; `string'
??_C@_0CO@BFNMPOJB@parse?5error?4?5Stopped?5parsing?5res@ db 'parse error. Stopped parsing resource with %s',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+217o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2004h
		public ??_C@_0CM@KGNPMHKO@parse?5error?4?5Stopped?5parsing?5tok@
; `string'
??_C@_0CM@KGNPMHKO@parse?5error?4?5Stopped?5parsing?5tok@ db 'parse error. Stopped parsing tokens with %s',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+1B4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2030h
		public ??_C@_0CN@CIOKGMEH@invariant?5characters?5required?5fo@
; `string'
??_C@_0CN@CIOKGMEH@invariant?5characters?5required?5fo@	db 'invariant characters required for table keys',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+175o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2060h
		public ??_C@_0BE@JICBCMFC@unexpected?5token?5?$CFs?$AA@
; `string'
??_C@_0BE@JICBCMFC@unexpected?5token?5?$CFs?$AA@ db 'unexpected token %s',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+111o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2074h
		public ??_C@_0BD@LJADOCP@unterminated?5table?$AA@
; `string'
??_C@_0BD@LJADOCP@unterminated?5table?$AA@ db 'unterminated table',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+F3o
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+14Co ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2088h
		public ??_C@_0BI@INNGNFHE@Encountered?5empty?5table?$AA@
; `string'
??_C@_0BI@INNGNFHE@Encountered?5empty?5table?$AA@ db 'Encountered empty table',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+C5o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20A0h
		public ??_C@_0BP@FFJCAGKI@?5parsing?5table?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BP@FFJCAGKI@?5parsing?5table?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db	' parsing table %s at line %i ',0Ah,0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+71o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20C0h
		public ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
; `string'
??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ db '(null)',0
					; DATA XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+4Fo
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+5Bo ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isTable(enum  EResourceType)
?isTable@@YACW4EResourceType@@@Z proc near ; CODE XREF:	_parse+20Dp

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 3
		jz	short loc_20FB
		cmp	[ebp+arg_0], 4
		jz	short loc_20FB
		mov	[ebp+var_C1], 0
		jmp	short loc_2102
; ---------------------------------------------------------------------------

loc_20FB:				; CODE XREF: isTable(EResourceType)+22j
					; isTable(EResourceType)+28j
		mov	[ebp+var_C1], 1

loc_2102:				; CODE XREF: isTable(EResourceType)+31j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isTable@@YACW4EResourceType@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2110h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	EResourceType __cdecl parseResourceType(struct ParseState *, enum  UErrorCode *)
?parseResourceType@@YA?AW4EResourceType@@PAUParseState@@PAW4UErrorCode@@@Z proc	near
					; CODE XREF: _parse+1FEp
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+FDp

var_504		= byte ptr -504h
var_440		= byte ptr -440h
var_41		= byte ptr -41h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= byte ptr -20h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 504h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_504]
		mov	ecx, 141h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		lea	eax, [ebp+var_20]
		push	eax
		call	_ustr_init
		add	esp, 4
		mov	eax, [ebp+arg_4]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		lea	edx, [ebp+var_20]
		push	edx
		lea	eax, [ebp+var_C]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_218C
		xor	eax, eax
		jmp	loc_2258
; ---------------------------------------------------------------------------

loc_218C:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+73j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		mov	[ebp+var_2C], 0

loc_219C:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *):loc_21CCj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0Fh
		jge	short loc_21CE
		mov	eax, [ebp+var_2C]
		imul	eax, 0Ch
		mov	ecx, ds:dword_300[eax]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx]
		push	eax
		call	_u_strcmp_56
		add	esp, 8
		test	eax, eax
		jnz	short loc_21CC
		jmp	short loc_21CE
; ---------------------------------------------------------------------------

loc_21CC:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+B8j
		jmp	short loc_219C
; ---------------------------------------------------------------------------

loc_21CE:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+99j
					; parseResourceType(ParseState *,UErrorCode *)+BAj
		mov	eax, ds:_k_type_int
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		push	edx
		call	_u_strcmp_56
		add	esp, 8
		test	eax, eax
		jnz	short loc_21EF
		mov	[ebp+var_2C], 5
		jmp	short loc_2255
; ---------------------------------------------------------------------------

loc_21EF:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+D4j
		mov	eax, ds:_k_type_bin
		push	eax
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		push	edx
		call	_u_strcmp_56
		add	esp, 8
		test	eax, eax
		jnz	short loc_2210
		mov	[ebp+var_2C], 2
		jmp	short loc_2255
; ---------------------------------------------------------------------------

loc_2210:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+F5j
		cmp	[ebp+var_2C], 0Fh
		jnz	short loc_2255
		push	400h
		mov	eax, [ebp+var_C]
		mov	ecx, [eax]
		push	ecx
		lea	edx, [ebp+var_440]
		push	edx
		call	_u_austrncpy_56
		add	esp, 0Ch
		mov	[ebp+var_41], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 3
		lea	eax, [ebp+var_440]
		push	eax
		push	offset ??_C@_0BL@PLHECGDM@unknown?5resource?5type?5?8?$CFs?8?$AA@ ; "unknown resource type '%s'"
		mov	ecx, [ebp+var_38]
		push	ecx
		call	_error
		add	esp, 0Ch

loc_2255:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+DDj
					; parseResourceType(ParseState *,UErrorCode *)+FEj ...
		mov	eax, [ebp+var_2C]

loc_2258:				; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+77j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 504h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseResourceType@@YA?AW4EResourceType@@PAUParseState@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN17		dd 4			; DATA XREF: parseResourceType(ParseState *,UErrorCode *)+14Co
		dd offset $LN16
$LN16		dd 0FFFFFFF4h, 4	; DATA XREF: .text:0000228Co
		dd offset $LN12		; "tokenValue"
		dd 0FFFFFFE0h, 0Ch
		dd offset $LN13		; "comment"
		dd 0FFFFFFC8h, 4
		dd offset $LN14		; "line"
		dd 0FFFFFBC0h, 400h
		dd offset $LN15		; "tokenBuffer"
$LN15		db 'tokenBuffer',0      ; DATA XREF: .text:000022BCo
$LN14		db 'line',0             ; DATA XREF: .text:000022B0o
$LN13		db 'comment',0          ; DATA XREF: .text:000022A4o
$LN12		db 'tokenValue',0       ; DATA XREF: .text:00002298o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 22E4h
		public ??_C@_0BL@PLHECGDM@unknown?5resource?5type?5?8?$CFs?8?$AA@
; `string'
??_C@_0BL@PLHECGDM@unknown?5resource?5type?5?8?$CFs?8?$AA@ db 'unknown resource type ',27h,'%s',27h,0
					; DATA XREF: parseResourceType(ParseState *,UErrorCode *)+134o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2300h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseResource(struct ParseState *,	char *,	struct UString const *,	enum  UErrorCode *)
?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z proc near
					; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+1E2p
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+1FDp ...

var_10C		= dword	ptr -10Ch
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= byte ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		push	0
		lea	edx, [ebp+var_2C]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_8], eax
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_2392
		cmp	[ebp+arg_4], 0
		jnz	short loc_2367
		mov	[ebp+var_10C], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_2370
; ---------------------------------------------------------------------------

loc_2367:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+59j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_10C], eax

loc_2370:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+65j
		mov	esi, esp
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+var_10C]
		push	edx
		push	offset ??_C@_0BK@OPKHGHEG@?5resource?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ;	" resource %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2392:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+53j
		mov	eax, [ebp+var_8]
		mov	[ebp+var_10C], eax
		mov	ecx, [ebp+var_10C]
		sub	ecx, 1
		mov	[ebp+var_10C], ecx
		cmp	[ebp+var_10C], 5 ; switch 6 cases
		ja	$LN20_0		; jumptable 000023BD default case
		mov	edx, [ebp+var_10C]
		jmp	ds:$LN38[edx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN25_0:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+BDj
					; DATA XREF: .text:$LN38o
		mov	eax, [ebp+arg_C] ; jumptable 000023BD case 4
		mov	dword ptr [eax], 3
		push	offset ??_C@_0BL@KNAOOEON@Unexpected?5EOF?5encountered?$AA@ ; "Unexpected EOF encountered"
		mov	eax, [ebp+var_38]
		push	eax
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

$LN24_0:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+BDj
					; DATA XREF: .text:$LN38o
		mov	eax, [ebp+arg_C] ; jumptable 000023BD case 5
		mov	dword ptr [eax], 3
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

$LN23_0:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+BDj
					; DATA XREF: .text:$LN38o
		mov	eax, [ebp+arg_C] ; jumptable 000023BD case 3
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?parseResourceType@@YA?AW4EResourceType@@PAUParseState@@PAW4UErrorCode@@@Z ; parseResourceType(ParseState *,UErrorCode *)
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		push	0
		lea	edx, [ebp+var_2C]
		push	edx
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2440
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

loc_2440:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+137j
		jmp	short loc_2465
; ---------------------------------------------------------------------------

$LN21_0:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+BDj
					; DATA XREF: .text:$LN38o
		jmp	short loc_2465	; jumptable 000023BD case 0
; ---------------------------------------------------------------------------

$LN20_0:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+B1j
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+BDj
					; DATA XREF: ...
		mov	eax, [ebp+arg_C] ; jumptable 000023BD default case
		mov	dword ptr [eax], 3
		push	offset ??_C@_0DL@HMJOJDIN@syntax?5error?5while?5reading?5a?5res@ ; "syntax error while reading a resource, "...
		mov	eax, [ebp+var_38]
		push	eax
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

loc_2465:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *):loc_2440j
					; parseResource(ParseState *,char *,UString const *,UErrorCode *):$LN21_0j
		cmp	[ebp+var_14], 0
		jnz	loc_25A1
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		lea	ecx, [ebp+var_44]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_24A8
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

loc_24A8:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+19Fj
		cmp	[ebp+var_8], 1
		jz	short loc_24BA
		cmp	[ebp+var_8], 4
		jz	short loc_24BA
		cmp	[ebp+var_8], 2
		jnz	short loc_24C6

loc_24BA:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+1ACj
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+1B2j
		mov	[ebp+var_14], 6
		jmp	loc_259F
; ---------------------------------------------------------------------------

loc_24C6:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+1B8j
		cmp	[ebp+var_8], 0
		jnz	loc_257E
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		lea	ecx, [ebp+var_44]
		push	ecx
		push	0
		push	1
		mov	edx, [ebp+arg_0]
		push	edx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2509
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

loc_2509:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+200j
		mov	eax, [ebp+var_8]
		mov	[ebp+var_10C], eax
		mov	ecx, [ebp+var_10C]
		sub	ecx, 1
		mov	[ebp+var_10C], ecx
		cmp	[ebp+var_10C], 3 ; switch 4 cases
		ja	short loc_255B	; jumptable 00002530 default case
		mov	edx, [ebp+var_10C]
		jmp	ds:$LN39[edx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+230j
					; DATA XREF: .text:$LN39o
		mov	[ebp+var_14], 6	; jumptable 00002530 case 2
		jmp	short loc_257C
; ---------------------------------------------------------------------------

$LN9_0:					; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+230j
					; DATA XREF: .text:$LN39o
		mov	[ebp+var_14], 3	; jumptable 00002530 case 0
		jmp	short loc_257C
; ---------------------------------------------------------------------------

$LN8_0:					; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+230j
					; DATA XREF: .text:$LN39o
		mov	[ebp+var_14], 1	; jumptable 00002530 case 1
		jmp	short loc_257C
; ---------------------------------------------------------------------------

$LN7_0:					; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+230j
					; DATA XREF: .text:$LN39o
		mov	[ebp+var_14], 3	; jumptable 00002530 case 3
		jmp	short loc_257C
; ---------------------------------------------------------------------------

loc_255B:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+228j
		mov	eax, [ebp+arg_C] ; jumptable 00002530 default case
		mov	dword ptr [eax], 3
		push	offset ??_C@_0DI@BNHMMFKP@Unexpected?5token?5after?5string?0?5e@ ; "Unexpected token after string, expected"...
		mov	eax, [ebp+var_44]
		push	eax
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

loc_257C:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+23Ej
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+247j	...
		jmp	short loc_259F
; ---------------------------------------------------------------------------

loc_257E:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+1CAj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		push	offset ??_C@_0BL@EEKFNJNH@Unexpected?5token?5after?5?8?$HL?8?$AA@ ; "Unexpected	token after '{'"
		mov	eax, [ebp+var_44]
		push	eax
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	loc_2637
; ---------------------------------------------------------------------------

loc_259F:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+1C1j
					; parseResource(ParseState *,char *,UString const *,UErrorCode *):loc_257Cj
		jmp	short loc_25D2
; ---------------------------------------------------------------------------

loc_25A1:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+169j
		cmp	[ebp+var_14], 4
		jnz	short loc_25D2
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		mov	eax, [ebp+var_14]
		imul	eax, 0Ch
		mov	ecx, ds:_gResourceTypes[eax]
		push	ecx
		push	offset ??_C@_0DN@GFEBKNDM@error?3?5?$CFs?5resource?5type?5not?5vali@ ; "error: %s resource type	not valid excep"...
		mov	edx, [ebp+var_38]
		push	edx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	short loc_2637
; ---------------------------------------------------------------------------

loc_25D2:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *):loc_259Fj
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+2A5j
		mov	eax, [ebp+var_14]
		imul	eax, 0Ch
		mov	ecx, ds:dword_304[eax]
		mov	[ebp+var_20], ecx
		cmp	[ebp+var_20], 0
		jz	short loc_260E
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_38]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	[ebp+var_20]
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_2637
; ---------------------------------------------------------------------------
		jmp	short loc_2635
; ---------------------------------------------------------------------------

loc_260E:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+2E5j
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 5
		mov	eax, [ebp+var_14]
		imul	eax, 0Ch
		mov	ecx, ds:_gResourceTypes[eax]
		push	ecx
		push	offset ??_C@_0DH@CPJPLEN@internal?5error?3?5?$CFs?5resource?5type@ ; "internal error: %s resource type found "...
		mov	edx, [ebp+var_38]
		push	edx
		call	_error
		add	esp, 0Ch

loc_2635:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+30Cj
		xor	eax, eax

loc_2637:				; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+E0j
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+F0j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN37_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN37_0		dd 3			; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+33Bo
		dd offset $LN36_0
$LN36_0		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00002660o
		dd offset $LN33_1	; "tokenValue"
		dd 0FFFFFFC8h, 4
		dd offset $LN34_0	; "startline"
		dd 0FFFFFFBCh, 4
		dd offset $LN35_0	; "line"
$LN35_0		db 'line',0             ; DATA XREF: .text:00002684o
$LN34_0		db 'startline',0        ; DATA XREF: .text:00002678o
$LN33_1		db 'tokenValue',0       ; DATA XREF: .text:0000266Co
		align 4
$LN38		dd offset $LN21_0	; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+BDr
		dd offset $LN20_0	; jump table for switch	statement
		dd offset $LN20_0
		dd offset $LN23_0
		dd offset $LN25_0
		dd offset $LN24_0
$LN39		dd offset $LN9_0	; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+230r
		dd offset $LN8_0	; jump table for switch	statement
		dd offset $LN10
		dd offset $LN7_0
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26CCh
		public ??_C@_0DH@CPJPLEN@internal?5error?3?5?$CFs?5resource?5type@
; `string'
??_C@_0DH@CPJPLEN@internal?5error?3?5?$CFs?5resource?5type@ db 'internal error: %s resource type found and not handled',0
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+324o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2704h
		public ??_C@_0DN@GFEBKNDM@error?3?5?$CFs?5resource?5type?5not?5vali@
; `string'
??_C@_0DN@GFEBKNDM@error?3?5?$CFs?5resource?5type?5not?5vali@ db 'error: %s resource type not valid except on top bundle level',0
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+2BDo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2744h
		public ??_C@_0BL@EEKFNJNH@Unexpected?5token?5after?5?8?$HL?8?$AA@
; `string'
??_C@_0BL@EEKFNJNH@Unexpected?5token?5after?5?8?$HL?8?$AA@ db 'Unexpected token after ',27h,'{',27h,0
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+287o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2760h
		public ??_C@_0DI@BNHMMFKP@Unexpected?5token?5after?5string?0?5e@
; `string'
??_C@_0DI@BNHMMFKP@Unexpected?5token?5after?5string?0?5e@ db 'Unexpected token after string, expected ',27h,',',27h,', ',27h,'{',27h,' or ',27h
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+264o
		db '}',27h,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2798h
		public ??_C@_0DL@HMJOJDIN@syntax?5error?5while?5reading?5a?5res@
; `string'
??_C@_0DL@HMJOJDIN@syntax?5error?5while?5reading?5a?5res@ db 'syntax error while reading a resource, expected ',27h,'{',27h,' or ',27h,':'
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+14Do
		db 27h,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 27D4h
		public ??_C@_0BL@KNAOOEON@Unexpected?5EOF?5encountered?$AA@
; `string'
??_C@_0BL@KNAOOEON@Unexpected?5EOF?5encountered?$AA@ db	'Unexpected EOF encountered',0
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+CDo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 27F0h
		public ??_C@_0BK@OPKHGHEG@?5resource?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BK@OPKHGHEG@?5resource?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db ' resource %s at line %i ',0Ah,0
					; DATA XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+7Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 280Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	ETokenType __cdecl peekToken(struct ParseState *, unsigned int,	struct UString * *, unsigned int *, struct UString *, enum  UErrorCode *)
?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z proc near
					; CODE XREF: parseResource(ParseState *,char *,UString const *,UErrorCode *)+181p
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+1E2p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+80h]
		add	eax, [ebp+arg_4]
		xor	edx, edx
		mov	ecx, 4
		div	ecx
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_285E
		mov	eax, 6
		jmp	short loc_28DA
; ---------------------------------------------------------------------------

loc_285E:				; CODE XREF: peekToken(ParseState *,uint,UString * *,uint *,UString *,UErrorCode *)+49j
		cmp	[ebp+arg_4], 3
		jb	short loc_2874
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 5
		mov	eax, 6
		jmp	short loc_28DA
; ---------------------------------------------------------------------------

loc_2874:				; CODE XREF: peekToken(ParseState *,uint,UString * *,uint *,UString *,UErrorCode *)+56j
		cmp	[ebp+arg_8], 0
		jz	short loc_288C
		mov	eax, [ebp+var_8]
		shl	eax, 5
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax+4]
		mov	eax, [ebp+arg_8]
		mov	[eax], edx

loc_288C:				; CODE XREF: peekToken(ParseState *,uint,UString * *,uint *,UString *,UErrorCode *)+6Cj
		cmp	[ebp+arg_C], 0
		jz	short loc_28A4
		mov	eax, [ebp+var_8]
		shl	eax, 5
		mov	ecx, [ebp+arg_C]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+eax+1Ch]
		mov	[ecx], eax

loc_28A4:				; CODE XREF: peekToken(ParseState *,uint,UString * *,uint *,UString *,UErrorCode *)+84j
		cmp	[ebp+arg_10], 0
		jz	short loc_28CE
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+80h]
		shl	edx, 5
		mov	eax, [ebp+arg_0]
		lea	ecx, [eax+edx+10h]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		call	_ustr_cpy
		add	esp, 0Ch

loc_28CE:				; CODE XREF: peekToken(ParseState *,uint,UString * *,uint *,UString *,UErrorCode *)+9Cj
		mov	eax, [ebp+var_8]
		shl	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+eax]

loc_28DA:				; CODE XREF: peekToken(ParseState *,uint,UString * *,uint *,UString *,UErrorCode *)+50j
					; peekToken(ParseState *,uint,UString *	*,uint *,UString *,UErrorCode *)+66j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall SRBRoot::`scalar deleting destructor'(unsigned int)
		public ??_GSRBRoot@@QAEPAXI@Z
??_GSRBRoot@@QAEPAXI@Z proc near	; CODE XREF: _parse+2E9p _parse+409p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SRBRoot@@QAE@XZ ; SRBRoot::~SRBRoot(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_292F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_292F:				; CODE XREF: SRBRoot::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSRBRoot@@QAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2948h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<struct UCHARBUF>::LocalPointerBase<struct	UCHARBUF>(struct UCHARBUF *)
		public ??0?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@PAUUCHARBUF@@@Z
??0?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@PAUUCHARBUF@@@Z proc near
					; CODE XREF: icu_56::LocalUCHARBUFPointer::LocalUCHARBUFPointer(UCHARBUF *)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@PAUUCHARBUF@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2980h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<struct UCHARBUF>::~LocalPointerBase<struct UCHARBUF>(void)
		public ??1?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@XZ
??1?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)+34p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointerBase@UUCHARBUF@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::LocalPointerBase<struct UCHARBUF>::isNull(void)const
		public ?isNull@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBECXZ
?isNull@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBECXZ proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+486p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNull@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct UCHARBUF * __thiscall icu_56::LocalPointerBase<struct UCHARBUF>::getAlias(void)const
		public ?getAlias@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBEPAUUCHARBUF@@XZ
?getAlias@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBEPAUUCHARBUF@@XZ proc near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+588p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$LocalPointerBase@UUCHARBUF@@@icu_56@@QBEPAUUCHARBUF@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yc	segment	para public 'CODE' use32
		assume cs:_text$yc
		;org 2A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'gResourceTypes''(void)
??__EgResourceTypes@@YAXXZ proc	near	; DATA XREF: .CRT$XCU:_gResourceTypes$initializer$o

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, ds:_k_type_string
		mov	ds:dword_30C, eax
		mov	ds:dword_310, offset ?parseString@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseString(ParseState *,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_314, offset ??_C@_06FNFBAEBE@binary?$AA@ ; "binary"
		mov	eax, ds:_k_type_binary
		mov	ds:dword_318, eax
		mov	ds:dword_31C, offset ?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseBinary(ParseState *,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_320, offset ??_C@_05LCLENNFI@table?$AA@ ; "table"
		mov	eax, ds:_k_type_table
		mov	ds:dword_324, eax
		mov	ds:dword_328, offset ?parseTable@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseTable(ParseState *,char *,uint,UString const	*,UErrorCode *)
		mov	ds:dword_32C, offset ??_C@_0BC@GAILGOLI@table?$CInofallback?$CJ?$AA@ ; "table(nofallback)"
		mov	eax, ds:_k_type_table_no_fallback
		mov	ds:dword_330, eax
		mov	ds:dword_334, 0
		mov	ds:dword_338, offset ??_C@_07LKHFMGFB@integer?$AA@ ; "integer"
		mov	eax, ds:_k_type_integer
		mov	ds:dword_33C, eax
		mov	ds:dword_340, offset ?parseInteger@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ;	parseInteger(ParseState	*,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_344, offset ??_C@_05HIFJDKLD@array?$AA@ ; "array"
		mov	eax, ds:_k_type_array
		mov	ds:dword_348, eax
		mov	ds:dword_34C, offset ?parseArray@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseArray(ParseState *,char *,uint,UString const	*,UErrorCode *)
		mov	ds:dword_350, offset ??_C@_05NKHOCLEE@alias?$AA@ ; "alias"
		mov	eax, ds:_k_type_alias
		mov	ds:dword_354, eax
		mov	ds:dword_358, offset ?parseAlias@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseAlias(ParseState *,char *,uint,UString const	*,UErrorCode *)
		mov	ds:dword_35C, offset ??_C@_09DOPAKLKI@intvector?$AA@ ; "intvector"
		mov	eax, ds:_k_type_intvector
		mov	ds:dword_360, eax
		mov	ds:dword_364, offset ?parseIntVector@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	; parseIntVector(ParseState *,char *,uint,UString const	*,UErrorCode *)
		mov	ds:dword_368, offset ??_C@_06EOGGDCGF@import?$AA@ ; "import"
		mov	eax, ds:_k_type_import
		mov	ds:dword_36C, eax
		mov	ds:dword_370, offset ?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseImport(ParseState *,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_374, offset ??_C@_07FHOHOHLG@include?$AA@ ; "include"
		mov	eax, ds:_k_type_include
		mov	ds:dword_378, eax
		mov	ds:dword_37C, offset ?parseInclude@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ;	parseInclude(ParseState	*,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_380, offset ??_C@_0BD@NKLHFJNJ@process?$CIuca_rules?$CJ?$AA@ ;	"process(uca_rules)"
		mov	eax, ds:_k_type_plugin_uca_rules
		mov	ds:dword_384, eax
		mov	ds:dword_388, offset ?parseUCARules@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseUCARules(ParseState *,char *,uint,UString	const *,UErrorCode *)
		mov	ds:dword_38C, offset ??_C@_0BD@FCAMAONH@process?$CIcollation?$CJ?$AA@ ;	"process(collation)"
		mov	eax, ds:_k_type_plugin_collation
		mov	ds:dword_390, eax
		mov	ds:dword_394, 0
		mov	ds:dword_398, offset ??_C@_0BI@DHDOIJFK@process?$CItransliterator?$CJ?$AA@ ; "process(transliterator)"
		mov	eax, ds:_k_type_plugin_transliterator
		mov	ds:dword_39C, eax
		mov	ds:dword_3A0, offset ?parseTransliterator@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseTransliterator(ParseState *,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_3A4, offset ??_C@_0BE@DBCPCDGA@process?$CIdependency?$CJ?$AA@ ; "process(dependency)"
		mov	eax, ds:_k_type_plugin_dependency
		mov	ds:dword_3A8, eax
		mov	ds:dword_3AC, offset ?parseDependency@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z ; parseDependency(ParseState *,char *,uint,UString const *,UErrorCode *)
		mov	ds:dword_3B0, offset ??_C@_08FINKBBAF@reserved?$AA@ ; "reserved"
		mov	ds:dword_3B4, 0
		mov	ds:dword_3B8, 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??__EgResourceTypes@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$yc	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2BF0h
		public ??_C@_08FINKBBAF@reserved?$AA@
; `string'
??_C@_08FINKBBAF@reserved?$AA@ db 'reserved',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1B8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2BFCh
		public ??_C@_0BE@DBCPCDGA@process?$CIdependency?$CJ?$AA@
; `string'
??_C@_0BE@DBCPCDGA@process?$CIdependency?$CJ?$AA@ db 'process(dependency)',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+19Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C10h
		public ??_C@_0BI@DHDOIJFK@process?$CItransliterator?$CJ?$AA@
; `string'
??_C@_0BI@DHDOIJFK@process?$CItransliterator?$CJ?$AA@ db 'process(transliterator)',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+17Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C28h
		public ??_C@_0BD@FCAMAONH@process?$CIcollation?$CJ?$AA@
; `string'
??_C@_0BD@FCAMAONH@process?$CIcollation?$CJ?$AA@ db 'process(collation)',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+15Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C3Ch
		public ??_C@_0BD@NKLHFJNJ@process?$CIuca_rules?$CJ?$AA@
; `string'
??_C@_0BD@NKLHFJNJ@process?$CIuca_rules?$CJ?$AA@ db 'process(uca_rules)',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+140o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C50h
		public ??_C@_07FHOHOHLG@include?$AA@
; `string'
??_C@_07FHOHOHLG@include?$AA@ db 'include',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+122o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C58h
		public ??_C@_06EOGGDCGF@import?$AA@
; `string'
??_C@_06EOGGDCGF@import?$AA@ db	'import',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+104o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C60h
		public ??_C@_09DOPAKLKI@intvector?$AA@
; `string'
??_C@_09DOPAKLKI@intvector?$AA@	db 'intvector',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+E6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C6Ch
		public ??_C@_05NKHOCLEE@alias?$AA@
; char `string'[]
??_C@_05NKHOCLEE@alias?$AA@ db 'alias',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+C8o
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+385o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C74h
		public ??_C@_05HIFJDKLD@array?$AA@
; `string'
??_C@_05HIFJDKLD@array?$AA@ db 'array',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+AAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C7Ch
		public ??_C@_07LKHFMGFB@integer?$AA@
; `string'
??_C@_07LKHFMGFB@integer?$AA@ db 'integer',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+8Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C84h
		public ??_C@_0BC@GAILGOLI@table?$CInofallback?$CJ?$AA@
; `string'
??_C@_0BC@GAILGOLI@table?$CInofallback?$CJ?$AA@	db 'table(nofallback)',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+6Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C98h
		public ??_C@_05LCLENNFI@table?$AA@
; `string'
??_C@_05LCLENNFI@table?$AA@ db 'table',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+50o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2CA0h
		public ??_C@_06FNFBAEBE@binary?$AA@
; `string'
??_C@_06FNFBAEBE@binary?$AA@ db	'binary',0
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+32o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseUCARules(struct ParseState *,	char *,	unsigned int, struct UString const *, enum  UErrorCode *)
?parseUCARules@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+154o

var_2E8		= dword	ptr -2E8h
var_220		= dword	ptr -220h
var_214		= dword	ptr -214h
var_208		= dword	ptr -208h
var_1FC		= dword	ptr -1FCh
var_1F0		= dword	ptr -1F0h
var_1E4		= dword	ptr -1E4h
var_1D8		= dword	ptr -1D8h
var_1C9		= byte ptr -1C9h
var_1C0		= dword	ptr -1C0h
Source		= byte ptr -1B4h
var_1B3		= byte ptr -1B3h
Dest		= byte ptr -12Ch
Dst		= byte ptr -12Bh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 2E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_2E8]
		mov	ecx, 0BAh ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0
		mov	[ebp+var_24], 0
		mov	[ebp+Dest], 0
		push	0FFh		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+Source], 0
		push	7Fh ; ''       ; Size
		push	0		; Val
		lea	eax, [ebp+var_1B3]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+var_1C9], 0
		mov	[ebp+var_1D8], 0
		mov	[ebp+var_1E4], 0
		mov	[ebp+var_1F0], 0
		mov	[ebp+var_1FC], 0
		mov	[ebp+var_208], 0
		mov	[ebp+var_214], 0
		mov	[ebp+var_220], 0
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_1C0]
		push	ecx
		push	0
		lea	edx, [ebp+var_18]
		push	edx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_2DCA
		cmp	[ebp+arg_4], 0
		jnz	short loc_2D9F
		mov	[ebp+var_2E8], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_2DA8
; ---------------------------------------------------------------------------

loc_2D9F:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+E9j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_2E8], eax

loc_2DA8:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+F5j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_2E8]
		push	edx
		push	offset ??_C@_0BB@HANANFDC@?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	%s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2DCA:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+E3j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2DE6
		xor	eax, eax
		jmp	loc_324C
; ---------------------------------------------------------------------------

loc_2DE6:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+135j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8Ch], 0
		jz	short loc_2E3B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8Ch]
		push	ecx		; Source
		lea	edx, [ebp+Dest]
		push	edx		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8Ch]
		movsx	ecx, byte ptr [eax+ecx-1]
		cmp	ecx, 5Ch ; '\'
		jz	short loc_2E3B
		push	offset ??_C@_01KICIPPFI@?2?$AA@	; "\\"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcat
		add	esp, 8

loc_2E3B:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+148j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+17Dj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		push	ecx
		lea	edx, [ebp+Source]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2E8B
		xor	eax, eax
		jmp	loc_324C
; ---------------------------------------------------------------------------

loc_2E8B:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+1DAj
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+0A1h]
		test	ecx, ecx
		jz	short loc_2EB9
		call	_res_none
		jmp	loc_324C
; ---------------------------------------------------------------------------

loc_2EB9:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+205j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		call	_getShowWarning
		movzx	ecx, al
		push	ecx
		lea	edx, [ebp+var_1F0]
		push	edx
		lea	eax, [ebp+Dest]
		push	eax
		call	_ucbuf_open
		add	esp, 14h
		mov	[ebp+var_1D8], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2F1B
		lea	eax, [ebp+Dest]
		push	eax
		push	offset ??_C@_0DC@NBEIADHC@An?5error?5occured?5while?5opening?5t@ ; "An error occured while opening the inpu"...
		mov	ecx, [ebp+var_1C0]
		push	ecx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	loc_324C
; ---------------------------------------------------------------------------

loc_2F1B:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+24Fj
		mov	eax, [ebp+var_1D8]
		push	eax
		call	_ucbuf_size
		add	esp, 4
		add	eax, 1
		mov	[ebp+var_220], eax
		mov	eax, [ebp+var_220]
		shl	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_1FC], eax
		mov	eax, [ebp+var_220]
		shl	eax, 1
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+var_1FC]
		push	ecx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+var_1FC]
		mov	[ebp+var_208], eax
		mov	eax, [ebp+var_220]
		mov	ecx, [ebp+var_1FC]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_214], edx

loc_2F85:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *):loc_30C5j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *):loc_314Dj ...
		mov	eax, [ebp+var_208]
		cmp	eax, [ebp+var_214]
		jnb	loc_31D1
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_1D8]
		push	ecx
		call	_ucbuf_getc
		add	esp, 8
		mov	[ebp+var_1E4], eax
		cmp	[ebp+var_1E4], 27h ; '''
		jnz	short loc_2FCB
		movsx	eax, [ebp+var_1C9]
		test	eax, eax
		setz	cl
		mov	[ebp+var_1C9], cl

loc_2FCB:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+30Fj
		cmp	[ebp+var_1E4], 5Bh ; '['
		jnz	loc_3084
		movsx	eax, [ebp+var_1C9]
		test	eax, eax
		jnz	loc_3084

loc_2FE7:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+3D2j
		cmp	[ebp+var_1E4], 5Dh ; ']'
		jz	loc_307F
		cmp	[ebp+var_1E4], 0FFFFh
		jg	short loc_3021

loc_3000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	eax, [ebp+var_208]
		mov	cx, word ptr [ebp+var_1E4]
		mov	[eax], cx
		mov	edx, [ebp+var_208]
		add	edx, 2
		mov	[ebp+var_208], edx
		jmp	short loc_3061
; ---------------------------------------------------------------------------

loc_3021:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+356j
		mov	eax, [ebp+var_1E4]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_208]
		mov	[ecx], ax
		mov	eax, [ebp+var_1E4]
		and	eax, 3FFh
		or	eax, 0DC00h
		mov	ecx, [ebp+var_208]
		mov	[ecx+2], ax
		mov	eax, [ebp+var_208]
		add	eax, 4
		mov	[ebp+var_208], eax

loc_3061:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+377j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_1D8]
		push	ecx
		call	_ucbuf_getc
		add	esp, 8
		mov	[ebp+var_1E4], eax
		jmp	loc_2FE7
; ---------------------------------------------------------------------------

loc_307F:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+346j
		jmp	loc_3152
; ---------------------------------------------------------------------------

loc_3084:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+32Aj
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+339j
		cmp	[ebp+var_1E4], 23h ; '#'
		jnz	short loc_30CF
		movsx	eax, [ebp+var_1C9]
		test	eax, eax
		jnz	short loc_30CF

loc_3098:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+41Bj
		cmp	[ebp+var_1E4], 0Dh
		jz	short loc_30C5
		cmp	[ebp+var_1E4], 0Ah
		jz	short loc_30C5
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_1D8]
		push	ecx
		call	_ucbuf_getc
		add	esp, 8
		mov	[ebp+var_1E4], eax
		jmp	short loc_3098
; ---------------------------------------------------------------------------

loc_30C5:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+3F7j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+400j
		jmp	loc_2F85
; ---------------------------------------------------------------------------
		jmp	loc_3152
; ---------------------------------------------------------------------------

loc_30CF:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+3E3j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+3EEj
		cmp	[ebp+var_1E4], 5Ch ; '\'
		jnz	short loc_311E
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_1D8]
		push	ecx
		call	_unescape
		add	esp, 8
		mov	[ebp+var_1E4], eax
		cmp	[ebp+var_1E4], 0FFFFFFFEh
		jnz	short loc_311C
		mov	eax, [ebp+var_1FC]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_24]
		push	eax
		call	_T_FileStream_close
		add	esp, 4
		xor	eax, eax
		jmp	loc_324C
; ---------------------------------------------------------------------------

loc_311C:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+450j
		jmp	short loc_3152
; ---------------------------------------------------------------------------

loc_311E:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+42Ej
		movsx	eax, [ebp+var_1C9]
		test	eax, eax
		jnz	short loc_3152
		cmp	[ebp+var_1E4], 20h ; ' '
		jz	short loc_314D
		cmp	[ebp+var_1E4], 9
		jz	short loc_314D
		cmp	[ebp+var_1E4], 0Dh
		jz	short loc_314D
		cmp	[ebp+var_1E4], 0Ah
		jnz	short loc_3152

loc_314D:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+488j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+491j ...
		jmp	loc_2F85
; ---------------------------------------------------------------------------

loc_3152:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *):loc_307Fj
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+422j ...
		cmp	[ebp+var_1E4], 0FFFFFFFFh
		jz	short loc_31CA
		cmp	[ebp+var_1E4], 0FFFFh
		jg	short loc_3188
		mov	eax, [ebp+var_208]
		mov	cx, word ptr [ebp+var_1E4]
		mov	[eax], cx
		mov	edx, [ebp+var_208]
		add	edx, 2
		mov	[ebp+var_208], edx
		jmp	short loc_31C8
; ---------------------------------------------------------------------------

loc_3188:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+4BDj
		mov	eax, [ebp+var_1E4]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_208]
		mov	[ecx], ax
		mov	eax, [ebp+var_1E4]
		and	eax, 3FFh
		or	eax, 0DC00h
		mov	ecx, [ebp+var_208]
		mov	[ecx+2], ax
		mov	eax, [ebp+var_208]
		add	eax, 4
		mov	[ebp+var_208], eax

loc_31C8:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+4DEj
		jmp	short loc_31CC
; ---------------------------------------------------------------------------

loc_31CA:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+4B1j
		jmp	short loc_31D1
; ---------------------------------------------------------------------------

loc_31CC:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *):loc_31C8j
		jmp	loc_2F85
; ---------------------------------------------------------------------------

loc_31D1:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+2E9j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *):loc_31CAj
		mov	eax, [ebp+var_208]
		cmp	eax, [ebp+var_214]
		jnb	short loc_31EA
		xor	eax, eax
		mov	ecx, [ebp+var_208]
		mov	[ecx], ax

loc_31EA:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+535j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_208]
		sub	ecx, [ebp+var_1FC]
		sar	ecx, 1
		push	ecx
		mov	edx, [ebp+var_1FC]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_C], eax
		mov	eax, [ebp+var_1D8]
		push	eax
		call	_ucbuf_close
		add	esp, 4
		mov	eax, [ebp+var_1FC]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_24]
		push	eax
		call	_T_FileStream_close
		add	esp, 4
		mov	eax, [ebp+var_C]

loc_324C:				; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+139j
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+1DEj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN43
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseUCARules@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN43		dd 5			; DATA XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+5A8o
		dd offset $LN42
$LN42		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00003280o
		dd offset $LN37_1	; "tokenValue"
		dd 0FFFFFED4h, 100h
		dd offset $LN38_0	; "filename"
		dd 0FFFFFE4Ch, 80h
		dd offset $LN39_0	; "cs"
		dd 0FFFFFE40h, 4
		dd offset $LN40		; "line"
		dd 0FFFFFE10h, 4
		dd offset $LN41
$LN41		db 63h,	70h, 0		; DATA XREF: .text:000032BCo
$LN40		db 'line',0             ; DATA XREF: .text:000032B0o
$LN39_0		db 'cs',0               ; DATA XREF: .text:000032A4o
$LN38_0		db 'filename',0         ; DATA XREF: .text:00003298o
$LN37_1		db 'tokenValue',0       ; DATA XREF: .text:0000328Co
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 32E0h
		public ??_C@_0DC@NBEIADHC@An?5error?5occured?5while?5opening?5t@
; `string'
??_C@_0DC@NBEIADHC@An?5error?5occured?5while?5opening?5t@ db 'An error occured while opening the input file %s',0Ah,0
					; DATA XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+258o
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+225o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3314h
		public ??_C@_01KICIPPFI@?2?$AA@
; char `string'[2]
??_C@_01KICIPPFI@?2?$AA@ db '\',0       ; DATA XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+17Fo
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+164o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3318h
		public ??_C@_0BB@HANANFDC@?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BB@HANANFDC@?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db	' %s at line %i ',0Ah,0
					; DATA XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+10Do
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+F2o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 332Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseTransliterator(struct	ParseState *, char *, unsigned int, struct UString const *, enum  UErrorCode *)
?parseTransliterator@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+190o

var_2C4		= dword	ptr -2C4h
var_1FC		= dword	ptr -1FCh
var_1F0		= dword	ptr -1F0h
var_1E4		= dword	ptr -1E4h
var_1D8		= dword	ptr -1D8h
var_1CC		= dword	ptr -1CCh
var_1C0		= dword	ptr -1C0h
Source		= byte ptr -1B4h
var_1B3		= byte ptr -1B3h
Dest		= byte ptr -12Ch
Dst		= byte ptr -12Bh
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 2C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_2C4]
		mov	ecx, 0B1h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0
		mov	[ebp+var_24], 0
		mov	[ebp+Dest], 0
		push	0FFh		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+Source], 0
		push	7Fh ; ''       ; Size
		push	0		; Val
		lea	eax, [ebp+var_1B3]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+var_1CC], 0
		mov	[ebp+var_1D8], 0
		mov	[ebp+var_1E4], 0
		mov	[ebp+var_1F0], 0
		mov	[ebp+var_1FC], 0
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_1C0]
		push	ecx
		push	0
		lea	edx, [ebp+var_18]
		push	edx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_3433
		cmp	[ebp+arg_4], 0
		jnz	short loc_3408
		mov	[ebp+var_2C4], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_3411
; ---------------------------------------------------------------------------

loc_3408:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+CEj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_2C4], eax

loc_3411:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+DAj
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_2C4]
		push	edx
		push	offset ??_C@_0BB@HANANFDC@?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	%s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3433:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+C8j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_344F
		xor	eax, eax
		jmp	loc_3640
; ---------------------------------------------------------------------------

loc_344F:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+11Aj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8Ch], 0
		jz	short loc_34A4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8Ch]
		push	ecx		; Source
		lea	edx, [ebp+Dest]
		push	edx		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8Ch]
		movsx	ecx, byte ptr [eax+ecx-1]
		cmp	ecx, 5Ch ; '\'
		jz	short loc_34A4
		push	offset ??_C@_01KICIPPFI@?2?$AA@	; "\\"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcat
		add	esp, 8

loc_34A4:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+12Dj
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+162j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+4]
		push	ecx
		lea	edx, [ebp+Source]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_34F4
		xor	eax, eax
		jmp	loc_3640
; ---------------------------------------------------------------------------

loc_34F4:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+1BFj
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		call	_getShowWarning
		movzx	ecx, al
		push	ecx
		lea	edx, [ebp+var_1D8]
		push	edx
		lea	eax, [ebp+Dest]
		push	eax
		call	_ucbuf_open
		add	esp, 14h
		mov	[ebp+var_1CC], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_356C
		lea	eax, [ebp+Dest]
		push	eax
		push	offset ??_C@_0DC@NBEIADHC@An?5error?5occured?5while?5opening?5t@ ; "An error occured while opening the inpu"...
		mov	ecx, [ebp+var_1C0]
		push	ecx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	loc_3640
; ---------------------------------------------------------------------------

loc_356C:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+21Cj
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_1FC]
		push	ecx
		mov	edx, [ebp+var_1CC]
		push	edx
		call	_ucbuf_getBuffer
		add	esp, 0Ch
		mov	[ebp+var_1F0], eax
		mov	eax, [ebp+var_1FC]
		lea	ecx, [eax+eax+2]
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_1E4], eax
		mov	eax, [ebp+var_1FC]
		shl	eax, 1
		push	eax		; Size
		push	0		; Val
		mov	ecx, [ebp+var_1E4]
		push	ecx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_1E4]
		push	ecx
		mov	edx, [ebp+var_1FC]
		push	edx
		mov	eax, [ebp+var_1F0]
		push	eax
		call	_utrans_stripRules_56
		add	esp, 10h
		mov	[ebp+var_1FC], eax
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_1FC]
		push	ecx
		mov	edx, [ebp+var_1E4]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_C], eax
		mov	eax, [ebp+var_1CC]
		push	eax
		call	_ucbuf_close
		add	esp, 4
		mov	eax, [ebp+var_1E4]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_24]
		push	eax
		call	_T_FileStream_close
		add	esp, 4
		mov	eax, [ebp+var_C]

loc_3640:				; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+11Ej
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+1C3j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 2C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseTransliterator@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN18		dd 6			; DATA XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+318o
		dd offset $LN17_0
$LN17_0		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00003674o
		dd offset $LN11		; "tokenValue"
		dd 0FFFFFED4h, 100h
		dd offset $LN12_0	; "filename"
		dd 0FFFFFE4Ch, 80h
		dd offset $LN13_0	; "cs"
		dd 0FFFFFE40h, 4
		dd offset $LN14_0	; "line"
		dd 0FFFFFE28h, 4
		dd offset $LN15_0	; "cp"
		dd 0FFFFFE04h, 4
		dd offset $LN16_0	; "size"
$LN16_0		db 'size',0             ; DATA XREF: .text:000036BCo
$LN15_0		db 'cp',0               ; DATA XREF: .text:000036B0o
$LN14_0		db 'line',0             ; DATA XREF: .text:000036A4o
$LN13_0		db 'cs',0               ; DATA XREF: .text:00003698o
$LN12_0		db 'filename',0         ; DATA XREF: .text:0000368Co
$LN11		db 'tokenValue',0       ; DATA XREF: .text:00003680o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseDependency(struct ParseState *, char *, unsigned int,	struct UString const *,	enum  UErrorCode *)
?parseDependency@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+1AEo

var_288		= dword	ptr -288h
Source		= byte ptr -1C0h
var_1BF		= byte ptr -1BFh
Dest		= byte ptr -138h
Dst		= byte ptr -137h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 288h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_288]
		mov	ecx, 0A2h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0
		mov	[ebp+var_18], 0
		mov	[ebp+Dest], 0
		push	0FFh		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	[ebp+Source], 0
		push	7Fh ; ''       ; Size
		push	0		; Val
		lea	eax, [ebp+var_1BF]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_30]
		push	ecx
		push	0
		lea	edx, [ebp+var_24]
		push	edx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_37B6
		cmp	[ebp+arg_4], 0
		jnz	short loc_378B
		mov	[ebp+var_288], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_3794
; ---------------------------------------------------------------------------

loc_378B:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+99j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_288], eax

loc_3794:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+A5j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_288]
		push	edx
		push	offset ??_C@_0BB@HANANFDC@?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	%s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_37B6:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+93j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_37D2
		xor	eax, eax
		jmp	loc_3997
; ---------------------------------------------------------------------------

loc_37D2:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+E5j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+94h], 0
		jz	short loc_3827
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+94h]
		push	ecx		; Source
		lea	edx, [ebp+Dest]
		push	edx		; Dest
		call	_strcat
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+98h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+94h]
		movsx	ecx, byte ptr [eax+ecx-1]
		cmp	ecx, 5Ch ; '\'
		jz	short loc_3827
		push	offset ??_C@_01KICIPPFI@?2?$AA@	; "\\"
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		call	_strcat
		add	esp, 8

loc_3827:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+F8j
					; parseDependency(ParseState *,char *,uint,UString const *,UErrorCode *)+12Dj
		mov	eax, [ebp+var_24]
		mov	ecx, [eax+4]
		push	ecx
		lea	edx, [ebp+Source]
		push	edx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_385F
		xor	eax, eax
		jmp	loc_3997
; ---------------------------------------------------------------------------

loc_385F:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+172j
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		lea	eax, [ebp+Dest]
		push	eax
		call	_T_FileStream_file_exists
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_38C9
		call	_isStrict
		movsx	eax, al
		test	eax, eax
		jz	short loc_38B1
		lea	eax, [ebp+Dest]
		push	eax
		push	offset ??_C@_0EE@FKJKBGMP@The?5dependency?5file?5?$CFs?5does?5not?5@ ; "The dependency file %s does not	exist. "...
		mov	ecx, [ebp+var_30]
		push	ecx
		call	_error
		add	esp, 0Ch
		jmp	short loc_38C9
; ---------------------------------------------------------------------------

loc_38B1:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+1B1j
		lea	eax, [ebp+Dest]
		push	eax
		push	offset ??_C@_0EE@FKJKBGMP@The?5dependency?5file?5?$CFs?5does?5not?5@ ; "The dependency file %s does not	exist. "...
		mov	ecx, [ebp+var_30]
		push	ecx
		call	_warning
		add	esp, 0Ch

loc_38C9:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+1A5j
					; parseDependency(ParseState *,char *,uint,UString const *,UErrorCode *)+1CBj
		cmp	ds:_dependencyArray, 0
		jnz	short loc_38F4
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	offset ??_C@_0N@KBOFKNOI@?$CF?$CFDEPENDENCY?$AA@ ; "%%DEPENDENCY"
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_array_open
		add	esp, 10h
		mov	ds:_dependencyArray, eax

loc_38F4:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+1ECj
		cmp	[ebp+arg_4], 0
		jz	short loc_3928
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_24]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_C], eax

loc_3928:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+214j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_24]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_24]
		mov	edx, [ecx]
		push	edx
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_18], eax
		mov	eax, [ebp+var_18]
		push	eax		; struct SResource *
		mov	ecx, ds:_dependencyArray ; this
		call	?add@ArrayResource@@QAEXPAUSResource@@@Z ; ArrayResource::add(SResource	*)
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_397C
		xor	eax, eax
		jmp	short loc_3997
; ---------------------------------------------------------------------------

loc_397C:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+292j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+var_C]

loc_3997:				; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+E9j
					; parseDependency(ParseState *,char *,uint,UString const *,UErrorCode *)+176j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 288h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseDependency@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN21_1		dd 4			; DATA XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+2B7o
		dd offset $LN20_1
$LN20_1		dd 0FFFFFFDCh, 4	; DATA XREF: .text:000039CCo
		dd offset $LN16_1	; "tokenValue"
		dd 0FFFFFFD0h, 4
		dd offset $LN17_1	; "line"
		dd 0FFFFFEC8h, 100h
		dd offset $LN18_0	; "filename"
		dd 0FFFFFE40h, 80h
		dd offset $LN19_0
$LN19_0		db 63h,	73h, 0		; DATA XREF: .text:000039FCo
$LN18_0		db 'filename',0         ; DATA XREF: .text:000039F0o
$LN17_1		db 'line',0             ; DATA XREF: .text:000039E4o
$LN16_1		db 'tokenValue',0       ; DATA XREF: .text:000039D8o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3A1Ch
		public ??_C@_0N@KBOFKNOI@?$CF?$CFDEPENDENCY?$AA@
; `string'
??_C@_0N@KBOFKNOI@?$CF?$CFDEPENDENCY?$AA@ db '%%DEPENDENCY',0
					; DATA XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+1F4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3A2Ch
		public ??_C@_0EE@FKJKBGMP@The?5dependency?5file?5?$CFs?5does?5not?5@
; `string'
??_C@_0EE@FKJKBGMP@The?5dependency?5file?5?$CFs?5does?5not?5@ db 'The dependency file %s does not exist. Please make sure it exists'
					; DATA XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+1BAo
					; parseDependency(ParseState *,char *,uint,UString const *,UErrorCode *)+1D4o
		db '.',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseString(struct	ParseState *, char *, unsigned int, struct UString const *, enum  UErrorCode *)
?parseString@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+28o

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_3ADE
		cmp	[ebp+arg_4], 0
		jnz	short loc_3AB3
		mov	[ebp+var_DC], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@	; "(null)"
		jmp	short loc_3ABC
; ---------------------------------------------------------------------------

loc_3AB3:				; CODE XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+35j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_DC], eax

loc_3ABC:				; CODE XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+41j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_DC]
		push	edx
		push	offset ??_C@_0BI@MBLCPKIG@?5string?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	string %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3ADE:				; CODE XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+2Fj
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		lea	ecx, [ebp+var_8]
		push	ecx
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_3B97
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3B97
		cmp	[ebp+var_14], 0
		jz	short loc_3B97
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3B97
		mov	eax, [ebp+var_14]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_3B9A
; ---------------------------------------------------------------------------

loc_3B97:				; CODE XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+9Bj
					; parseString(ParseState *,char	*,uint,UString const *,UErrorCode *)+E2j ...
		mov	eax, [ebp+var_14]

loc_3B9A:				; CODE XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+125j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseString@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN11_0		dd 1			; DATA XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+12Eo
		dd offset $LN10_0
$LN10_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00003BC4o
		dd offset $LN9_1	; "tokenValue"
$LN9_1		db 'tokenValue',0       ; DATA XREF: .text:00003BD0o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3BE0h
		public ??_C@_0BI@MBLCPKIG@?5string?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BI@MBLCPKIG@?5string?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db	' string %s at line %i ',0Ah,0
					; DATA XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+59o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: parseString(ParseState *,char *,uint,UString const	*,UErrorCode *)+8Ep
					; parseString(ParseState *,char	*,uint,UString const *,UErrorCode *)+D5p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseAlias(struct ParseState *, char *, unsigned int, struct UString const	*, enum	 UErrorCode *)
?parseAlias@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+DCo

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		lea	ecx, [ebp+var_8]
		push	ecx
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_3CAC
		cmp	[ebp+arg_4], 0
		jnz	short loc_3C81
		mov	[ebp+var_DC], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@	; "(null)"
		jmp	short loc_3C8A
; ---------------------------------------------------------------------------

loc_3C81:				; CODE XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+4Fj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_DC], eax

loc_3C8A:				; CODE XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+5Bj
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_DC]
		push	edx
		push	offset ??_C@_0BH@IAJJPCNE@?5alias?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; " alias %s	at line	%i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3CAC:				; CODE XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+49j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3D2C
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_alias_open
		add	esp, 18h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3D2C
		mov	eax, [ebp+var_14]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_3D2F
; ---------------------------------------------------------------------------

loc_3D2C:				; CODE XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+9Bj
					; parseAlias(ParseState	*,char *,uint,UString const *,UErrorCode *)+F6j
		mov	eax, [ebp+var_14]

loc_3D2F:				; CODE XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+106j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseAlias@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN10_1		dd 1			; DATA XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+10Fo
		dd offset $LN9_2
$LN9_2		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00003D58o
		dd offset $LN8_1	; "tokenValue"
$LN8_1		db 'tokenValue',0       ; DATA XREF: .text:00003D64o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3D74h
		public ??_C@_0BH@IAJJPCNE@?5alias?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BH@IAJJPCNE@?5alias?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db ' alias %s at line %i ',0Ah,0
					; DATA XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+73o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl parseTable(int, char *Str1, int, int, enum UErrorCode *)
?parseTable@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+64o

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str1		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+Str1], 0
		jz	short loc_3DE4
		push	offset ??_C@_0BC@JFCCCNAE@CollationElements?$AA@ ; "CollationElements"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_3DE4
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		push	0		; char
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+Str1]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?parseCollationElements@@YAPAUSResource@@PAUParseState@@PADICPAW4UErrorCode@@@Z	; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)
		add	esp, 14h
		jmp	loc_3EC3
; ---------------------------------------------------------------------------

loc_3DE4:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+22j
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+37j
		cmp	[ebp+Str1], 0
		jz	short loc_3E1E
		push	offset ??_C@_0L@EMPPBAGD@collations?$AA@ ; "collations"
		mov	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_3E1E
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		push	1		; char
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+Str1]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?parseCollationElements@@YAPAUSResource@@PAUParseState@@PADICPAW4UErrorCode@@@Z	; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)
		add	esp, 14h
		jmp	loc_3EC3
; ---------------------------------------------------------------------------

loc_3E1E:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+5Cj
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+71j
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_3E67
		cmp	[ebp+Str1], 0
		jnz	short loc_3E3C
		mov	[ebp+var_D0], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@	; "(null)"
		jmp	short loc_3E45
; ---------------------------------------------------------------------------

loc_3E3C:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+A2j
		mov	eax, [ebp+Str1]
		mov	[ebp+var_D0], eax

loc_3E45:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+AEj
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_D0]
		push	edx
		push	offset ??_C@_0BH@OPLACKNM@?5table?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; " table %s	at line	%i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3E67:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+9Cj
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+Str1]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_table_open
		add	esp, 10h
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_3EA3
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3EA7

loc_3EA3:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+100j
		xor	eax, eax
		jmp	short loc_3EC3
; ---------------------------------------------------------------------------

loc_3EA7:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+115j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+Str1]
		push	edx		; int
		mov	eax, [ebp+var_8]
		push	eax		; TableResource	*
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?realParseTable@@YAPAUSResource@@PAUParseState@@PAVTableResource@@PADIPAW4UErrorCode@@@Z ; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)
		add	esp, 14h

loc_3EC3:				; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+53j
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+8Dj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseTable@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3ED8h
		public ??_C@_0BH@OPLACKNM@?5table?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BH@OPLACKNM@?5table?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db ' table %s at line %i ',0Ah,0
					; DATA XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+C6o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3EF0h
		public ??_C@_0BC@JFCCCNAE@CollationElements?$AA@
; char `string'[]
??_C@_0BC@JFCCCNAE@CollationElements?$AA@ db 'CollationElements',0
					; DATA XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+24o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl parseCollationElements(int, int, int, char, enum UErrorCode *)
?parseCollationElements@@YAPAUSResource@@PAUParseState@@PADICPAW4UErrorCode@@@Z	proc near
					; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+4Bp
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+85p

var_934		= dword	ptr -934h
var_86C		= dword	ptr -86Ch
var_860		= dword	ptr -860h
var_854		= byte ptr -854h
Str1		= byte ptr -44Ch
var_44		= dword	ptr -44h
var_38		= byte ptr -38h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 934h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_934]
		mov	ecx, 24Dh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], 0
		mov	[ebp+var_18], 0
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+88h]
		push	eax
		call	_table_open
		add	esp, 10h
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jz	short loc_3F74
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_3F7B

loc_3F74:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+59j
		xor	eax, eax
		jmp	loc_4359
; ---------------------------------------------------------------------------

loc_3F7B:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+6Ej
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_3FC4
		cmp	[ebp+arg_4], 0
		jnz	short loc_3F99
		mov	[ebp+var_934], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_3FA2
; ---------------------------------------------------------------------------

loc_3F99:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+87j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_934], eax

loc_3FA2:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+93j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_934]
		push	edx
		push	offset ??_C@_0CE@OKOOMCMI@?5collation?5elements?5?$CFs?5at?5line?5?$CF@	; " collation elements %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3FC4:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+81j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_3FF3
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		push	offset ??_C@_09BHDMPOMF@?$CIno?5type?$CJ?$AA@ ;	"(no type)"
		mov	edx, [ebp+var_C]
		push	edx		; TableResource	*
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z ;	addCollation(ParseState	*,TableResource	*,char const *,uint,UErrorCode *)
		add	esp, 14h
		jmp	loc_4359
; ---------------------------------------------------------------------------
		jmp	loc_4359
; ---------------------------------------------------------------------------

loc_3FF3:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+C6j
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *):loc_4354j
		lea	eax, [ebp+var_38]
		push	eax
		call	_ustr_init
		add	esp, 4

loc_3FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_860]
		push	ecx
		lea	edx, [ebp+var_38]
		push	edx
		lea	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 2
		jnz	short loc_402F
		mov	eax, [ebp+var_C]
		jmp	loc_4359
; ---------------------------------------------------------------------------

loc_402F:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+121j
		cmp	[ebp+var_44], 0
		jz	short loc_4089
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		cmp	[ebp+var_44], 5
		jnz	short loc_4063
		push	offset ??_C@_0BD@LJADOCP@unterminated?5table?$AA@ ; "unterminated table"
		mov	eax, [ebp+arg_8]
		push	eax
		call	_error
		add	esp, 8
		jmp	short loc_4082
; ---------------------------------------------------------------------------

loc_4063:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+14Aj
		mov	eax, [ebp+var_44]
		mov	ecx, ds:?tokenNames@@3PAPBDA[eax*4] ; char const * * tokenNames
		push	ecx
		push	offset ??_C@_0BE@ICNNHMFJ@Unexpected?5token?5?$CFs?$AA@	; "Unexpected token %s"
		mov	edx, [ebp+var_860]
		push	edx
		call	_error
		add	esp, 0Ch

loc_4082:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+15Dj
		xor	eax, eax
		jmp	loc_4359
; ---------------------------------------------------------------------------

loc_4089:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+12Fj
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_strlen_56
		add	esp, 4
		add	eax, 1
		push	eax
		lea	edx, [ebp+Str1]
		push	edx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_40D8
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	loc_4359
; ---------------------------------------------------------------------------

loc_40D8:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+1BFj
		push	offset ??_C@_07DLHCIBDH@default?$AA@ ; "default"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_4150
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z ; parseResource(ParseState *,char *,UString const *,UErrorCode	*)
		add	esp, 10h
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4134
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	loc_4359
; ---------------------------------------------------------------------------

loc_4134:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+21Bj
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_860]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		push	edx		; struct SResource *
		mov	ecx, [ebp+var_C] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		jmp	loc_432F
; ---------------------------------------------------------------------------

loc_4150:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+1EAj
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		lea	edx, [ebp+var_860]
		push	edx
		lea	eax, [ebp+var_24]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 1
		jnz	loc_4234
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_860]
		push	ecx
		lea	edx, [ebp+var_38]
		push	edx
		lea	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_44], eax
		lea	eax, [ebp+Str1]
		push	eax
		call	?keepCollationType@@YACPBD@Z ; keepCollationType(char const *)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_41DD
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+88h]
		push	eax
		call	_table_open
		add	esp, 10h
		mov	[ebp+var_86C], eax
		jmp	short loc_41E7
; ---------------------------------------------------------------------------

loc_41DD:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+2B0j
		mov	[ebp+var_86C], 0

loc_41E7:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+2D7j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		lea	edx, [ebp+Str1]
		push	edx		; char *
		mov	eax, [ebp+var_86C]
		push	eax		; TableResource	*
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z ;	addCollation(ParseState	*,TableResource	*,char const *,uint,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_86C], eax
		cmp	[ebp+var_86C], 0
		jz	short loc_422F
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+var_86C]
		push	edx		; struct SResource *
		mov	ecx, [ebp+var_C] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)

loc_422F:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+312j
		jmp	loc_432F
; ---------------------------------------------------------------------------

loc_4234:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+274j
		cmp	[ebp+var_44], 4
		jnz	loc_4316
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_38]
		push	ecx
		lea	edx, [ebp+var_860]
		push	edx
		lea	eax, [ebp+var_24]
		push	eax
		push	1
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_strlen_56
		add	esp, 4
		add	eax, 1
		push	eax
		lea	edx, [ebp+var_854]
		push	edx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		push	offset ??_C@_05NKHOCLEE@alias?$AA@ ; "alias"
		lea	eax, [ebp+var_854]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_42FB
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z ; parseResource(ParseState *,char *,UString const *,UErrorCode	*)
		add	esp, 10h
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_42E2
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_4359
; ---------------------------------------------------------------------------

loc_42E2:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+3CCj
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_860]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		push	edx		; struct SResource *
		mov	ecx, [ebp+var_C] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		jmp	short loc_4314
; ---------------------------------------------------------------------------

loc_42FB:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+39Bj
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		xor	eax, eax
		jmp	short loc_4359
; ---------------------------------------------------------------------------

loc_4314:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+3F5j
		jmp	short loc_432F
; ---------------------------------------------------------------------------

loc_4316:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+334j
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		xor	eax, eax
		jmp	short loc_4359
; ---------------------------------------------------------------------------

loc_432F:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+247j
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *):loc_422Fj ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4354
		mov	eax, [ebp+var_C]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_4359
; ---------------------------------------------------------------------------

loc_4354:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+43Ej
		jmp	loc_3FF3
; ---------------------------------------------------------------------------

loc_4359:				; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+72j
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+E5j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN37_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 934h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseCollationElements@@YAPAUSResource@@PAUParseState@@PADICPAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
$LN37_2		dd 5			; DATA XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+459o
		dd offset $LN36_1
$LN36_1		dd 0FFFFFFDCh, 4	; DATA XREF: .text:0000438Co
		dd offset $LN31		; "tokenValue"
		dd 0FFFFFFC8h, 0Ch
		dd offset $LN32_1	; "comment"
		dd 0FFFFFBB4h, 400h
		dd offset $LN33_2	; "subtag"
		dd 0FFFFF7ACh, 400h
		dd offset $LN34_1	; "typeKeyword"
		dd 0FFFFF7A0h, 4
		dd offset $LN35_1	; "line"
$LN35_1		db 'line',0             ; DATA XREF: .text:000043C8o
$LN34_1		db 'typeKeyword',0      ; DATA XREF: .text:000043BCo
$LN33_2		db 'subtag',0           ; DATA XREF: .text:000043B0o
$LN32_1		db 'comment',0          ; DATA XREF: .text:000043A4o
$LN31		db 'tokenValue',0       ; DATA XREF: .text:00004398o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 43F8h
		public ??_C@_07DLHCIBDH@default?$AA@
; char `string'[]
??_C@_07DLHCIBDH@default?$AA@ db 'default',0
					; DATA XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *):loc_40D8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4400h
		public ??_C@_0BE@ICNNHMFJ@Unexpected?5token?5?$CFs?$AA@
; `string'
??_C@_0BE@ICNNHMFJ@Unexpected?5token?5?$CFs?$AA@ db 'Unexpected token %s',0
					; DATA XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+16Ao
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+FEo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4414h
		public ??_C@_09BHDMPOMF@?$CIno?5type?$CJ?$AA@
; char `string'[]
??_C@_09BHDMPOMF@?$CIno?5type?$CJ?$AA@ db '(no type)',0
					; DATA XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+D0o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4420h
		public ??_C@_0CE@OKOOMCMI@?5collation?5elements?5?$CFs?5at?5line?5?$CF@
; char `string'[]
??_C@_0CE@OKOOMCMI@?5collation?5elements?5?$CFs?5at?5line?5?$CF@ db ' collation elements %s at line %i ',0Ah,0
					; DATA XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+ABo
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4444h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl addCollation(int,	TableResource *, char *, int, enum UErrorCode *)
?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z proc near
					; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+DDp
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+2FDp

var_A10		= byte ptr -0A10h
var_A0C		= dword	ptr -0A0Ch
var_A00		= dword	ptr -0A00h
var_9F4		= dword	ptr -9F4h
var_9E8		= dword	ptr -9E8h
var_9DC		= dword	ptr -9DCh
var_9D0		= dword	ptr -9D0h
var_9C4		= dword	ptr -9C4h
var_9B8		= dword	ptr -9B8h
var_9AC		= dword	ptr -9ACh
var_9A0		= dword	ptr -9A0h
var_994		= dword	ptr -994h
var_988		= dword	ptr -988h
var_97C		= dword	ptr -97Ch
var_970		= dword	ptr -970h
var_8A4		= dword	ptr -8A4h
var_898		= dword	ptr -898h
var_88C		= dword	ptr -88Ch
var_834		= dword	ptr -834h
var_828		= dword	ptr -828h
var_81C		= byte ptr -81Ch
var_810		= byte ptr -810h
Dest		= byte ptr -7A4h
var_738		= dword	ptr -738h
var_72C		= byte ptr -72Ch
var_720		= byte ptr -720h
var_588		= dword	ptr -588h
var_57C		= byte ptr -57Ch
Dst		= byte ptr -568h
var_564		= dword	ptr -564h
var_560		= dword	ptr -560h
var_540		= dword	ptr -540h
var_518		= dword	ptr -518h
var_50C		= dword	ptr -50Ch
var_500		= dword	ptr -500h
var_4F4		= byte ptr -4F4h
var_4C4		= dword	ptr -4C4h
var_4B8		= dword	ptr -4B8h
var_4AC		= byte ptr -4ACh
var_4AB		= byte ptr -4ABh
var_4AA		= byte ptr -4AAh
var_4A9		= byte ptr -4A9h
var_49D		= byte ptr -49Dh
var_494		= byte ptr -494h
Str1		= byte ptr -44Ch
var_44		= dword	ptr -44h
var_38		= byte ptr -38h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0A04h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_A10]
		mov	ecx, 281h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], 0
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??0UnicodeString@icu_56@@QAE@XZ ; icu_56::UnicodeString::UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	[ebp+var_49D], 0
		mov	[ebp+var_4AC], 0
		mov	[ebp+var_4AB], 0
		mov	[ebp+var_4AA], 0
		mov	[ebp+var_4A9], 0

loc_44CA:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *):loc_4857j
		lea	eax, [ebp+var_38]
		push	eax
		call	_ustr_init
		add	esp, 4
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_4B8]
		push	ecx
		lea	edx, [ebp+var_38]
		push	edx
		lea	eax, [ebp+var_24]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 2
		jnz	short loc_4503
		jmp	loc_485C
; ---------------------------------------------------------------------------

loc_4503:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+B8j
		cmp	[ebp+var_44], 0
		jz	short loc_4587
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		cmp	[ebp+var_44], 5
		jnz	short loc_4537
		push	offset ??_C@_0BD@LJADOCP@unterminated?5table?$AA@ ; "unterminated table"
		mov	eax, [ebp+arg_C]
		push	eax
		call	_error
		add	esp, 8
		jmp	short loc_4556
; ---------------------------------------------------------------------------

loc_4537:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+DEj
		mov	eax, [ebp+var_44]
		mov	ecx, ds:?tokenNames@@3PAPBDA[eax*4] ; char const * * tokenNames
		push	ecx
		push	offset ??_C@_0BE@ICNNHMFJ@Unexpected?5token?5?$CFs?$AA@	; "Unexpected token %s"
		mov	edx, [ebp+var_4B8]
		push	edx
		call	_error
		add	esp, 0Ch

loc_4556:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+F1j
		mov	[ebp+var_A0C], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_A0C]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4587:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C3j
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_strlen_56
		add	esp, 4
		add	eax, 1
		push	eax
		lea	edx, [ebp+Str1]
		push	edx
		mov	eax, [ebp+var_24]
		mov	ecx, [eax]
		push	ecx
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4600
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_A00], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_A00]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4600:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+17Dj
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+Str1]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z ; parseResource(ParseState *,char *,UString const *,UErrorCode	*)
		add	esp, 10h
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_466E
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_9F4], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9F4]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_466E:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+1EBj
		cmp	[ebp+arg_4], 0
		jnz	short loc_4679
		jmp	loc_47F9
; ---------------------------------------------------------------------------

loc_4679:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+22Ej
		push	offset ??_C@_07NGFJPNPN@Version?$AA@ ; "Version"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	loc_473A
		mov	ecx, [ebp+var_18] ; this
		call	?isString@SResource@@QBECXZ ; SResource::isString(void)
		movsx	eax, al
		test	eax, eax
		jz	loc_473A
		mov	eax, [ebp+var_18]
		mov	[ebp+var_4C4], eax
		mov	ecx, [ebp+var_4C4] ; this
		call	?length@StringBaseResource@@QBEHXZ ; StringBaseResource::length(void)
		mov	[ebp+var_500], eax
		cmp	[ebp+var_500], 28h ; '('
		jl	short loc_46D5
		mov	[ebp+var_500], 27h ; '''

loc_46D5:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+285j
		mov	esi, esp
		push	0
		push	28h ; '('
		lea	eax, [ebp+var_4F4]
		push	eax
		mov	ecx, [ebp+var_500]
		push	ecx
		push	0
		mov	ecx, [ebp+var_4C4]
		add	ecx, 2Ch ; ','
		call	dword ptr ds:__imp_?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z ; icu_56::UnicodeString::extract(int,int,char *,int,icu_56::UnicodeString::EInvariant)
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+var_4F4]
		push	eax
		lea	ecx, [ebp+var_4AC]
		push	ecx
		call	_u_versionFromString_56
		add	esp, 8
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_4B8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		push	edx		; struct SResource *
		mov	ecx, [ebp+arg_4] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		mov	[ebp+var_18], 0
		jmp	loc_47F9
; ---------------------------------------------------------------------------

loc_473A:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+24Bj
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+25Ej
		push	offset ??_C@_0P@DONENFIN@?$CF?$CFCollationBin?$AA@ ; "%%CollationBin"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_4757
		jmp	loc_47F9
; ---------------------------------------------------------------------------

loc_4757:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+30Cj
		push	offset ??_C@_08DOCONEG@Sequence?$AA@ ; "Sequence"
		lea	eax, [ebp+Str1]
		push	eax		; Str1
		call	_strcmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_47DB
		mov	ecx, [ebp+var_18] ; this
		call	?isString@SResource@@QBECXZ ; SResource::isString(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_47DB
		mov	eax, [ebp+var_18]
		mov	[ebp+var_50C], eax
		mov	eax, [ebp+var_50C]
		add	eax, 2Ch ; ','
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_494]
		call	dword ptr ds:__imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ;	icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_49D], 1
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+0A1h]
		test	ecx, ecx
		jnz	short loc_47D9
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_4B8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		push	edx		; struct SResource *
		mov	ecx, [ebp+arg_4] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		mov	[ebp+var_18], 0

loc_47D9:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+375j
		jmp	short loc_47F9
; ---------------------------------------------------------------------------

loc_47DB:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+329j
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+338j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_4B8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		push	edx		; struct SResource *
		mov	ecx, [ebp+arg_4] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		mov	[ebp+var_18], 0

loc_47F9:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+230j
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+2F1j ...
		mov	eax, [ebp+var_18]
		push	eax
		call	_res_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4857
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_9E8], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9E8]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4857:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+3D4j
		jmp	loc_44CA
; ---------------------------------------------------------------------------

loc_485C:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+BAj
		movsx	eax, [ebp+var_49D]
		test	eax, eax
		jnz	short loc_4897
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_9DC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9DC]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4897:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+421j
		push	1
		mov	eax, [ebp+arg_8]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	1
		push	offset ??_C@_08OKEMGDJB@private?9?$AA@ ; "private-"
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	8		; MaxCount
		push	offset ??_C@_08OKEMGDJB@private?9?$AA@ ; "private-"
		mov	ecx, [ebp+arg_8]
		push	ecx		; Str1
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_4936
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_4906
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+9Ch]
		push	edx
		push	offset ??_C@_0CF@KEPHFBMB@Not?5building?5?$CFs?$HO?$CFs?5collation?5bin@ ; "Not	building %s~%s collation binary\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4906:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+49Bj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_9D0], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9D0]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4936:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+48Fj
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+0A0h]
		test	ecx, ecx
		jnz	short loc_49A5
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_4975
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+9Ch]
		push	edx
		push	offset ??_C@_0CF@KEPHFBMB@Not?5building?5?$CFs?$HO?$CFs?5collation?5bin@ ; "Not	building %s~%s collation binary\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4975:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+50Aj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_9C4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9C4]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_49A5:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+4FEj
		mov	[ebp+var_518], 0
		push	48h ; 'H'       ; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+94h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8Ch]
		push	eax
		lea	ecx, [ebp+var_57C]
		call	??0GenrbImporter@?A0x82188031@@QAE@PBD0@Z ; `anonymous namespace'::GenrbImporter::GenrbImporter(char const *,char const *)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	eax, [ebp+var_518]
		push	eax		; enum UErrorCode *
		call	dword ptr ds:__imp_?getRoot@CollationRoot@icu_56@@SAPBUCollationTailoring@2@AAW4UErrorCode@@@Z ; icu_56::CollationRoot::getRoot(UErrorCode &)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_588], eax
		mov	eax, [ebp+var_518]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_4A8A
		mov	eax, [ebp+var_518]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		push	eax
		push	offset ??_C@_0DA@POBGMJIK@failed?5to?5load?5root?5collator?5?$CIuc@ ; "failed to load root collator (ucadata.i"...
		mov	ecx, [ebp+var_4B8]
		push	ecx
		call	_error
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_9B8], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9B8]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4A8A:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+5D4j
		mov	esi, esp
		lea	eax, [ebp+var_518]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_588]
		push	ecx		; struct icu_56::CollationTailoring *
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??0CollationBuilder@icu_56@@QAE@PBUCollationTailoring@1@AAW4UErrorCode@@@Z ;	icu_56::CollationBuilder::CollationBuilder(icu_56::CollationTailoring const *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 2
		push	1
		mov	eax, [ebp+arg_8]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	1
		push	offset ??_C@_06GFPLNGOC@search?$AA@ ; "search"
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	6		; MaxCount
		push	offset ??_C@_06GFPLNGOC@search?$AA@ ; "search"
		mov	ecx, [ebp+arg_8]
		push	ecx		; Str1
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_4B04
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_?disableFastLatin@CollationBuilder@icu_56@@QAEXXZ ; icu_56::CollationBuilder::disableFastLatin(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4B04:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+6A9j
		mov	esi, esp
		lea	eax, [ebp+var_518]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+Dst]
		push	ecx		; struct UParseError *
		lea	edx, [ebp+var_57C]
		push	edx		; struct icu_56::CollationRuleParser::Importer *
		lea	eax, [ebp+var_4AC]
		push	eax		; unsigned __int8 *
		lea	ecx, [ebp+var_494]
		push	ecx		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_?parseAndBuild@CollationBuilder@icu_56@@QAEPAUCollationTailoring@2@ABVUnicodeString@2@QBEPAVImporter@CollationRuleParser@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::CollationBuilder::parseAndBuild(icu_56::UnicodeString const &,uchar const * const,icu_56::CollationRuleParser::Importer *,UParseError *,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_72C]
		call	??0?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z ;	icu_56::LocalPointer<icu_56::CollationTailoring>::LocalPointer<icu_56::CollationTailoring>(icu_56::CollationTailoring *)
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+var_518]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_4CD5
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_?getErrorReason@CollationBuilder@icu_56@@QBEPBDXZ ; icu_56::CollationBuilder::getErrorReason(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_738], eax
		cmp	[ebp+var_738], 0
		jnz	short loc_4B94
		mov	[ebp+var_738], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'

loc_4B94:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+744j
		mov	eax, [ebp+var_738]
		push	eax
		mov	ecx, [ebp+var_518]
		push	ecx
		call	_u_errorName_56
		add	esp, 4
		push	eax
		mov	edx, [ebp+var_564]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+9Ch]
		push	edx
		push	offset ??_C@_0EC@JIOKCMDG@CollationBuilder?5failed?5at?5?$CFs?$HO?$CFs@	; "CollationBuilder failed at %s~%s/Sequen"...
		mov	eax, [ebp+var_4B8]
		push	eax
		call	_error
		add	esp, 1Ch
		movzx	eax, word ptr [ebp+var_560]
		test	eax, eax
		jnz	short loc_4BEA
		movzx	eax, word ptr [ebp+var_540]
		test	eax, eax
		jz	short loc_4C38

loc_4BEA:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+799j
		lea	eax, [ebp+Dest]
		push	eax		; Dest
		lea	ecx, [ebp+var_560]
		push	ecx		; int
		call	?escape@?A0x82188031@@YAXPB_WPAD@Z ; `anonymous	namespace'::escape(wchar_t const *,char *)
		add	esp, 8
		lea	eax, [ebp+var_810]
		push	eax		; Dest
		lea	ecx, [ebp+var_540]
		push	ecx		; int
		call	?escape@?A0x82188031@@YAXPB_WPAD@Z ; `anonymous	namespace'::escape(wchar_t const *,char *)
		add	esp, 8
		lea	eax, [ebp+var_810]
		push	eax
		lea	ecx, [ebp+Dest]
		push	ecx
		push	offset ??_C@_0CD@KIPDILNG@?5?5error?5context?3?5?$CC?4?4?4?$CFs?$CC?5?$CB?5?$CC?$CFs?4?4@ ; "  error context: \"...%s\"	! \"%s...\""
		mov	edx, [ebp+var_4B8]
		push	edx
		call	_error
		add	esp, 10h

loc_4C38:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+7A4j
		call	_isStrict
		movsx	eax, al
		test	eax, eax
		jnz	short loc_4C56
		lea	ecx, [ebp+var_72C]
		call	?isNull@?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBECXZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::isNull(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_4CD5

loc_4C56:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+7FEj
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+var_518]
		mov	[eax], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_9AC], 0
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_72C]
		call	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9AC]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4CD5:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+71Cj
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+810j
		push	0
		lea	ecx, [ebp+var_81C]
		call	??0?$LocalMemory@E@icu_56@@QAE@PAE@Z ; icu_56::LocalMemory<uchar>::LocalMemory<uchar>(uchar *)
		mov	byte ptr [ebp+var_4], 4
		mov	[ebp+var_828], 186A0h
		push	0		; Size
		mov	eax, [ebp+var_828]
		push	eax		; int
		lea	ecx, [ebp+var_81C]
		call	?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z ; icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)
		mov	[ebp+var_834], eax
		cmp	[ebp+var_834], 0
		jnz	loc_4DD4
		mov	esi, esp
		mov	eax, [ebp+var_828]
		push	eax
		push	offset ??_C@_0DI@CCECMDLD@memory?5allocation?5?$CI?$CFld?5bytes?$CJ?5fo@ ; "memory allocation (%ld bytes) for file "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_9A0], 0
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_81C]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_72C]
		call	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_9A0]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4DD4:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+8CDj
		mov	esi, esp
		lea	eax, [ebp+var_518]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_828]
		push	ecx		; int
		mov	edx, [ebp+var_834]
		push	edx		; unsigned __int8 *
		lea	eax, [ebp+var_88C]
		push	eax		; int *
		lea	ecx, [ebp+var_72C]
		call	??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator->(void)
		mov	ecx, [eax+18h]
		push	ecx		; struct icu_56::CollationSettings *
		lea	ecx, [ebp+var_72C]
		call	??D?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEAAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator*(void)
		push	eax		; struct icu_56::CollationTailoring *
		call	dword ptr ds:__imp_?writeTailoring@CollationDataWriter@icu_56@@SAHABUCollationTailoring@2@ABUCollationSettings@2@QAHPAEHAAW4UErrorCode@@@Z ; icu_56::CollationDataWriter::writeTailoring(icu_56::CollationTailoring const &,icu_56::CollationSettings const &,int * const,uchar	*,int,UErrorCode &)
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_898], eax
		cmp	[ebp+var_518], 0Fh
		jnz	loc_4F79
		mov	[ebp+var_518], 0
		mov	eax, [ebp+var_898]
		mov	[ebp+var_828], eax
		push	0		; Size
		mov	eax, [ebp+var_828]
		push	eax		; int
		lea	ecx, [ebp+var_81C]
		call	?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z ; icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)
		mov	[ebp+var_834], eax
		cmp	[ebp+var_834], 0
		jnz	loc_4F2A
		mov	esi, esp
		mov	eax, [ebp+var_828]
		push	eax
		push	offset ??_C@_0DI@CCECMDLD@memory?5allocation?5?$CI?$CFld?5bytes?$CJ?5fo@ ; "memory allocation (%ld bytes) for file "...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_994], 0
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_81C]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_72C]
		call	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_994]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_4F2A:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+A23j
		mov	esi, esp
		lea	eax, [ebp+var_518]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_828]
		push	ecx		; int
		mov	edx, [ebp+var_834]
		push	edx		; unsigned __int8 *
		lea	eax, [ebp+var_88C]
		push	eax		; int *
		lea	ecx, [ebp+var_72C]
		call	??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator->(void)
		mov	ecx, [eax+18h]
		push	ecx		; struct icu_56::CollationSettings *
		lea	ecx, [ebp+var_72C]
		call	??D?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEAAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator*(void)
		push	eax		; struct icu_56::CollationTailoring *
		call	dword ptr ds:__imp_?writeTailoring@CollationDataWriter@icu_56@@SAHABUCollationTailoring@2@ABUCollationSettings@2@QAHPAEHAAW4UErrorCode@@@Z ; icu_56::CollationDataWriter::writeTailoring(icu_56::CollationTailoring const &,icu_56::CollationSettings const &,int * const,uchar	*,int,UErrorCode &)
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_898], eax

loc_4F79:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+9E6j
		mov	eax, [ebp+var_518]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_5050
		mov	eax, [ebp+var_518]
		push	eax
		call	_u_errorName_56
		add	esp, 4
		mov	esi, esp
		push	eax
		push	offset ??_C@_0DC@PNDPNOML@CollationDataWriter?3?3writeTailor@ ;	"CollationDataWriter::writeTailoring() f"...
		mov	edi, esp
		call	dword ptr ds:__imp____iob_func
		cmp	edi, esp
		call	__RTC_CheckEsp
		add	eax, 40h ; '@'
		push	eax		; File
		call	dword ptr ds:__imp__fprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_988], 0
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_81C]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_72C]
		call	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_988]
		jmp	loc_528A
; ---------------------------------------------------------------------------

loc_5050:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+B49j
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	loc_5133
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+9Ch]
		push	edx
		push	offset ??_C@_0CH@GKEIHHBD@?$CFs?$HO?$CFs?5collation?5tailoring?5part?5s@ ; "%s~%s collation tailoring part sizes:\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		lea	eax, [ebp+var_88C]
		push	eax		; int *
		mov	ecx, [ebp+var_898]
		push	ecx		; int
		call	dword ptr ds:__imp_?printSizes@CollationInfo@icu_56@@SAXHQBH@Z ; icu_56::CollationInfo::printSizes(int,int const * const)
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_72C]
		call	??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator->(void)
		mov	esi, esp
		mov	ecx, [eax+18h]	; this
		call	dword ptr ds:__imp_?hasReordering@CollationSettings@icu_56@@QBECXZ ; icu_56::CollationSettings::hasReordering(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_5133
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+9Ch]
		push	edx
		push	offset ??_C@_0CE@PIGANEBA@?$CFs?$HO?$CFs?5collation?5reordering?5range@	; "%s~%s collation reordering ranges:\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_72C]
		call	??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator->(void)
		mov	eax, [eax+18h]
		mov	esi, esp
		mov	ecx, [eax+30h]
		push	ecx		; int
		lea	ecx, [ebp+var_72C]
		call	??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator->(void)
		mov	edx, [eax+18h]
		mov	eax, [edx+2Ch]
		push	eax		; int *
		lea	ecx, [ebp+var_72C]
		call	??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::operator->(void)
		mov	ecx, [eax+14h]
		push	ecx		; struct icu_56::CollationData *
		call	dword ptr ds:__imp_?printReorderRanges@CollationInfo@icu_56@@SAXABUCollationData@2@PBHH@Z ; icu_56::CollationInfo::printReorderRanges(icu_56::CollationData const &,int	const *,int)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5133:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C16j
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C83j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+var_834]
		push	ecx
		mov	edx, [ebp+var_898]
		push	edx
		push	offset ??_C@_0P@DONENFIN@?$CF?$CFCollationBin?$AA@ ; "%%CollationBin"
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_bin_open
		add	esp, 1Ch
		mov	[ebp+var_8A4], eax
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_4B8]
		push	ecx		; int
		mov	edx, [ebp+var_8A4]
		push	edx		; struct SResource *
		mov	ecx, [ebp+arg_4] ; this
		call	?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z ; TableResource::add(SResource *,int,UErrorCode &)
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5219
		mov	eax, [ebp+arg_4]
		push	eax
		call	_res_close
		add	esp, 4
		mov	[ebp+var_97C], 0
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_81C]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_72C]
		call	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_97C]
		jmp	short loc_528A
; ---------------------------------------------------------------------------

loc_5219:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+D4Fj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_970], eax
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_81C]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_72C]
		call	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	esi, esp
		lea	ecx, [ebp+var_720] ; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_57C]
		call	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_494] ; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_970]

loc_528A:				; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+13Ej
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+1B7j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN65
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0A10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN65		dd 10h			; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+E4Ao
		dd offset $LN64
$LN64		dd 0FFFFFFDCh, 4	; DATA XREF: .text:000052C8o
		dd offset $LN47		; "tokenValue"
		dd 0FFFFFFC8h, 0Ch
		dd offset $LN48		; "comment"
		dd 0FFFFFBB4h, 400h
		dd offset $LN49		; "subtag"
		dd 0FFFFFB6Ch, 40h
		dd offset $LN50		; "rules"
		dd 0FFFFFB54h, 4
		dd offset $LN51		; "version"
		dd 0FFFFFB48h, 4
		dd offset $LN52		; "line"
		dd 0FFFFFB0Ch, 28h
		dd offset $LN53		; "ver"
		dd 0FFFFFAE8h, 4
		dd offset $LN54		; "intStatus"
		dd 0FFFFFA98h, 48h
		dd offset $LN55		; "parseError"
		dd 0FFFFFA84h, 0Ch
		dd offset $LN56		; "importer"
		dd 0FFFFF8E0h, 190h
		dd offset $LN57		; "builder"
		dd 0FFFFF8D4h, 4
		dd offset $LN58		; "t"
		dd 0FFFFF85Ch, 64h
		dd offset $LN59		; "preBuffer"
		dd 0FFFFF7F0h, 64h
		dd offset $LN60		; "postBuffer"
		dd 0FFFFF7E4h, 4
		dd offset $LN61		; "buffer"
		dd 0FFFFF774h, 50h
		dd offset $LN62		; "indexes"
$LN62		db 'indexes',0          ; DATA XREF: .text:00005388o
$LN61		db 'buffer',0           ; DATA XREF: .text:0000537Co
$LN60		db 'postBuffer',0       ; DATA XREF: .text:00005370o
$LN59		db 'preBuffer',0        ; DATA XREF: .text:00005364o
$LN58		db 't',0                ; DATA XREF: .text:00005358o
$LN57		db 'builder',0          ; DATA XREF: .text:0000534Co
$LN56		db 'importer',0         ; DATA XREF: .text:00005340o
$LN55		db 'parseError',0       ; DATA XREF: .text:00005334o
$LN54		db 'intStatus',0        ; DATA XREF: .text:00005328o
$LN53		db 'ver',0              ; DATA XREF: .text:0000531Co
$LN52		db 'line',0             ; DATA XREF: .text:00005310o
$LN51		db 'version',0          ; DATA XREF: .text:00005304o
$LN50		db 'rules',0            ; DATA XREF: .text:000052F8o
$LN49		db 'subtag',0           ; DATA XREF: .text:000052ECo
$LN48		db 'comment',0          ; DATA XREF: .text:000052E0o
$LN47		db 'tokenValue',0       ; DATA XREF: .text:000052D4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 540Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:0000564Co
		mov	esi, esp
		lea	ecx, [ebp-494h]	; this
		call	dword ptr ds:__imp_??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$1	proc near
					; DATA XREF: .xdata$x:00005654o
		lea	ecx, [ebp-57Ch]
		jmp	??1GenrbImporter@?A0x82188031@@UAE@XZ ;	`anonymous namespace'::GenrbImporter::~GenrbImporter(void)
__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$2	proc near
					; DATA XREF: .xdata$x:0000565Co
		mov	esi, esp
		lea	ecx, [ebp-720h]	; this
		call	dword ptr ds:__imp_??1CollationBuilder@icu_56@@UAE@XZ ;	icu_56::CollationBuilder::~CollationBuilder(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$2	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$3	proc near
					; DATA XREF: .xdata$x:00005664o
		lea	ecx, [ebp-72Ch]
		jmp	??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ;	icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)
__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$3	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$4	proc near
					; DATA XREF: .xdata$x:0000566Co
		lea	ecx, [ebp-81Ch]
		jmp	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
__unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$4	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z proc near
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0A14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5480h
		public ??_C@_0CE@PIGANEBA@?$CFs?$HO?$CFs?5collation?5reordering?5range@
; char `string'[]
??_C@_0CE@PIGANEBA@?$CFs?$HO?$CFs?5collation?5reordering?5range@ db '%s~%s collation reordering ranges:',0Ah,0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C95o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54A4h
		public ??_C@_0CH@GKEIHHBD@?$CFs?$HO?$CFs?5collation?5tailoring?5part?5s@
; char `string'[]
??_C@_0CH@GKEIHHBD@?$CFs?$HO?$CFs?5collation?5tailoring?5part?5s@ db '%s~%s collation tailoring part sizes:',0Ah,0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C2Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54CCh
		public ??_C@_0DC@PNDPNOML@CollationDataWriter?3?3writeTailor@
; char `string'[]
??_C@_0DC@PNDPNOML@CollationDataWriter?3?3writeTailor@ db 'CollationDataWriter::writeTailoring() failed: %s',0Ah,0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+B61o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5500h
		public ??_C@_0DI@CCECMDLD@memory?5allocation?5?$CI?$CFld?5bytes?$CJ?5fo@
; char `string'[]
??_C@_0DI@CCECMDLD@memory?5allocation?5?$CI?$CFld?5bytes?$CJ?5fo@ db 'memory allocation (%ld bytes) for file contents failed',0Ah,0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+8DCo
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+A32o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5538h
		public ??_C@_0CD@KIPDILNG@?5?5error?5context?3?5?$CC?4?4?4?$CFs?$CC?5?$CB?5?$CC?$CFs?4?4@
; `string'
??_C@_0CD@KIPDILNG@?5?5error?5context?3?5?$CC?4?4?4?$CFs?$CC?5?$CB?5?$CC?$CFs?4?4@ db '  error context: "...%s" ! "%s..."',0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+7E0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 555Ch
		public ??_C@_0EC@JIOKCMDG@CollationBuilder?5failed?5at?5?$CFs?$HO?$CFs@
; `string'
??_C@_0EC@JIOKCMDG@CollationBuilder?5failed?5at?5?$CFs?$HO?$CFs@ db 'CollationBuilder failed at %s~%s/Sequence rule offset %ld: %s  %s'
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+77Co
		db 0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 55A0h
		public ??_C@_06GFPLNGOC@search?$AA@
; char `string'[]
??_C@_06GFPLNGOC@search?$AA@ db	'search',0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+67Do
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+68Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 55A8h
		public ??_C@_0DA@POBGMJIK@failed?5to?5load?5root?5collator?5?$CIuc@
; `string'
??_C@_0DA@POBGMJIK@failed?5to?5load?5root?5collator?5?$CIuc@ db	'failed to load root collator (ucadata.icu) - %s',0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+5E6o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 55D8h
		public ??_C@_0CF@KEPHFBMB@Not?5building?5?$CFs?$HO?$CFs?5collation?5bin@
; char `string'[]
??_C@_0CF@KEPHFBMB@Not?5building?5?$CFs?$HO?$CFs?5collation?5bin@ db 'Not building %s~%s collation binary',0Ah,0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+4ADo
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+51Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5600h
		public ??_C@_08OKEMGDJB@private?9?$AA@
; char `string'[]
??_C@_08OKEMGDJB@private?9?$AA@	db 'private-',0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+463o
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+474o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 560Ch
		public ??_C@_0P@DONENFIN@?$CF?$CFCollationBin?$AA@
; char `string'[]
??_C@_0P@DONENFIN@?$CF?$CFCollationBin?$AA@ db '%%CollationBin',0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *):loc_473Ao
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+D05o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 561Ch
		public ??_C@_07NGFJPNPN@Version?$AA@
; char `string'[]
??_C@_07NGFJPNPN@Version?$AA@ db 'Version',0
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *):loc_4679o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5624h
__ehfuncinfo$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z dd 19930522h, 5
					; DATA XREF: __ehhandler$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
__unwindtable$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000562Co
		dd offset __unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$2
		dd 2
		dd offset __unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$3
		dd 3
		dd offset __unwindfunclet$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z$4
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5670h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall StringBaseResource::length(StringBaseResource *__hidden this)
		public ?length@StringBaseResource@@QBEHXZ
?length@StringBaseResource@@QBEHXZ proc	near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+273p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 2Ch ; ','  ; this
		mov	esi, esp
		call	dword ptr ds:__imp_?length@UnicodeString@icu_56@@QBEHXZ	; icu_56::UnicodeString::length(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@StringBaseResource@@QBEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall `anonymous	namespace'::GenrbImporter::GenrbImporter(char const *, char const *)
		public ??0GenrbImporter@?A0x82188031@@QAE@PBD0@Z
??0GenrbImporter@?A0x82188031@@QAE@PBD0@Z proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+598p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_8] ; this
		call	dword ptr ds:__imp_??0Importer@CollationRuleParser@icu_56@@QAE@XZ ; icu_56::CollationRuleParser::Importer::Importer(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7GenrbImporter@?A0x82188031@@6B@ ; const `anonymous namespace'::GenrbImporter::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0GenrbImporter@?A0x82188031@@QAE@PBD0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5728h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl `anonymous namespace'::escape(int, char *Dest)
?escape@?A0x82188031@@YAXPB_WPAD@Z proc	near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+7B4p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+7CAp

var_F0		= byte ptr -0F0h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Dest		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0

loc_575C:				; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *):loc_5818j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_57C4
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jz	short loc_57C4
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_2C], dx
		movzx	eax, [ebp+var_2C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_57C4
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_2C]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_20], edx

loc_57C4:				; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+57j
					; `anonymous namespace'::escape(wchar_t const *,char *)+5Fj ...
		cmp	[ebp+var_20], 0
		jnz	short loc_57D4
		mov	eax, [ebp+Dest]
		mov	byte ptr [eax],	0
		jmp	short loc_581D
; ---------------------------------------------------------------------------
		jmp	short loc_5818
; ---------------------------------------------------------------------------

loc_57D4:				; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+A0j
		cmp	[ebp+var_20], 20h ; ' '
		jl	short loc_57F3
		cmp	[ebp+var_20], 7Eh ; '~'
		jg	short loc_57F3
		mov	eax, [ebp+Dest]
		mov	cl, byte ptr [ebp+var_20]
		mov	[eax], cl
		mov	edx, [ebp+Dest]
		add	edx, 1
		mov	[ebp+Dest], edx
		jmp	short loc_5818
; ---------------------------------------------------------------------------

loc_57F3:				; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+B0j
					; `anonymous namespace'::escape(wchar_t const *,char *)+B6j
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		push	offset ??_C@_06HFADPNPF@?2u?$CF04X?$AA@	; "\\u%04X"
		mov	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	dword ptr ds:__imp__sprintf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+Dest]
		mov	[ebp+Dest], eax

loc_5818:				; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+AAj
					; `anonymous namespace'::escape(wchar_t const *,char *)+C9j
		jmp	loc_575C
; ---------------------------------------------------------------------------

loc_581D:				; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+A8j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?escape@?A0x82188031@@YAXPB_WPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5834h
		public ??_C@_06HFADPNPF@?2u?$CF04X?$AA@
; char `string'[]
??_C@_06HFADPNPF@?2u?$CF04X?$AA@ db '\u%04X',0
					; DATA XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+D1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 583Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl keepCollationType(char const *)
?keepCollationType@@YACPBD@Z proc near	; CODE XREF: parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+2A3p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?keepCollationType@@YACPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5864h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseArray(struct ParseState *, char *, unsigned int, struct UString const	*, enum	 UErrorCode *)
?parseArray@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+BEo

var_114		= dword	ptr -114h
var_4C		= dword	ptr -4Ch
var_3D		= byte ptr -3Dh
var_34		= dword	ptr -34h
var_28		= byte ptr -28h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	[ebp+var_3D], 0
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_array_open
		add	esp, 10h
		mov	[ebp+var_4C], eax
		cmp	[ebp+var_4C], 0
		jz	short loc_58C9
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_58D0

loc_58C9:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+4Ej
		xor	eax, eax
		jmp	loc_5AD8
; ---------------------------------------------------------------------------

loc_58D0:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+63j
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_5919
		cmp	[ebp+arg_4], 0
		jnz	short loc_58EE
		mov	[ebp+var_114], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_58F7
; ---------------------------------------------------------------------------

loc_58EE:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+7Cj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_114], eax

loc_58F7:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+88j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_114]
		push	edx
		push	offset ??_C@_0BH@NIIDBJFK@?5array?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; " array %s	at line	%i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5919:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+76j
		lea	eax, [ebp+var_28]
		push	eax
		call	_ustr_init
		add	esp, 4

loc_5925:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+260j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+var_28]
		push	ecx
		call	_ustr_setlen
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_28]
		push	ecx
		push	0
		lea	edx, [ebp+var_14]
		push	edx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_34], eax
		cmp	[ebp+var_34], 2
		jnz	short loc_5990
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		movsx	eax, [ebp+var_3D]
		test	eax, eax
		jnz	short loc_598B
		push	offset ??_C@_0BI@EHDLDCJP@Encountered?5empty?5array?$AA@ ; "Encountered	empty array"
		mov	eax, [ebp+arg_8]
		push	eax
		call	_warning
		add	esp, 8

loc_598B:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+114j
		jmp	loc_5AC9
; ---------------------------------------------------------------------------

loc_5990:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+F6j
		cmp	[ebp+var_34], 5
		jnz	short loc_59C3
		mov	eax, [ebp+var_4C]
		push	eax
		call	_res_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		push	offset ??_C@_0BD@MBHNNJME@unterminated?5array?$AA@ ; "unterminated array"
		mov	eax, [ebp+arg_8]
		push	eax
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	loc_5AD8
; ---------------------------------------------------------------------------

loc_59C3:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+130j
		cmp	[ebp+var_34], 0
		jnz	short loc_5A11
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+var_28]
		push	ecx
		lea	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_28]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		push	edx
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_8], eax
		jmp	short loc_5A2A
; ---------------------------------------------------------------------------

loc_5A11:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+163j
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_28]
		push	ecx
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		call	?parseResource@@YAPAUSResource@@PAUParseState@@PADPBUUString@@PAW4UErrorCode@@@Z ; parseResource(ParseState *,char *,UString const *,UErrorCode	*)
		add	esp, 10h
		mov	[ebp+var_8], eax

loc_5A2A:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+1ABj
		cmp	[ebp+var_8], 0
		jz	short loc_5A45
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5A58

loc_5A45:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+1CAj
		mov	eax, [ebp+var_4C]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	loc_5AD8
; ---------------------------------------------------------------------------

loc_5A58:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+1DFj
		mov	eax, [ebp+var_8]
		push	eax		; struct SResource *
		mov	ecx, [ebp+var_4C] ; this
		call	?add@ArrayResource@@QAEXPAUSResource@@@Z ; ArrayResource::add(SResource	*)
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_34], eax
		cmp	[ebp+var_34], 3
		jnz	short loc_5A9B
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h

loc_5A9B:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+21Fj
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5AC0
		mov	eax, [ebp+var_4C]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_5AD8
; ---------------------------------------------------------------------------

loc_5AC0:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+24Aj
		mov	[ebp+var_3D], 1
		jmp	loc_5925
; ---------------------------------------------------------------------------

loc_5AC9:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *):loc_598Bj
		lea	eax, [ebp+var_28]
		push	eax
		call	_ustr_deinit
		add	esp, 4
		mov	eax, [ebp+var_4C]

loc_5AD8:				; CODE XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+67j
					; parseArray(ParseState	*,char *,uint,UString const *,UErrorCode *)+15Aj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN22_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseArray@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN22_0		dd 2			; DATA XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+278o
		dd offset $LN21_2
$LN21_2		dd 0FFFFFFECh, 4	; DATA XREF: .text:00005B04o
		dd offset $LN19_1	; "tokenValue"
		dd 0FFFFFFD8h, 0Ch
		dd offset $LN20_2	; "memberComments"
$LN20_2		db 'memberComments',0   ; DATA XREF: .text:00005B1Co
$LN19_1		db 'tokenValue',0       ; DATA XREF: .text:00005B10o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5B3Ch
		public ??_C@_0BD@MBHNNJME@unterminated?5array?$AA@
; `string'
??_C@_0BD@MBHNNJME@unterminated?5array?$AA@ db 'unterminated array',0
					; DATA XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+147o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5B50h
		public ??_C@_0BI@EHDLDCJP@Encountered?5empty?5array?$AA@
; `string'
??_C@_0BI@EHDLDCJP@Encountered?5empty?5array?$AA@ db 'Encountered empty array',0
					; DATA XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+116o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5B68h
		public ??_C@_0BH@NIIDBJFK@?5array?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BH@NIIDBJFK@?5array?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db ' array %s at line %i ',0Ah,0
					; DATA XREF: parseArray(ParseState *,char *,uint,UString const *,UErrorCode *)+A0o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl parseIntVector(int, int, int, int, enum UErrorCode *)
?parseIntVector@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc	near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+FAo

var_12C		= dword	ptr -12Ch
var_64		= dword	ptr -64h
var_58		= byte ptr -58h
var_44		= dword	ptr -44h
EndPtr		= dword	ptr -38h
var_29		= byte ptr -29h
var_20		= dword	ptr -20h
Str		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_29], 0
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_intvector_open
		add	esp, 10h
		mov	[ebp+var_64], eax
		cmp	[ebp+var_64], 0
		jz	short loc_5BDE
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5BE5

loc_5BDE:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+47j
		xor	eax, eax
		jmp	loc_5DC2
; ---------------------------------------------------------------------------

loc_5BE5:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+5Cj
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_5C2E
		cmp	[ebp+arg_4], 0
		jnz	short loc_5C03
		mov	[ebp+var_12C], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_5C0C
; ---------------------------------------------------------------------------

loc_5C03:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+75j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_12C], eax

loc_5C0C:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+81j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_12C]
		push	edx
		push	offset ??_C@_0BI@HLFABOBN@?5vector?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	vector %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5C2E:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+6Fj
		lea	eax, [ebp+var_58]
		push	eax
		call	_ustr_init
		add	esp, 4

loc_5C3A:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+23Dj
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+var_58]
		push	ecx
		call	_ustr_setlen
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_58]
		push	ecx
		push	0
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 2
		jnz	short loc_5CB2
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h
		movsx	eax, [ebp+var_29]
		test	eax, eax
		jnz	short loc_5C9E
		push	offset ??_C@_0BN@EFDCCLLN@Encountered?5empty?5int?5vector?$AA@ ; "Encountered empty int	vector"
		mov	eax, [ebp+arg_8]
		push	eax
		call	_warning
		add	esp, 8

loc_5C9E:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+10Bj
		lea	eax, [ebp+var_58]
		push	eax
		call	_ustr_deinit
		add	esp, 4
		mov	eax, [ebp+var_64]
		jmp	loc_5DC2
; ---------------------------------------------------------------------------

loc_5CB2:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+EDj
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z ; getInvariantString(ParseState *,uint *,UString *,UErrorCode *)
		add	esp, 10h
		mov	[ebp+Str], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5CF1
		mov	eax, [ebp+var_64]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	loc_5DC2
; ---------------------------------------------------------------------------

loc_5CF1:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+15Cj
		mov	esi, esp
		push	0		; Radix
		lea	eax, [ebp+EndPtr]
		push	eax		; EndPtr
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strtoul
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+EndPtr]
		sub	eax, [ebp+Str]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	[ebp+var_44], eax
		jnz	short loc_5D63
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_64] ; this
		call	?add@IntVectorResource@@QAEXHAAW4UErrorCode@@@Z	; IntVectorResource::add(int,UErrorCode	&)
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?peekToken@@YA?AW4ETokenType@@PAUParseState@@IPAPAUUString@@PAIPAU3@PAW4UErrorCode@@@Z ; peekToken(ParseState *,uint,UString * *,uint *,UString	*,UErrorCode *)
		add	esp, 18h
		mov	[ebp+var_8], eax
		jmp	short loc_5D78
; ---------------------------------------------------------------------------

loc_5D63:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+1A8j
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah

loc_5D78:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+1E1j
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5D9D
		mov	eax, [ebp+var_64]
		push	eax
		call	_res_close
		add	esp, 4
		xor	eax, eax
		jmp	short loc_5DC2
; ---------------------------------------------------------------------------

loc_5D9D:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+20Bj
		cmp	[ebp+var_8], 3
		jnz	short loc_5DB9
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getToken@@YA?AW4ETokenType@@PAUParseState@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; getToken(ParseState *,UString * *,UString *,uint	*,UErrorCode *)
		add	esp, 14h

loc_5DB9:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+221j
		mov	[ebp+var_29], 1
		jmp	loc_5C3A
; ---------------------------------------------------------------------------

loc_5DC2:				; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+60j
					; parseIntVector(ParseState *,char *,uint,UString const	*,UErrorCode *)+12Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseIntVector@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN20_3		dd 2			; DATA XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+246o
		dd offset $LN19_2
$LN19_2		dd 0FFFFFFC8h, 4	; DATA XREF: .text:00005DECo
		dd offset $LN17_2	; "stopstring"
		dd 0FFFFFFA8h, 0Ch
		dd offset $LN18_1	; "memberComments"
$LN18_1		db 'memberComments',0   ; DATA XREF: .text:00005E04o
$LN17_2		db 'stopstring',0       ; DATA XREF: .text:00005DF8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E24h
		public ??_C@_0BN@EFDCCLLN@Encountered?5empty?5int?5vector?$AA@
; `string'
??_C@_0BN@EFDCCLLN@Encountered?5empty?5int?5vector?$AA@	db 'Encountered empty int vector',0
					; DATA XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+10Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E44h
		public ??_C@_0BI@HLFABOBN@?5vector?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BI@HLFABOBN@?5vector?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db	' vector %s at line %i ',0Ah,0
					; DATA XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+99o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5E5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl getInvariantString(struct ParseState *, unsigned int *, struct	UString	*, enum	 UErrorCode *)
?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z proc	near
					; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+13Ep
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+4Bp ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		lea	eax, [ebp+var_8]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5EB4
		xor	eax, eax
		jmp	loc_5F3F
; ---------------------------------------------------------------------------

loc_5EB4:				; CODE XREF: getInvariantString(ParseState *,uint *,UString *,UErrorCode *)+4Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_uprv_isInvariantUString_56
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_5EFE
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		push	offset ??_C@_0EA@CELGHIGO@invariant?5characters?5required?5fo@ ; "invariant characters required	for table"...
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	_error
		add	esp, 8
		xor	eax, eax
		jmp	short loc_5F3F
; ---------------------------------------------------------------------------

loc_5EFE:				; CODE XREF: getInvariantString(ParseState *,uint *,UString *,UErrorCode *)+80j
		mov	eax, [ebp+var_20]
		add	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_5F23
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	short loc_5F3F
; ---------------------------------------------------------------------------

loc_5F23:				; CODE XREF: getInvariantString(ParseState *,uint *,UString *,UErrorCode *)+B8j
		mov	eax, [ebp+var_20]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		push	eax
		call	_u_UCharsToChars_56
		add	esp, 0Ch
		mov	eax, [ebp+var_14]

loc_5F3F:				; CODE XREF: getInvariantString(ParseState *,uint *,UString *,UErrorCode *)+53j
					; getInvariantString(ParseState	*,uint *,UString *,UErrorCode *)+A0j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN8_2		dd 1			; DATA XREF: getInvariantString(ParseState *,uint *,UString *,UErrorCode *)+E7o
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFF8h, 4	; DATA XREF: .text:00005F68o
		dd offset $LN6		; "tokenValue"
$LN6		db 'tokenValue',0       ; DATA XREF: .text:00005F74o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5F84h
		public ??_C@_0EA@CELGHIGO@invariant?5characters?5required?5fo@
; `string'
??_C@_0EA@CELGHIGO@invariant?5characters?5required?5fo@	db 'invariant characters required for table keys, binary data, etc.',0
					; DATA XREF: getInvariantString(ParseState *,uint *,UString *,UErrorCode *)+8Bo
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5FC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseBinary(struct	ParseState *, char *, unsigned int, struct UString const *, enum  UErrorCode *)
?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+46o

var_184		= dword	ptr -184h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_68		= dword	ptr -68h
EndPtr		= dword	ptr -5Ch
var_50		= dword	ptr -50h
Str		= byte ptr -44h
var_43		= byte ptr -43h
var_42		= byte ptr -42h
var_38		= byte ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= byte ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 178h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_184]
		mov	ecx, 5Eh ; '^'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z ; getInvariantString(ParseState *,uint *,UString *,UErrorCode *)
		add	esp, 10h
		push	eax
		lea	ecx, [ebp+var_20]
		call	??0?$LocalMemory@D@icu_56@@QAE@PAD@Z ; icu_56::LocalMemory<char>::LocalMemory<char>(char *)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_20]
		call	?isNull@?$LocalPointerBase@D@icu_56@@QBECXZ ; icu_56::LocalPointerBase<char>::isNull(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_604B
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_606F

loc_604B:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+70j
		mov	[ebp+var_17C], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_17C]
		jmp	loc_635E
; ---------------------------------------------------------------------------

loc_606F:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+85j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_60C0
		mov	[ebp+var_170], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_170]
		jmp	loc_635E
; ---------------------------------------------------------------------------

loc_60C0:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+D6j
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_6109
		cmp	[ebp+arg_4], 0
		jnz	short loc_60DE
		mov	[ebp+var_184], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_60E7
; ---------------------------------------------------------------------------

loc_60DE:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+10Cj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_184], eax

loc_60E7:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+118j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_184]
		push	edx
		push	offset ??_C@_0BI@CFLPKBPA@?5binary?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	binary %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6109:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+106j
		lea	ecx, [ebp+var_20]
		call	?getAlias@?$LocalPointerBase@D@icu_56@@QBEPADXZ	; icu_56::LocalPointerBase<char>::getAlias(void)
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jbe	loc_62FA
		mov	eax, [ebp+var_2C]
		xor	edx, edx
		mov	ecx, 2
		div	ecx
		test	edx, edx
		jnz	loc_62BD
		push	0
		lea	ecx, [ebp+var_38]
		call	??0?$LocalMemory@E@icu_56@@QAE@PAE@Z ; icu_56::LocalMemory<uchar>::LocalMemory<uchar>(uchar *)
		mov	byte ptr [ebp+var_4], 1
		push	0		; Size
		mov	eax, [ebp+var_2C]
		push	eax		; int
		lea	ecx, [ebp+var_38]
		call	?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z ; icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)
		test	eax, eax
		jnz	short loc_6194
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	[ebp+var_164], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_38]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_164]
		jmp	loc_635E
; ---------------------------------------------------------------------------

loc_6194:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+195j
		mov	[ebp+Str], 0
		mov	[ebp+var_43], 0
		mov	[ebp+var_42], 0
		mov	[ebp+var_50], 0
		jmp	short loc_61B2
; ---------------------------------------------------------------------------

loc_61A9:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *):loc_625Bj
		mov	eax, [ebp+var_50]
		add	eax, 2
		mov	[ebp+var_50], eax

loc_61B2:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+1E3j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_2C]
		jnb	loc_6260
		mov	eax, [ebp+var_50]
		push	eax
		lea	ecx, [ebp+var_20]
		call	??A?$LocalMemory@D@icu_56@@QBEAADH@Z ; icu_56::LocalMemory<char>::operator[](int)
		mov	cl, [eax]
		mov	[ebp+Str], cl
		mov	eax, [ebp+var_50]
		add	eax, 1
		push	eax
		lea	ecx, [ebp+var_20]
		call	??A?$LocalMemory@D@icu_56@@QBEAADH@Z ; icu_56::LocalMemory<char>::operator[](int)
		mov	cl, [eax]
		mov	[ebp+var_43], cl
		mov	esi, esp
		push	10h		; Radix
		lea	eax, [ebp+EndPtr]
		push	eax		; EndPtr
		lea	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strtoul
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ebx, eax
		mov	edx, [ebp+var_50]
		shr	edx, 1
		push	edx
		lea	ecx, [ebp+var_38]
		call	??A?$LocalMemory@E@icu_56@@QBEAAEH@Z ; icu_56::LocalMemory<uchar>::operator[](int)
		mov	[eax], bl
		mov	eax, [ebp+EndPtr]
		lea	ecx, [ebp+Str]
		sub	eax, ecx
		mov	[ebp+var_68], eax
		cmp	[ebp+var_68], 2
		jz	short loc_625B
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah
		mov	[ebp+var_158], 0
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_38]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_158]
		jmp	loc_635E
; ---------------------------------------------------------------------------

loc_625B:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+25Cj
		jmp	loc_61A9
; ---------------------------------------------------------------------------

loc_6260:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+1F4j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	0
		lea	ecx, [ebp+var_38]
		call	?getAlias@?$LocalPointerBase@E@icu_56@@QBEPAEXZ	; icu_56::LocalPointerBase<uchar>::getAlias(void)
		push	eax
		mov	edx, [ebp+var_2C]
		shr	edx, 1
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_bin_open
		add	esp, 1Ch
		mov	[ebp+var_14C], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_38]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_14C]
		jmp	loc_635E
; ---------------------------------------------------------------------------
		jmp	short loc_62F8
; ---------------------------------------------------------------------------

loc_62BD:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+171j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah
		push	offset ??_C@_0DB@HKAPFEMA@Encountered?5invalid?5binary?5value@ ; "Encountered invalid binary value (lengt"...
		mov	eax, [ebp+var_14]
		push	eax
		call	_error
		add	esp, 8
		mov	[ebp+var_140], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_140]
		jmp	short loc_635E
; ---------------------------------------------------------------------------

loc_62F8:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+2F7j
		jmp	short loc_634F
; ---------------------------------------------------------------------------

loc_62FA:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+15Dj
		push	offset ??_C@_0BP@FIDCNKGJ@Encountered?5empty?5binary?5value?$AA@ ; "Encountered	empty binary value"
		mov	eax, [ebp+arg_8]
		push	eax
		call	_warning
		add	esp, 8
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		push	0
		push	0
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+88h]
		push	ecx
		call	_bin_open
		add	esp, 1Ch
		mov	[ebp+var_134], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_134]
		jmp	short loc_635E
; ---------------------------------------------------------------------------

loc_634F:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *):loc_62F8j
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)

loc_635E:				; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+A6j
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+F7j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN27_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 184h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN27_0		dd 5			; DATA XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+39Eo
		dd offset $LN26_0
$LN26_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:00006394o
		dd offset $LN20_4	; "line"
		dd 0FFFFFFE0h, 4
		dd offset $LN21_3	; "string"
		dd 0FFFFFFC8h, 4
		dd offset $LN22_1	; "value"
		dd 0FFFFFFBCh, 3
		dd offset $LN23_1	; "toConv"
		dd 0FFFFFFA4h, 4
		dd offset $LN24_1	; "stopstring"
$LN24_1		db 'stopstring',0       ; DATA XREF: .text:000063D0o
$LN23_1		db 'toConv',0           ; DATA XREF: .text:000063C4o
$LN22_1		db 'value',0            ; DATA XREF: .text:000063B8o
$LN21_3		db 'string',0           ; DATA XREF: .text:000063ACo
$LN20_4		db 'line',0             ; DATA XREF: .text:000063A0o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 63F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006498o
		lea	ecx, [ebp-20h]
		jmp	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
__unwindfunclet$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000064A0o
		lea	ecx, [ebp-38h]
		jmp	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
__unwindfunclet$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-188h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6428h
		public ??_C@_0BP@FIDCNKGJ@Encountered?5empty?5binary?5value?$AA@
; `string'
??_C@_0BP@FIDCNKGJ@Encountered?5empty?5binary?5value?$AA@ db 'Encountered empty binary value',0
					; DATA XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *):loc_62FAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6448h
		public ??_C@_0DB@HKAPFEMA@Encountered?5invalid?5binary?5value@
; `string'
??_C@_0DB@HKAPFEMA@Encountered?5invalid?5binary?5value@	db 'Encountered invalid binary value (length is odd)',0
					; DATA XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+302o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 647Ch
		public ??_C@_0BI@CFLPKBPA@?5binary?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BI@CFLPKBPA@?5binary?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db	' binary %s at line %i ',0Ah,0
					; DATA XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+130o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6494h
__unwindtable$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000064ACo
		dd offset __unwindfunclet$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$1
__ehfuncinfo$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z dd	19930522h, 2
					; DATA XREF: __ehhandler$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?parseBinary@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 64C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseInteger(struct ParseState *, char *, unsigned	int, struct UString const *, enum  UErrorCode *)
?parseInteger@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+A0o

var_100		= dword	ptr -100h
var_38		= dword	ptr -38h
EndPtr		= dword	ptr -2Ch
Str		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z ; getInvariantString(ParseState *,uint *,UString *,UErrorCode *)
		add	esp, 10h
		mov	[ebp+Str], eax
		cmp	[ebp+Str], 0
		jz	short loc_651F
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6526

loc_651F:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+40j
		xor	eax, eax
		jmp	loc_6648
; ---------------------------------------------------------------------------

loc_6526:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+55j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6566
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_6648
; ---------------------------------------------------------------------------

loc_6566:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+89j
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_65AF
		cmp	[ebp+arg_4], 0
		jnz	short loc_6584
		mov	[ebp+var_100], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_658D
; ---------------------------------------------------------------------------

loc_6584:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+AEj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_100], eax

loc_658D:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+BAj
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_100]
		push	edx
		push	offset ??_C@_0BJ@IPNHCEPE@?5integer?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; " integer %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_65AF:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+A8j
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		test	eax, eax
		ja	short loc_65D0
		push	offset ??_C@_0CP@KOFJPFBN@Encountered?5empty?5integer?4?5Defau@	; "Encountered empty integer. Default valu"...
		mov	eax, [ebp+arg_8]
		push	eax
		call	_warning
		add	esp, 8

loc_65D0:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+F5j
		mov	esi, esp
		push	0		; Radix
		lea	eax, [ebp+EndPtr]
		push	eax		; EndPtr
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strtoul
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+EndPtr]
		sub	eax, [ebp+Str]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	[ebp+var_38], eax
		jnz	short loc_6630
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_int_open
		add	esp, 14h
		mov	[ebp+var_8], eax
		jmp	short loc_6639
; ---------------------------------------------------------------------------

loc_6630:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+13Fj
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah

loc_6639:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+166j
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]

loc_6648:				; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+59j
					; parseInteger(ParseState *,char *,uint,UString	const *,UErrorCode *)+99j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseInteger@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN14_1		dd 1			; DATA XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+184o
		dd offset $LN13_1
$LN13_1		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00006674o
		dd offset $LN12_1	; "stopstring"
$LN12_1		db 'stopstring',0       ; DATA XREF: .text:00006680o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6690h
		public ??_C@_0CP@KOFJPFBN@Encountered?5empty?5integer?4?5Defau@
; `string'
??_C@_0CP@KOFJPFBN@Encountered?5empty?5integer?4?5Defau@ db 'Encountered empty integer. Default value is 0.',0
					; DATA XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+F7o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 66C0h
		public ??_C@_0BJ@IPNHCEPE@?5integer?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BJ@IPNHCEPE@?5integer?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db ' integer %s at line %i ',0Ah,0
					; DATA XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+D2o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 66DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl parseImport(int, int, int, int, enum UErrorCode *)
?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+118o

var_1B8		= dword	ptr -1B8h
var_1B0		= dword	ptr -1B0h
var_1A4		= dword	ptr -1A4h
var_198		= byte ptr -198h
var_188		= byte ptr -188h
var_178		= dword	ptr -178h
var_16C		= dword	ptr -16Ch
var_160		= dword	ptr -160h
var_154		= dword	ptr -154h
var_88		= byte ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= dword	ptr -70h
var_64		= byte ptr -64h
var_24		= byte ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1ACh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_1B8]
		mov	ecx, 6Bh ; 'k'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z ; getInvariantString(ParseState *,uint *,UString *,UErrorCode *)
		add	esp, 10h
		push	eax
		lea	ecx, [ebp+var_24]
		call	??0?$LocalMemory@D@icu_56@@QAE@PAD@Z ; icu_56::LocalMemory<char>::LocalMemory<char>(char *)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_677B
		mov	[ebp+var_1B0], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_1B0]
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

loc_677B:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+79j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_67CC
		mov	[ebp+var_1A4], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_1A4]
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

loc_67CC:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+CAj
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_6815
		cmp	[ebp+arg_4], 0
		jnz	short loc_67EA
		mov	[ebp+var_1B8], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_67F3
; ---------------------------------------------------------------------------

loc_67EA:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+100j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_1B8], eax

loc_67F3:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+10Cj
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_1B8]
		push	edx
		push	offset ??_C@_0BI@HNDKNCDL@?5import?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; "	import %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6815:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+FAj
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_??0CharString@icu_56@@QAE@XZ	; icu_56::CharString::CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8Ch], 0
		jz	short loc_6873
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8Ch]
		push	ecx		; char *
		lea	ecx, [ebp+var_198] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	edx, [ebp+arg_10]
		push	edx		; enum UErrorCode *
		lea	eax, [ebp+var_198]
		push	eax		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6873:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+159j
		lea	ecx, [ebp+var_24]
		call	?getAlias@?$LocalPointerBase@D@icu_56@@QBEPADXZ	; icu_56::LocalPointerBase<char>::getAlias(void)
		mov	esi, esp
		push	eax		; char *
		lea	ecx, [ebp+var_188] ; this
		call	dword ptr ds:__imp_??0StringPiece@icu_56@@QAE@PBD@Z ; icu_56::StringPiece::StringPiece(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_188]
		push	ecx		; struct icu_56::StringPiece *
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_?appendPathPart@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z ; icu_56::CharString::appendPathPart(icu_56::StringPiece const &,UErrorCode &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_68FD
		mov	[ebp+var_178], 0
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_178]
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

loc_68FD:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+1E5j
		push	offset ??_C@_02JDPG@rb?$AA@ ; "rb"
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	_T_FileStream_open
		add	esp, 8
		mov	[ebp+var_70], eax
		cmp	[ebp+var_70], 0
		jnz	short loc_6983
		lea	ecx, [ebp+var_24]
		call	?getAlias@?$LocalPointerBase@D@icu_56@@QBEPADXZ	; icu_56::LocalPointerBase<char>::getAlias(void)
		push	eax
		push	offset ??_C@_0BM@FBPAECF@couldn?8t?5open?5input?5file?5?$CFs?$AA@ ; "couldn't open input file %s"
		mov	eax, [ebp+var_18]
		push	eax
		call	_error
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 4
		mov	[ebp+var_16C], 0
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_16C]
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

loc_6983:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+248j
		mov	eax, [ebp+var_70]
		push	eax
		call	_T_FileStream_size
		add	esp, 4
		mov	[ebp+var_7C], eax
		push	0
		lea	ecx, [ebp+var_88]
		call	??0?$LocalMemory@E@icu_56@@QAE@PAE@Z ; icu_56::LocalMemory<uchar>::LocalMemory<uchar>(uchar *)
		mov	byte ptr [ebp+var_4], 2
		push	0		; Size
		mov	eax, [ebp+var_7C]
		push	eax		; int
		lea	ecx, [ebp+var_88]
		call	?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z ; icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)
		test	eax, eax
		jnz	short loc_6A16
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_70]
		push	eax
		call	_T_FileStream_close
		add	esp, 4
		mov	[ebp+var_160], 0
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_88]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_160]
		jmp	loc_6ABF
; ---------------------------------------------------------------------------

loc_6A16:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+2DAj
		mov	eax, [ebp+var_7C]
		push	eax
		lea	ecx, [ebp+var_88]
		call	?getAlias@?$LocalPointerBase@E@icu_56@@QBEPAEXZ	; icu_56::LocalPointerBase<uchar>::getAlias(void)
		push	eax
		mov	ecx, [ebp+var_70]
		push	ecx
		call	_T_FileStream_read
		add	esp, 0Ch
		mov	eax, [ebp+var_70]
		push	eax
		call	_T_FileStream_close
		add	esp, 4
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_?data@CharString@icu_56@@QAEPADXZ ; icu_56::CharString::data(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		lea	ecx, [ebp+var_88]
		call	?getAlias@?$LocalPointerBase@E@icu_56@@QBEPAEXZ	; icu_56::LocalPointerBase<uchar>::getAlias(void)
		push	eax
		mov	edx, [ebp+var_7C]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+88h]
		push	edx
		call	_bin_open
		add	esp, 1Ch
		mov	[ebp+var_154], eax
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_88]
		call	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
		mov	byte ptr [ebp+var_4], 0
		mov	esi, esp
		lea	ecx, [ebp+var_64] ; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		mov	eax, [ebp+var_154]

loc_6ABF:				; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+9Aj
					; parseImport(ParseState *,char	*,uint,UString const *,UErrorCode *)+EBj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1B8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN21_4		dd 4			; DATA XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+3E7o
		dd offset $LN20_5
$LN20_5		dd 0FFFFFFE8h, 4	; DATA XREF: .text:00006B00o
		dd offset $LN15_1	; "line"
		dd 0FFFFFFDCh, 4
		dd offset $LN16_2	; "filename"
		dd 0FFFFFF9Ch, 38h
		dd offset $LN17_3	; "fullname"
		dd 0FFFFFF78h, 4
		dd offset $LN18_2	; "data"
$LN18_2		db 'data',0             ; DATA XREF: .text:00006B30o
$LN17_3		db 'fullname',0         ; DATA XREF: .text:00006B24o
$LN16_2		db 'filename',0         ; DATA XREF: .text:00006B18o
$LN15_1		db 'line',0             ; DATA XREF: .text:00006B0Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6B50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00006BDCo
		lea	ecx, [ebp-24h]
		jmp	??1?$LocalMemory@D@icu_56@@QAE@XZ ; icu_56::LocalMemory<char>::~LocalMemory<char>(void)
__unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00006BE4o
		mov	esi, esp
		lea	ecx, [ebp-64h]	; this
		call	dword ptr ds:__imp_??1CharString@icu_56@@QAE@XZ	; icu_56::CharString::~CharString(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$2 proc near
					; DATA XREF: .xdata$x:00006BECo
		lea	ecx, [ebp-88h]
		jmp	??1?$LocalMemory@E@icu_56@@QAE@XZ ; icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)
__unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1BCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6BA0h
		public ??_C@_0BM@FBPAECF@couldn?8t?5open?5input?5file?5?$CFs?$AA@
; `string'
??_C@_0BM@FBPAECF@couldn?8t?5open?5input?5file?5?$CFs?$AA@ db 'couldn',27h,'t open input file %s',0
					; DATA XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+253o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6BBCh
		public ??_C@_02JDPG@rb?$AA@
; `string'
??_C@_02JDPG@rb?$AA@ db	'rb',0          ; DATA XREF: parseImport(ParseState *,char *,uint,UString const *,UErrorCode *):loc_68FDo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6BC0h
		public ??_C@_0BI@HNDKNCDL@?5import?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BI@HNDKNCDL@?5import?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db	' import %s at line %i ',0Ah,0
					; DATA XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+124o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6BD8h
__unwindtable$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006BF8o
		dd offset __unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$1
		dd 1
		dd offset __unwindfunclet$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z$2
__ehfuncinfo$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z dd	19930522h, 3
					; DATA XREF: __ehhandler$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z+1Eo
		dd offset __unwindtable$?parseImport@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6C14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct SResource * __cdecl parseInclude(struct ParseState *, char *, unsigned	int, struct UString const *, enum  UErrorCode *)
?parseInclude@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z proc near
					; DATA XREF: `dynamic initializer for 'gResourceTypes''(void)+136o

var_13C		= dword	ptr -13Ch
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
Dest		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
Str		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		mov	[ebp+var_38], 0
		mov	[ebp+Dest], 0
		mov	[ebp+var_5C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_74], 0
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?getInvariantString@@YAPADPAUParseState@@PAIPAUUString@@PAW4UErrorCode@@@Z ; getInvariantString(ParseState *,uint *,UString *,UErrorCode *)
		add	esp, 10h
		mov	[ebp+Str], eax
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6CA0
		xor	eax, eax
		jmp	loc_6ED7
; ---------------------------------------------------------------------------

loc_6CA0:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+83j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		push	0
		push	0
		push	2
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?expect@@YAXPAUParseState@@W4ETokenType@@PAPAUUString@@PAU3@PAIPAW4UErrorCode@@@Z ; expect(ParseState *,ETokenType,UString * *,UString *,uint *,UErrorCode *)
		add	esp, 18h
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6CE0
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_6ED7
; ---------------------------------------------------------------------------

loc_6CE0:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+B7j
		call	_isVerbose
		movsx	eax, al
		test	eax, eax
		jz	short loc_6D29
		cmp	[ebp+arg_4], 0
		jnz	short loc_6CFE
		mov	[ebp+var_13C], offset ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; "(null)"
		jmp	short loc_6D07
; ---------------------------------------------------------------------------

loc_6CFE:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+DCj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_13C], eax

loc_6D07:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+E8j
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_13C]
		push	edx
		push	offset ??_C@_0BJ@MLLGNBJA@?5include?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ ; " include %s at line %i \n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6D29:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+D6j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		mov	edx, [ebp+var_5C]
		lea	eax, [ecx+edx+2]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dest], eax
		cmp	[ebp+Dest], 0
		jnz	short loc_6D67
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_6ED7
; ---------------------------------------------------------------------------

loc_6D67:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+135j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8Ch], 0
		jz	loc_6E04
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8Ch]
		movsx	ecx, byte ptr [eax+ecx-1]
		cmp	ecx, 5Ch ; '\'
		jz	short loc_6DDC
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8Ch]
		push	ecx		; Source
		mov	edx, [ebp+Dest]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		mov	edx, [ebp+Dest]
		mov	byte ptr [edx+ecx], 5Ch	; '\'
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+90h]
		mov	edx, [ebp+Dest]
		mov	byte ptr [edx+ecx+1], 0
		mov	eax, [ebp+Str]
		push	eax		; Source
		mov	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8
		jmp	short loc_6E02
; ---------------------------------------------------------------------------

loc_6DDC:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+17Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8Ch]
		push	ecx		; Source
		mov	edx, [ebp+Dest]
		push	edx		; Dest
		call	_strcpy
		add	esp, 8
		mov	eax, [ebp+Str]
		push	eax		; Source
		mov	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcat
		add	esp, 8

loc_6E02:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+1C6j
		jmp	short loc_6E14
; ---------------------------------------------------------------------------

loc_6E04:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+15Dj
		mov	eax, [ebp+Str]
		push	eax		; Source
		mov	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	_strcpy
		add	esp, 8

loc_6E14:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *):loc_6E02j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		call	_getShowWarning
		movzx	ecx, al
		push	ecx
		lea	edx, [ebp+var_68]
		push	edx
		mov	eax, [ebp+Dest]
		push	eax
		call	_ucbuf_open
		add	esp, 14h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6E64
		mov	eax, [ebp+Str]
		push	eax
		push	offset ??_C@_0BN@LBOOCDMJ@couldn?8t?5open?5input?5file?5?$CFs?6?$AA@ ; "couldn't open input file %s\n"
		mov	ecx, [ebp+var_2C]
		push	ecx
		call	_error
		add	esp, 0Ch
		xor	eax, eax
		jmp	short loc_6ED7
; ---------------------------------------------------------------------------

loc_6E64:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+235j
		mov	eax, [ebp+arg_10]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		call	_ucbuf_getBuffer
		add	esp, 0Ch
		mov	[ebp+var_74], eax
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+var_74]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+88h]
		push	eax
		call	_string_open
		add	esp, 18h
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_44]
		push	eax
		call	_ucbuf_close
		add	esp, 4
		mov	eax, [ebp+var_38]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+Str]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+Dest]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]

loc_6ED7:				; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+87j
					; parseInclude(ParseState *,char *,uint,UString	const *,UErrorCode *)+C7j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseInclude@@YAPAUSResource@@PAUParseState@@PADIPBUUString@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN18_3		dd 3			; DATA XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+2C7o
		dd offset $LN17_4
$LN17_4		dd 0FFFFFFECh, 4	; DATA XREF: .text:00006F00o
		dd offset $LN14_2	; "len"
		dd 0FFFFFFD4h, 4
		dd offset $LN15_2	; "line"
		dd 0FFFFFF98h, 4
		dd offset $LN16_3
$LN16_3		db 63h,	70h, 0		; DATA XREF: .text:00006F24o
$LN15_2		db 'line',0             ; DATA XREF: .text:00006F18o
$LN14_2		db 'len',0              ; DATA XREF: .text:00006F0Co
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6F34h
		public ??_C@_0BN@LBOOCDMJ@couldn?8t?5open?5input?5file?5?$CFs?6?$AA@
; `string'
??_C@_0BN@LBOOCDMJ@couldn?8t?5open?5input?5file?5?$CFs?6?$AA@ db 'couldn',27h,'t open input file %s',0Ah,0
					; DATA XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+23Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6F54h
		public ??_C@_0BJ@MLLGNBJA@?5include?5?$CFs?5at?5line?5?$CFi?5?6?$AA@
; char `string'[]
??_C@_0BJ@MLLGNBJA@?5include?5?$CFs?5at?5line?5?$CFi?5?6?$AA@ db ' include %s at line %i ',0Ah,0
					; DATA XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+100o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointer<struct icu_56::CollationTailoring>::LocalPointer<struct icu_56::CollationTailoring>(struct icu_56::CollationTailoring	*)
		public ??0?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z
??0?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+6FFp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::LocalPointerBase<icu_56::CollationTailoring>(icu_56::CollationTailoring *)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointer<struct icu_56::CollationTailoring>::~LocalPointer<struct icu_56::CollationTailoring>(void)
		public ??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ
??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+83Dp
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+93Cp ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_7046
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_7050
; ---------------------------------------------------------------------------

loc_7046:				; CODE XREF: icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)+67j
		mov	[ebp+var_F4], 0

loc_7050:				; CODE XREF: icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)+8Cj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		call	??1?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::~LocalPointerBase<icu_56::CollationTailoring>(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7080h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ$0	proc near
					; DATA XREF: .xdata$x:000070ACo
		mov	ecx, [ebp-14h]
		jmp	??1?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<icu_56::CollationTailoring>::~LocalPointerBase<icu_56::CollationTailoring>(void)
__unwindfunclet$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 70A8h
__unwindtable$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000070B8o
		dd offset __unwindfunclet$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ$0
__ehfuncinfo$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 70D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::LocalPointerBase<struct icu_56::CollationTailoring>::isNull(void)const
		public ?isNull@?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBECXZ
?isNull@?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBECXZ proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+806p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNull@?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7108h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct icu_56::CollationTailoring & __thiscall icu_56::LocalPointerBase<struct icu_56::CollationTailoring>::operator*(void)const
		public ??D?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEAAUCollationTailoring@1@XZ
??D?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEAAUCollationTailoring@1@XZ proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+9C3p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+B19p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??D?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEAAUCollationTailoring@1@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7138h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct icu_56::CollationTailoring * __thiscall icu_56::LocalPointerBase<struct icu_56::CollationTailoring>::operator->(void)const
		public ??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ
??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+9B4p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+B0Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??C?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QBEPAUCollationTailoring@1@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7168h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalMemory<unsigned char>::LocalMemory<unsigned char>(unsigned char *)
		public ??0?$LocalMemory@E@icu_56@@QAE@PAE@Z
??0?$LocalMemory@E@icu_56@@QAE@PAE@Z proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+899p
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+17Cp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0?$LocalPointerBase@E@icu_56@@QAE@PAE@Z ; icu_56::LocalPointerBase<uchar>::LocalPointerBase<uchar>(uchar *)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalMemory@E@icu_56@@QAE@PAE@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalMemory<unsigned char>::~LocalMemory<unsigned char>(void)
		public ??1?$LocalMemory@E@icu_56@@QAE@XZ
??1?$LocalMemory@E@icu_56@@QAE@XZ proc near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+92Dp
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+A83p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		call	??1?$LocalPointerBase@E@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<uchar>::~LocalPointerBase<uchar>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalMemory@E@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7200h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned char	& __thiscall icu_56::LocalMemory<unsigned char>::operator[](int)const
		public ??A?$LocalMemory@E@icu_56@@QBEAAEH@Z
??A?$LocalMemory@E@icu_56@@QBEAAEH@Z proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+246p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$LocalMemory@E@icu_56@@QBEAAEH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7234h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned char	* __thiscall icu_56::LocalPointerBase<unsigned char>::getAlias(void)const
		public ?getAlias@?$LocalPointerBase@E@icu_56@@QBEPAEXZ
?getAlias@?$LocalPointerBase@E@icu_56@@QBEPAEXZ	proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+2A9p
					; parseImport(ParseState *,char	*,uint,UString const *,UErrorCode *)+344p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$LocalPointerBase@E@icu_56@@QBEPAEXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7264h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalMemory<char>::LocalMemory<char>(char *)
		public ??0?$LocalMemory@D@icu_56@@QAE@PAD@Z
??0?$LocalMemory@D@icu_56@@QAE@PAD@Z proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+57p
					; parseImport(ParseState *,char	*,uint,UString const *,UErrorCode *)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??0?$LocalPointerBase@D@icu_56@@QAE@PAD@Z ; icu_56::LocalPointerBase<char>::LocalPointerBase<char>(char	*)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalMemory@D@icu_56@@QAE@PAD@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalMemory<char>::~LocalMemory<char>(void)
		public ??1?$LocalMemory@D@icu_56@@QAE@XZ
??1?$LocalMemory@D@icu_56@@QAE@XZ proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+9Bp
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+ECp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		call	??1?$LocalPointerBase@D@icu_56@@QAE@XZ ; icu_56::LocalPointerBase<char>::~LocalPointerBase<char>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalMemory@D@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::LocalMemory<char>::operator[](int)const
		public ??A?$LocalMemory@D@icu_56@@QBEAADH@Z
??A?$LocalMemory@D@icu_56@@QBEAADH@Z proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+201p
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+215p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$LocalMemory@D@icu_56@@QBEAADH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7330h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::LocalPointerBase<char>::isNull(void)const
		public ?isNull@?$LocalPointerBase@D@icu_56@@QBECXZ
?isNull@?$LocalPointerBase@D@icu_56@@QBECXZ proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+66p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isNull@?$LocalPointerBase@D@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7364h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::LocalPointerBase<char>::getAlias(void)const
		public ?getAlias@?$LocalPointerBase@D@icu_56@@QBEPADXZ
?getAlias@?$LocalPointerBase@D@icu_56@@QBEPADXZ	proc near
					; CODE XREF: parseBinary(ParseState *,char *,uint,UString const	*,UErrorCode *)+148p
					; parseImport(ParseState *,char	*,uint,UString const *,UErrorCode *)+19Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$LocalPointerBase@D@icu_56@@QBEPADXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7394h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<struct icu_56::CollationTailoring>::LocalPointerBase<struct icu_56::CollationTailoring>(struct icu_56::CollationTailoring	*)
		public ??0?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z
??0?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z proc near
					; CODE XREF: icu_56::LocalPointer<icu_56::CollationTailoring>::LocalPointer<icu_56::CollationTailoring>(icu_56::CollationTailoring *)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@PAUCollationTailoring@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<struct icu_56::CollationTailoring>::~LocalPointerBase<struct icu_56::CollationTailoring>(void)
		public ??1?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ
??1?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::LocalPointer<icu_56::CollationTailoring>::~LocalPointer<icu_56::CollationTailoring>(void)+A2p
					; __unwindfunclet$??1?$LocalPointer@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ$0+3j

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointerBase@UCollationTailoring@icu_56@@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<unsigned char>::LocalPointerBase<unsigned	char>(unsigned char *)
		public ??0?$LocalPointerBase@E@icu_56@@QAE@PAE@Z
??0?$LocalPointerBase@E@icu_56@@QAE@PAE@Z proc near
					; CODE XREF: icu_56::LocalMemory<uchar>::LocalMemory<uchar>(uchar *)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointerBase@E@icu_56@@QAE@PAE@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<unsigned char>::~LocalPointerBase<unsigned char>(void)
		public ??1?$LocalPointerBase@E@icu_56@@QAE@XZ
??1?$LocalPointerBase@E@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::LocalMemory<uchar>::~LocalMemory<uchar>(void)+34p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointerBase@E@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 745Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<char>::LocalPointerBase<char>(char *)
		public ??0?$LocalPointerBase@D@icu_56@@QAE@PAD@Z
??0?$LocalPointerBase@D@icu_56@@QAE@PAD@Z proc near
					; CODE XREF: icu_56::LocalMemory<char>::LocalMemory<char>(char *)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$LocalPointerBase@D@icu_56@@QAE@PAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7494h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::LocalPointerBase<char>::~LocalPointerBase<char>(void)
		public ??1?$LocalPointerBase@D@icu_56@@QAE@XZ
??1?$LocalPointerBase@D@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::LocalMemory<char>::~LocalMemory<char>(void)+34p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1?$LocalPointerBase@D@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 74C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::LocalMemory<unsigned char>::allocateInsteadAndCopy(int,	size_t Size)
		public ?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z
?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z proc	near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+8BBp
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+A11p ...

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jle	short loc_7555
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_754E
		cmp	[ebp+Size], 0
		jle	short loc_7538
		mov	eax, [ebp+Size]
		cmp	eax, [ebp+arg_0]
		jle	short loc_7512
		mov	eax, [ebp+arg_0]
		mov	[ebp+Size], eax

loc_7512:				; CODE XREF: icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+4Aj
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_7538:				; CODE XREF: icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+42j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx

loc_754E:				; CODE XREF: icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+3Cj
		mov	eax, [ebp+Dst]
		jmp	short loc_7557
; ---------------------------------------------------------------------------
		jmp	short loc_7557
; ---------------------------------------------------------------------------

loc_7555:				; CODE XREF: icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+27j
		xor	eax, eax

loc_7557:				; CODE XREF: icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+91j
					; icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+93j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?allocateInsteadAndCopy@?$LocalMemory@E@icu_56@@QAEPAEHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 7570h
_gResourceTypes$initializer$ dd	offset ??__EgResourceTypes@@YAXXZ ; `dynamic initializer for 'gResourceTypes''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _uprv_isInvariantUString_56:near
					; CODE XREF: _uprv_isInvariantUnicodeString+44p
					; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)+134p ...
; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		extrn __imp_?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ:near
					; CODE XREF: _uprv_isInvariantUnicodeString+36p
					; DATA XREF: _uprv_isInvariantUnicodeString+36r
; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		extrn __imp_?length@UnicodeString@icu_56@@QBEHXZ:near
					; CODE XREF: _uprv_isInvariantUnicodeString+23p
					; StringBaseResource::length(void)+2Bp
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _uprv_isInvariantUnicodeString+2Bp
					; _uprv_isInvariantUnicodeString+3Ep ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; _DWORD __thiscall icu_56::CollationRuleParser::Importer::~Importer(icu_56::CollationRuleParser::Importer *__hidden this)
		extrn __imp_??1Importer@CollationRuleParser@icu_56@@UAE@XZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::~GenrbImporter(void)+31p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::~GenrbImporter(void)+31r
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:`anonymous namespace'::GenrbImporter `RTTI Type Descriptor'o
					; .data:icu_56::CollationRuleParser::Importer `RTTI Type Descriptor'o ...
; public: virtual void * __thiscall `anonymous namespace'::GenrbImporter::`scalar deleting destructor'(unsigned int)
		extrn ??_GGenrbImporter@?A0x82188031@@UAEPAXI@Z_0:near
; public: virtual void * __thiscall `anonymous namespace'::GenrbImporter::`vector deleting destructor'(unsigned int)
		extrn ??_EGenrbImporter@?A0x82188031@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const `anonymous namespace'::GenrbImporter::`vftable'o
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000488o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn __imp_??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::`scalar deleting destructor'(uint)+39p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::`scalar deleting destructor'(uint)+39r
; __declspec(dllimport)	public:	class icu_56::UnicodeString & __thiscall icu_56::UnicodeString::operator=(class	icu_56::UnicodeString const &)
		extrn __imp_??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+6B3p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+355p
					; DATA XREF: ...
		extrn _u_errorName_56:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+4B1p
					; _parse+24Ap ...
; int _fprintf(FILE *File, const char *Format, ...)
		extrn __imp__fprintf:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+411p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+4EAp ...
; FILE *__cdecl	___iob_func()
		extrn __imp____iob_func:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+400p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+4D9p ...
		extrn _ucbuf_open:near	; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+3BDp
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+22Ep ...
		extrn _getShowWarning:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+397p
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+217p ...
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const struct icu_56::CharString *, enum UErrorCode *)
		extrn __imp_?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+315p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+315r
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, char, enum UErrorCode *)
		extrn __imp_?append@CharString@icu_56@@QAEAAV12@DAAW4UErrorCode@@@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+2F8p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+2F8r
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const char *, int, enum UErrorCode *)
		extrn __imp_?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+2C7p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+2C7r
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+26Dp
					; _parse+A7p ...
; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *__hidden this, int)
		extrn __imp_?remove_suffix@StringPiece@icu_56@@QAEXH@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+219p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+219r
; struct icu_56::StringPiece __thiscall	__high icu_56::CharString::toStringPiece()
		extrn __imp_?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+1C9p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+1C9r
; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this)
		extrn __imp_??0CharString@icu_56@@QAE@XZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+156p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+16Fp ...
; _DWORD __thiscall icu_56::CharString::~CharString(icu_56::CharString *__hidden this)
		extrn __imp_??1CharString@icu_56@@QAE@XZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+13Cp
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+343p ...
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const struct icu_56::StringPiece *, enum UErrorCode *)
		extrn __imp_?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+10Ep
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+239p ...
; char *__thiscall icu_56::CharString::data(icu_56::CharString *__hidden this)
		extrn __imp_?data@CharString@icu_56@@QAEPADXZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+CEp
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+194p ...
; __declspec(dllimport)	public:	char __thiscall	icu_56::CharString::operator[](int)const
		extrn __imp_??ACharString@icu_56@@QBEDH@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+B4p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+282p
					; DATA XREF: ...
; int __thiscall icu_56::CharString::length(icu_56::CharString *__hidden this)
		extrn __imp_?length@CharString@icu_56@@QBEHXZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+99p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+1EFp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this, const struct icu_56::StringPiece *, enum UErrorCode *)
		extrn __imp_??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+6Ep
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+6Er
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const char *)
		extrn __imp_??0StringPiece@icu_56@@QAE@PBD@Z:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+51p
					; `anonymous namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+F1p ...
		extrn ___security_cookie:near
					; DATA XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+2Er
					; _parse+1Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z+23j
					; __ehhandler$?addCollation@@YAPAVTableResource@@PAUParseState@@PAV1@PBDIPAW4UErrorCode@@@Z+23j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+73Ep
					; __ehhandler$?getRules@GenrbImporter@?A0x82188031@@UAEXPBD0AAVUnicodeString@icu_56@@AAPBDAAW4UErrorCode@@@Z+Fp ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::getRules(char const *,char const *,icu_56::UnicodeString &,char const * &,UErrorCode &)+724p
					; _parse+4A4p ...
; char *__cdecl	_strrchr(const char *Str, int Ch)
		extrn __imp__strrchr:near ; CODE XREF: strrchr(char *,int)+28p
					; DATA XREF: strrchr(char *,int)+28r
		extrn _ucbuf_close:near	; CODE XREF: icu_56::LocalUCHARBUFPointer::~LocalUCHARBUFPointer(void)+29p
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+57Ep ...
; int __cdecl strcmp(const char	*Str1, const char *Str2)
		extrn _strcmp:near	; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+64p
					; parseTable(ParseState	*,char *,uint,UString const *,UErrorCode *)+2Dp ...
		extrn _res_none:near	; CODE XREF: ?resLookup@?A0x82188031@@YAPAUSResource@@PAU2@PBD@Z+1Ep
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+207p
		extrn _ustr_deinit:near	; CODE XREF: _parse+48Fp
					; cleanupLookahead(ParseState *)+44p ...
		extrn _isStrict:near	; CODE XREF: _parse+463p
					; parseDependency(ParseState *,char *,uint,UString const *,UErrorCode *)+1A7p ...
		extrn _warning:near	; CODE XREF: _parse+45Bp
					; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)+CEp ...
		extrn _res_close:near	; CODE XREF: _parse+426p
					; parseString(ParseState *,char	*,uint,UString const *,UErrorCode *)+11Bp ...
; void __thiscall TableResource::add(TableResource *__hidden this, struct SResource *, int, enum UErrorCode *)
		extrn ?add@TableResource@@QAEXPAUSResource@@HAAW4UErrorCode@@@Z:near
					; CODE XREF: _parse+3BFp
					; realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode *)+241p ...
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	_parse+335p
					; _parse+368p
					; DATA XREF: ...
		extrn _error:near	; CODE XREF: _parse+25Cp _parse+2A6p ...
; void __thiscall SRBRoot::setLocale(SRBRoot *__hidden this, wchar_t *,	enum UErrorCode	*)
		extrn ?setLocale@SRBRoot@@QAEXPA_WAAW4UErrorCode@@@Z:near
					; CODE XREF: _parse+1C1p
; public: __thiscall SRBRoot::SRBRoot(struct UString const *, signed char, enum	 UErrorCode &)
		extrn ??0SRBRoot@@QAE@PBUUString@@CAAW4UErrorCode@@@Z:near
					; CODE XREF: _parse+166p
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: _parse+13Fp
		extrn _ustr_init:near	; CODE XREF: _parse+5Dp _parse+76p ...
		extrn _getNextToken:near
					; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+9Fp
					; getToken(ParseState *,UString	* *,UString *,uint *,UErrorCode	*)+13Fp
		extrn _resetLineNumber:near
					; CODE XREF: initLookahead(ParseState *,UCHARBUF *,UErrorCode *)+4Ap
		extrn _ustr_setlen:near	; CODE XREF: getToken(ParseState *,UString * *,UString *,uint *,UErrorCode *)+E3p
					; getToken(ParseState *,UString	* *,UString *,uint *,UErrorCode	*)+FFp	...
		extrn _ustr_cpy:near	; CODE XREF: getToken(ParseState *,UString * *,UString *,uint *,UErrorCode *)+91p
					; peekToken(ParseState *,uint,UString *	*,uint *,UString *,UErrorCode *)+BAp
		extrn _u_UCharsToChars_56:near
					; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+162p
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+1A7p ...
		extrn _u_strlen_56:near	; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+149p
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+18Bp ...
; int _printf(const char *Format, ...)
		extrn __imp__printf:near
					; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+76p
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+82p ...
		extrn _isVerbose:near	; CODE XREF: realParseTable(ParseState *,TableResource *,char *,uint,UErrorCode	*)+3Dp
					; parseResource(ParseState *,char *,UString const *,UErrorCode *)+49p ...
		extrn _u_austrncpy_56:near
					; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+118p
		extrn _u_strcmp_56:near	; CODE XREF: parseResourceType(ParseState *,UErrorCode *)+AEp
					; parseResourceType(ParseState *,UErrorCode *)+CAp ...
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: SRBRoot::`scalar deleting destructor'(uint)+37p
; _DWORD __thiscall SRBRoot::~SRBRoot(SRBRoot *__hidden	this)
		extrn ??1SRBRoot@@QAE@XZ:near
					; CODE XREF: SRBRoot::`scalar deleting destructor'(uint)+26p
		extrn _string_open:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+56Cp
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+2DCp ...
		extrn _T_FileStream_close:near
					; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+465p
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+599p ...
		extrn _uprv_free_56:near
					; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+459p
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+58Dp ...
		extrn _unescape:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+43Bp
		extrn _ucbuf_getc:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+2FAp
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+3C4p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+2B4p
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+28Bp ...
		extrn _uprv_malloc_56:near
					; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+294p
					; parseTransliterator(ParseState *,char	*,uint,UString const *,UErrorCode *)+26Bp ...
		extrn _ucbuf_size:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+27Ap
; char *__cdecl	strcat(char *Dest, const char *Source)
		extrn _strcat:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+15Bp
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+18Bp ...
; void *__cdecl	memset_0(void *Dst, int	Val, size_t Size)
		extrn _memset_0:near	; CODE XREF: parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+4Bp
					; parseUCARules(ParseState *,char *,uint,UString const *,UErrorCode *)+65p ...
		extrn _utrans_stripRules_56:near
					; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+2ACp
		extrn _ucbuf_getBuffer:near
					; CODE XREF: parseTransliterator(ParseState *,char *,uint,UString const	*,UErrorCode *)+252p
					; parseInclude(ParseState *,char *,uint,UString	const *,UErrorCode *)+25Cp
; void __thiscall ArrayResource::add(ArrayResource *__hidden this, struct SResource *)
		extrn ?add@ArrayResource@@QAEXPAUSResource@@@Z:near
					; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+27Ap
					; parseArray(ParseState	*,char *,uint,UString const *,UErrorCode *)+1FBp
		extrn _array_open:near	; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+203p
					; parseArray(ParseState	*,char *,uint,UString const *,UErrorCode *)+3Fp
		extrn _T_FileStream_file_exists:near
					; CODE XREF: parseDependency(ParseState	*,char *,uint,UString const *,UErrorCode *)+198p
		extrn _alias_open:near	; CODE XREF: parseAlias(ParseState *,char *,uint,UString const *,UErrorCode *)+C0p
		extrn _table_open:near	; CODE XREF: parseTable(ParseState *,char *,uint,UString const *,UErrorCode *)+F1p
					; parseCollationElements(ParseState *,char *,uint,signed char,UErrorCode *)+4Ap ...
		extrn _bin_open:near	; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+D14p
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+2C3p ...
; void __cdecl static icu_56::CollationInfo::printReorderRanges(const struct icu_56::CollationData *, const int	*, int)
		extrn __imp_?printReorderRanges@CollationInfo@icu_56@@SAXABUCollationData@2@PBHH@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+CDFp
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+CDFr
; signed __int8	__thiscall icu_56::CollationSettings::hasReordering(icu_56::CollationSettings *__hidden	this)
		extrn __imp_?hasReordering@CollationSettings@icu_56@@QBECXZ:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C71p
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C71r
; void __cdecl static icu_56::CollationInfo::printSizes(int, const int *const )
		extrn __imp_?printSizes@CollationInfo@icu_56@@SAXHQBH@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C51p
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+C51r
; int __cdecl static icu_56::CollationDataWriter::writeTailoring(const struct icu_56::CollationTailoring *, const struct icu_56::CollationSettings *, int *const , unsigned __int8 *, int, enum	UErrorCode *)
		extrn __imp_?writeTailoring@CollationDataWriter@icu_56@@SAHABUCollationTailoring@2@ABUCollationSettings@2@QAHPAEHAAW4UErrorCode@@@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+9C9p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+B1Fp
					; DATA XREF: ...
; _DWORD __thiscall icu_56::CollationBuilder::~CollationBuilder(icu_56::CollationBuilder *__hidden this)
		extrn __imp_??1CollationBuilder@icu_56@@UAE@XZ:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+84Ep
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+94Dp ...
; const	char *__thiscall icu_56::CollationBuilder::getErrorReason(icu_56::CollationBuilder *__hidden this)
		extrn __imp_?getErrorReason@CollationBuilder@icu_56@@QBEPBDXZ:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+72Ap
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+72Ar
; struct icu_56::CollationTailoring *__thiscall	icu_56::CollationBuilder::parseAndBuild(icu_56::CollationBuilder *__hidden this, const struct icu_56::UnicodeString *, const unsigned __int8 *const , struct icu_56::CollationRuleParser::Importer *, struct UParseError *, enum UErrorCode *)
		extrn __imp_?parseAndBuild@CollationBuilder@icu_56@@QAEPAUCollationTailoring@2@ABVUnicodeString@2@QBEPAVImporter@CollationRuleParser@2@PAUUParseError@@AAW4UErrorCode@@@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+6EBp
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+6EBr
; void __thiscall icu_56::CollationBuilder::disableFastLatin(icu_56::CollationBuilder *__hidden	this)
		extrn __imp_?disableFastLatin@CollationBuilder@icu_56@@QAEXXZ:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+6B3p
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+6B3r
; _DWORD __thiscall icu_56::CollationBuilder::CollationBuilder(icu_56::CollationBuilder	*__hidden this,	const struct icu_56::CollationTailoring	*, enum	UErrorCode *)
		extrn __imp_??0CollationBuilder@icu_56@@QAE@PBUCollationTailoring@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+65Cp
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+65Cr
; const	struct icu_56::CollationTailoring *__cdecl static icu_56::CollationRoot::getRoot(enum UErrorCode *)
		extrn __imp_?getRoot@CollationRoot@icu_56@@SAPBUCollationTailoring@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+5AAp
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+5AAr
; int __cdecl _strncmp(const char *Str1, const char *Str2, size_t MaxCount)
		extrn __imp__strncmp:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+47Dp
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+697p
					; DATA XREF: ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+459p
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+468p ...
		extrn _u_versionFromString_56:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+2CBp
; int __thiscall __high	icu_56::UnicodeString::extract(int, int, char *, int, enum icu_56::UnicodeString::EInvariant)
		extrn __imp_?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+2B0p
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+2B0r
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn __imp_??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+12Bp
					; addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+1A4p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		extrn __imp_??0UnicodeString@icu_56@@QAE@XZ:near
					; CODE XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+4Fp
					; DATA XREF: addCollation(ParseState *,TableResource *,char const *,uint,UErrorCode *)+4Fr
; _DWORD __thiscall icu_56::CollationRuleParser::Importer::Importer(icu_56::CollationRuleParser::Importer *__hidden this)
		extrn __imp_??0Importer@CollationRuleParser@icu_56@@QAE@XZ:near
					; CODE XREF: `anonymous	namespace'::GenrbImporter::GenrbImporter(char const *,char const *)+28p
					; DATA XREF: `anonymous	namespace'::GenrbImporter::GenrbImporter(char const *,char const *)+28r
; int _sprintf(char *Dest, const char *Format, ...)
		extrn __imp__sprintf:near
					; CODE XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+DAp
					; DATA XREF: `anonymous	namespace'::escape(wchar_t const *,char *)+DAr
; void __thiscall IntVectorResource::add(IntVectorResource *__hidden this, int,	enum UErrorCode	*)
		extrn ?add@IntVectorResource@@QAEXHAAW4UErrorCode@@@Z:near
					; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+1B5p
; unsigned __int32 __cdecl _strtoul(const char *Str, char **EndPtr, int	Radix)
		extrn __imp__strtoul:near
					; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+17Dp
					; parseBinary(ParseState *,char	*,uint,UString const *,UErrorCode *)+22Bp ...
		extrn _intvector_open:near
					; CODE XREF: parseIntVector(ParseState *,char *,uint,UString const *,UErrorCode	*)+38p
		extrn _int_open:near	; CODE XREF: parseInteger(ParseState *,char *,uint,UString const *,UErrorCode *)+15Bp
		extrn _T_FileStream_read:near
					; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+34Ep
		extrn _T_FileStream_size:near
					; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+2ABp
		extrn _T_FileStream_open:near
					; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+239p
; struct icu_56::CharString *__thiscall	icu_56::CharString::appendPathPart(icu_56::CharString *__hidden	this, const struct icu_56::StringPiece *, enum UErrorCode *)
		extrn __imp_?appendPathPart@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z:near
					; CODE XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+1C5p
					; DATA XREF: parseImport(ParseState *,char *,uint,UString const	*,UErrorCode *)+1C5r
; char *__cdecl	strcpy(char *Dest, const char *Source)
		extrn _strcpy:near	; CODE XREF: parseInclude(ParseState *,char *,uint,UString const *,UErrorCode *)+18Dp
					; parseInclude(ParseState *,char *,uint,UString	const *,UErrorCode *)+1D6p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::LocalMemory<uchar>::allocateInsteadAndCopy(int,int)+70p


		end
