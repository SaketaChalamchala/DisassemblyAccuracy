;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	1086ED1995AFD8AB8051F519FB5587A8
; Input	CRC32 :	D070341E

; File Name   :	D:\compspace\objfiles\firefox\servicehelper\Services.obj
; Format      :	COFF (X386MAGIC)
; includelib "uuid.lib"
; includelib "advapi32.lib"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
; int const `int __cdecl StopService(wchar_t const *)'::`8'::maxWaitTime
?maxWaitTime@?7??StopService@@YAHPB_W@Z@4HB dd 0EA60h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl IsServiceInstalled(LPCWSTR lpServiceName,	int)
?IsServiceInstalled@@YAHPB_WAAH@Z proc near ; CODE XREF: _IsInstalled+ACp

var_D8		= byte ptr -0D8h
hSCObject	= dword	ptr -14h
hSCManager	= dword	ptr -8
lpServiceName	= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		mov	esi, esp
		push	4		; dwDesiredAccess

loc_2F:					; DATA XREF: .rdata:`string'o
		push	0		; lpDatabaseName

loc_31:					; DATA XREF: .rdata:`string'o
		push	0		; lpMachineName
		call	dword ptr ds:__imp__OpenSCManagerW@12 ;	OpenSCManagerW(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+hSCManager], eax
		cmp	[ebp+hSCManager], 0
		jnz	short loc_50
		xor	eax, eax
		jmp	loc_D9
; ---------------------------------------------------------------------------

loc_50:					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+43j
		mov	esi, esp
		push	1		; dwDesiredAccess
		mov	eax, [ebp+lpServiceName]
		push	eax		; lpServiceName
		mov	ecx, [ebp+hSCManager]
		push	ecx		; hSCManager
		call	dword ptr ds:__imp__OpenServiceW@12 ; OpenServiceW(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+hSCObject], eax
		cmp	[ebp+hSCObject], 0
		jnz	short loc_9F
		mov	esi, esp
		call	dword ptr ds:__imp__GetLastError@0 ; GetLastError()
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 424h
		jz	short loc_9F
		mov	esi, esp
		mov	eax, [ebp+hSCManager]
		push	eax		; hSCObject
		call	dword ptr ds:__imp__CloseServiceHandle@4 ; CloseServiceHandle(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		jmp	short loc_D9
; ---------------------------------------------------------------------------

loc_9F:					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+6Cj
					; IsServiceInstalled(wchar_t const *,int &)+82j
		cmp	[ebp+hSCObject], 0
		jz	short loc_C1
		mov	esi, esp
		mov	eax, [ebp+hSCObject]
		push	eax		; hSCObject
		call	dword ptr ds:__imp__CloseServiceHandle@4 ; CloseServiceHandle(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1

loc_C1:					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+9Fj
		mov	esi, esp
		mov	eax, [ebp+hSCManager]
		push	eax		; hSCObject
		call	dword ptr ds:__imp__CloseServiceHandle@4 ; CloseServiceHandle(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, 1

loc_D9:					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+47j
					; IsServiceInstalled(wchar_t const *,int &)+99j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?IsServiceInstalled@@YAHPB_WAAH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl StopService(LPCWSTR lpServiceName)
?StopService@@YAHPB_W@Z	proc near	; CODE XREF: _Stop+A5p

var_118		= byte ptr -118h
var_54		= dword	ptr -54h
ServiceStatus	= _SERVICE_STATUS ptr -48h
var_24		= dword	ptr -24h
hService	= dword	ptr -18h
hSCManager	= dword	ptr -0Ch
var_4		= dword	ptr -4
lpServiceName	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	esi, esp
		push	4		; dwDesiredAccess
		push	0		; lpDatabaseName
		push	0		; lpMachineName
		call	dword ptr ds:__imp__OpenSCManagerW@12 ;	OpenSCManagerW(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+hSCManager], eax
		cmp	[ebp+hSCManager], 0
		jnz	short loc_13D
		xor	eax, eax
		jmp	loc_224
; ---------------------------------------------------------------------------

loc_13D:				; CODE XREF: StopService(wchar_t const *)+44j
		mov	esi, esp
		push	20h ; ' '       ; dwDesiredAccess
		mov	eax, [ebp+lpServiceName]
		push	eax		; lpServiceName
		mov	ecx, [ebp+hSCManager]
		push	ecx		; hSCManager
		call	dword ptr ds:__imp__OpenServiceW@12 ; OpenServiceW(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+hService],	eax
		cmp	[ebp+hService],	0
		jnz	short loc_179
		mov	esi, esp
		mov	eax, [ebp+hSCManager]
		push	eax		; hSCObject
		call	dword ptr ds:__imp__CloseServiceHandle@4 ; CloseServiceHandle(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		jmp	loc_224
; ---------------------------------------------------------------------------

loc_179:				; CODE XREF: StopService(wchar_t const *)+6Dj
		mov	[ebp+var_24], 0
		mov	[ebp+var_54], 0
		mov	esi, esp
		lea	eax, [ebp+ServiceStatus]
		push	eax		; lpServiceStatus
		push	1		; dwControl
		mov	ecx, [ebp+hService]
		push	ecx		; hService
		call	dword ptr ds:__imp__ControlService@12 ;	ControlService(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_1FB

loc_1A4:				; CODE XREF: StopService(wchar_t const *)+109j
		mov	esi, esp
		mov	eax, [ebp+ServiceStatus.dwWaitHint]
		push	eax		; dwMilliseconds
		call	dword ptr ds:__imp__Sleep@4 ; Sleep(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+ServiceStatus.dwWaitHint]
		mov	ecx, [ebp+var_24]
		lea	edx, [ecx+eax+0Ah]
		mov	[ebp+var_24], edx
		cmp	[ebp+ServiceStatus.dwCurrentState], 1
		jnz	short loc_1D5
		mov	[ebp+var_54], 1
		jmp	short loc_1FB
; ---------------------------------------------------------------------------
		jmp	short loc_1E0
; ---------------------------------------------------------------------------

loc_1D5:				; CODE XREF: StopService(wchar_t const *)+D8j
		cmp	[ebp+var_24], 0EA60h
		jbe	short loc_1E0
		jmp	short loc_1FB
; ---------------------------------------------------------------------------

loc_1E0:				; CODE XREF: StopService(wchar_t const *)+E3j
					; StopService(wchar_t const *)+ECj
		mov	esi, esp
		lea	eax, [ebp+ServiceStatus]
		push	eax		; lpServiceStatus
		mov	ecx, [ebp+hService]
		push	ecx		; hService
		call	dword ptr ds:__imp__QueryServiceStatus@8 ; QueryServiceStatus(x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_1A4

loc_1FB:				; CODE XREF: StopService(wchar_t const *)+B2j
					; StopService(wchar_t const *)+E1j ...
		mov	esi, esp
		mov	eax, [ebp+hService]
		push	eax		; hSCObject
		call	dword ptr ds:__imp__CloseServiceHandle@4 ; CloseServiceHandle(x)
		cmp	esi, esp

loc_209:				; DATA XREF: .text$mn:000006A0o
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+hSCManager]
		push	eax		; hSCObject
		call	dword ptr ds:__imp__CloseServiceHandle@4 ; CloseServiceHandle(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_54]

loc_224:				; CODE XREF: StopService(wchar_t const *)+48j
					; StopService(wchar_t const *)+84j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StopService@@YAHPB_W@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN14		dd 1			; DATA XREF: StopService(wchar_t const *)+138o
		dd offset $LN13
$LN13		dd 0FFFFFFB8h, 1Ch	; DATA XREF: .text$mn:00000258o
		dd offset $LN12		; "status"
$LN12		db 'status',0           ; DATA XREF: .text$mn:00000264o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl popstring(struct _stack_t	**, LPWSTR lpString1, int iMaxLength)
		public ?popstring@@YAHPAPAU_stack_t@@PA_WH@Z
?popstring@@YAHPAPAU_stack_t@@PA_WH@Z proc near	; CODE XREF: _IsInstalled+76p
					; _PathToUniqueRegistryPath+76p ...

var_CC		= byte ptr -0CCh
hMem		= dword	ptr -8
arg_0		= dword	ptr  8
lpString1	= dword	ptr  0Ch
iMaxLength	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_29C
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jnz	short loc_2A3

loc_29C:				; CODE XREF: popstring(_stack_t	* *,wchar_t *,int)+22j
		mov	eax, 1
		jmp	short loc_2E8
; ---------------------------------------------------------------------------

loc_2A3:				; CODE XREF: popstring(_stack_t	* *,wchar_t *,int)+2Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+hMem], ecx
		mov	esi, esp
		mov	eax, [ebp+iMaxLength]
		push	eax		; iMaxLength
		mov	ecx, [ebp+hMem]
		add	ecx, 4
		push	ecx		; lpString2
		mov	edx, [ebp+lpString1]
		push	edx		; lpString1
		call	dword ptr ds:__imp__lstrcpynW@12 ; lstrcpynW(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+hMem]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	esi, esp
		mov	eax, [ebp+hMem]
		push	eax		; hMem
		call	dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax

loc_2E8:				; CODE XREF: popstring(_stack_t	* *,wchar_t *,int)+31j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?popstring@@YAHPAPAU_stack_t@@PA_WH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl pushstring(struct _stack_t **, LPCWSTR lpString2, int iMaxLength)
		public ?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z
?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z proc near ; CODE	XREF: _IsInstalled+C3p
					; _IsInstalled+F9p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
lpString2	= dword	ptr  0Ch
iMaxLength	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jnz	short loc_322
		jmp	short loc_36F
; ---------------------------------------------------------------------------

loc_322:				; CODE XREF: pushstring(_stack_t * *,wchar_t const *,int)+22j
		mov	eax, [ebp+iMaxLength]
		add	eax, 20Ch
		mov	esi, esp
		push	eax		; dwBytes
		push	40h ; '@'       ; uFlags
		call	dword ptr ds:__imp__GlobalAlloc@8 ; GlobalAlloc(x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+iMaxLength]
		push	eax		; iMaxLength
		mov	ecx, [ebp+lpString2]
		push	ecx		; lpString2
		mov	edx, [ebp+var_8]
		add	edx, 4
		push	edx		; lpString1
		call	dword ptr ds:__imp__lstrcpynW@12 ; lstrcpynW(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx

loc_36F:				; CODE XREF: pushstring(_stack_t * *,wchar_t const *,int)+24j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 384h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
		public _DllMain@12
_DllMain@12	proc near

var_C0		= byte ptr -0C0h
hinstDLL	= dword	ptr  8
fdwReason	= dword	ptr  0Ch
lpvReserved	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	0Ch
_DllMain@12	endp

_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl IsInstalled(int, int, int, struct	_stack_t **)
		public _IsInstalled
_IsInstalled	proc near

lpString2	= dword	ptr -4F4h
var_42C		= dword	ptr -42Ch
Dest		= word ptr -420h
var_41E		= byte ptr -41Eh
Source		= word ptr -210h
Dst		= byte ptr -20Eh
var_4		= dword	ptr -4
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 4F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+lpString2]
		mov	ecx, 13Dh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		mov	[ebp+Source], ax
		push	206h		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		xor	eax, eax
		mov	[ebp+Dest], ax
		push	206h		; Size
		push	0		; Val
		lea	eax, [ebp+var_41E]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		push	104h		; iMaxLength
		lea	eax, [ebp+Source]
		push	eax		; lpString1
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct _stack_t **
		call	?popstring@@YAHPAPAU_stack_t@@PA_WH@Z ;	popstring(_stack_t * *,wchar_t *,int)
		add	esp, 0Ch
		mov	esi, esp
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	dword ptr ds:__imp__wcscpy
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+var_42C]
		push	eax		; int
		lea	ecx, [ebp+Dest]
		push	ecx		; lpServiceName
		call	?IsServiceInstalled@@YAHPB_WAAH@Z ; IsServiceInstalled(wchar_t const *,int &)
		add	esp, 8
		test	eax, eax
		jnz	short loc_47D
		push	3		; iMaxLength
		push	offset ??_C@_15LNJINHHA@?$AA?9?$AA1?$AA?$AA@ ; "-1"
		mov	eax, [ebp+arg_C]
		push	eax		; struct _stack_t **
		call	?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z ; pushstring(_stack_t * *,wchar_t const *,int)
		add	esp, 0Ch
		jmp	short loc_4B1
; ---------------------------------------------------------------------------

loc_47D:				; CODE XREF: _IsInstalled+B6j
		cmp	[ebp+var_42C], 0
		jz	short loc_492
		mov	[ebp+lpString2], offset	??_C@_13JGCMLPCH@?$AA1?$AA?$AA@	; `string'
		jmp	short loc_49C
; ---------------------------------------------------------------------------

loc_492:				; CODE XREF: _IsInstalled+D4j
		mov	[ebp+lpString2], offset	??_C@_13COJANIEC@?$AA0?$AA?$AA@	; `string'

loc_49C:				; CODE XREF: _IsInstalled+E0j
		push	2		; iMaxLength
		mov	eax, [ebp+lpString2]
		push	eax		; lpString2
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct _stack_t **
		call	?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z ; pushstring(_stack_t * *,wchar_t const *,int)
		add	esp, 0Ch

loc_4B1:				; CODE XREF: _IsInstalled+CBj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 4F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_IsInstalled	endp

; ---------------------------------------------------------------------------
$LN11		dd 3			; DATA XREF: _IsInstalled+105o
		dd offset $LN10
$LN10		dd 0FFFFFDF0h, 208h	; DATA XREF: .text$mn:000004E4o
		dd offset $LN7		; "tmp"
		dd 0FFFFFBE0h, 208h
		dd offset $LN8		; "serviceName"
		dd 0FFFFFBD4h, 4
		dd offset $LN9		; "serviceInstalled"
$LN9		db 'serviceInstalled',0 ; DATA XREF: .text$mn:00000508o
$LN8		db 'serviceName',0      ; DATA XREF: .text$mn:000004FCo
$LN7		db 'tmp',0              ; DATA XREF: .text$mn:000004F0o
		align 10h
_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 530h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl PathToUniqueRegistryPath(int, int, int, struct _stack_t **)
		public _PathToUniqueRegistryPath
_PathToUniqueRegistryPath proc near

var_6F8		= byte ptr -6F8h
Str		= word ptr -634h
var_632		= byte ptr -632h
Dest		= word ptr -420h
var_41E		= byte ptr -41Eh
Source		= word ptr -210h
Dst		= byte ptr -20Eh
var_4		= dword	ptr -4
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 6F8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_6F8]
		mov	ecx, 1BEh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		mov	[ebp+Source], ax
		push	206h		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		xor	eax, eax
		mov	[ebp+Dest], ax
		push	206h		; Size
		push	0		; Val
		lea	eax, [ebp+var_41E]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		push	104h		; iMaxLength
		lea	eax, [ebp+Source]
		push	eax		; lpString1
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct _stack_t **
		call	?popstring@@YAHPAPAU_stack_t@@PA_WH@Z ;	popstring(_stack_t * *,wchar_t *,int)
		add	esp, 0Ch
		mov	esi, esp
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	dword ptr ds:__imp__wcscpy
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax
		mov	[ebp+Str], ax
		push	208h		; Size
		push	0		; Val
		lea	eax, [ebp+var_632]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		lea	eax, [ebp+Str]
		push	eax		; wchar_t *
		lea	ecx, [ebp+Dest]
		push	ecx		; wchar_t *
		call	?CalculateRegistryPathFromFilePath@@YAHQB_WPA_W@Z ; CalculateRegistryPathFromFilePath(wchar_t const * const,wchar_t *)
		add	esp, 8
		test	eax, eax
		jz	short loc_639
		mov	esi, esp
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	dword ptr ds:__imp__wcslen
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		push	eax		; iMaxLength
		lea	ecx, [ebp+Str]
		push	ecx		; lpString2
		mov	edx, [ebp+arg_C]
		push	edx		; struct _stack_t **
		call	?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z ; pushstring(_stack_t * *,wchar_t const *,int)
		add	esp, 0Ch
		jmp	short loc_64C
; ---------------------------------------------------------------------------

loc_639:				; CODE XREF: _PathToUniqueRegistryPath+D5j
		push	1		; iMaxLength
		push	offset ??_C@_11LOCGONAA@?$AA?$AA@ ; lpString2
		mov	eax, [ebp+arg_C]
		push	eax		; struct _stack_t **
		call	?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z ; pushstring(_stack_t * *,wchar_t const *,int)
		add	esp, 0Ch

loc_64C:				; CODE XREF: _PathToUniqueRegistryPath+107j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 6F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_PathToUniqueRegistryPath endp

; ---------------------------------------------------------------------------
		align 4
$LN9_0		dd 3			; DATA XREF: _PathToUniqueRegistryPath+120o
		dd offset $LN8_1
$LN8_1		dd 0FFFFFDF0h, 208h	; DATA XREF: .text$mn:00000680o
		dd offset $LN5_0	; "tmp"
		dd 0FFFFFBE0h, 208h
		dd offset $LN6_0	; "installBasePath"
		db 0CCh
		db 0F9h, 2 dup(0FFh)
		dd offset loc_209+1
		dd offset $LN7_1	; "registryPath"
$LN7_1		db 'registryPath',0     ; DATA XREF: .text$mn:000006A4o
$LN6_0		db 'installBasePath',0  ; DATA XREF: .text$mn:00000698o
$LN5_0		db 'tmp',0              ; DATA XREF: .text$mn:0000068Co
		align 4
_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl Stop(int,	int, int, struct _stack_t **)
		public _Stop
_Stop		proc near

var_4E4		= byte ptr -4E4h
Dest		= word ptr -420h
var_41E		= byte ptr -41Eh
Source		= word ptr -210h
Dst		= byte ptr -20Eh
var_4		= dword	ptr -4
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 4E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_4E4]
		mov	ecx, 139h
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		xor	eax, eax
		mov	[ebp+Source], ax
		push	206h		; Size
		push	0		; Val
		lea	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		xor	eax, eax
		mov	[ebp+Dest], ax
		push	206h		; Size
		push	0		; Val
		lea	eax, [ebp+var_41E]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		push	104h		; iMaxLength
		lea	eax, [ebp+Source]
		push	eax		; lpString1
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct _stack_t **
		call	?popstring@@YAHPAPAU_stack_t@@PA_WH@Z ;	popstring(_stack_t * *,wchar_t *,int)
		add	esp, 0Ch
		mov	esi, esp
		lea	eax, [ebp+Source]
		push	eax		; Source
		lea	ecx, [ebp+Dest]
		push	ecx		; Dest
		call	dword ptr ds:__imp__wcscpy
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+Dest]
		push	eax		; lpServiceName
		call	?StopService@@YAHPB_W@Z	; StopService(wchar_t const *)
		add	esp, 4
		test	eax, eax
		jz	short loc_792
		push	2		; iMaxLength
		push	offset ??_C@_13JGCMLPCH@?$AA1?$AA?$AA@ ; lpString2
		mov	eax, [ebp+arg_C]
		push	eax		; struct _stack_t **
		call	?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z ; pushstring(_stack_t * *,wchar_t const *,int)
		add	esp, 0Ch
		jmp	short loc_7A5
; ---------------------------------------------------------------------------

loc_792:				; CODE XREF: _Stop+AFj
		push	2		; iMaxLength
		push	offset ??_C@_13COJANIEC@?$AA0?$AA?$AA@ ; lpString2
		mov	eax, [ebp+arg_C]
		push	eax		; struct _stack_t **
		call	?pushstring@@YAXPAPAU_stack_t@@PB_WH@Z ; pushstring(_stack_t * *,wchar_t const *,int)
		add	esp, 0Ch

loc_7A5:				; CODE XREF: _Stop+C4j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 4E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_Stop		endp

; ---------------------------------------------------------------------------
$LN8_0		dd 2			; DATA XREF: _Stop+DDo
		dd offset $LN7_0
$LN7_0		dd 0FFFFFDF0h, 208h	; DATA XREF: .text$mn:000007D8o
		dd offset $LN5		; "tmp"
		dd 0FFFFFBE0h, 208h
		dd offset $LN6		; "serviceName"
$LN6		db 'serviceName',0      ; DATA XREF: .text$mn:000007F0o
$LN5		db 'tmp',0              ; DATA XREF: .text$mn:000007E4o
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 804h
		public ??_C@_15LNJINHHA@?$AA?9?$AA1?$AA?$AA@
; const	WCHAR `string'
??_C@_15LNJINHHA@?$AA?9?$AA1?$AA?$AA@:	; DATA XREF: _IsInstalled+BAo
		unicode	0, <-1>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80Ch
		public ??_C@_13JGCMLPCH@?$AA1?$AA?$AA@
; const	WCHAR `string'
??_C@_13JGCMLPCH@?$AA1?$AA?$AA@	dd offset loc_31 ; DATA	XREF: _IsInstalled+D6o
					; _Stop+B3o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 810h
		public ??_C@_13COJANIEC@?$AA0?$AA?$AA@
; const	WCHAR `string'
??_C@_13COJANIEC@?$AA0?$AA?$AA@	dd offset loc_2F+1 ; DATA XREF:	_IsInstalled:loc_492o
					; _Stop+C8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 814h
		public ??_C@_11LOCGONAA@?$AA?$AA@
; const	WCHAR `string'
??_C@_11LOCGONAA@?$AA?$AA@ db 2	dup(0)	; DATA XREF: _PathToUniqueRegistryPath+10Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 818h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 81Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; wchar_t *__cdecl _wcscpy(wchar_t *Dest, const	wchar_t	*Source)
		extrn __imp__wcscpy:near ; CODE	XREF: _IsInstalled+8Ep
					; _PathToUniqueRegistryPath+8Ep ...
; size_t __cdecl _wcslen(const wchar_t *Str)
		extrn __imp__wcslen:near ; CODE	XREF: _PathToUniqueRegistryPath+E0p
					; DATA XREF: _PathToUniqueRegistryPath+E0r
; DWORD	__stdcall GetLastError()
		extrn __imp__GetLastError@0:near
					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+70p
					; DATA XREF: IsServiceInstalled(wchar_t	const *,int &)+70r
; void __stdcall Sleep(DWORD dwMilliseconds)
		extrn __imp__Sleep@4:near ; CODE XREF: StopService(wchar_t const *)+BAp
					; DATA XREF: StopService(wchar_t const *)+BAr
; HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
		extrn __imp__GlobalAlloc@8:near
					; CODE XREF: pushstring(_stack_t * *,wchar_t const *,int)+33p
					; DATA XREF: pushstring(_stack_t * *,wchar_t const *,int)+33r
; HGLOBAL __stdcall GlobalFree(HGLOBAL hMem)
		extrn __imp__GlobalFree@4:near
					; CODE XREF: popstring(_stack_t	* *,wchar_t *,int)+69p
					; DATA XREF: popstring(_stack_t	* *,wchar_t *,int)+69r
; LPWSTR __stdcall lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
		extrn __imp__lstrcpynW@12:near
					; CODE XREF: popstring(_stack_t	* *,wchar_t *,int)+4Cp
					; pushstring(_stack_t *	*,wchar_t const	*,int)+54p
					; DATA XREF: ...
; BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject)
		extrn __imp__CloseServiceHandle@4:near
					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+8Ap
					; IsServiceInstalled(wchar_t const *,int &)+A7p ...
; BOOL __stdcall ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
		extrn __imp__ControlService@12:near
					; CODE XREF: StopService(wchar_t const *)+A3p
					; DATA XREF: StopService(wchar_t const *)+A3r
; SC_HANDLE __stdcall OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
		extrn __imp__OpenSCManagerW@12:near
					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+2Fp
					; StopService(wchar_t const *)+30p
					; DATA XREF: ...
; SC_HANDLE __stdcall OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName,	DWORD dwDesiredAccess)
		extrn __imp__OpenServiceW@12:near
					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+58p
					; StopService(wchar_t const *)+59p
					; DATA XREF: ...
; BOOL __stdcall QueryServiceStatus(SC_HANDLE hService,	LPSERVICE_STATUS lpServiceStatus)
		extrn __imp__QueryServiceStatus@8:near
					; CODE XREF: StopService(wchar_t const *)+FAp
					; DATA XREF: StopService(wchar_t const *)+FAr
; int __cdecl CalculateRegistryPathFromFilePath(const wchar_t *const , wchar_t *)
		extrn ?CalculateRegistryPathFromFilePath@@YAHQB_WPA_W@Z:near
					; CODE XREF: _PathToUniqueRegistryPath+CBp
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: StopService(wchar_t const *)+13Ep
					; _IsInstalled+10Bp ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: StopService(wchar_t const *)+14Dp
					; _IsInstalled+11Ap ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: IsServiceInstalled(wchar_t	const *,int &)+37p
					; IsServiceInstalled(wchar_t const *,int &)+60p ...
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _IsInstalled+3Fp
					; _IsInstalled+5Ep ...
		extrn ___security_cookie:near ;	DATA XREF: StopService(wchar_t const *)+1Er
					; _IsInstalled+1Er ...


		end
