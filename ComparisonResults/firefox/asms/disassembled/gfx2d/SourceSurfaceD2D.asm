;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	760C30677B4EE6DE74425A14074C55F7
; Input	CRC32 :	8FA58A37

; File Name   :	D:\compspace\objfiles\firefox\gfx2d\SourceSurfaceD2D.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "uuid.lib"
; must resolve:	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; must resolve:	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; must resolve:	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; must resolve:	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; must resolve:	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
$SG161830	db 'Bitmap does not fit in texture.',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *):loc_790o
; char _SG161859[]
$SG161859	db 'Failed to create D2D Bitmap for data. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1C1o
		align 10h
; char _SG161864[]
$SG161864	db 'Failed to copy data to D2D bitmap. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+279o
					; .rdata:00008E7Co
		align 4
; char _SG162003[]
$SG162003	db 'Failed to QI texture to surface. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+83o
; char _SG162015[]
$SG162015	db 'Failed to create SharedBitmap. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+221o
		align 4
; char _SG162075[]
$SG162075	db 'Failed to create texture. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+163o
		align 10h
; char _SG162104[]
$SG162104	db 'Failed to create DXGI surface. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+22Co
		align 4
; char _SG162135[]
$SG162135	db 'Failed to create render target. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+3A3o
		align 10h
$SG152979	db 'Failed to create Direct2D stroke style.',0
; char _SG162289[]
$SG162289	db 'Failed to draw bitmap. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+696o
		align 4
; char _SG162295[]
$SG162295	db 'Failed to create staging texture. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+7AFo
		align 4
; char _SG162343[]
$SG162343	db 'Texture map failed with code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+DDo
		align 4
; char _SG162364[]
$SG162364	db 'Failed to map texture. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+BEo
		align 4
$SG4890		db 'Assertion failure: %s, at %s:%d',0Ah,0
		align 4
$SG4896		db 'Hit MOZ_CRASH(%s) at %s:%d',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 234h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mozilla::gfx::BytesPerPixel(enum	mozilla::gfx::SurfaceFormat)
?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetByteSize(void)+24p

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 6
		jz	short loc_25A
		cmp	byte ptr [ebp+var_4], 7
		jz	short loc_253
		jmp	short loc_261
; ---------------------------------------------------------------------------

loc_253:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+1Bj
		mov	eax, 1
		jmp	short loc_266
; ---------------------------------------------------------------------------

loc_25A:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 2
		jmp	short loc_266
; ---------------------------------------------------------------------------

loc_261:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+1Dj
		mov	eax, 4

loc_266:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+24j
					; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+2Bj
		mov	esp, ebp
		pop	ebp
		retn
?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		db 0Ah dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_SIZE_U __cdecl mozilla::gfx::D2DIntSize(struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> const	&)
?D2DIntSize@gfx@mozilla@@YA?AUD2D_SIZE_U@@ABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+165p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		push	eax
		call	?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z ; D2D1::SizeU(uint,uint)
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], edx
		mov	eax, [ebp+var_8]
		mov	edx, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?D2DIntSize@gfx@mozilla@@YA?AUD2D_SIZE_U@@ABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@12@@Z endp

; ---------------------------------------------------------------------------
		db 0Dh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	DXGI_FORMAT __cdecl mozilla::gfx::DXGIFormat(enum  mozilla::gfx::SurfaceFormat)
?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+27p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+B8p

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 0
		jz	short loc_2E9
		cmp	byte ptr [ebp+var_4], 1
		jz	short loc_2F0
		cmp	byte ptr [ebp+var_4], 7
		jz	short loc_2F7
		jmp	short loc_2FE
; ---------------------------------------------------------------------------

loc_2E9:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 57h ; 'W'
		jmp	short loc_300
; ---------------------------------------------------------------------------

loc_2F0:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+1Bj
		mov	eax, 57h ; 'W'
		jmp	short loc_300
; ---------------------------------------------------------------------------

loc_2F7:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+21j
		mov	eax, 41h ; 'A'
		jmp	short loc_300
; ---------------------------------------------------------------------------

loc_2FE:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+23j
		xor	eax, eax

loc_300:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+2Aj
					; mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+31j ...
		mov	esp, ebp
		pop	ebp
		retn
?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	D2D1_ALPHA_MODE	__cdecl	mozilla::gfx::D2DAlphaModeForFormat(enum  mozilla::gfx::SurfaceFormat)
?D2DAlphaModeForFormat@gfx@mozilla@@YA?AW4D2D1_ALPHA_MODE@@W4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+19p

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 1
		jz	short loc_31D
		jmp	short loc_324
; ---------------------------------------------------------------------------

loc_31D:				; CODE XREF: mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 3
		jmp	short loc_329
; ---------------------------------------------------------------------------

loc_324:				; CODE XREF: mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)+17j
		mov	eax, 1

loc_329:				; CODE XREF: mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)+1Ej
		mov	esp, ebp
		pop	ebp
		retn
?D2DAlphaModeForFormat@gfx@mozilla@@YA?AW4D2D1_ALPHA_MODE@@W4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		db 7 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_PIXEL_FORMAT __cdecl mozilla::gfx::D2DPixelFormat(enum  mozilla::gfx::SurfaceFormat)
?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+F8p
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+142p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		movzx	eax, [ebp+arg_0]
		push	eax
		call	?D2DAlphaModeForFormat@gfx@mozilla@@YA?AW4D2D1_ALPHA_MODE@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		push	eax
		movzx	ecx, [ebp+arg_0]
		push	ecx
		call	?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		push	eax
		call	?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	; D2D1::PixelFormat(DXGI_FORMAT,D2D1_ALPHA_MODE)
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], edx
		mov	eax, [ebp+var_8]
		mov	edx, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		db 0Eh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *__hidden this)
		public ??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ
??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ	proc near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10] ; this
		call	??0SourceSurface@gfx@mozilla@@QAE@XZ ; mozilla::gfx::SourceSurface::SourceSurface(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurfaceD2D@gfx@mozilla@@6B@ ;	const mozilla::gfx::SourceSurfaceD2D::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::RefPtr<ID2D1Bitmap>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??0?$RefPtr@UID3D10Device@@@@QAE@XZ ; RefPtr<ID3D10Device>::RefPtr<ID3D10Device>(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		db 0Fh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *__hidden this)
		public ??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ
??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::`scalar deleting destructor'(uint)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurfaceD2D@gfx@mozilla@@6B@ ;	const mozilla::gfx::SourceSurfaceD2D::`vftable'
		mov	[ebp+var_4], 2
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		test	eax, eax
		jz	short loc_4A4
		mov	ecx, [ebp+var_10] ; this
		call	?GetByteSize@SourceSurfaceD2D@gfx@mozilla@@ABEIXZ ; mozilla::gfx::SourceSurfaceD2D::GetByteSize(void)
		xor	ecx, ecx
		mov	edx, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		sub	edx, eax
		mov	eax, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4 ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		sbb	eax, ecx
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA, edx	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4, eax ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS

loc_4A4:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+4Aj
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??1?$RefPtr@UID3D10Device@@@@QAE@XZ ; RefPtr<ID3D10Device>::~RefPtr<ID3D10Device>(void)
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10] ; this
		call	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ	endp

; ---------------------------------------------------------------------------
		db 0Ah dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> __thiscall mozilla::gfx::SourceSurfaceD2D::GetSize(void)const
		public ?GetSize@SourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ
?GetSize@SourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ proc near
					; DATA XREF: .rdata:00008E8Co

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+1Ch]
		mov	edx, [eax+20h]
		mov	eax, [ebp+arg_0]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+arg_0]
		mov	esp, ebp
		pop	ebp
		retn	4
?GetSize@SourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ endp

; ---------------------------------------------------------------------------
		db 8 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceFormat __thiscall mozilla::gfx::SourceSurfaceD2D::GetFormat(void)const
		public ?GetFormat@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ
?GetFormat@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ proc near
					; DATA XREF: .rdata:00008E90o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+18h]
		mov	esp, ebp
		pop	ebp
		retn
?GetFormat@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ endp

; ---------------------------------------------------------------------------
		db 8 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall mozilla::gfx::SourceSurfaceD2D::IsValid(mozilla::gfx::SourceSurfaceD2D *__hidden this)
		public ?IsValid@SourceSurfaceD2D@gfx@mozilla@@UBE_NXZ
?IsValid@SourceSurfaceD2D@gfx@mozilla@@UBE_NXZ proc near ; DATA	XREF: .rdata:00008E94o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		push	eax
		mov	eax, [ebp+var_4]
		add	eax, 14h
		push	eax
		call	??$?8UID3D10Device@@UID3D10Device1@@@@YA_NABV?$RefPtr@UID3D10Device@@@@PAUID3D10Device1@@@Z ; operator==<ID3D10Device,ID3D10Device1>(RefPtr<ID3D10Device> const	&,ID3D10Device1	*)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?IsValid@SourceSurfaceD2D@gfx@mozilla@@UBE_NXZ endp

; ---------------------------------------------------------------------------
		db 0Fh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual struct already_AddRefed<class	mozilla::gfx::DataSourceSurface> __thiscall mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)
		public ?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ proc near
					; DATA XREF: .rdata:00008E98o

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= byte ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 2Ch
		push	edi
		push	ecx
		lea	edi, [ebp+var_38]
		mov	ecx, 0Bh
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_2C], 0
		push	30h ; '0'       ; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_24], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_24], 0
		jz	short loc_5F0
		mov	eax, [ebp+var_10]
		push	eax		; struct mozilla::gfx::SourceSurfaceD2D	*
		mov	ecx, [ebp+var_24] ; this
		call	??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z ; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)
		mov	[ebp+var_30], eax
		jmp	short loc_5F7
; ---------------------------------------------------------------------------

loc_5F0:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+59j
		mov	[ebp+var_30], 0

loc_5F7:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+6Aj
		mov	ecx, [ebp+var_30]
		mov	[ebp+var_20], ecx
		mov	byte ptr [ebp+var_4], 0
		mov	edx, [ebp+var_20]
		push	edx
		lea	ecx, [ebp+var_18]
		call	??0?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(mozilla::gfx::DataSourceSurfaceD2D *)
		mov	[ebp+var_4], 2
		lea	ecx, [ebp+var_18]
		call	??C?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::operator->(void)
		mov	ecx, eax	; this
		call	?IsValid@DataSourceSurfaceD2D@gfx@mozilla@@QAE_NXZ ; mozilla::gfx::DataSourceSurfaceD2D::IsValid(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_675
		lea	ecx, [ebp+var_28]
		push	ecx
		lea	ecx, [ebp+var_18]
		call	?forget@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@XZ ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::forget(void)
		mov	[ebp+var_34], eax
		mov	edx, [ebp+var_34]
		mov	[ebp+var_38], edx
		mov	byte ptr [ebp+var_4], 3
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$?0VDataSourceSurfaceD2D@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@@Z ; already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D> &&)
		mov	ecx, [ebp+var_2C]
		or	ecx, 1
		mov	[ebp+var_2C], ecx
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_28]
		call	??1?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>::~already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_18]
		call	??1?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ	; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(void)
		mov	eax, [ebp+arg_0]
		jmp	short loc_697
; ---------------------------------------------------------------------------

loc_675:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+A4j
		push	0
		mov	ecx, [ebp+arg_0]
		call	??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z ; already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(void (already_AddRefed<mozilla::gfx::DataSourceSurface>::*)(double,float))
		mov	edx, [ebp+var_2C]
		or	edx, 1
		mov	[ebp+var_2C], edx
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_18]
		call	??1?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ	; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(void)
		mov	eax, [ebp+arg_0]

loc_697:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+EFj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		add	esp, 38h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ endp

; ---------------------------------------------------------------------------
$LN14_0		dd 1			; DATA XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+117o
		dd offset $LN13
$LN13		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:000006C8o
		dd offset $LN11		; "result"
$LN11		db 'result',0           ; DATA XREF: .text$mn:000006D4o
		db 5 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::SourceSurfaceD2D::InitFromData(unsigned	char *,	struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> const &, int, enum	 mozilla::gfx::SurfaceFormat, struct ID2D1RenderTarget *)
		public ?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z proc near

var_220		= dword	ptr -220h
var_21C		= dword	ptr -21Ch
var_20C		= dword	ptr -20Ch
var_208		= dword	ptr -208h
var_204		= dword	ptr -204h
var_200		= dword	ptr -200h
var_1FC		= dword	ptr -1FCh
var_1F8		= dword	ptr -1F8h
var_1F4		= dword	ptr -1F4h
var_1F0		= byte ptr -1F0h
var_1EC		= byte ptr -1ECh
var_12C		= byte ptr -12Ch
var_128		= byte ptr -128h
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= byte ptr -60h
var_5C		= byte ptr -5Ch
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_41		= byte ptr -41h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 200h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_20C]
		mov	ecx, 80h ; 'Ä'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	cl, [ebp+arg_C]
		mov	[eax+18h], cl
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		mov	ecx, [edx+4]
		mov	edx, [ebp+var_14]
		mov	[edx+1Ch], eax
		mov	[edx+20h], ecx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ecx+0DCh]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_4]
		cmp	[ecx], eax
		ja	short loc_785
		mov	edx, [ebp+arg_10]
		mov	eax, [edx]
		mov	esi, esp
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [eax+0DCh]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_4]
		cmp	[ecx+4], eax
		jbe	short loc_7D7

loc_785:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+7Dj
		mov	edx, 1
		test	edx, edx
		jz	short loc_790
		jmp	short loc_7D0
; ---------------------------------------------------------------------------

loc_790:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+A8j
		push	offset $SG161830 ; "Bitmap does	not fit	in texture."
		lea	ecx, [ebp+var_41] ; this
		call	??0NoLog@gfx@mozilla@@QAE@XZ ; mozilla::gfx::NoLog::NoLog(void)
		mov	[ebp+var_1F4], eax
		mov	eax, [ebp+var_1F4]
		mov	[ebp+var_1F8], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_1F8]
		call	??$?6$$BY0CA@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0CA@$$CBD@Z ; mozilla::gfx::NoLog::operator<<<char const [32]>(char const (&)[32])
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_41] ; this
		call	??1NoLog@gfx@mozilla@@QAE@XZ ; mozilla::gfx::NoLog::~NoLog(void)

loc_7D0:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+AAj
		xor	al, al
		jmp	loc_9EF
; ---------------------------------------------------------------------------

loc_7D7:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+9Fj
		movzx	ecx, [ebp+arg_C]
		push	ecx
		call	?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		mov	[ebp+var_4C], eax
		mov	[ebp+var_48], edx
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+21Ch+var_21C], xmm0
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+220h+var_220], xmm0
		lea	edx, [ebp+var_4C]
		push	edx
		lea	eax, [ebp+var_5C]
		push	eax
		call	?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	; D2D1::BitmapProperties(D2D1_PIXEL_FORMAT const &,float,float)
		add	esp, 10h
		mov	ecx, [eax]
		mov	[ebp+var_40], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_3C], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_38], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_34], edx
		mov	eax, [ebp+var_40]
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_3C]
		mov	[ebp+var_28], ecx
		mov	edx, [ebp+var_38]
		mov	[ebp+var_24], edx
		mov	eax, [ebp+var_34]
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	?D2DIntSize@gfx@mozilla@@YA?AUD2D_SIZE_U@@ABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@12@@Z ;	mozilla::gfx::D2DIntSize(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>	const &)
		add	esp, 4
		mov	[ebp+var_68], eax
		mov	[ebp+var_64], edx
		mov	edx, [ebp+var_14]
		add	edx, 10h
		push	edx
		lea	eax, [ebp+var_60]
		push	eax
		call	??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z ; getter_AddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ ; RefPtrGetterAddRefs<ID2D1Bitmap>::operator ID2D1Bitmap * *(void)
		push	eax
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_64]
		push	edx
		mov	eax, [ebp+var_68]
		push	eax
		mov	ecx, [ebp+arg_10]
		call	?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z ; ID2D1RenderTarget::CreateBitmap(D2D_SIZE_U,D2D1_BITMAP_PROPERTIES const &,ID2D1Bitmap * *)
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	short loc_906
		mov	ecx, [ebp+var_18]
		push	ecx
		lea	edx, [ebp+var_12C]
		push	edx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	eax, [eax]
		push	eax
		push	offset $SG161859 ; "Failed to create D2D Bitmap	for data. C"...
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_128]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_1FC], eax
		mov	ecx, [ebp+var_1FC]
		mov	[ebp+var_200], ecx
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_200]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_128]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		xor	al, al
		jmp	loc_9EF
; ---------------------------------------------------------------------------

loc_906:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1A9j
		mov	ecx, [ebp+var_14]
		add	ecx, 10h
		call	??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator->(void)
		mov	[ebp+var_204], eax
		mov	esi, esp
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		mov	ecx, [ebp+var_204]
		push	ecx
		mov	edx, [ebp+var_204]
		mov	eax, [edx]
		mov	ecx, [eax+28h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	short loc_9BB
		mov	edx, [ebp+var_18]
		push	edx
		lea	eax, [ebp+var_1F0]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG161864 ; "Failed to copy data	to D2D bitmap. Code"...
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_1EC]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_208], eax
		mov	edx, [ebp+var_208]
		mov	[ebp+var_20C], edx
		mov	[ebp+var_4], 2
		mov	ecx, [ebp+var_20C]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_1EC]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		xor	al, al
		jmp	short loc_9EF
; ---------------------------------------------------------------------------

loc_9BB:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+261j
		mov	ecx, [ebp+var_14] ; this
		call	?GetByteSize@SourceSurfaceD2D@gfx@mozilla@@ABEIXZ ; mozilla::gfx::SourceSurfaceD2D::GetByteSize(void)
		xor	ecx, ecx
		add	eax, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		adc	ecx, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4 ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA, eax	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4, ecx ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??4?$RefPtr@UID3D10Device@@@@QAEAAV0@PAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::operator=(ID3D10Device	*)
		mov	al, 1

loc_9EF:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+EEj
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+21Dj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN15_0		dd 1			; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+30Fo
		dd offset $LN14_1
$LN14_1		dd 0FFFFFFD4h, 10h	; DATA XREF: .text$mn:00000A30o
		dd offset $LN12_0	; "props"
$LN12_0		db 'props',0            ; DATA XREF: .text$mn:00000A3Co
		db 0Eh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::SourceSurfaceD2D::InitFromTexture(struct ID3D10Texture2D *, enum  mozilla::gfx::SurfaceFormat, struct ID2D1RenderTarget	*)
		public ?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z proc near

var_260		= dword	ptr -260h
var_25C		= dword	ptr -25Ch
var_24C		= dword	ptr -24Ch
var_248		= dword	ptr -248h
var_244		= dword	ptr -244h
var_240		= dword	ptr -240h
var_239		= byte ptr -239h
var_238		= byte ptr -238h
var_231		= byte ptr -231h
var_230		= byte ptr -230h
var_22C		= byte ptr -22Ch
var_16C		= byte ptr -16Ch
var_168		= byte ptr -168h
var_158		= dword	ptr -158h
var_154		= dword	ptr -154h
var_150		= byte ptr -150h
var_145		= byte ptr -145h
var_144		= byte ptr -144h
var_140		= byte ptr -140h
var_80		= dword	ptr -80h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_6C		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_20		= byte ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 240h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_24C]
		mov	ecx, 90h ; 'ê'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		lea	ecx, [ebp+var_20]
		call	??0?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::RefPtr<IDXGISurface>(void)
		mov	[ebp+var_4], 0
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z ;	IUnknown::QueryInterface<IDXGISurface>(IDXGISurface * *)
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_B4C
		mov	edx, [ebp+var_18]
		push	edx
		lea	eax, [ebp+var_144]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162003 ; "Failed to QI texture to surface. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_140]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_240], eax
		mov	edx, [ebp+var_240]
		mov	[ebp+var_244], edx
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_244]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_140]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	[ebp+var_145], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	al, [ebp+var_145]
		jmp	loc_D59
; ---------------------------------------------------------------------------

loc_B4C:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+67j
		mov	esi, esp
		lea	eax, [ebp+var_54]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [edx+30h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+var_54]
		push	eax
		lea	ecx, [ebp+var_150]
		call	??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z ; mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(int,int)
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_14]
		mov	[eax+1Ch], ecx
		mov	[eax+20h], edx
		mov	ecx, [ebp+var_14]
		mov	dl, [ebp+arg_4]
		mov	[ecx+18h], dl
		movzx	eax, [ebp+arg_4]
		push	eax
		call	?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		mov	[ebp+var_158], eax
		mov	[ebp+var_154], edx
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+25Ch+var_25C], xmm0
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+260h+var_260], xmm0
		lea	ecx, [ebp+var_158]
		push	ecx
		lea	edx, [ebp+var_168]
		push	edx
		call	?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	; D2D1::BitmapProperties(D2D1_PIXEL_FORMAT const &,float,float)
		add	esp, 10h
		mov	ecx, [eax]
		mov	[ebp+var_80], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_7C], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_78], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_74], edx
		mov	eax, [ebp+var_80]
		mov	[ebp+var_6C], eax
		mov	ecx, [ebp+var_7C]
		mov	[ebp+var_68], ecx
		mov	edx, [ebp+var_78]
		mov	[ebp+var_64], edx
		mov	eax, [ebp+var_74]
		mov	[ebp+var_60], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 10h
		push	ecx
		lea	edx, [ebp+var_16C]
		push	edx
		call	??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z ; getter_AddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ ; RefPtrGetterAddRefs<ID2D1Bitmap>::operator ID2D1Bitmap * *(void)
		mov	esi, esp
		push	eax
		lea	eax, [ebp+var_6C]
		push	eax
		lea	ecx, [ebp+var_20]
		call	??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ ; RefPtr<IDXGISurface>::operator IDXGISurface *(void)
		push	eax
		push	offset _IID_IDXGISurface
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [edx+18h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_CE7
		mov	edx, [ebp+var_18]
		push	edx
		lea	eax, [ebp+var_230]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162015 ; "Failed to create SharedBitmap. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_22C]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_248], eax
		mov	edx, [ebp+var_248]
		mov	[ebp+var_24C], edx
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_24C]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_22C]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	[ebp+var_231], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	al, [ebp+var_231]
		jmp	short loc_D59
; ---------------------------------------------------------------------------

loc_CE7:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+205j
		mov	eax, [ebp+var_14]
		add	eax, 14h
		push	eax
		lea	ecx, [ebp+var_238]
		push	ecx
		call	??$getter_AddRefs@UID3D10Device@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Device@@@@AAV?$RefPtr@UID3D10Device@@@@@Z ; getter_AddRefs<ID3D10Device>(RefPtr<ID3D10Device> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ ; RefPtrGetterAddRefs<ID3D10Device>::operator ID3D10Device *	*(void)
		mov	esi, esp
		push	eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [eax+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14] ; this
		call	?GetByteSize@SourceSurfaceD2D@gfx@mozilla@@ABEIXZ ; mozilla::gfx::SourceSurfaceD2D::GetByteSize(void)
		xor	ecx, ecx
		add	eax, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		adc	ecx, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4 ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA, eax	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4, ecx ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	[ebp+var_239], 1
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	al, [ebp+var_239]

loc_D59:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+F3j
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+291j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
$LN13_0		dd 3			; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+309o
		dd offset $LN12_1
$LN12_1		dd 0FFFFFFE0h, 4	; DATA XREF: .text$mn:00000D98o
		dd offset $LN8		; "surf"
		dd 0FFFFFFACh, 2Ch
		dd offset $LN9_0	; "desc"
		dd 0FFFFFF94h, 10h
		dd offset $LN10_0	; "props"
$LN10_0		db 'props',0            ; DATA XREF: .text$mn:00000DBCo
$LN9_0		db 'desc',0             ; DATA XREF: .text$mn:00000DB0o
$LN8		db 'surf',0             ; DATA XREF: .text$mn:00000DA4o
		db 4 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __thiscall mozilla::gfx::SourceSurfaceD2D::GetByteSize(mozilla::gfx::SourceSurfaceD2D *__hidden this)
		public ?GetByteSize@SourceSurfaceD2D@gfx@mozilla@@ABEIXZ
?GetByteSize@SourceSurfaceD2D@gfx@mozilla@@ABEIXZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+4Fp
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+2DAp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	esi, [eax+1Ch]
		imul	esi, [ecx+20h]
		mov	edx, [ebp+var_4]
		movzx	eax, byte ptr [edx+18h]
		push	eax
		call	?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		imul	eax, esi
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetByteSize@SourceSurfaceD2D@gfx@mozilla@@ABEIXZ endp

; ---------------------------------------------------------------------------
		align 4

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::DataSourceSurfaceD2D	*this, struct mozilla::gfx::SourceSurfaceD2D *)
		public ??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z
??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+62p

var_56C		= dword	ptr -56Ch
var_568		= dword	ptr -568h
var_564		= dword	ptr -564h
var_560		= dword	ptr -560h
var_55C		= dword	ptr -55Ch
var_550		= dword	ptr -550h
var_54C		= dword	ptr -54Ch
var_548		= dword	ptr -548h
var_544		= dword	ptr -544h
var_540		= dword	ptr -540h
var_53C		= dword	ptr -53Ch
var_538		= dword	ptr -538h
var_534		= dword	ptr -534h
var_530		= dword	ptr -530h
var_52C		= dword	ptr -52Ch
var_528		= dword	ptr -528h
var_524		= dword	ptr -524h
var_520		= dword	ptr -520h
var_51C		= dword	ptr -51Ch
var_518		= dword	ptr -518h
var_514		= dword	ptr -514h
var_510		= dword	ptr -510h
var_50C		= dword	ptr -50Ch
var_508		= byte ptr -508h
var_504		= byte ptr -504h
var_444		= byte ptr -444h
var_440		= byte ptr -440h
var_43C		= byte ptr -43Ch
var_37C		= byte ptr -37Ch
var_378		= byte ptr -378h
var_368		= byte ptr -368h
var_364		= byte ptr -364h
var_2A4		= byte ptr -2A4h
var_2A0		= byte ptr -2A0h
var_284		= dword	ptr -284h
var_280		= dword	ptr -280h
var_27C		= byte ptr -27Ch
var_278		= byte ptr -278h
var_1B8		= byte ptr -1B8h
var_1B4		= byte ptr -1B4h
var_1B0		= byte ptr -1B0h
var_F0		= byte ptr -0F0h
var_EC		= byte ptr -0ECh
var_D8		= byte ptr -0D8h
var_D0		= dword	ptr -0D0h
var_CC		= dword	ptr -0CCh
var_C8		= dword	ptr -0C8h
var_C4		= dword	ptr -0C4h
var_C0		= byte ptr -0C0h
var_AC		= byte ptr -0ACh
var_A4		= byte ptr -0A4h
var_84		= byte ptr -84h
var_60		= byte ptr -60h
var_58		= dword	ptr -58h
var_50		= byte ptr -50h
var_44		= byte ptr -44h
var_3C		= dword	ptr -3Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 544h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_550]
		mov	ecx, 151h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0DataSourceSurface@gfx@mozilla@@QAE@XZ ; mozilla::gfx::DataSourceSurface::DataSourceSurface(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7DataSourceSurfaceD2D@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurfaceD2D::`vftable'
		push	0
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(ID3D10Texture2D *)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		mov	al, [edx+18h]
		mov	[ecx+20h], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+1Ch]
		mov	eax, [ecx+20h]
		mov	ecx, [ebp+var_14]
		mov	[ecx+24h], edx
		mov	[ecx+28h], eax
		mov	edx, [ebp+var_14]
		mov	byte ptr [edx+2Ch], 0
		push	0		; unsigned int
		push	0		; unsigned int
		push	1		; unsigned int
		push	0		; unsigned int
		push	0		; enum D3D10_USAGE
		push	8		; unsigned int
		push	0		; unsigned int
		push	1		; unsigned int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		push	ecx		; unsigned int
		mov	edx, [ebp+var_14]
		mov	eax, [edx+24h]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_14]
		movzx	edx, byte ptr [ecx+20h]
		push	edx
		call	?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		push	eax		; enum DXGI_FORMAT
		lea	ecx, [ebp+var_44] ; this
		call	??0CD3D10_TEXTURE2D_DESC@@QAE@W4DXGI_FORMAT@@IIIIIW4D3D10_USAGE@@IIII@Z	; CD3D10_TEXTURE2D_DESC::CD3D10_TEXTURE2D_DESC(DXGI_FORMAT,uint,uint,uint,uint,uint,D3D10_USAGE,uint,uint,uint,uint)
		mov	byte ptr [ebp+var_4], 2
		mov	[ebp+var_3C], 1
		mov	[ebp+var_28], 0
		mov	[ebp+var_24], 28h ; '('
		lea	ecx, [ebp+var_50]
		call	??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ ; RefPtr<ID3D10Device>::operator->(void)
		mov	[ebp+var_50C], eax
		lea	eax, [ebp+var_50]
		push	eax
		lea	ecx, [ebp+var_F0]
		push	ecx
		call	??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	; getter_AddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ ; RefPtrGetterAddRefs<ID3D10Texture2D>::operator ID3D10Texture2D * *(void)
		mov	esi, esp
		push	eax
		push	0
		lea	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+var_50C]
		push	eax
		mov	ecx, [ebp+var_50C]
		mov	edx, [ecx]
		mov	eax, [edx+124h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		cmp	[ebp+var_58], 0
		jge	loc_FE8
		mov	ecx, [ebp+var_58]
		push	ecx
		lea	edx, [ebp+var_1B4]
		push	edx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	eax, [eax]
		push	eax
		push	offset $SG162075 ; "Failed to create texture. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_1B0]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_510], eax
		mov	ecx, [ebp+var_510]
		mov	[ebp+var_514], ecx
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_514]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_1B0]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_50]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_44] ; this
		call	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)
		jmp	loc_16D2
; ---------------------------------------------------------------------------

loc_FE8:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+147j
		lea	ecx, [ebp+var_60]
		call	??0?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 5
		lea	edx, [ebp+var_60]
		push	edx
		lea	eax, [ebp+var_1B8]
		push	eax
		call	??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z ; getter_AddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ ; RefPtrGetterAddRefs<IDXGISurface>::operator IDXGISurface *	*(void)
		push	eax
		lea	ecx, [ebp+var_50]
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		push	eax
		call	??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z ;	IUnknown::QueryInterface<IDXGISurface>(IDXGISurface * *)
		mov	[ebp+var_58], eax
		cmp	[ebp+var_58], 0
		jge	loc_10BD
		mov	ecx, [ebp+var_58]
		push	ecx
		lea	edx, [ebp+var_27C]
		push	edx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	eax, [eax]
		push	eax
		push	offset $SG162104 ; "Failed to create DXGI surface. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_278]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_518], eax
		mov	ecx, [ebp+var_518]
		mov	[ebp+var_51C], ecx
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_51C]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 5
		lea	ecx, [ebp+var_278]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_60]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_50]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_44] ; this
		call	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)
		jmp	loc_16D2
; ---------------------------------------------------------------------------

loc_10BD:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+210j
		push	1
		push	0
		call	?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	; D2D1::PixelFormat(DXGI_FORMAT,D2D1_ALPHA_MODE)
		add	esp, 8
		mov	[ebp+var_284], eax
		mov	[ebp+var_280], edx
		push	0
		push	0
		push	ecx
		movss	xmm0, ds:__real@00000000
		movss	[esp+568h+var_568], xmm0
		push	ecx
		movss	xmm0, ds:__real@00000000
		movss	[esp+56Ch+var_56C], xmm0
		lea	edx, [ebp+var_284]
		push	edx
		push	0
		lea	eax, [ebp+var_2A0]
		push	eax
		call	?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z ; D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE,D2D1_PIXEL_FORMAT const &,float,float,D2D1_RENDER_TARGET_USAGE,D2D1_FEATURE_LEVEL)
		add	esp, 1Ch
		mov	ecx, 7
		mov	esi, eax
		lea	edi, [ebp+var_A4]
		rep movsd
		mov	ecx, 7
		lea	esi, [ebp+var_A4]
		lea	edi, [ebp+var_84]
		rep movsd
		lea	ecx, [ebp+var_AC]
		call	??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::RefPtr<ID2D1RenderTarget>(void)
		mov	byte ptr [ebp+var_4], 7
		call	?factory@DrawTargetD2D@gfx@mozilla@@SAPAUID2D1Factory@@XZ ; mozilla::gfx::DrawTargetD2D::factory(void)
		mov	[ebp+var_520], eax
		lea	ecx, [ebp+var_AC]
		push	ecx
		lea	edx, [ebp+var_2A4]
		push	edx
		call	??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z ;	getter_AddRefs<ID2D1RenderTarget>(RefPtr<ID2D1RenderTarget> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ ; RefPtrGetterAddRefs<ID2D1RenderTarget>::operator	ID2D1RenderTarget * *(void)
		mov	esi, esp
		push	eax
		lea	eax, [ebp+var_84]
		push	eax
		lea	ecx, [ebp+var_60]
		call	??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ ; RefPtr<IDXGISurface>::operator IDXGISurface *(void)
		push	eax
		mov	ecx, [ebp+var_520]
		push	ecx
		mov	edx, [ebp+var_520]
		mov	eax, [edx]
		mov	ecx, [eax+3Ch]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		cmp	[ebp+var_58], 0
		jge	loc_1243
		mov	edx, [ebp+var_58]
		push	edx
		lea	eax, [ebp+var_368]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162135 ; "Failed to create render target. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_364]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_524], eax
		mov	edx, [ebp+var_524]
		mov	[ebp+var_528], edx
		mov	byte ptr [ebp+var_4], 8
		mov	ecx, [ebp+var_528]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 7
		lea	ecx, [ebp+var_364]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	byte ptr [ebp+var_4], 5
		lea	ecx, [ebp+var_AC]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_60]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_50]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_44] ; this
		call	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)
		jmp	loc_16D2
; ---------------------------------------------------------------------------

loc_1243:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+387j
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	[ebp+var_52C], eax
		mov	eax, [ebp+var_52C]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+var_52C]
		push	edx
		mov	eax, [ecx+0C0h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	ecx		; float
		movss	xmm0, ds:__real@00000000
		movss	[esp+55Ch+var_55C], xmm0
		push	0		; unsigned int
		lea	ecx, [ebp+var_C0] ; this
		call	??0ColorF@D2D1@@QAE@IM@Z ; D2D1::ColorF::ColorF(uint,float)
		push	eax		; struct _D3DCOLORVALUE	*
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	ecx, eax	; this
		call	?Clear@ID2D1RenderTarget@@QAEXABU_D3DCOLORVALUE@@@Z ; ID2D1RenderTarget::Clear(_D3DCOLORVALUE const &)
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	al, 7
		jz	loc_1366
		mov	ecx, [ebp+var_14]
		cvtsi2ss xmm0, dword ptr [ecx+28h]
		push	ecx
		movss	[esp+55Ch+var_55C], xmm0
		mov	edx, [ebp+var_14]
		cvtsi2ss xmm0, dword ptr [edx+24h]
		push	ecx
		movss	[esp+560h+var_560], xmm0
		push	ecx
		movss	xmm0, ds:__real@00000000
		movss	[esp+564h+var_564], xmm0
		push	ecx
		movss	xmm0, ds:__real@00000000
		movss	[esp+568h+var_568], xmm0
		lea	eax, [ebp+var_378]
		push	eax
		call	?RectF@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z ; D2D1::RectF(float,float,float,float)
		add	esp, 14h
		mov	ecx, [eax]
		mov	[ebp+var_D0], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_CC], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_C8], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_C4], edx
		push	0
		push	1
		push	ecx
		movss	xmm0, ds:__real@3f800000
		movss	[esp+564h+var_564], xmm0
		lea	eax, [ebp+var_D0]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		push	eax
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	ecx, eax
		call	?DrawBitmap@ID2D1RenderTarget@@QAEXPAUID2D1Bitmap@@ABUD2D_RECT_F@@MW4D2D1_BITMAP_INTERPOLATION_MODE@@PBU3@@Z ; ID2D1RenderTarget::DrawBitmap(ID2D1Bitmap *,D2D_RECT_F const &,float,D2D1_BITMAP_INTERPOLATION_MODE,D2D_RECT_F const *)
		jmp	loc_1452
; ---------------------------------------------------------------------------

loc_1366:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+4A6j
		lea	ecx, [ebp+var_D8]
		call	??0?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ ; RefPtr<ID2D1SolidColorBrush>::RefPtr<ID2D1SolidColorBrush>(void)
		mov	byte ptr [ebp+var_4], 9
		lea	ecx, [ebp+var_D8]
		push	ecx
		lea	edx, [ebp+var_37C]
		push	edx
		call	??$getter_AddRefs@UID2D1SolidColorBrush@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z ; getter_AddRefs<ID2D1SolidColorBrush>(RefPtr<ID2D1SolidColorBrush> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ ; RefPtrGetterAddRefs<ID2D1SolidColorBrush>::operator ID2D1SolidColorBrush *	*(void)
		push	eax		; struct ID2D1SolidColorBrush **
		push	ecx
		movss	xmm0, ds:__real@3f800000
		movss	[esp+560h+var_560], xmm0
		push	0FFFFFFh
		lea	ecx, [ebp+var_EC]
		call	??0ColorF@D2D1@@QAE@W4Enum@01@M@Z ; D2D1::ColorF::ColorF(D2D1::ColorF::Enum,float)
		push	eax		; struct _D3DCOLORVALUE	*
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	ecx, eax	; this
		call	?CreateSolidColorBrush@ID2D1RenderTarget@@QAEJABU_D3DCOLORVALUE@@PAPAUID2D1SolidColorBrush@@@Z ; ID2D1RenderTarget::CreateSolidColorBrush(_D3DCOLORVALUE const &,ID2D1SolidColorBrush *	*)
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	[ebp+var_530], eax
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_530]
		push	eax
		mov	ecx, [ebp+var_530]
		mov	edx, [ecx]
		mov	eax, [edx+80h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	[ebp+var_534], eax
		mov	esi, esp
		push	0
		push	0
		push	0
		lea	ecx, [ebp+var_D8]
		call	??B?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ ; RefPtr<ID2D1SolidColorBrush>::operator ID2D1SolidColorBrush *(void)
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		push	eax
		mov	ecx, [ebp+var_534]
		push	ecx
		mov	edx, [ebp+var_534]
		mov	eax, [edx]
		mov	ecx, [eax+64h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 7
		lea	ecx, [ebp+var_D8]
		call	??1?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ ; RefPtr<ID2D1SolidColorBrush>::~RefPtr<ID2D1SolidColorBrush>(void)

loc_1452:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+54Dj
		lea	ecx, [ebp+var_AC]
		call	??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator->(void)
		mov	[ebp+var_538], eax
		mov	esi, esp
		push	0
		push	0
		mov	edx, [ebp+var_538]
		push	edx
		mov	eax, [ebp+var_538]
		mov	ecx, [eax]
		mov	edx, [ecx+0C4h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		cmp	[ebp+var_58], 0
		jge	loc_1536
		mov	eax, [ebp+var_58]
		push	eax
		lea	ecx, [ebp+var_440]
		push	ecx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	edx, [eax]
		push	edx
		push	offset $SG162289 ; "Failed to draw bitmap. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_43C]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_53C], eax
		mov	eax, [ebp+var_53C]
		mov	[ebp+var_540], eax
		mov	byte ptr [ebp+var_4], 0Ah
		mov	ecx, [ebp+var_540]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 7
		lea	ecx, [ebp+var_43C]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	byte ptr [ebp+var_4], 5
		lea	ecx, [ebp+var_AC]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_60]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_50]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_44] ; this
		call	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)
		jmp	loc_16D2
; ---------------------------------------------------------------------------

loc_1536:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+67Aj
		mov	[ebp+var_20], 30000h
		mov	[ebp+var_28], 3
		mov	[ebp+var_24], 0
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ ; RefPtr<ID3D10Device>::operator->(void)
		mov	[ebp+var_544], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		push	ecx
		lea	edx, [ebp+var_444]
		push	edx
		call	??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	; getter_AddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ ; RefPtrGetterAddRefs<ID3D10Texture2D>::operator ID3D10Texture2D * *(void)
		mov	esi, esp
		push	eax
		push	0
		lea	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_544]
		push	ecx
		mov	edx, [ebp+var_544]
		mov	eax, [edx]
		mov	ecx, [eax+124h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		cmp	[ebp+var_58], 0
		jge	loc_1659
		mov	edx, [ebp+var_58]
		push	edx
		lea	eax, [ebp+var_508]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162295 ; "Failed to create staging texture. Code:"...
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_504]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_548], eax
		mov	edx, [ebp+var_548]
		mov	[ebp+var_54C], edx
		mov	byte ptr [ebp+var_4], 0Bh
		mov	ecx, [ebp+var_54C]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 7
		lea	ecx, [ebp+var_504]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		push	0
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??4?$RefPtr@UID3D10Texture2D@@@@QAEAAV0@PAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::operator=(ID3D10Texture2D *)
		mov	byte ptr [ebp+var_4], 5
		lea	ecx, [ebp+var_AC]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_60]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_50]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_44] ; this
		call	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)
		jmp	short loc_16D2
; ---------------------------------------------------------------------------

loc_1659:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+793j
		mov	ecx, [ebp+arg_0]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ ; RefPtr<ID3D10Device>::operator->(void)
		mov	[ebp+var_550], eax
		lea	ecx, [ebp+var_50]
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		push	eax
		mov	eax, [ebp+var_550]
		push	eax
		mov	ecx, [ebp+var_550]
		mov	edx, [ecx]
		mov	eax, [edx+84h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 5
		lea	ecx, [ebp+var_AC]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_60]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_50]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_44] ; this
		call	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)

loc_16D2:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1CFj
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+2A4j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN30
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 550h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN30		dd 6			; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+8CCo
		dd offset $LN29
$LN29		dd 0FFFFFFBCh, 2Ch	; DATA XREF: .text$mn:0000171Co
		dd offset $LN22_0	; "desc"
		dd 0FFFFFFB0h, 4
		dd offset $LN23_0	; "sourceTexture"
		dd 0FFFFFFA0h, 4
		dd offset $LN24		; "dxgiSurface"
		dd 0FFFFFF7Ch, 1Ch
		dd offset $LN25		; "rtProps"
		dd 0FFFFFF54h, 4
		dd offset $LN26		; "renderTarget"
		dd 0FFFFFF28h, 4
		dd offset $LN27		; "brush"
$LN27		db 'brush',0            ; DATA XREF: .text$mn:00001764o
$LN26		db 'renderTarget',0     ; DATA XREF: .text$mn:00001758o
$LN25		db 'rtProps',0          ; DATA XREF: .text$mn:0000174Co
$LN24		db 'dxgiSurface',0      ; DATA XREF: .text$mn:00001740o
$LN23_0		db 'sourceTexture',0    ; DATA XREF: .text$mn:00001734o
$LN22_0		db 'desc',0             ; DATA XREF: .text$mn:00001728o
		align 4

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(mozilla::gfx::DataSourceSurfaceD2D *__hidden this)
		public ??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ
??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::`scalar deleting destructor'(uint)+11p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		push	esi
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7DataSourceSurfaceD2D@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurfaceD2D::`vftable'
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		movzx	edx, byte ptr [ecx+2Ch]
		test	edx, edx
		jz	short loc_181D
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_14], eax
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_181D:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(void)+50j
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10] ; this
		call	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
		db 0Fh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int8 *__thiscall mozilla::gfx::DataSourceSurfaceD2D::GetData(mozilla::gfx::DataSourceSurfaceD2D *__hidden this)
		public ?GetData@DataSourceSurfaceD2D@gfx@mozilla@@UAEPAEXZ
?GetData@DataSourceSurfaceD2D@gfx@mozilla@@UAEPAEXZ proc near ;	DATA XREF: .rdata:00008EC8o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ ;	mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)
		mov	eax, [ebp+var_4]
		movzx	ecx, byte ptr [eax+2Ch]
		test	ecx, ecx
		jnz	short loc_1889
		xor	eax, eax
		jmp	short loc_188F
; ---------------------------------------------------------------------------

loc_1889:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::GetData(void)+1Fj
		mov	edx, [ebp+var_4]
		mov	eax, [edx+18h]

loc_188F:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::GetData(void)+23j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetData@DataSourceSurfaceD2D@gfx@mozilla@@UAEPAEXZ endp

; ---------------------------------------------------------------------------
		db 7 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall mozilla::gfx::DataSourceSurfaceD2D::Stride(mozilla::gfx::DataSourceSurfaceD2D *__hidden this)
		public ?Stride@DataSourceSurfaceD2D@gfx@mozilla@@UAEHXZ
?Stride@DataSourceSurfaceD2D@gfx@mozilla@@UAEHXZ proc near ; DATA XREF:	.rdata:00008ECCo

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ ;	mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)
		mov	eax, [ebp+var_4]
		movzx	ecx, byte ptr [eax+2Ch]
		test	ecx, ecx
		jnz	short loc_18C9
		xor	eax, eax
		jmp	short loc_18CF
; ---------------------------------------------------------------------------

loc_18C9:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Stride(void)+1Fj
		mov	edx, [ebp+var_4]
		mov	eax, [edx+1Ch]

loc_18CF:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Stride(void)+23j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Stride@DataSourceSurfaceD2D@gfx@mozilla@@UAEHXZ endp

; ---------------------------------------------------------------------------
		db 7 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> __thiscall mozilla::gfx::DataSourceSurfaceD2D::GetSize(void)const
		public ?GetSize@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ
?GetSize@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ proc near
					; DATA XREF: .rdata:00008EB0o

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+24h]
		mov	edx, [eax+28h]
		mov	eax, [ebp+arg_0]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+arg_0]
		mov	esp, ebp
		pop	ebp
		retn	4
?GetSize@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ endp

; ---------------------------------------------------------------------------
		db 8 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceFormat __thiscall mozilla::gfx::DataSourceSurfaceD2D::GetFormat(void)const
		public ?GetFormat@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ
?GetFormat@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ	proc near
					; DATA XREF: .rdata:00008EB4o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+20h]
		mov	esp, ebp
		pop	ebp
		retn
?GetFormat@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ	endp

; ---------------------------------------------------------------------------
		db 8 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual bool __thiscall mozilla::gfx::DataSourceSurfaceD2D::Map(enum	mozilla::gfx::DataSourceSurface::MapType, struct mozilla::gfx::DataSourceSurface::MappedSurface	*)
		public ?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z proc	near
					; DATA XREF: .rdata:00008ED0o

var_FC		= dword	ptr -0FCh
var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_F0		= dword	ptr -0F0h
var_EC		= byte ptr -0ECh
var_E8		= byte ptr -0E8h
var_28		= dword	ptr -28h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F0h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx

loc_1975:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+43j
		xor	eax, eax
		jnz	short loc_1975

loc_1979:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+47j
		xor	ecx, ecx
		jnz	short loc_1979
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		test	eax, eax
		jnz	short loc_1993
		xor	al, al
		jmp	loc_1AB0
; ---------------------------------------------------------------------------

loc_1993:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+56j
		cmp	[ebp+arg_0], 0
		jnz	short loc_19A2
		mov	[ebp+var_14], 1
		jmp	short loc_19B8
; ---------------------------------------------------------------------------

loc_19A2:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+63j
		cmp	[ebp+arg_0], 1
		jnz	short loc_19B1
		mov	[ebp+var_14], 2
		jmp	short loc_19B8
; ---------------------------------------------------------------------------

loc_19B1:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+72j
		mov	[ebp+var_14], 3

loc_19B8:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+6Cj
					; mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+7Bj
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_F0], eax
		mov	esi, esp
		lea	edx, [ebp+var_20]
		push	edx
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		push	0
		mov	ecx, [ebp+var_F0]
		push	ecx
		mov	edx, [ebp+var_F0]
		mov	eax, [edx]
		mov	ecx, [eax+28h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_28], eax
		cmp	[ebp+var_28], 0
		jge	short loc_1A6F
		mov	edx, [ebp+var_28]
		push	edx
		lea	eax, [ebp+var_EC]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162343 ; "Texture map	failed with code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_E8]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_F4], eax
		mov	edx, [ebp+var_F4]
		mov	[ebp+var_F8], edx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_F8]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_E8]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		xor	al, al
		jmp	short loc_1AB0
; ---------------------------------------------------------------------------

loc_1A6F:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+C5j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+var_1C]
		mov	[edx+4], eax
		mov	ecx, [ebp+arg_4]
		cmp	dword ptr [ecx], 0
		jz	short loc_1A94
		mov	[ebp+var_FC], 1
		jmp	short loc_1A9E
; ---------------------------------------------------------------------------

loc_1A94:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+152j
		mov	[ebp+var_FC], 0

loc_1A9E:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+15Ej
		mov	edx, [ebp+var_10]
		mov	al, byte ptr [ebp+var_FC]
		mov	[edx+10h], al
		mov	ecx, [ebp+var_10]
		mov	al, [ecx+10h]

loc_1AB0:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+5Aj
					; mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+139j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN21		dd 1			; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+180o
		dd offset $LN20_0
$LN20_0		dd 0FFFFFFE0h, 8	; DATA XREF: .text$mn:00001AE8o
		dd offset $LN18_0
$LN18_0		dd 70616Dh, 2 dup(0CCCCCCCCh) ;	DATA XREF: .text$mn:00001AF4o

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::DataSourceSurfaceD2D::Unmap(mozilla::gfx::DataSourceSurfaceD2D *__hidden this)
		public ?Unmap@DataSourceSurfaceD2D@gfx@mozilla@@UAEXXZ
?Unmap@DataSourceSurfaceD2D@gfx@mozilla@@UAEXXZ	proc near ; DATA XREF: .rdata:00008ED4o

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_1B1C:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::Unmap(void)+1Aj
		xor	eax, eax
		jnz	short loc_1B1C
		mov	ecx, [ebp+var_4]
		mov	byte ptr [ecx+10h], 0
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_8], eax
		mov	esi, esp
		push	0
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ecx+2Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Unmap@DataSourceSurfaceD2D@gfx@mozilla@@UAEXXZ	endp

; ---------------------------------------------------------------------------
		db 7 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(mozilla::gfx::DataSourceSurfaceD2D *__hidden this)
		public ?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ
?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::GetData(void)+11p
					; mozilla::gfx::DataSourceSurfaceD2D::Stride(void)+11p

var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_D8		= byte ptr -0D8h
var_D4		= byte ptr -0D4h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx

loc_1BA5:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+43j
		xor	eax, eax
		jnz	short loc_1BA5
		mov	ecx, [ebp+var_10]
		movzx	edx, byte ptr [ecx+2Ch]
		test	edx, edx
		jnz	short loc_1BC3
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		test	eax, eax
		jnz	short loc_1BC8

loc_1BC3:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+4Ej
		jmp	loc_1C92
; ---------------------------------------------------------------------------

loc_1BC8:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+5Dj
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_DC], eax
		mov	eax, [ebp+var_10]
		add	eax, 18h
		mov	esi, esp
		push	eax
		push	0
		push	1
		push	0
		mov	ecx, [ebp+var_DC]
		push	ecx
		mov	edx, [ebp+var_DC]
		mov	eax, [edx]
		mov	ecx, [eax+28h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_1C8B
		mov	edx, [ebp+var_14]
		push	edx
		lea	eax, [ebp+var_D8]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162364 ; "Failed to map texture. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_D4]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_E0], eax
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_E4], edx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_E4]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_D4]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		push	0
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??4?$RefPtr@UID3D10Texture2D@@@@QAEAAV0@PAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::operator=(ID3D10Texture2D *)
		jmp	short loc_1C92
; ---------------------------------------------------------------------------

loc_1C8B:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+A6j
		mov	eax, [ebp+var_10]
		mov	byte ptr [eax+2Ch], 1

loc_1C92:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void):loc_1BC3j
					; mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+125j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1CB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008860o
		mov	ecx, [ebp-10h]	; this
		jmp	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
__unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$1 proc near
					; DATA XREF: .xdata$x:00008868o
		mov	ecx, [ebp-10h]
		add	ecx, 10h
		jmp	??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)
__unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$2 proc near
					; DATA XREF: .xdata$x:00008870o
		mov	ecx, [ebp-10h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID3D10Device@@@@QAE@XZ ; RefPtr<ID3D10Device>::~RefPtr<ID3D10Device>(void)
__unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008848o
		mov	ecx, [ebp-10h]	; this
		jmp	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
__unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$1 proc near
					; DATA XREF: .xdata$x:00008850o
		mov	ecx, [ebp-10h]
		add	ecx, 10h
		jmp	??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)
__unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$2 proc near
					; DATA XREF: .xdata$x:00008858o
		mov	ecx, [ebp-10h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID3D10Device@@@@QAE@XZ ; RefPtr<ID3D10Device>::~RefPtr<ID3D10Device>(void)
__unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0 proc near
					; DATA XREF: .xdata$x:00008880o
		mov	eax, [ebp-24h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$1 proc near
					; DATA XREF: .xdata$x:00008888o
		lea	ecx, [ebp-18h]
		jmp	??1?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ	; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(void)
__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2 proc near
					; DATA XREF: .xdata$x:00008890o
		lea	ecx, [ebp-28h]
		jmp	??1?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>::~already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>(void)
__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3 proc near
					; DATA XREF: .xdata$x:00008878o
		mov	eax, [ebp-2Ch]
		and	eax, 1
		jz	locret_1D55
		and	dword ptr [ebp-2Ch], 0FFFFFFFEh
		mov	ecx, [ebp+8]
		jmp	??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::DataSourceSurface>::~already_AddRefed<mozilla::gfx::DataSourceSurface>(void)
; ---------------------------------------------------------------------------

locret_1D55:				; CODE XREF: __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3+6j
		retn
__unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ	proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-34h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008830o
		lea	ecx, [ebp-41h]	; this
		jmp	??1NoLog@gfx@mozilla@@QAE@XZ ; mozilla::gfx::NoLog::~NoLog(void)
__unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$1 proc near
					; DATA XREF: .xdata$x:00008838o
		lea	ecx, [ebp-128h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$2 proc near
					; DATA XREF: .xdata$x:00008840o
		lea	ecx, [ebp-1ECh]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-20Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008818o
		lea	ecx, [ebp-20h]
		jmp	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
__unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$1 proc near
					; DATA XREF: .xdata$x:00008820o
		lea	ecx, [ebp-140h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$2 proc near
					; DATA XREF: .xdata$x:00008828o
		lea	ecx, [ebp-22Ch]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z	proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$0 proc near
					; DATA XREF: .xdata$x:000089DCo
		mov	ecx, [ebp-14h]	; this
		jmp	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$1 proc near
					; DATA XREF: .xdata$x:000089E4o
		mov	ecx, [ebp-14h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$2 proc near
					; DATA XREF: .xdata$x:000089ECo
		lea	ecx, [ebp-44h]	; this
		jmp	??1CD3D10_TEXTURE2D_DESC@@QAE@XZ ; CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$3 proc near
					; DATA XREF: .xdata$x:000089F4o
		lea	ecx, [ebp-50h]
		jmp	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$4 proc near
					; DATA XREF: .xdata$x:000089FCo
		lea	ecx, [ebp-1B0h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$5 proc near
					; DATA XREF: .xdata$x:00008A04o
		lea	ecx, [ebp-60h]
		jmp	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$6 proc near
					; DATA XREF: .xdata$x:00008A0Co
		lea	ecx, [ebp-278h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$7 proc near
					; DATA XREF: .xdata$x:00008A14o
		lea	ecx, [ebp-0ACh]
		jmp	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$7 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$8 proc near
					; DATA XREF: .xdata$x:00008A1Co
		lea	ecx, [ebp-364h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$8 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$9 proc near
					; DATA XREF: .xdata$x:00008A24o
		lea	ecx, [ebp-0D8h]
		jmp	??1?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ ; RefPtr<ID2D1SolidColorBrush>::~RefPtr<ID2D1SolidColorBrush>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$9 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$10 proc near
					; DATA XREF: .xdata$x:00008A2Co
		lea	ecx, [ebp-43Ch]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$10 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$11 proc near
					; DATA XREF: .xdata$x:00008A34o
		lea	ecx, [ebp-504h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$11 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-550h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008808o
		mov	ecx, [ebp-10h]	; this
		jmp	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
__unwindfunclet$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ$1 proc near
					; DATA XREF: .xdata$x:00008810o
		mov	ecx, [ebp-10h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
__unwindfunclet$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ	proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-10h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z$0 proc near
					; DATA XREF: .xdata$x:00008800o
		lea	ecx, [ebp-0E8h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0FCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ$0	proc near
					; DATA XREF: .xdata$x:000087F8o
		lea	ecx, [ebp-0D4h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::already_AddRefed<class mozilla::gfx::DataSourceSurface>(struct already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2D>	&&)
		public ??$?0VDataSourceSurfaceD2D@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@@Z
??$?0VDataSourceSurfaceD2D@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+C6p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?take@?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ ; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>::take(void)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?0VDataSourceSurfaceD2D@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::NoLog & __thiscall mozilla::gfx::NoLog::operator<<<char const [32]>(char const (&)[32])
		public ??$?6$$BY0CA@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0CA@$$CBD@Z
??$?6$$BY0CA@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0CA@$$CBD@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+D8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??$?6$$BY0CA@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0CA@$$CBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger> & __thiscall mozilla::gfx::Log<2, struct	mozilla::gfx::BasicLogger>::operator<<<long>(struct mozilla::gfx::Hexa<long>)
		public ??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z
??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+204p
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+2BCp ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	ebx
		push	esi
		push	edi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_2017
		mov	esi, esp
		push	offset ?dec@std@@YAAAVios_base@1@AAV21@@Z ; std::dec(std::ios_base &)
		mov	edi, esp
		push	offset ?noshowbase@std@@YAAAVios_base@1@AAV21@@Z ; std::noshowbase(std::ios_base &)
		mov	ebx, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	eax, esp
		push	offset ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex(std::ios_base &)
		mov	ecx, esp
		push	offset ?showbase@std@@YAAAVios_base@1@AAV21@@Z ; std::showbase(std::ios_base &)
		mov	edx, [ebp+var_4]
		add	edx, 10h
		mov	[ebp+var_8], ecx
		mov	ecx, edx
		mov	[ebp+var_C], eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		mov	ecx, [ebp+var_8]
		cmp	ecx, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		mov	ecx, [ebp+var_C]
		cmp	ecx, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(long)
		cmp	ebx, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2017:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+2Ej
		mov	eax, [ebp+var_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2030h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::operator<<<std::char_traits<char>>(int, char	*Str)
		public ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+46p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+9Ap ...

var_88		= dword	ptr -88h
var_84		= dword	ptr -84h
var_7D		= byte ptr -7Dh
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_65		= byte ptr -65h
var_64		= dword	ptr -64h
var_60		= qword	ptr -60h
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_30		= byte ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch

; FUNCTION CHUNK AT 000023B4 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 000023C4 SIZE 00000068 BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 78h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_88]
		mov	ecx, 1Eh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], 0
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?length@?$char_traits@D@std@@SAIPBD@Z ;	std::char_traits<char>::length(char const *)
		add	esp, 4
		xor	ecx, ecx
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [eax+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?width@ios_base@std@@QBE_JXZ	; std::ios_base::width(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	[ebp+var_4C], edx
		cmp	[ebp+var_4C], 0
		jl	short loc_2111
		jg	short loc_20B7
		cmp	[ebp+var_50], 0
		jbe	short loc_2111

loc_20B7:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+7Fj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?width@ios_base@std@@QBE_JXZ	; std::ios_base::width(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		mov	[ebp+var_54], edx
		mov	eax, [ebp+var_54]
		cmp	eax, [ebp+var_18]
		jl	short loc_2111
		jg	short loc_20E9
		mov	ecx, [ebp+var_58]
		cmp	ecx, [ebp+var_1C]
		jbe	short loc_2111

loc_20E9:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+AFj
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [eax+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?width@ios_base@std@@QBE_JXZ	; std::ios_base::width(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+var_1C]
		sbb	edx, [ebp+var_18]
		mov	dword ptr [ebp+var_60],	eax
		mov	dword ptr [ebp+var_60+4], edx
		jmp	short loc_211A
; ---------------------------------------------------------------------------

loc_2111:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+7Dj
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+85j ...
		xorpd	xmm0, xmm0
		movlpd	[ebp+var_60], xmm0

loc_211A:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+DFj
		mov	ecx, dword ptr [ebp+var_60]
		mov	[ebp+var_24], ecx
		mov	edx, dword ptr [ebp+var_60+4]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_30]
		call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_30]
		call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(void)
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_2156
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx
		jmp	loc_23C4
; ---------------------------------------------------------------------------

loc_2156:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+116j
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx	; this
		call	dword ptr ds:__imp_?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_64]
		and	eax, 1C0h
		cmp	eax, 40h ; '@'
		jz	loc_2241
		jmp	short loc_219E
; ---------------------------------------------------------------------------

loc_218C:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *):loc_223Cj
		mov	ecx, [ebp+var_24]
		sub	ecx, 1
		mov	edx, [ebp+var_20]
		sbb	edx, 0
		mov	[ebp+var_24], ecx
		mov	[ebp+var_20], edx

loc_219E:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+15Aj
		cmp	[ebp+var_20], 0
		jl	loc_2241
		jg	short loc_21B4
		cmp	[ebp+var_24], 0
		jbe	loc_2241

loc_21B4:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+178j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char>>::fill(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_65], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		mov	esi, esp
		movzx	eax, [ebp+var_65]
		push	eax
		mov	ecx, [ebp+var_6C]
		call	dword ptr ds:__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char>>::sputc(char)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_70], eax
		mov	ecx, [ebp+var_70]
		mov	[ebp+var_38], ecx
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_3C], eax
		lea	edx, [ebp+var_38]
		push	edx
		lea	eax, [ebp+var_3C]
		push	eax
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_223C
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx
		jmp	short loc_2241
; ---------------------------------------------------------------------------

loc_223C:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1FFj
		jmp	loc_218C
; ---------------------------------------------------------------------------

loc_2241:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+154j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+172j	...
		cmp	[ebp+var_14], 0
		jnz	short loc_22A3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_1C]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		mov	ecx, [ebp+var_74]
		call	dword ptr ds:__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::sputn(char const *,__int64)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7C], eax
		mov	[ebp+var_78], edx
		mov	eax, [ebp+var_7C]
		cmp	eax, [ebp+var_1C]
		jnz	short loc_229A
		mov	ecx, [ebp+var_78]
		cmp	ecx, [ebp+var_18]
		jz	short loc_22A3

loc_229A:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+260j
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx

loc_22A3:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+215j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+268j
		cmp	[ebp+var_14], 0
		jnz	loc_236C
		jmp	short loc_22C1
; ---------------------------------------------------------------------------

loc_22AF:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *):loc_2367j
		mov	eax, [ebp+var_24]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		sbb	ecx, 0
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], ecx

loc_22C1:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+27Dj
		cmp	[ebp+var_20], 0
		jl	loc_236C
		jg	short loc_22D7
		cmp	[ebp+var_24], 0
		jbe	loc_236C

loc_22D7:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+29Bj
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [eax+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char>>::fill(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7D], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_84], eax
		mov	esi, esp
		movzx	eax, [ebp+var_7D]
		push	eax
		mov	ecx, [ebp+var_84]
		call	dword ptr ds:__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char>>::sputc(char)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_88], eax
		mov	ecx, [ebp+var_88]
		mov	[ebp+var_40], ecx
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_44], eax
		lea	edx, [ebp+var_40]
		push	edx
		lea	eax, [ebp+var_44]
		push	eax
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_2367
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx
		jmp	short loc_236C
; ---------------------------------------------------------------------------

loc_2367:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+32Aj
		jmp	loc_22AF
; ---------------------------------------------------------------------------

loc_236C:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+277j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+295j	...
		mov	esi, esp
		push	0
		push	0		; __int64
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	ecx, edx	; this
		call	dword ptr ds:__imp_?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width(__int64)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_23B4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z endp


; =============== S U B	R O U T	I N E =======================================


__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0 proc near
					; DATA XREF: .xdata$x:00008A44o
		mov	esi, esp
		push	1
		push	4
		mov	eax, [ebp+8]
		mov	ecx, [eax]
		mov	edx, [ebp+8]
		add	edx, [ecx+4]
		mov	ecx, edx
		call	dword ptr ds:__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z	; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset $LN23_1
		retn
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0 endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z

loc_23B4:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+35Cj
		mov	[ebp+var_4], 0
		jmp	short loc_23C4
; END OF FUNCTION CHUNK	FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z

; =============== S U B	R O U T	I N E =======================================


$LN23_1		proc near		; DATA XREF: __catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0+20o
		mov	dword ptr [ebp-4], 0
$LN23_1		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z

loc_23C4:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+121j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+38Bj
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]
		call	dword ptr ds:__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z	; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_48], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_30]
		call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ;	std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)
		mov	eax, [ebp+var_48]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN32
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 88h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
; END OF FUNCTION CHUNK	FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
; ---------------------------------------------------------------------------
$LN32		dd 1			; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+3D0o
		dd offset $LN31
$LN31		dd 0FFFFFFD0h, 8	; DATA XREF: .text$mn:00002430o
		dd offset $LN29_0
$LN29_0		dd 6B4F5Fh		; DATA XREF: .text$mn:0000243Co
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2444h
; COMDAT (pick associative to section at 2030)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 proc near
					; DATA XREF: .xdata$x:00008A60o
		lea	ecx, [ebp-30h]
		jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ;	std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z	proc near
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 246Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl operator==<struct ID3D10Device, struct ID3D10Device1>(class RefPtr<struct ID3D10Device> const &,	struct ID3D10Device1 *)
		public ??$?8UID3D10Device@@UID3D10Device1@@@@YA_NABV?$RefPtr@UID3D10Device@@@@PAUID3D10Device1@@@Z
??$?8UID3D10Device@@UID3D10Device1@@@@YA_NABV?$RefPtr@UID3D10Device@@@@PAUID3D10Device1@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::IsValid(void)+1Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	ecx, [ebp+arg_0]
		call	?get@?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ ;	RefPtr<ID3D10Device>::get(void)
		cmp	eax, [ebp+arg_4]
		jnz	short loc_248D
		mov	[ebp+var_4], 1
		jmp	short loc_2494
; ---------------------------------------------------------------------------

loc_248D:				; CODE XREF: operator==<ID3D10Device,ID3D10Device1>(RefPtr<ID3D10Device> const &,ID3D10Device1 *)+16j
		mov	[ebp+var_4], 0

loc_2494:				; CODE XREF: operator==<ID3D10Device,ID3D10Device1>(RefPtr<ID3D10Device> const &,ID3D10Device1 *)+1Fj
		mov	al, byte ptr [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$?8UID3D10Device@@UID3D10Device1@@@@YA_NABV?$RefPtr@UID3D10Device@@@@PAUID3D10Device1@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: long __stdcall IUnknown::QueryInterface<struct IDXGISurface>(struct IDXGISurface * *)
		public ??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z
??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+5Bp
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+204p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		push	offset __GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [edx]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn	8
??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_RECT_F __cdecl D2D1::Rect<float>(float, float, float, float)
		public ??$Rect@M@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z
??$Rect@M@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z	proc near
					; CODE XREF: D2D1::RectF(float,float,float,float)+60p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		movss	xmm0, [ebp+arg_4]
		movss	[ebp+var_18], xmm0
		movss	xmm0, [ebp+arg_8]
		movss	[ebp+var_14], xmm0
		movss	xmm0, [ebp+arg_C]
		movss	[ebp+var_10], xmm0
		movss	xmm0, [ebp+arg_10]
		movss	[ebp+var_C], xmm0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	[eax], ecx
		mov	edx, [ebp+var_14]
		mov	[eax+4], edx
		mov	ecx, [ebp+var_10]
		mov	[eax+8], ecx
		mov	edx, [ebp+var_C]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
??$Rect@M@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_3		dd 1			; DATA XREF: D2D1::Rect<float>(float,float,float,float)+73o
		dd offset $LN4_3
$LN4_3		dd 0FFFFFFE8h, 10h	; DATA XREF: .text$mn:0000256Co
		dd offset $LN3_3	; "rect"
$LN3_3		db 'rect',0             ; DATA XREF: .text$mn:00002578o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2584h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_SIZE_U __cdecl D2D1::Size<unsigned	int>(unsigned int, unsigned int)
		public ??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z
??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z proc near	; CODE XREF: D2D1::SizeU(uint,uint)+1Cp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_2		dd 1			; DATA XREF: D2D1::Size<uint>(uint,uint)+2Do
		dd offset $LN4_2
$LN4_2		dd 0FFFFFFF4h, 8	; DATA XREF: .text$mn:000025C8o
		dd offset $LN3_2	; "size"
$LN3_2		db 'size',0             ; DATA XREF: .text$mn:000025D4o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 25E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::_Allocate<char>(unsigned int, char *)
		public ??$_Allocate@D@std@@YAPADIPAD@Z
??$_Allocate@D@std@@YAPADIPAD@Z	proc near
					; CODE XREF: std::allocator<char>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_25FB
		jmp	short loc_2625
; ---------------------------------------------------------------------------

loc_25FB:				; CODE XREF: std::_Allocate<char>(uint,char *)+17j
		cmp	[ebp+arg_0], 0FFFFFFFFh
		ja	short loc_2616
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_2625

loc_2616:				; CODE XREF: std::_Allocate<char>(uint,char *)+1Fj
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2625:				; CODE XREF: std::_Allocate<char>(uint,char *)+19j
					; std::_Allocate<char>(uint,char *)+34j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@D@std@@YAPADIPAD@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2638h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
		public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
					; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_2653
		jmp	short loc_2683
; ---------------------------------------------------------------------------

loc_2653:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+17j
		cmp	[ebp+arg_0], 1FFFFFFFh
		ja	short loc_2674
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_2683

loc_2674:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2683:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+19j
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Aj
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2698h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<char>(int, wchar_t *,	unsigned int)
		public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+1Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+22p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_26C1
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_26C1:				; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::addressof<char>(char &)
		public ??$addressof@D@std@@YAPADAAD@Z
??$addressof@D@std@@YAPADAAD@Z proc near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p
					; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p	...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$addressof@D@std@@YAPADAAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::construct<char *,char *	&>(void	*, int)
		public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+5Ep
					; $LN19+4Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_4]
		push	edx		; int
		call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ;	std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2710h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::construct<char *,char * &>(void *, int)
		public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char	* &>(std::allocator<char> &,char * *,char * &)+17p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	4		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_2782
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		mov	edx, [ebp+var_18]
		mov	eax, [eax]
		mov	[edx], eax
		mov	ecx, [ebp+var_18]
		mov	[ebp+var_1C], ecx
		jmp	short loc_2789
; ---------------------------------------------------------------------------

loc_2782:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+55j
		mov	[ebp+var_1C], 0

loc_2789:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+70j
		mov	edx, [ebp+var_1C]
		mov	[ebp+var_14], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 27B4h
; COMDAT (pick associative to section at 2710)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
					; DATA XREF: .xdata$x:00008AF4o
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 27E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void	*, int)
		public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+23p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		mov	ecx, [ebp+arg_0]
		call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char	* &>(char * *,char * &)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2808h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
		public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+49p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	8		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_2880
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
		add	esp, 4
		mov	edx, [eax]
		mov	eax, [eax+4]
		mov	ecx, [ebp+var_18]
		mov	[ecx], edx
		mov	[ecx+4], eax
		mov	edx, [ebp+var_18]
		mov	[ebp+var_1C], edx
		jmp	short loc_2887
; ---------------------------------------------------------------------------

loc_2880:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+55j
		mov	[ebp+var_1C], 0

loc_2887:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+76j
		mov	eax, [ebp+var_1C]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 28B0h
; COMDAT (pick associative to section at 2808)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
					; DATA XREF: .xdata$x:00008AC8o
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc	near
					; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+4Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		push	ecx
		call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 290Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char *	*)+Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2920h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
		public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ;	std::allocator<char>::destroy<char *>(char * *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2938h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<struct	std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
		public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+3Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 294Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * & __cdecl std::forward<char * &>(char * &)
		public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+12p
					; std::allocator<char>::construct<char *,char *	&>(char	* *,char * &)+5Bp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2954h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
		public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc	near
					; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5Bp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 295Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> && __cdecl std::forward<class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>>>(class std::basic_string<char, struct std::char_traits<char>, class	std::allocator<char>> &)
		public ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+3Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2964h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID2D1Bitmap>	__cdecl	getter_AddRefs<struct ID2D1Bitmap>(class RefPtr<struct ID2D1Bitmap> &)
		public ??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z
??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+17Ep
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1C5p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z ; RefPtrGetterAddRefs<ID2D1Bitmap>::RefPtrGetterAddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2980h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID2D1RenderTarget> __cdecl getter_AddRefs<struct ID2D1RenderTarget>(class RefPtr<struct ID2D1RenderTarget> &)
		public ??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z
??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+343p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z	; RefPtrGetterAddRefs<ID2D1RenderTarget>::RefPtrGetterAddRefs<ID2D1RenderTarget>(RefPtr<ID2D1RenderTarget> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 299Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID2D1SolidColorBrush> __cdecl getter_AddRefs<struct ID2D1SolidColorBrush>(class RefPtr<struct ID2D1SolidColorBrush> &)
		public ??$getter_AddRefs@UID2D1SolidColorBrush@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z
??$getter_AddRefs@UID2D1SolidColorBrush@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+56Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAE@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z ;	RefPtrGetterAddRefs<ID2D1SolidColorBrush>::RefPtrGetterAddRefs<ID2D1SolidColorBrush>(RefPtr<ID2D1SolidColorBrush> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID2D1SolidColorBrush@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 29B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID3D10Device> __cdecl getter_AddRefs<struct ID3D10Device>(class RefPtr<struct ID3D10Device> &)
		public ??$getter_AddRefs@UID3D10Device@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Device@@@@AAV?$RefPtr@UID3D10Device@@@@@Z
??$getter_AddRefs@UID3D10Device@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Device@@@@AAV?$RefPtr@UID3D10Device@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+2A1p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID3D10Device@@@@QAE@AAV?$RefPtr@UID3D10Device@@@@@Z ;	RefPtrGetterAddRefs<ID3D10Device>::RefPtrGetterAddRefs<ID3D10Device>(RefPtr<ID3D10Device> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID3D10Device@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Device@@@@AAV?$RefPtr@UID3D10Device@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 29D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID3D10Texture2D> __cdecl getter_AddRefs<struct ID3D10Texture2D>(class RefPtr<struct ID3D10Texture2D>	&)
		public ??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z
??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+10Ap
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+756p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z ; RefPtrGetterAddRefs<ID3D10Texture2D>::RefPtrGetterAddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 29F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct IDXGISurface> __cdecl getter_AddRefs<struct IDXGISurface>(class RefPtr<struct IDXGISurface> &)
		public ??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z
??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1EBp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z ;	RefPtrGetterAddRefs<IDXGISurface>::RefPtrGetterAddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct mozilla::gfx::Hexa<long> __cdecl mozilla::gfx::hexa<long>(long)
		public ??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z
??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1B6p
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+26Ep ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$Hexa@J@gfx@mozilla@@QAE@J@Z ; mozilla::gfx::Hexa<long>::Hexa<long>(long)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::Atomic<unsigned int, 2, void>::Atomic<unsigned int, 2, void>(unsigned int)
		public ??0?$Atomic@I$01X@mozilla@@QAE@I@Z
??0?$Atomic@I$01X@mozilla@@QAE@I@Z proc	near
					; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::RefCounted<mozilla::gfx::SourceSurface,0>(void)+13p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z ; mozilla::detail::AtomicBaseIncDec<uint,2>::AtomicBaseIncDec<uint,2>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$Atomic@I$01X@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::detail::AtomicBase<unsigned int, 2>::AtomicBase<unsigned int, 2>(unsigned	int)
		public ??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z
??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z proc near
					; CODE XREF: mozilla::detail::AtomicBaseIncDec<uint,2>::AtomicBaseIncDec<uint,2>(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z ; mozilla::detail::ToStorageTypeArgument<uint>::convert(uint)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$atomic@I@std@@QAE@I@Z ; std::atomic<uint>::atomic<uint>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::detail::AtomicBaseIncDec<unsigned	int, 2>::AtomicBaseIncDec<unsigned int,	2>(unsigned int)
		public ??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z
??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z proc	near
					; CODE XREF: mozilla::Atomic<uint,2,void>::Atomic<uint,2,void>(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z ; mozilla::detail::AtomicBase<uint,2>::AtomicBase<uint,2>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AC0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::AtomicRefCounted<class mozilla::gfx::SourceSurface>(void)
		public ??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ
??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+33p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::RefCounted<mozilla::gfx::SourceSurface,0>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::BaseSize<int, struct	mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>::BaseSize<int, struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>(int, int)
		public ??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z
??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z proc near
					; CODE XREF: mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(int,int)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B10h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::BaseSize<int, struct	mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>::BaseSize<int, struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>(void)
		public ??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Hexa<long>::Hexa<long>(long)
		public ??0?$Hexa@J@gfx@mozilla@@QAE@J@Z
??0?$Hexa@J@gfx@mozilla@@QAE@J@Z proc near ; CODE XREF:	mozilla::gfx::hexa<long>(long)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$Hexa@J@gfx@mozilla@@QAE@J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>::IntSizeTyped<struct	mozilla::gfx::UnknownUnits>(int, int)
		public ??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z
??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+121p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z ; mozilla::gfx::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>(int,int)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>::IntSizeTyped<struct	mozilla::gfx::UnknownUnits>(void)
		public ??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+69p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BB4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::Log<2, struct mozilla::gfx::BasicLogger>(int, enum	 mozilla::gfx::LogReason)
		public ??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1D9p
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+291p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		push	1
		push	3
		mov	ecx, [ebp+var_10]
		call	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax+0B0h], 0
		mov	ecx, [ebp+var_10]
		mov	byte ptr [ecx+0B8h], 0
		mov	edx, [ebp+arg_4]
		push	edx
		push	2		; int
		call	?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z ;	mozilla::gfx::BasicLogger::ShouldOutputMessage(int)
		add	esp, 4
		movzx	eax, al
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		call	?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2C50h
; COMDAT (pick associative to section at 2BB4)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0 proc near
					; DATA XREF: .xdata$x:0000876Co
		mov	ecx, [ebp-10h]
		jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
__unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C74h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::RefCounted<class mozilla::gfx::SourceSurface, 0>(void)
		public ??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ
??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	proc near
					; CODE XREF: mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::AtomicRefCounted<mozilla::gfx::SourceSurface>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	??0?$Atomic@I$01X@mozilla@@QAE@I@Z ; mozilla::Atomic<uint,2,void>::Atomic<uint,2,void>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1Bitmap>::RefPtr<struct ID2D1Bitmap>(void)
		public ??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ
??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+4Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CC0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1RenderTarget>::RefPtr<struct ID2D1RenderTarget>(void)
		public ??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ
??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+321p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1SolidColorBrush>::RefPtr<struct	ID2D1SolidColorBrush>(void)
		public ??0?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ
??0?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+558p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D00h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Device>::RefPtr<struct	ID3D10Device>(void)
		public ??0?$RefPtr@UID3D10Device@@@@QAE@XZ
??0?$RefPtr@UID3D10Device@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+5Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID3D10Device@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::RefPtr<struct ID3D10Texture2D>(struct ID3D10Texture2D *)
		public ??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z
??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z proc	near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+64p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		cmp	dword ptr [edx], 0
		jz	short loc_2D4C
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		call	?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::AddRef(ID3D10Texture2D *)
		add	esp, 4

loc_2D4C:				; CODE XREF: RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(ID3D10Texture2D *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::RefPtr<struct ID3D10Texture2D>(void)
		public ??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ
??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+E5p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDXGISurface>::RefPtr<struct	IDXGISurface>(void)
		public ??0?$RefPtr@UIDXGISurface@@@@QAE@XZ
??0?$RefPtr@UIDXGISurface@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+47p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1D7p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UIDXGISurface@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>(class mozilla::gfx::DataSourceSurfaceD2D *)
		public ??0?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
??0?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+84p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		cmp	dword ptr [edx], 0
		jz	short loc_2DCC
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		call	?AddRef@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2D>::AddRef(mozilla::gfx::DataSourceSurfaceD2D *)
		add	esp, 4

loc_2DCC:				; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(mozilla::gfx::DataSourceSurfaceD2D *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1Bitmap>::RefPtrGetterAddRefs<struct ID2D1Bitmap>(class RefPtr<struct ID2D1Bitmap> &)
		public ??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z
??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E00h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1RenderTarget>::RefPtrGetterAddRefs<struct ID2D1RenderTarget>(class	RefPtr<struct ID2D1RenderTarget> &)
		public ??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z
??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z	proc near
					; CODE XREF: getter_AddRefs<ID2D1RenderTarget>(RefPtr<ID2D1RenderTarget> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1SolidColorBrush>::RefPtrGetterAddRefs<struct ID2D1SolidColorBrush>(class RefPtr<struct ID2D1SolidColorBrush> &)
		public ??0?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAE@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z
??0?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAE@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID2D1SolidColorBrush>(RefPtr<ID2D1SolidColorBrush> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAE@AAV?$RefPtr@UID2D1SolidColorBrush@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E40h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10Device>::RefPtrGetterAddRefs<struct ID3D10Device>(class RefPtr<struct ID3D10Device> &)
		public ??0?$RefPtrGetterAddRefs@UID3D10Device@@@@QAE@AAV?$RefPtr@UID3D10Device@@@@@Z
??0?$RefPtrGetterAddRefs@UID3D10Device@@@@QAE@AAV?$RefPtr@UID3D10Device@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID3D10Device>(RefPtr<ID3D10Device> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID3D10Device@@@@QAE@AAV?$RefPtr@UID3D10Device@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10Texture2D>::RefPtrGetterAddRefs<struct ID3D10Texture2D>(class RefPtr<struct ID3D10Texture2D> &)
		public ??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z
??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDXGISurface>::RefPtrGetterAddRefs<struct IDXGISurface>(class RefPtr<struct IDXGISurface> &)
		public ??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z
??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z proc near
					; CODE XREF: getter_AddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
		public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+27p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+42p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2F0Ch
; COMDAT (pick associative to section at 2EA0)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00008578o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
		public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+14h], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<char>::allocator<char>(void)
		public ??0?$allocator@D@std@@QAE@XZ
??0?$allocator@D@std@@QAE@XZ proc near	; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+11p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+39p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@D@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
		public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+1Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::already_AddRefed<class mozilla::gfx::DataSourceSurface>(void (__thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::*)(double, float))
		public ??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z
??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+F6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FF0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2D>::already_AddRefed<class	mozilla::gfx::DataSourceSurfaceD2D>(class mozilla::gfx::DataSourceSurfaceD2D *)
		public ??0?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
??0?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::forget(void)+3Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3010h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::atomic<unsigned int>::atomic<unsigned	int>(unsigned int)
		public ??0?$atomic@I@std@@QAE@I@Z
??0?$atomic@I@std@@QAE@I@Z proc	near	; CODE XREF: mozilla::detail::AtomicBase<uint,2>::AtomicBase<uint,2>(uint)+1Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	??4atomic_uint@std@@QAEII@Z ; std::atomic_uint::operator=(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$atomic@I@std@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3040h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>	&&)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+CAp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+159p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_8+3]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z	; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+84p
					; std::_Generic_error_category::message(int)+57p ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	eax, [ebp+Str]
		push	eax		; Str
		mov	ecx, [ebp+var_10]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 312Ch
; COMDAT (pick associative to section at 30A0)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
					; DATA XREF: .xdata$x:000085FCo
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3150h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void *Src, size_t Size)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+BEp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+14Dp

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	ecx, [ebp+var_10]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char	const *,uint)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 31E0h
; COMDAT (pick associative to section at 3150)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0 proc near
					; DATA XREF: .xdata$x:000085D0o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3204h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+179p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3284h
; COMDAT (pick associative to section at 3204)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000085A4o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc	near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 32A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>(int)
		public ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc	near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+D4p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		push	esi
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_10]
		call	dword ptr ds:__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@	; const	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 40h ; '@'
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		call	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)
		push	eax		; int
		push	0		; Size
		push	0		; Src
		mov	ecx, [ebp+var_10]
		call	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3344h
; COMDAT (pick associative to section at 32A8)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0 proc near
					; DATA XREF: .xdata$x:00008740o
		mov	esi, esp
		mov	ecx, [ebp-10h]
		call	dword ptr ds:__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc near
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3374h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class	std::allocator<char>>::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>(int)
		public ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+34p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		push	esi
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_14], 0
		cmp	[ebp+arg_4], 0
		jz	short loc_33F0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbtable'{for `std::basic_istream<char,std::char_traits<char>>'}
		mov	ecx, [ebp+var_10]
		mov	dword ptr [ecx+10h], offset ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbtable'{for `std::basic_ostream<char,std::char_traits<char>>'}
		mov	ecx, [ebp+var_10]
		add	ecx, 68h ; 'h'
		mov	esi, esp
		call	dword ptr ds:__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	edx, [ebp+var_14]
		or	edx, 1
		mov	[ebp+var_14], edx

loc_33F0:				; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+42j
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_10]
		add	eax, 18h
		push	eax
		mov	ecx, [ebp+var_10]
		call	dword ptr ds:__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(std::basic_streambuf<char,std::char_traits<char>> *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		mov	ecx, [ebp+var_10]
		mov	dword ptr [ecx+eax], offset ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	edx, [ebp+var_10]
		mov	eax, [edx]
		mov	ecx, [eax+4]
		sub	ecx, 68h ; 'h'
		mov	edx, [ebp+var_10]
		mov	eax, [edx]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_10]
		mov	[eax+edx-4], ecx
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		add	ecx, 18h
		call	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3474h
; COMDAT (pick associative to section at 3374)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0	proc near
					; DATA XREF: .xdata$x:0000870Co
		mov	eax, [ebp-14h]
		and	eax, 1
		jz	$LN5_7
		and	dword ptr [ebp-14h], 0FFFFFFFEh
		mov	ecx, [ebp-10h]
		add	ecx, 68h ; 'h'
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN5_7:					; CODE XREF: __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0+6j
		retn
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1	proc near
					; DATA XREF: .xdata$x:00008714o
		mov	ecx, [ebp-10h]
		add	ecx, 20h ; ' '
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc near
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-10h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::fpos<int>::fpos<int>(__int64)
		public ??0?$fpos@H@std@@QAE@_J@Z
??0?$fpos@H@std@@QAE@_J@Z proc near	; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+3A2p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+2BFp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+arg_4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+10h], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$fpos@H@std@@QAE@_J@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 350Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall CD3D10_TEXTURE2D_DESC::CD3D10_TEXTURE2D_DESC(CD3D10_TEXTURE2D_DESC *this, enum DXGI_FORMAT,	unsigned int, unsigned int, unsigned int, unsigned int,	unsigned int, enum D3D10_USAGE,	unsigned int, unsigned int, unsigned int, unsigned int)
		public ??0CD3D10_TEXTURE2D_DESC@@QAE@W4DXGI_FORMAT@@IIIIIW4D3D10_USAGE@@IIII@Z
??0CD3D10_TEXTURE2D_DESC@@QAE@W4DXGI_FORMAT@@IIIIIW4D3D10_USAGE@@IIII@Z	proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+C4p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
arg_20		= dword	ptr  28h
arg_24		= dword	ptr  2Ch
arg_28		= dword	ptr  30h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_8]
		mov	[edx+4], eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+arg_10]
		mov	[ecx+8], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_C]
		mov	[eax+0Ch], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx+10h], eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+arg_20]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_24]
		mov	[eax+18h], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_18]
		mov	[edx+1Ch], eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+arg_14]
		mov	[ecx+20h], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_1C]
		mov	[eax+24h], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_28]
		mov	[edx+28h], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	2Ch
??0CD3D10_TEXTURE2D_DESC@@QAE@W4DXGI_FORMAT@@IIIIIW4D3D10_USAGE@@IIII@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3588h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall D2D1::ColorF::ColorF(D2D1::ColorF *this, unsigned int, float)
		public ??0ColorF@D2D1@@QAE@IM@Z
??0ColorF@D2D1@@QAE@IM@Z proc near	; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+476p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	ecx		; float
		movss	xmm0, [ebp+arg_4]
		movss	[esp+8+var_8], xmm0
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_4] ; this
		call	?Init@ColorF@D2D1@@AAEXIM@Z ; D2D1::ColorF::Init(uint,float)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0ColorF@D2D1@@QAE@IM@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall D2D1::ColorF::ColorF(enum	D2D1::ColorF::Enum, float)
		public ??0ColorF@D2D1@@QAE@W4Enum@01@M@Z
??0ColorF@D2D1@@QAE@W4Enum@01@M@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+598p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	ecx		; float
		movss	xmm0, [ebp+arg_4]
		movss	[esp+8+var_8], xmm0
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_4] ; this
		call	?Init@ColorF@D2D1@@AAEXIM@Z ; D2D1::ColorF::Init(uint,float)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0ColorF@D2D1@@QAE@W4Enum@01@M@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurface::DataSourceSurface(mozilla::gfx::DataSourceSurface *__hidden this)
		public ??0DataSourceSurface@gfx@mozilla@@QAE@XZ
??0DataSourceSurface@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+47p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0SourceSurface@gfx@mozilla@@QAE@XZ ; mozilla::gfx::SourceSurface::SourceSurface(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7DataSourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurface::`vftable'
		mov	ecx, [ebp+var_4]
		mov	byte ptr [ecx+10h], 0
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0DataSourceSurface@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3630h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::NoLog::NoLog(mozilla::gfx::NoLog *__hidden this)
		public ??0NoLog@gfx@mozilla@@QAE@XZ
??0NoLog@gfx@mozilla@@QAE@XZ proc near	; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+B4p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0NoLog@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3648h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurface::SourceSurface(mozilla::gfx::SourceSurface *__hidden this)
		public ??0SourceSurface@gfx@mozilla@@QAE@XZ
??0SourceSurface@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+30p
					; mozilla::gfx::DataSourceSurface::DataSourceSurface(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		add	ecx, 4
		call	??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurface::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 8		; this
		call	??0UserData@gfx@mozilla@@QAE@XZ	; mozilla::gfx::UserData::UserData(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0SourceSurface@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 36C0h
; COMDAT (pick associative to section at 3648)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000086E0o
		mov	ecx, [ebp-10h]
		add	ecx, 4
		jmp	??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
__unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SourceSurface@gfx@mozilla@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::UserData::UserData(mozilla::gfx::UserData *__hidden this)
		public ??0UserData@gfx@mozilla@@QAE@XZ
??0UserData@gfx@mozilla@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+4Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0UserData@gfx@mozilla@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3710h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
		public ??0_Container_proxy@std@@QAE@XZ
??0_Container_proxy@std@@QAE@XZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+3Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0_Container_proxy@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3738h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
		public ??0_Generic_error_category@std@@QAE@XZ
??0_Generic_error_category@std@@QAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+11p
					; std::_System_error_category::_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0error_category@std@@QAE@XZ ;	std::error_category::error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Generic_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3768h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??0_Iostream_error_category@std@@QAE@XZ
??0_Iostream_error_category@std@@QAE@XZ	proc near
					; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Iostream_error_category@std@@6B@ ;	const std::_Iostream_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Iostream_error_category@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3798h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Sentry_base::_Sentry_base(class std::basic_ostream<char,	struct std::char_traits<char>> &)
		public ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+35p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		add	ecx, [edx+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_381C
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_C], ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_C]
		add	ecx, [eax+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10], eax
		mov	ecx, [ebp+var_10]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, [ebp+var_10]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_381C:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char>> &)+47j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3830h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
		public ??0_System_error_category@std@@QAE@XZ
??0_System_error_category@std@@QAE@XZ proc near
					; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_System_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3860h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
		public ??0error_category@std@@QAE@XZ
??0error_category@std@@QAE@XZ proc near	; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0error_category@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3880h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct	std::error_category *)
		public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+36p
					; std::_System_error_category::default_error_condition(int)+4Fp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::sentry(class std::basic_ostream<char, struct std::char_traits<char>> &)
		public ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+FDp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		push	esi
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char>>	&)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jz	short loc_3976
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_3976
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, [ebp+arg_0]
		jz	short loc_3976
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, eax
		call	dword ptr ds:__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char>>::flush(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3976:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+60j
					; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+7Ej ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx	; this
		call	dword ptr ds:__imp_?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_10]
		mov	[ecx+4], al
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 39C0h
; COMDAT (pick associative to section at 38A8)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0 proc near
					; DATA XREF: .xdata$x:00008A9Co
		mov	ecx, [ebp-10h]
		jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z	proc near
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::~AtomicRefCounted<class mozilla::gfx::SourceSurface>(void)
		public ??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ
??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0+6j
					; mozilla::gfx::SourceSurface::~SourceSurface(void)+55p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::~RefCounted<mozilla::gfx::SourceSurface,0>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::~Log<2, struct mozilla::gfx::BasicLogger>(void)
		public ??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+216p
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+2CEp ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10]
		call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3A6Ch
; COMDAT (pick associative to section at 3A08)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008798o
		mov	ecx, [ebp-10h]
		jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
__unwindfunclet$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::~RefCounted<class mozilla::gfx::SourceSurface, 0>(void)
		public ??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ
??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	proc near
					; CODE XREF: mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_3A9E:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::~RefCounted<mozilla::gfx::SourceSurface,0>(void)+10j
		xor	eax, eax
		jnz	short loc_3A9E
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3AA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1Bitmap>::~RefPtr<struct	ID2D1Bitmap>(void)
		public ??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ
??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+89p
					; __unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$1+6j	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3ACC
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z ;	RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::Release(ID2D1Bitmap *)
		add	esp, 4

loc_3ACC:				; CODE XREF: RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3ADCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1RenderTarget>::~RefPtr<struct ID2D1RenderTarget>(void)
		public ??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ
??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+401p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+6F4p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3B00
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	; RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::Release(ID2D1RenderTarget	*)
		add	esp, 4

loc_3B00:				; CODE XREF: RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B10h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1SolidColorBrush>::~RefPtr<struct ID2D1SolidColorBrush>(void)
		public ??1?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ
??1?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+639p
					; __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$9+6j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3B34
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID2D1SolidColorBrush@@@?$RefPtr@UID2D1SolidColorBrush@@@@SAXPAUID2D1SolidColorBrush@@@Z ; RefPtr<ID2D1SolidColorBrush>::AddRefTraits<ID2D1SolidColorBrush>::Release(ID2D1SolidColorBrush *)
		add	esp, 4

loc_3B34:				; CODE XREF: RefPtr<ID2D1SolidColorBrush>::~RefPtr<ID2D1SolidColorBrush>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID2D1SolidColorBrush@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B44h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Device>::~RefPtr<struct ID3D10Device>(void)
		public ??1?$RefPtr@UID3D10Device@@@@QAE@XZ
??1?$RefPtr@UID3D10Device@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+7Ap
					; __unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$2+6j	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3B68
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::AddRefTraits<ID3D10Device>::Release(ID3D10Device *)
		add	esp, 4

loc_3B68:				; CODE XREF: RefPtr<ID3D10Device>::~RefPtr<ID3D10Device>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID3D10Device@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::~RefPtr<struct ID3D10Texture2D>(void)
		public ??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ
??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1BEp
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+293p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3B9C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::Release(ID3D10Texture2D *)
		add	esp, 4

loc_3B9C:				; CODE XREF: RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDXGISurface>::~RefPtr<struct IDXGISurface>(void)
		public ??1?$RefPtr@UIDXGISurface@@@@QAE@XZ
??1?$RefPtr@UIDXGISurface@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+E8p
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+286p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3BD0
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::AddRefTraits<IDXGISurface>::Release(IDXGISurface *)
		add	esp, 4

loc_3BD0:				; CODE XREF: RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UIDXGISurface@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::~RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>(void)
		public ??1?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ
??1?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+E7p
					; mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+10Bp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3C04
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2D>::Release(mozilla::gfx::DataSourceSurfaceD2D	*)
		add	esp, 4

loc_3C04:				; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::~_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>(void)
		public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
					; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0+3j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C40h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
		public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::~already_AddRefed<class mozilla::gfx::DataSourceSurface>(void)
		public ??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ
??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3+13j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_3C7E:				; CODE XREF: already_AddRefed<mozilla::gfx::DataSourceSurface>::~already_AddRefed<mozilla::gfx::DataSourceSurface>(void)+10j
		xor	eax, eax
		jnz	short loc_3C7E
		mov	esp, ebp
		pop	ebp
		retn
??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2D>::~already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2D>(void)
		public ??1?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ
??1?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+DBp
					; __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_3C96:				; CODE XREF: already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>::~already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>(void)+10j
		xor	eax, eax
		jnz	short loc_3C96
		mov	esp, ebp
		pop	ebp
		retn
??1?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
		public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+A0p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+AFp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	ecx, [ebp+var_4]
		call	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::~basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>>(void)
		public ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)+45p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`scalar deleting destructor'(uint)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@	; const	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ;	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class	std::allocator<char>>::~basic_stringstream<char, struct	std::char_traits<char>,	class std::allocator<char>>(void)
		public ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax-68h]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+edx-68h], offset	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx-68h]
		mov	eax, [edx+4]
		sub	eax, 68h ; 'h'
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx-68h]
		mov	ecx, [edx+4]
		mov	edx, [ebp+var_4]
		mov	[edx+ecx-6Ch], eax
		mov	ecx, [ebp+var_4]
		sub	ecx, 50h ; 'P'
		call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	ecx, [ebp+var_4]
		sub	ecx, 48h ; 'H'
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall CD3D10_TEXTURE2D_DESC::~CD3D10_TEXTURE2D_DESC(CD3D10_TEXTURE2D_DESC	*__hidden this)
		public ??1CD3D10_TEXTURE2D_DESC@@QAE@XZ
??1CD3D10_TEXTURE2D_DESC@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1CAp
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+29Fp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn
??1CD3D10_TEXTURE2D_DESC@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurface::~DataSourceSurface(mozilla::gfx::DataSourceSurface	*__hidden this)
		public ??1DataSourceSurface@gfx@mozilla@@UAE@XZ
??1DataSourceSurface@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(void)+92p
					; __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$0+3j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DataSourceSurface@gfx@mozilla@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DBCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::NoLog::~NoLog(mozilla::gfx::NoLog *__hidden this)
		public ??1NoLog@gfx@mozilla@@QAE@XZ
??1NoLog@gfx@mozilla@@QAE@XZ proc near	; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+E7p
					; __unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn
??1NoLog@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurface::~SourceSurface(mozilla::gfx::SourceSurface *__hidden this)
		public ??1SourceSurface@gfx@mozilla@@UAE@XZ
??1SourceSurface@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+98p
					; __unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$0+3j	...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurface::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 8		; this
		call	??1UserData@gfx@mozilla@@QAE@XZ	; mozilla::gfx::UserData::~UserData(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10]
		add	ecx, 4
		call	??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SourceSurface@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3E44h
; COMDAT (pick associative to section at 3DD0)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurface@gfx@mozilla@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000086B4o
		mov	ecx, [ebp-10h]
		add	ecx, 4
		jmp	??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
__unwindfunclet$??1SourceSurface@gfx@mozilla@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurface::~SourceSurface(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1SourceSurface@gfx@mozilla@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E6Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::UserData::~UserData(mozilla::gfx::UserData *__hidden this)
		public ??1UserData@gfx@mozilla@@QAE@XZ
??1UserData@gfx@mozilla@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurface::~SourceSurface(void)+43p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?Destroy@UserData@gfx@mozilla@@QAEXXZ ;	mozilla::gfx::UserData::Destroy(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UserData@gfx@mozilla@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category	*__hidden this)
		public ??1_Generic_error_category@std@@UAE@XZ
??1_Generic_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+11p
					; std::_System_error_category::~_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Generic_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3EB4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??1_Iostream_error_category@std@@UAE@XZ
??1_Iostream_error_category@std@@UAE@XZ	proc near
					; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Iostream_error_category@std@@UAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3ED8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
		public ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0+3j
					; std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+3Cp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		add	ecx, [eax+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_3F56
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	[ebp+var_C], edx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax]
		mov	edx, [ebp+var_C]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10], eax
		mov	eax, [ebp+var_10]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_10]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3F56:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)+3Fj
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
		public ??1_System_error_category@std@@UAE@XZ
??1_System_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_System_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
		public ??1error_category@std@@UAE@XZ
??1error_category@std@@UAE@XZ proc near	; CODE XREF: std::_Generic_error_category::~_Generic_error_category(void)+11p
					; std::error_category::`scalar deleting	destructor'(uint)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	esp, ebp
		pop	ebp
		retn
??1error_category@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::~sentry(void)
		public ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+3C4p
					; __unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		call	dword ptr ds:__imp_?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jnz	short loc_3FE1
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	ecx, [ecx]
		call	dword ptr ds:__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ;	std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3FE1:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+23j
		mov	ecx, [ebp+var_4]
		call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int, void	*)
		public ??2@YAPAXIPAX@Z
??2@YAPAXIPAX@Z	proc near		; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+3Fp
					; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+3Fp

arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		pop	ebp
		retn
??2@YAPAXIPAX@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4000h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX0@Z
??3@YAXPAX0@Z	proc near		; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
					; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
??3@YAXPAX0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4008h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RefPtr<struct ID3D10Device> & __thiscall RefPtr<struct ID3D10Device>::operator=(struct ID3D10Device *)
		public ??4?$RefPtr@UID3D10Device@@@@QAEAAV0@PAUID3D10Device@@@Z
??4?$RefPtr@UID3D10Device@@@@QAEAAV0@PAUID3D10Device@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+304p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?assign_with_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z ;	RefPtr<ID3D10Device>::assign_with_AddRef(ID3D10Device *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$RefPtr@UID3D10Device@@@@QAEAAV0@PAUID3D10Device@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4038h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RefPtr<struct ID3D10Texture2D> & __thiscall RefPtr<struct ID3D10Texture2D>::operator=(struct ID3D10Texture2D *)
		public ??4?$RefPtr@UID3D10Texture2D@@@@QAEAAV0@PAUID3D10Texture2D@@@Z
??4?$RefPtr@UID3D10Texture2D@@@@QAEAAV0@PAUID3D10Texture2D@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+80Bp
					; mozilla::gfx::DataSourceSurfaceD2D::EnsureMappedTexture(void)+120p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?assign_with_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::assign_with_AddRef(ID3D10Texture2D *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$RefPtr@UID3D10Texture2D@@@@QAEAAV0@PAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4068h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::atomic_uint::operator=(unsigned int)
		public ??4atomic_uint@std@@QAEII@Z
??4atomic_uint@std@@QAEII@Z proc near	; CODE XREF: std::atomic<uint>::atomic<uint>(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_4]
		push	ecx		; struct std::atomic_uint *
		call	?atomic_store@std@@YAXPAUatomic_uint@1@I@Z ; std::atomic_store(std::atomic_uint	*,uint)
		add	esp, 8
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4atomic_uint@std@@QAEII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 409Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char	*Str)
		public ??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z
??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1FDp
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+2B5p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_40EA
		cmp	[ebp+var_4], 0
		jz	short loc_40D3
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_8], ecx
		jmp	short loc_40DA
; ---------------------------------------------------------------------------

loc_40D3:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+2Aj
		mov	[ebp+var_8], 0

loc_40DA:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+35j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_40EA:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+24j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4100h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::error_category::operator==(class	std::error_category const &)const
		public ??8error_category@std@@QBE_NABV01@@Z
??8error_category@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Bp
					; std::error_category::equivalent(std::error_code const	&,int)+23p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_4128
		mov	[ebp+var_8], 1
		jmp	short loc_412F
; ---------------------------------------------------------------------------

loc_4128:				; CODE XREF: std::error_category::operator==(std::error_category const &)+1Dj
		mov	[ebp+var_8], 0

loc_412F:				; CODE XREF: std::error_category::operator==(std::error_category const &)+26j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_category@std@@QBE_NABV01@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4138h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::error_condition::operator==(std::error_condition *)
		public ??8error_condition@std@@QBE_NABV01@@Z
??8error_condition@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+43p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		push	eax
		mov	ecx, [ebp+var_4] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		mov	ecx, eax
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_418E
		mov	ecx, [ebp+var_4] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		cmp	esi, eax
		jnz	short loc_418E
		mov	[ebp+var_8], 1
		jmp	short loc_4195
; ---------------------------------------------------------------------------

loc_418E:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+35j
					; std::error_condition::operator==(std::error_condition	const &)+4Bj
		mov	[ebp+var_8], 0

loc_4195:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+54j
		mov	al, byte ptr [ebp+var_8]
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_condition@std@@QBE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1Bitmap>::operator struct ID2D1Bitmap *(void)const
		public ??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ
??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+43p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+535p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1SolidColorBrush>::operator struct ID2D1SolidColorBrush *(void)const
		public ??B?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ
??B?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+602p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ ;	RefPtr<ID2D1SolidColorBrush>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::operator struct ID3D10Texture2D *(void)const
		public ??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ
??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+859p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+867p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4218h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDXGISurface>::operator struct IDXGISurface *(void)const
		public ??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ
??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1DEp
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+35Fp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ ;	RefPtr<IDXGISurface>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 423Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1Bitmap>::operator struct ID2D1Bitmap * *(void)
		public ??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ
??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+188p
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1CFp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4264h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1RenderTarget>::operator struct ID2D1RenderTarget *	*(void)
		public ??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ
??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+34Dp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 428Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1SolidColorBrush>::operator	struct ID2D1SolidColorBrush * *(void)
		public ??B?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ
??B?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ proc	near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+579p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ ; RefPtr<ID2D1SolidColorBrush>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 42B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10Device>::operator	struct ID3D10Device * *(void)
		public ??B?$RefPtrGetterAddRefs@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ
??B?$RefPtrGetterAddRefs@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+2ABp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ ; RefPtr<ID3D10Device>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 42DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10Texture2D>::operator struct ID3D10Texture2D * *(void)
		public ??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ
??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+114p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+760p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4304h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDXGISurface>::operator	struct IDXGISurface * *(void)
		public ??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ
??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ proc	near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1F5p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ ; RefPtr<IDXGISurface>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 432Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::fpos<int>::operator __int64(void)const
		public ??B?$fpos@H@std@@QBE_JXZ
??B?$fpos@H@std@@QBE_JXZ proc near	; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+2Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	edx, [eax]
		add	edx, [ecx+8]
		mov	esi, [eax+4]
		adc	esi, [ecx+0Ch]
		mov	eax, edx
		mov	edx, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
??B?$fpos@H@std@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4358h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::operator bool(void)const
		public ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+10Cp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4370h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1Bitmap * __thiscall RefPtr<struct	ID2D1Bitmap>::operator->(void)const
		public ??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ
??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+228p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_437E:				; CODE XREF: RefPtr<ID2D1Bitmap>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_437E
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4398h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1RenderTarget * __thiscall	RefPtr<struct ID2D1RenderTarget>::operator->(void)const
		public ??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ
??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+435p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+482p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_43A6:				; CODE XREF: RefPtr<ID2D1RenderTarget>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_43A6
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ	; RefPtr<ID2D1RenderTarget>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 43C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Device *	__thiscall RefPtr<struct ID3D10Device>::operator->(void)const
		public ??C?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ
??C?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+F4p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+73Dp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_43CE:				; CODE XREF: RefPtr<ID3D10Device>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_43CE
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ ;	RefPtr<ID3D10Device>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 43E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Texture2D * __thiscall RefPtr<struct ID3D10Texture2D>::operator->(void)const
		public ??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ
??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+1FEp
					; mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(void)+58p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_43F6:				; CODE XREF: RefPtr<ID3D10Texture2D>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_43F6
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4410h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::DataSourceSurfaceD2D * __thiscall	RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::operator->(void)const
		public ??C?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ
??C?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+93p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_441E:				; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_441E
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4438h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall mozilla::detail::AtomicBaseIncDec<unsigned int, 2>::operator++(void)
		public ??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ
??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ proc near
					; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z ; mozilla::detail::IntrinsicIncDec<uint,2>::inc(std::atomic<uint> &)
		add	esp, 4
		add	eax, 1
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4464h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall mozilla::detail::AtomicBaseIncDec<unsigned int, 2>::operator--(void)
		public ??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ
??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ proc near
					; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+28p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z ; mozilla::detail::IntrinsicIncDec<uint,2>::dec(std::atomic<uint> &)
		add	esp, 4
		sub	eax, 1
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4490h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`vbase destructor(void)
		public ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ proc near
					; CODE XREF: __unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0+3j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)+46p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		add	ecx, 68h ; 'h'
		call	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	ecx, [ebp+var_4]
		add	ecx, 68h ; 'h'
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	byte public 'CODE' use32
		assume cs:_text$mn
		;org 44D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vector deleting destructor'`vtordisp{4294967292, 0}' (unsigned int)
		public ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z proc near
					; DATA XREF: .rdata:const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable'o
		sub	ecx, [ecx-4]
		jmp	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vector deleting destructor'(uint)
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 44D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`scalar deleting destructor'(unsigned int)
		public ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4502
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4502:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4518h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`scalar deleting destructor'(unsigned int)
		public ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		sub	ecx, 68h ; 'h'
		call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4548
		mov	ecx, [ebp+var_4]
		sub	ecx, 68h ; 'h'
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4548:				; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`scalar	deleting destructor'(uint)+1Fj
		mov	eax, [ebp+var_4]
		sub	eax, 68h ; 'h'
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4560h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::DataSourceSurface::`scalar deleting destructor'(unsigned int)
		public ??_GDataSourceSurface@gfx@mozilla@@UAEPAXI@Z
??_GDataSourceSurface@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_458A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_458A:				; CODE XREF: mozilla::gfx::DataSourceSurface::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDataSourceSurface@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 45A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::DataSourceSurfaceD2D::`scalar	deleting destructor'(unsigned int)
		public ??_GDataSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z
??_GDataSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_45CA
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_45CA:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDataSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 45E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurface::`scalar deleting destructor'(unsigned int)
		public ??_GSourceSurface@gfx@mozilla@@UAEPAXI@Z
??_GSourceSurface@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_460A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_460A:				; CODE XREF: mozilla::gfx::SourceSurface::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSourceSurface@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4620h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurfaceD2D::`scalar deleting destructor'(unsigned int)
		public ??_GSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z
??_GSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ	; mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_464A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_464A:				; CODE XREF: mozilla::gfx::SourceSurfaceD2D::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4660h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Generic_error_category@std@@UAEPAXI@Z
??_G_Generic_error_category@std@@UAEPAXI@Z proc	near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_468A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_468A:				; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Generic_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Iostream_error_category@std@@UAEPAXI@Z
??_G_Iostream_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_46CA
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_46CA:				; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Iostream_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_System_error_category@std@@UAEPAXI@Z
??_G_System_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_470A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_470A:				; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_System_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4720h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
		public ??_Gerror_category@std@@UAEPAXI@Z
??_Gerror_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_474A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_474A:				; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_Gerror_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4760h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		push	offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4784h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category(void)
		push	offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 47A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??0_System_error_category@std@@QAE@XZ ;	std::_System_error_category::_System_error_category(void)
		push	offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ	; void (__cdecl	*)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 47CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 47F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4814h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
??__Eallocator_arg@std@@YAXXZ proc near	; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Eallocator_arg@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4828h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
??__Epiecewise_construct@std@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Epiecewise_construct@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 483Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 4854h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 486Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4884h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10Device>::AddRefTraits<struct ID3D10Device>::AddRef(struct ID3D10Device *)
		public ?AddRef@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z
?AddRef@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z	proc near
					; CODE XREF: RefPtr<ID3D10Device>::assign_with_AddRef(ID3D10Device *)+18p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::AddRefTraitsAddRefHelper(ID3D10Device *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 489Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraits<struct ID3D10Texture2D>::AddRef(struct ID3D10Texture2D *)
		public ?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z
?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(ID3D10Texture2D *)+24p
					; RefPtr<ID3D10Texture2D>::assign_with_AddRef(ID3D10Texture2D *)+18p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraitsAddRefHelper(ID3D10Texture2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraits<class mozilla::gfx::DataSourceSurfaceD2D>::AddRef(class mozilla::gfx::DataSourceSurfaceD2D	*)
		public ?AddRef@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
?AddRef@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(mozilla::gfx::DataSourceSurfaceD2D *)+24p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraitsAddRefHelper(mozilla::gfx::DataSourceSurfaceD2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::AddRef(void)const
		public ?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ
?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraitsAddRefHelper(mozilla::gfx::DataSourceSurfaceD2D *)+9p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_48DA:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)+10j
		xor	eax, eax
		jnz	short loc_48DA
		mov	ecx, [ebp+var_4]
		call	??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ ; mozilla::detail::AtomicBaseIncDec<uint,2>::operator++(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10Device>::AddRefTraitsAddRefHelper(struct ID3D10Device *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z proc	near
					; CODE XREF: RefPtr<ID3D10Device>::AddRefTraits<ID3D10Device>::AddRef(ID3D10Device *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 491Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraitsAddRefHelper(struct ID3D10Texture2D *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::AddRef(ID3D10Texture2D *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4944h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraitsAddRefHelper(class	mozilla::gfx::DataSourceSurfaceD2D *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc	near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2D>::AddRef(mozilla::gfx::DataSourceSurfaceD2D *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 495Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1Bitmap>::AddRefTraitsReleaseHelper(struct ID2D1Bitmap	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::Release(ID2D1Bitmap *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4984h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1RenderTarget>::AddRefTraitsReleaseHelper(struct ID2D1RenderTarget *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::Release(ID2D1RenderTarget *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 49ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1SolidColorBrush>::AddRefTraitsReleaseHelper(struct ID2D1SolidColorBrush *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1SolidColorBrush@@@@CAXPAUID2D1SolidColorBrush@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1SolidColorBrush@@@@CAXPAUID2D1SolidColorBrush@@@Z proc near
					; CODE XREF: RefPtr<ID2D1SolidColorBrush>::AddRefTraits<ID2D1SolidColorBrush>::Release(ID2D1SolidColorBrush *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1SolidColorBrush@@@@CAXPAUID2D1SolidColorBrush@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 49D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10Device>::AddRefTraitsReleaseHelper(struct ID3D10Device *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Device>::AddRefTraits<ID3D10Device>::Release(ID3D10Device *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 49FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraitsReleaseHelper(struct	ID3D10Texture2D	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::Release(ID3D10Texture2D *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct IDXGISurface>::AddRefTraitsReleaseHelper(struct IDXGISurface *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z proc near
					; CODE XREF: RefPtr<IDXGISurface>::AddRefTraits<IDXGISurface>::Release(IDXGISurface *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraitsReleaseHelper(class mozilla::gfx::DataSourceSurfaceD2D *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2D>::Release(mozilla::gfx::DataSourceSurfaceD2D *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ ;	mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A64h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::AutoPrefix(void)const
		public ?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+57p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 2
		jz	short loc_4A8F
		mov	byte ptr [ebp+var_8+3],	1
		jmp	short loc_4A93
; ---------------------------------------------------------------------------

loc_4A8F:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::AutoPrefix(void)+23j
		mov	byte ptr [ebp+var_8+3],	0

loc_4A93:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::AutoPrefix(void)+29j
		mov	al, byte ptr [ebp+var_8+3]
		mov	esp, ebp
		pop	ebp
		retn
?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A9Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_BITMAP_PROPERTIES	__cdecl	D2D1::BitmapProperties(struct D2D1_PIXEL_FORMAT	const &, float,	float)
		public ?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z
?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+12Ap
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+180p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	[ebp+var_18], ecx
		mov	[ebp+var_14], edx
		movss	xmm0, [ebp+arg_8]
		movss	[ebp+var_10], xmm0
		movss	xmm0, [ebp+arg_C]
		movss	[ebp+var_C], xmm0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	[eax], ecx
		mov	edx, [ebp+var_14]
		mov	[eax+4], edx
		mov	ecx, [ebp+var_10]
		mov	[eax+8], ecx
		mov	edx, [ebp+var_C]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	endp

; ---------------------------------------------------------------------------
$LN5_5		dd 1			; DATA XREF: D2D1::BitmapProperties(D2D1_PIXEL_FORMAT const &,float,float)+6Do
		dd offset $LN4_5
$LN4_5		dd 0FFFFFFE8h, 10h	; DATA XREF: .text$mn:00004B28o
		dd offset $LN3_5	; "bitmapProperties"
$LN3_5		db 'bitmapProperties',0 ; DATA XREF: .text$mn:00004B34o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall ID2D1RenderTarget::Clear(ID2D1RenderTarget *this, const struct _D3DCOLORVALUE	*)
		public ?Clear@ID2D1RenderTarget@@QAEXABU_D3DCOLORVALUE@@@Z
?Clear@ID2D1RenderTarget@@QAEXABU_D3DCOLORVALUE@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+489p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		push	eax
		mov	ecx, [edx+0BCh]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?Clear@ID2D1RenderTarget@@QAEXABU_D3DCOLORVALUE@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl mozilla::gfx::BasicLogger::CrashAction(enum  mozilla::gfx::LogReason)
		public ?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z
?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z proc	near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+70p
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B94h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: long __thiscall ID2D1RenderTarget::CreateBitmap(struct D2D_SIZE_U, struct D2D1_BITMAP_PROPERTIES const &, struct ID2D1Bitmap * *)
		public ?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z
?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+19Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		push	eax
		mov	ecx, [edx+10h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4BE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int32 __thiscall ID2D1RenderTarget::CreateSolidColorBrush(ID2D1RenderTarget	*this, const struct _D3DCOLORVALUE *, struct ID2D1SolidColorBrush **)
		public ?CreateSolidColorBrush@ID2D1RenderTarget@@QAEJABU_D3DCOLORVALUE@@PAPAUID2D1SolidColorBrush@@@Z
?CreateSolidColorBrush@ID2D1RenderTarget@@QAEJABU_D3DCOLORVALUE@@PAPAUID2D1SolidColorBrush@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+5ABp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		mov	ecx, [ebp+var_4]
		push	ecx
		mov	edx, [eax+20h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?CreateSolidColorBrush@ID2D1RenderTarget@@QAEJABU_D3DCOLORVALUE@@PAPAUID2D1SolidColorBrush@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		public ?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z
?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1CAp
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+282p ...

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_4C40
		mov	[ebp+var_4], 4
		jmp	short loc_4C47
; ---------------------------------------------------------------------------

loc_4C40:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)+11j
		mov	[ebp+var_4], 0

loc_4C47:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)+1Aj
		mov	eax, [ebp+var_4]
		or	eax, 2
		mov	esp, ebp
		pop	ebp
		retn
?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::UserData::Destroy(mozilla::gfx::UserData *__hidden this)
		public ?Destroy@UserData@gfx@mozilla@@QAEXXZ
?Destroy@UserData@gfx@mozilla@@QAEXXZ proc near
					; CODE XREF: mozilla::gfx::UserData::~UserData(void)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		jmp	short loc_4C7E
; ---------------------------------------------------------------------------

loc_4C75:				; CODE XREF: mozilla::gfx::UserData::Destroy(void):loc_4CC4j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_4C7E:				; CODE XREF: mozilla::gfx::UserData::Destroy(void)+1Fj
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+var_8]
		cmp	edx, [ecx]
		jge	short loc_4CC6
		imul	eax, [ebp+var_8], 0Ch
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		cmp	dword ptr [edx+eax+8], 0
		jz	short loc_4CC4
		imul	eax, [ebp+var_8], 0Ch
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		mov	esi, esp
		mov	eax, [edx+eax+4]
		push	eax
		imul	ecx, [ebp+var_8], 0Ch
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	ecx, [eax+ecx+8]
		call	ecx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4CC4:				; CODE XREF: mozilla::gfx::UserData::Destroy(void)+43j
		jmp	short loc_4C75
; ---------------------------------------------------------------------------

loc_4CC6:				; CODE XREF: mozilla::gfx::UserData::Destroy(void)+32j
		mov	esi, esp
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		push	eax		; Memory
		call	dword ptr ds:__imp__free
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx], 0
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Destroy@UserData@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D04h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall ID2D1RenderTarget::DrawBitmap(struct ID2D1Bitmap *, struct D2D_RECT_F	const &, float,	enum  D2D1_BITMAP_INTERPOLATION_MODE, struct D2D_RECT_F	const *)
		public ?DrawBitmap@ID2D1RenderTarget@@QAEXPAUID2D1Bitmap@@ABUD2D_RECT_F@@MW4D2D1_BITMAP_INTERPOLATION_MODE@@PBU3@@Z
?DrawBitmap@ID2D1RenderTarget@@QAEXPAUID2D1Bitmap@@ABUD2D_RECT_F@@MW4D2D1_BITMAP_INTERPOLATION_MODE@@PBU3@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+548p

var_14		= dword	ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	ecx
		movss	xmm0, [ebp+arg_8]
		movss	[esp+14h+var_14], xmm0
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		push	eax
		mov	ecx, [edx+68h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?DrawBitmap@ID2D1RenderTarget@@QAEXPAUID2D1Bitmap@@ABUD2D_RECT_F@@MW4D2D1_BITMAP_INTERPOLATION_MODE@@PBU3@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::Flush(void)
		public ?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)+37p

var_54		= byte ptr -54h
var_34		= byte ptr -34h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 48h
		push	edi
		push	ecx
		lea	edi, [ebp+var_54]
		mov	ecx, 12h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jnz	short loc_4DA6
		jmp	short loc_4E0C
; ---------------------------------------------------------------------------

loc_4DA6:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+4Aj
		lea	ecx, [ebp+var_34]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(void)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_34]
		call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)
		movzx	edx, al
		test	edx, edx
		jnz	short loc_4DD4
		lea	eax, [ebp+var_34]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)

loc_4DD4:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+6Ej
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	Str
		lea	ecx, [ebp+var_54]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_54]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_34]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)

loc_4E0C:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+4Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 54h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN10		dd 1			; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+B8o
		dd offset $LN9
$LN9		db 0CCh			; DATA XREF: .text$mn:00004E48o
		db 3 dup(0FFh)
		dd 1Ch
		dd offset $LN7
; ---------------------------------------------------------------------------

$LN7:					; DATA XREF: .text$mn:00004E54o
		jnb	short loc_4ECE
		jb	short $+2
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4E5Ch
; COMDAT (pick associative to section at 4D58)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0 proc near
					; CODE XREF: .text$mn:00004E5Aj
					; DATA XREF: .xdata$x:000087C4o
		lea	ecx, [ebp-34h]
		jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1 proc near
					; DATA XREF: .xdata$x:000087CCo
		lea	ecx, [ebp-54h]
		jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ proc	near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-50h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4E94h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurface::GetNativeSurface(enum	mozilla::gfx::NativeSurfaceType)
		public ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z
?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z proc near
					; DATA XREF: .rdata:00008DD8o
					; .rdata:00008DFCo ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		xor	eax, eax
		mov	esp, ebp
		pop	ebp
		retn	4
?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4EACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceType __thiscall mozilla::gfx::DataSourceSurface::GetType(void)const
		public ?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ
?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ proc near
					; DATA XREF: .rdata:00008DE8o
					; .rdata:00008EACo

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		xor	al, al
		mov	esp, ebp
		pop	ebp
		retn
?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4EC0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceType __thiscall mozilla::gfx::SourceSurfaceD2D::GetType(void)const
		public ?GetType@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ
?GetType@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ	proc near
					; DATA XREF: .rdata:00008E88o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_4ECE:				; CODE XREF: .text$mn:$LN7j
		mov	al, 1
		mov	esp, ebp
		pop	ebp
		retn
?GetType@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4ED4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::SourceSurface::GuaranteePersistance(mozilla::gfx::SourceSurface	*__hidden this)
		public ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ
?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ	proc near
					; DATA XREF: .rdata:00008DDCo
					; .rdata:00008E00o ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn
?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4EE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall mozilla::gfx::Log<2,	struct mozilla::gfx::BasicLogger>::Init(int, bool, enum	 mozilla::gfx::LogReason)
		public ?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z
?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z	proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+70p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0B0h], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_8]
		mov	[edx+0B4h], eax
		mov	ecx, [ebp+var_4]
		mov	dl, [ebp+arg_4]
		mov	[ecx+0B8h], dl
		mov	eax, [ebp+var_4]
		movzx	ecx, byte ptr [eax+0B8h]
		test	ecx, ecx
		jz	loc_506F
		mov	ecx, [ebp+var_4]
		call	?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::AutoPrefix(void)
		movzx	edx, al
		test	edx, edx
		jz	loc_4FE5
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 4
		jz	short loc_4F9B
		cmp	[ebp+var_4], 0
		jz	short loc_4F6E
		mov	edx, [ebp+var_4]
		add	edx, 10h
		mov	[ebp+var_8], edx
		jmp	short loc_4F75
; ---------------------------------------------------------------------------

loc_4F6E:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+79j
		mov	[ebp+var_8], 0

loc_4F75:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+84j
		mov	esi, esp
		push	2
		push	offset ??_C@_04HGKILAJC@?$FLGFX?$AA@ ; "[GFX"
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_4FE5
; ---------------------------------------------------------------------------

loc_4F9B:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+73j
		cmp	[ebp+var_4], 0
		jz	short loc_4FAC
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_C], ecx
		jmp	short loc_4FB3
; ---------------------------------------------------------------------------

loc_4FAC:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+B7j
		mov	[ebp+var_C], 0

loc_4FB3:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+C2j
		push	offset ??_C@_01JOAMLHOP@?9?$AA@	; Str
		mov	esi, esp
		push	2
		push	offset ??_C@_04HGKILAJC@?$FLGFX?$AA@ ; "[GFX"
		mov	edx, [ebp+var_C]
		push	edx		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_4FE5:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+61j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+B1j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 8
		jz	short loc_5046
		mov	ecx, [ebp+var_4]
		call	?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ;	mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)
		movzx	edx, al
		test	edx, edx
		jz	short loc_5046
		cmp	[ebp+var_4], 0
		jz	short loc_5013
		mov	eax, [ebp+var_4]
		add	eax, 10h
		mov	[ebp+var_10], eax
		jmp	short loc_501A
; ---------------------------------------------------------------------------

loc_5013:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+11Ej
		mov	[ebp+var_10], 0

loc_501A:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+129j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+0B4h]
		push	edx
		push	offset ??_C@_01CLKCMJKC@?5?$AA@	; Str
		mov	eax, [ebp+var_10]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5046:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+109j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+118j
		cmp	[ebp+var_4], 0
		jz	short loc_5057
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_14], ecx
		jmp	short loc_505E
; ---------------------------------------------------------------------------

loc_5057:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+162j
		mov	[ebp+var_14], 0

loc_505E:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+16Dj
		push	offset ??_C@_03FLKELDHI@?$FN?3?5?$AA@ ;	Str
		mov	edx, [ebp+var_14]
		push	edx		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_506F:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+4Ej
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5080h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall D2D1::ColorF::Init(D2D1::ColorF *this, unsigned int, float)
		public ?Init@ColorF@D2D1@@AAEXIM@Z
?Init@ColorF@D2D1@@AAEXIM@Z proc near	; CODE XREF: D2D1::ColorF::ColorF(uint,float)+20p
					; D2D1::ColorF::ColorF(D2D1::ColorF::Enum,float)+20p

var_28		= qword	ptr -28h
var_20		= dword	ptr -20h
var_1C		= qword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= qword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		push	edi
		push	ecx
		lea	edi, [ebp+var_28]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 0FF0000h
		shr	eax, 10h
		mov	[ebp+var_8], eax
		cvtsi2sd xmm0, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		shr	ecx, 1Fh
		addsd	xmm0, ds:__xmm@41f00000000000000000000000000000[ecx*8]
		movsd	[ebp+var_10], xmm0
		cvtsd2ss xmm0, [ebp+var_10]
		divss	xmm0, ds:__real@437f0000
		mov	edx, [ebp+var_4]
		movss	dword ptr [edx], xmm0
		mov	eax, [ebp+arg_0]
		and	eax, 0FF00h
		shr	eax, 8
		mov	[ebp+var_14], eax
		cvtsi2sd xmm0, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		shr	ecx, 1Fh
		addsd	xmm0, ds:__xmm@41f00000000000000000000000000000[ecx*8]
		movsd	[ebp+var_1C], xmm0
		cvtsd2ss xmm0, [ebp+var_1C]
		divss	xmm0, ds:__real@437f0000
		mov	edx, [ebp+var_4]
		movss	dword ptr [edx+4], xmm0
		mov	eax, [ebp+arg_0]
		and	eax, 0FFh
		mov	[ebp+var_20], eax
		cvtsi2sd xmm0, [ebp+var_20]
		mov	ecx, [ebp+var_20]
		shr	ecx, 1Fh
		addsd	xmm0, ds:__xmm@41f00000000000000000000000000000[ecx*8]
		movsd	[ebp+var_28], xmm0
		cvtsd2ss xmm0, [ebp+var_28]
		divss	xmm0, ds:__real@437f0000
		mov	edx, [ebp+var_4]
		movss	dword ptr [edx+8], xmm0
		mov	eax, [ebp+var_4]
		movss	xmm0, [ebp+arg_4]
		movss	dword ptr [eax+0Ch], xmm0
		pop	edi
		mov	esp, ebp
		pop	ebp
		retn	8
?Init@ColorF@D2D1@@AAEXIM@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5160h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall mozilla::gfx::DataSourceSurfaceD2D::IsValid(mozilla::gfx::DataSourceSurfaceD2D *__hidden this)
		public ?IsValid@DataSourceSurfaceD2D@gfx@mozilla@@QAE_NXZ
?IsValid@DataSourceSurfaceD2D@gfx@mozilla@@QAE_NXZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+9Ap

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		test	eax, eax
		jz	short loc_518C
		mov	byte ptr [ebp+var_8+3],	1
		jmp	short loc_5190
; ---------------------------------------------------------------------------

loc_518C:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::IsValid(void)+24j
		mov	byte ptr [ebp+var_8+3],	0

loc_5190:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::IsValid(void)+2Aj
		mov	al, byte ptr [ebp+var_8+3]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?IsValid@DataSourceSurfaceD2D@gfx@mozilla@@QAE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 51A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall mozilla::gfx::SourceSurface::IsValid(mozilla::gfx::SourceSurface *__hidden this)
		public ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ
?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ proc near ;	DATA XREF: .rdata:00008DD0o
					; .rdata:00008DF4o ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	al, 1
		mov	esp, ebp
		pop	ebp
		retn
?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 51B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::LogIt(void)const
		public ?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+24p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const	* const)+1Ap ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+0B8h]
		mov	esp, ebp
		pop	ebp
		retn
?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 51D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual bool __thiscall mozilla::gfx::DataSourceSurface::Map(enum  mozilla::gfx::DataSourceSurface::MapType, struct mozilla::gfx::DataSourceSurface::MappedSurface *)
		public ?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z
?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z proc near
					; DATA XREF: .rdata:00008E0Co

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	edx, [eax+24h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_4]
		mov	[ecx+4], eax
		mov	edx, [ebp+arg_4]
		cmp	dword ptr [edx], 0
		jz	short loc_5234
		mov	[ebp+var_8], 1
		jmp	short loc_523B
; ---------------------------------------------------------------------------

loc_5234:				; CODE XREF: mozilla::gfx::DataSourceSurface::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+55j
		mov	[ebp+var_8], 0

loc_523B:				; CODE XREF: mozilla::gfx::DataSourceSurface::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+5Ej
		mov	eax, [ebp+var_4]
		mov	cl, byte ptr [ebp+var_8]
		mov	[eax+10h], cl
		mov	edx, [ebp+var_4]
		mov	al, [edx+10h]
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 525Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::NoNewline(void)const
		public ?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+20p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+0B0h]
		and	eax, 1
		mov	esp, ebp
		pop	ebp
		retn
?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 527Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl mozilla::gfx::BasicLogger::OutputMessage(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>	const &, int, bool)
		public ?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+2Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA ;	int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		cmp	eax, [ebp+arg_4]
		jl	short loc_52DD
		cmp	dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA, 4 ; int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		jge	short loc_52A1
		cmp	[ebp+arg_4], 3
		jge	short loc_52DD

loc_52A1:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+1Dj
		movzx	ecx, [ebp+arg_8]
		test	ecx, ecx
		jz	short loc_52B2
		mov	[ebp+var_4], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		jmp	short loc_52B9
; ---------------------------------------------------------------------------

loc_52B2:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+2Bj
		mov	[ebp+var_4], offset ??_C@_01EEMJAFIK@?6?$AA@ ; `string'

loc_52B9:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+34j
		mov	esi, esp
		mov	edx, [ebp+var_4]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		push	eax
		push	offset ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@	; "%s%s"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_52DD:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+14j
					; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,bool)+23j
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_PIXEL_FORMAT __cdecl D2D1::PixelFormat(enum  DXGI_FORMAT,	enum  D2D1_ALPHA_MODE)
		public ?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z
?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	proc near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+30p
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+2ADp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_4		dd 1			; DATA XREF: D2D1::PixelFormat(DXGI_FORMAT,D2D1_ALPHA_MODE)+2Do
		dd offset $LN4_4
$LN4_4		dd 0FFFFFFF4h, 8	; DATA XREF: .text$mn:00005330o
		dd offset $LN3_4	; "pixelFormat"
$LN3_4		db 'pixelFormat',0      ; DATA XREF: .text$mn:0000533Co
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 534Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_RECT_F __cdecl D2D1::RectF(float, float, float, float)
		public ?RectF@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z
?RectF@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+4EBp

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		push	ecx
		movss	xmm0, [ebp+arg_10]
		movss	[esp+28h+var_28], xmm0
		push	ecx
		movss	xmm0, [ebp+arg_C]
		movss	[esp+2Ch+var_2C], xmm0
		push	ecx
		movss	xmm0, [ebp+arg_8]
		movss	[esp+30h+var_30], xmm0
		push	ecx
		movss	xmm0, [ebp+arg_4]
		movss	[esp+34h+var_34], xmm0
		lea	eax, [ebp+var_24]
		push	eax
		call	??$Rect@M@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z	; D2D1::Rect<float>(float,float,float,float)
		add	esp, 14h
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_10], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_C], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	edx, [ebp+var_10]
		mov	[eax+4], edx
		mov	ecx, [ebp+var_C]
		mov	[eax+8], ecx
		mov	edx, [ebp+var_8]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?RectF@D2D1@@YA?AUD2D_RECT_F@@MMMM@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5400h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1Bitmap>::AddRefTraits<struct ID2D1Bitmap>::Release(struct ID2D1Bitmap *)
		public ?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z
?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)+1Cp
					; RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z ; RefPtr<ID2D1Bitmap>::AddRefTraitsReleaseHelper(ID2D1Bitmap *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5418h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1RenderTarget>::AddRefTraits<struct ID2D1RenderTarget>::Release(struct ID2D1RenderTarget *)
		public ?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z
?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)+1Cp
					; RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z ;	RefPtr<ID2D1RenderTarget>::AddRefTraitsReleaseHelper(ID2D1RenderTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5430h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1SolidColorBrush>::AddRefTraits<struct ID2D1SolidColorBrush>::Release(struct ID2D1SolidColorBrush *)
		public ?Release@?$AddRefTraits@UID2D1SolidColorBrush@@@?$RefPtr@UID2D1SolidColorBrush@@@@SAXPAUID2D1SolidColorBrush@@@Z
?Release@?$AddRefTraits@UID2D1SolidColorBrush@@@?$RefPtr@UID2D1SolidColorBrush@@@@SAXPAUID2D1SolidColorBrush@@@Z proc near
					; CODE XREF: RefPtr<ID2D1SolidColorBrush>::~RefPtr<ID2D1SolidColorBrush>(void)+1Cp
					; RefPtr<ID2D1SolidColorBrush>::assign_assuming_AddRef(ID2D1SolidColorBrush *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1SolidColorBrush@@@@CAXPAUID2D1SolidColorBrush@@@Z ; RefPtr<ID2D1SolidColorBrush>::AddRefTraitsReleaseHelper(ID2D1SolidColorBrush *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID2D1SolidColorBrush@@@?$RefPtr@UID2D1SolidColorBrush@@@@SAXPAUID2D1SolidColorBrush@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5448h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10Device>::AddRefTraits<struct ID3D10Device>::Release(struct ID3D10Device *)
		public ?Release@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z
?Release@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Device>::~RefPtr<ID3D10Device>(void)+1Cp
					; RefPtr<ID3D10Device>::assign_assuming_AddRef(ID3D10Device *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Device@@@@CAXPAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::AddRefTraitsReleaseHelper(ID3D10Device *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5460h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraits<struct ID3D10Texture2D>::Release(struct ID3D10Texture2D *)
		public ?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z
?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)+1Cp
					; RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraitsReleaseHelper(ID3D10Texture2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5478h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct IDXGISurface>::AddRefTraits<struct IDXGISurface>::Release(struct IDXGISurface *)
		public ?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z
?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z proc near
					; CODE XREF: RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)+1Cp
					; RefPtr<IDXGISurface>::assign_assuming_AddRef(IDXGISurface *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::AddRefTraitsReleaseHelper(IDXGISurface *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5490h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraits<class mozilla::gfx::DataSourceSurfaceD2D>::Release(class mozilla::gfx::DataSourceSurfaceD2D *)
		public ?Release@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
?Release@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2D>(void)+1Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraitsReleaseHelper(mozilla::gfx::DataSourceSurfaceD2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@VDataSourceSurfaceD2D@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 54A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::Release(void)const
		public ?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ
?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::AddRefTraitsReleaseHelper(mozilla::gfx::DataSourceSurfaceD2D *)+9p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx

loc_54C9:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+23j
		xor	eax, eax
		jnz	short loc_54C9
		mov	ecx, [ebp+var_4]
		call	??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ ; mozilla::detail::AtomicBaseIncDec<uint,2>::operator--(void)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_552B
		cmp	[ebp+var_4], 0
		jz	short loc_54EF
		mov	ecx, [ebp+var_4]
		sub	ecx, 4
		mov	[ebp+var_14], ecx
		jmp	short loc_54F6
; ---------------------------------------------------------------------------

loc_54EF:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+3Aj
		mov	[ebp+var_14], 0

loc_54F6:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+45j
		mov	edx, [ebp+var_14]
		mov	[ebp+var_10], edx
		mov	eax, [ebp+var_10]
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jz	short loc_5524
		mov	esi, esp
		push	1
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		jmp	short loc_552B
; ---------------------------------------------------------------------------

loc_5524:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+5Ej
		mov	[ebp+var_18], 0

loc_552B:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+34j
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+7Aj
		pop	esi
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 553Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_RENDER_TARGET_PROPERTIES __cdecl D2D1::RenderTargetProperties(enum  D2D1_RENDER_TARGET_TYPE, struct D2D1_PIXEL_FORMAT const &, float, float, enum	 D2D1_RENDER_TARGET_USAGE, enum	 D2D1_FEATURE_LEVEL)
		public ?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z
?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+2F1p

var_28		= byte ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		push	esi
		push	edi
		lea	edi, [ebp+var_28]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	eax, [ecx+4]
		mov	[ebp+var_20], edx
		mov	[ebp+var_1C], eax
		movss	xmm0, [ebp+arg_C]
		movss	[ebp+var_18], xmm0
		movss	xmm0, [ebp+arg_10]
		movss	[ebp+var_14], xmm0
		mov	ecx, [ebp+arg_14]
		mov	[ebp+var_10], ecx
		mov	edx, [ebp+arg_18]
		mov	[ebp+var_C], edx
		mov	ecx, 7
		lea	esi, [ebp+var_24]
		mov	edi, [ebp+arg_0]
		rep movsd
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_6		dd 1			; DATA XREF: D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE,D2D1_PIXEL_FORMAT const &,float,float,D2D1_RENDER_TARGET_USAGE,D2D1_FEATURE_LEVEL)+69o
		dd offset $LN4_6
$LN4_6		dd 0FFFFFFDCh, 1Ch	; DATA XREF: .text$mn:000055C8o
		dd offset $LN3_6	; "renderTargetProperties"
$LN3_6		db 'renderTargetProperties',0 ; DATA XREF: .text$mn:000055D4o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 55F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::gfx::BasicLogger::ShouldOutputMessage(int)
		public ?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z
?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+5Dp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA ;	int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		cmp	eax, [ebp+arg_0]
		jl	short loc_5610
		cmp	dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA, 4 ; int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		jge	short loc_560C
		cmp	[ebp+arg_0], 3
		jge	short loc_5610

loc_560C:				; CODE XREF: mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+14j
		mov	al, 1
		jmp	short loc_5612
; ---------------------------------------------------------------------------

loc_5610:				; CODE XREF: mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+Bj
					; mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+1Aj
		xor	al, al

loc_5612:				; CODE XREF: mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+1Ej
		pop	ebp
		retn
?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5614h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_SIZE_U __cdecl D2D1::SizeU(unsigned int, unsigned int)
		public ?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z
?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z proc	near
					; CODE XREF: mozilla::gfx::D2DIntSize(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &)+21p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z ;	D2D1::Size<uint>(uint,uint)
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], edx
		mov	eax, [ebp+var_8]
		mov	edx, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5654h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1Bitmap * * __thiscall RefPtr<struct ID2D1Bitmap>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ
?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID2D1Bitmap>::operator	ID2D1Bitmap * *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	; RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5680h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1RenderTarget * * __thiscall RefPtr<struct	ID2D1RenderTarget>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ
?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID2D1RenderTarget>::operator ID2D1RenderTarget	* *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z ; RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 56ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1SolidColorBrush *	* __thiscall RefPtr<struct ID2D1SolidColorBrush>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ
?StartAssignment@?$RefPtr@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID2D1SolidColorBrush>::operator ID2D1SolidColorBrush *	*(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1SolidColorBrush@@@@AAEXPAUID2D1SolidColorBrush@@@Z ; RefPtr<ID2D1SolidColorBrush>::assign_assuming_AddRef(ID2D1SolidColorBrush *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID2D1SolidColorBrush@@@@QAEPAPAUID2D1SolidColorBrush@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 56D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Device *	* __thiscall RefPtr<struct ID3D10Device>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ
?StartAssignment@?$RefPtr@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID3D10Device>::operator ID3D10Device *	*(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::assign_assuming_AddRef(ID3D10Device *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID3D10Device@@@@QAEPAPAUID3D10Device@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5704h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Texture2D * * __thiscall	RefPtr<struct ID3D10Texture2D>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ
?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID3D10Texture2D>::operator ID3D10Texture2D * *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	; RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5730h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDXGISurface *	* __thiscall RefPtr<struct IDXGISurface>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ
?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<IDXGISurface>::operator IDXGISurface *	*(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::assign_assuming_AddRef(IDXGISurface *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 575Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::DataSourceSurface::Unmap(mozilla::gfx::DataSourceSurface *__hidden this)
		public ?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ
?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ proc near ; DATA XREF: .rdata:00008E10o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_576A:				; CODE XREF: mozilla::gfx::DataSourceSurface::Unmap(void)+10j
		xor	eax, eax
		jnz	short loc_576A
		mov	ecx, [ebp+var_4]
		mov	byte ptr [ecx+10h], 0
		mov	esp, ebp
		pop	ebp
		retn
?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 577Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::ValidReason(void)const
		public ?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+10Ep
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Ap

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+0B4h], 0FFFFFFFFh
		jle	short loc_57B4
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+0B4h], 65h ; 'e'
		jge	short loc_57B4
		mov	[ebp+var_8], 1
		jmp	short loc_57BB
; ---------------------------------------------------------------------------

loc_57B4:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)+21j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)+2Dj
		mov	[ebp+var_8], 0

loc_57BB:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)+36j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 57C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall mozilla::gfx::Log<2,	struct mozilla::gfx::BasicLogger>::WriteLog(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+77p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_583C
		mov	ecx, [ebp+var_4]
		call	?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::NoNewline(void)
		movzx	ecx, al
		push	ecx
		push	2
		mov	edx, [ebp+arg_0]
		push	edx
		call	?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>>	const &,int,bool)
		add	esp, 0Ch
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 4
		jz	short loc_580D

loc_5809:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+47j
		xor	edx, edx
		jnz	short loc_5809

loc_580D:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+43j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 8
		jz	short loc_583C
		mov	ecx, [ebp+var_4]
		call	?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ;	mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)
		movzx	edx, al
		test	edx, edx
		jz	short loc_583C
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B4h]
		push	ecx
		call	?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z ; mozilla::gfx::BasicLogger::CrashAction(mozilla::gfx::LogReason)
		add	esp, 4

loc_583C:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+1Bj
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+55j ...
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 584Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	; std::allocator<std::_Container_proxy>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_0		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4_0
$LN4_0		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000058C8o
		dd offset $LN3_0	; "_Alproxy"
$LN3_0		db '_Alproxy',0         ; DATA XREF: .text$mn:000058D4o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 58E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Assign_rv(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &&)
		public ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z	proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+48p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 10h
		jnb	short loc_5926
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		add	edx, 1
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		add	ecx, 4
		push	ecx		; Dst
		call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
		add	esp, 0Ch
		jmp	short loc_5951
; ---------------------------------------------------------------------------

loc_5926:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+1Ej
		mov	edx, [ebp+arg_0]
		add	edx, 4
		push	edx		; int
		mov	eax, [ebp+var_4]
		add	eax, 4
		push	eax		; void *
		lea	ecx, [ebp+var_8+3]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char	*,char * &>(char * *,char * &)
		mov	edx, [ebp+arg_0]
		mov	dword ptr [edx+4], 0

loc_5951:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+40j
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+arg_0]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5988h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned long	__cdecl	std::_Atomic_fetch_add_4(unsigned long volatile	*, unsigned long, enum	std::memory_order)
		public ?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z
?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z proc near
					; CODE XREF: std::_Atomic_fetch_sub_4(ulong volatile *,ulong,std::memory_order)+11p
					; std::atomic_fetch_add_explicit(std::atomic_uint *,uint,std::memory_order)+Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 5	; switch 6 cases
		ja	short loc_59FE	; jumptable 000059A3 default case
		mov	ecx, [ebp+var_4]
		jmp	ds:$LN12[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	edx, [ebp+arg_4] ; jumptable 000059A3 case 0
		push	edx		; unsigned __int32
		mov	eax, [ebp+arg_0]
		push	eax		; volatile unsigned __int32 *
		call	?_Fetch_add_relaxed_4@std@@YAKPCKK@Z ; std::_Fetch_add_relaxed_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A86
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	ecx, [ebp+arg_4] ; jumptable 000059A3 cases 1,2
		push	ecx		; unsigned __int32
		mov	edx, [ebp+arg_0]
		push	edx		; volatile unsigned __int32 *
		call	?_Fetch_add_acquire_4@std@@YAKPCKK@Z ; std::_Fetch_add_acquire_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A86
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	eax, [ebp+arg_4] ; jumptable 000059A3 case 3
		push	eax		; unsigned __int32
		mov	ecx, [ebp+arg_0]
		push	ecx		; volatile unsigned __int32 *
		call	?_Fetch_add_release_4@std@@YAKPCKK@Z ; std::_Fetch_add_release_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A86
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	edx, [ebp+arg_4] ; jumptable 000059A3 cases 4,5
		push	edx		; unsigned __int32
		mov	eax, [ebp+arg_0]
		push	eax		; volatile unsigned __int32 *
		call	?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z ; std::_Fetch_add_seq_cst_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A86
; ---------------------------------------------------------------------------

loc_59FE:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+16j
		mov	esi, esp	; jumptable 000059A3 default case
		push	698h		; unsigned int
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@ ; "Invalid memory_order"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
		test	ecx, ecx
		jz	short loc_5A2C
		xor	edx, edx
		jnz	short loc_5A5C

loc_5A2C:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+9Ej
		mov	esi, esp
		push	offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	698h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_5A5C
		int	3		; Trap to Debugger

loc_5A5C:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+A2j
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+D1j
		mov	esi, esp
		push	0
		push	698h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1DC@FMPHIJPC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAf?$AAe?$AAt?$AAc?$AAh?$AA_?$AAa?$AAd?$AAd?$AA_?$AA4?$AA?$AA@ ;	"std::_Atomic_fetch_add_4"
		push	offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax

loc_5A86:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+32j
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+47j ...
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd offset $LN5		; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Br
		dd offset $LN4		; jump table for switch	statement
		dd offset $LN4
		dd offset $LN3
		dd offset $LN2
		dd offset $LN2
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5AB0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned long	__cdecl	std::_Atomic_fetch_sub_4(unsigned long volatile	*, unsigned long, enum	std::memory_order)
		public ?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z
?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_fetch_sub_explicit(std::atomic_uint *,uint,std::memory_order)+Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		xor	ecx, ecx
		sub	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z ; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5AD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Atomic_store_4(unsigned long volatile *, unsigned long, enum  std::memory_order)
		public ?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z
?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_store_explicit(std::atomic_uint *,uint,std::memory_order)+Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jz	short loc_5AFA
		cmp	[ebp+var_4], 3
		jz	short loc_5B0F
		cmp	[ebp+var_4], 5
		jz	short loc_5B24
		jmp	short loc_5B39
; ---------------------------------------------------------------------------

loc_5AFA:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+16j
		mov	ecx, [ebp+arg_4]
		push	ecx		; unsigned __int32
		mov	edx, [ebp+arg_0]
		push	edx		; volatile unsigned __int32 *
		call	?_Store_relaxed_4@std@@YAXPCKK@Z ; std::_Store_relaxed_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5BBF
; ---------------------------------------------------------------------------

loc_5B0F:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+1Cj
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned __int32
		mov	ecx, [ebp+arg_0]
		push	ecx		; volatile unsigned __int32 *
		call	?_Store_release_4@std@@YAXPCKK@Z ; std::_Store_release_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5BBF
; ---------------------------------------------------------------------------

loc_5B24:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+22j
		mov	edx, [ebp+arg_4]
		push	edx		; unsigned __int32
		mov	eax, [ebp+arg_0]
		push	eax		; volatile unsigned __int32 *
		call	?_Store_seq_cst_4@std@@YAXPCKK@Z ; std::_Store_seq_cst_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5BBF
; ---------------------------------------------------------------------------

loc_5B39:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+24j
		mov	esi, esp
		push	577h		; unsigned int
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@ ; "Invalid memory_order"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
		test	ecx, ecx
		jz	short loc_5B67
		xor	edx, edx
		jnz	short loc_5B97

loc_5B67:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+8Dj
		mov	esi, esp
		push	offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	577h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_5B97
		int	3		; Trap to Debugger

loc_5B97:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+91j
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+C0j
		mov	esi, esp
		push	0
		push	577h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@ ; "std::_Atomic_store_4"
		push	offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5BBF:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+36j
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+4Bj ...
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5BD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
		public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Cp

var_38		= byte ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_25		= byte ptr -25h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 00005D17 SIZE 00000009 BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 28h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_38]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		or	eax, 0Fh
		mov	[ebp+var_18], eax
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+var_18]
		jnb	short loc_5C2E
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_18], ecx
		jmp	short loc_5C80
; ---------------------------------------------------------------------------

loc_5C2E:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+54j
		mov	eax, [ebp+var_18]
		xor	edx, edx
		mov	ecx, 3
		div	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+18h]
		shr	ecx, 1
		cmp	ecx, eax
		ja	short loc_5C48
		jmp	short loc_5C80
; ---------------------------------------------------------------------------

loc_5C48:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+74j
		mov	edx, [ebp+var_14]
		mov	esi, [edx+18h]
		shr	esi, 1
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		sub	eax, esi
		mov	ecx, [ebp+var_14]
		cmp	[ecx+18h], eax
		ja	short loc_5C75
		mov	edx, [ebp+var_14]
		mov	eax, [edx+18h]
		shr	eax, 1
		mov	ecx, [ebp+var_14]
		add	eax, [ecx+18h]
		mov	[ebp+var_18], eax
		jmp	short loc_5C80
; ---------------------------------------------------------------------------

loc_5C75:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+90j
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		mov	[ebp+var_18], eax

loc_5C80:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5Cj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+76j ...
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_25]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_18]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_2C]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp+var_30], eax
		mov	ecx, [ebp+var_30]
		mov	[ebp+var_20], ecx
		jmp	short loc_5D17
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp


; =============== S U B	R O U T	I N E =======================================


__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
					; DATA XREF: .xdata$x:00008630o

; FUNCTION CHUNK AT 00005D01 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00005D11 SIZE 00000006 BYTES

		mov	[ebp-10h], esp
		mov	edx, [ebp+8]
		mov	[ebp-18h], edx
		mov	byte ptr [ebp-4], 2
		lea	eax, [ebp-26h]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp-34h], eax
		mov	ecx, [ebp-18h]
		add	ecx, 1
		push	ecx
		mov	ecx, [ebp-34h]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp-38h], eax
		mov	edx, [ebp-38h]
		mov	[ebp-20h], edx
		jmp	short loc_5D01
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
					; DATA XREF: .xdata$x:00008640o
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN17
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_5D01:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+34j
		mov	dword ptr [ebp-4], 1
		jmp	short loc_5D11
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

; =============== S U B	R O U T	I N E =======================================


$LN17		proc near		; DATA XREF: .text$mn:00005CFBo
		mov	dword ptr [ebp-4], 1
$LN17		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_5D11:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+58j
		mov	eax, offset $LN19
		retn
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

loc_5D17:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+DEj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_5D27
; END OF FUNCTION CHUNK	FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

; =============== S U B	R O U T	I N E =======================================


$LN19		proc near		; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_5D11o
		mov	dword ptr [ebp-4], 0FFFFFFFFh

loc_5D27:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+14Ej
		cmp	dword ptr [ebp+0Ch], 0
		jbe	short loc_5D46
		mov	eax, [ebp+0Ch]
		push	eax		; Size
		mov	ecx, [ebp-14h]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Src
		mov	ecx, [ebp-20h]
		push	ecx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_5D46:				; CODE XREF: $LN19+Bj
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		lea	edx, [ebp-20h]
		push	edx		; int
		mov	eax, [ebp-14h]
		add	eax, 4
		push	eax		; void *
		lea	ecx, [ebp-27h]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char	*,char * &>(char * *,char * &)
		mov	edx, [ebp-14h]
		mov	eax, [ebp-18h]
		mov	[edx+18h], eax
		mov	ecx, [ebp+0Ch]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp-0Ch]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 38h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
$LN19		endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN23		dd 1			; DATA XREF: $LN19+69o
		dd offset $LN22
$LN22		dd 0FFFFFFE0h, 4	; DATA XREF: .text$mn:00005DB8o
		dd offset $LN20		; "_Ptr"
$LN20		db '_Ptr',0             ; DATA XREF: .text$mn:00005DC4o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5DD0h
; COMDAT (pick associative to section at 5BD0)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-3Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
		public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc	near
					; CODE XREF: $LN19+60p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+98p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	byte ptr [ebp+var_8+3],	0
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		lea	edx, [ebp+var_8+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		push	eax
		call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
		add	esp, 8
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_acquire_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_acquire_4@std@@YAKPCKK@Z
?_Fetch_add_acquire_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+3Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_acquire_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E48h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_relaxed_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_relaxed_4@std@@YAKPCKK@Z
?_Fetch_add_relaxed_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+2Ap

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_relaxed_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_release_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_release_4@std@@YAKPCKK@Z
?_Fetch_add_release_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+54p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_release_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_seq_cst_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z
?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+69p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_1		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+60o
		dd offset $LN4_1
$LN4_1		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00005EF8o
		dd offset $LN3_1	; "_Alproxy"
$LN3_1		db '_Alproxy',0         ; DATA XREF: .text$mn:00005F04o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5F14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
		public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+1Ep
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+57p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5F40h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::_Getstate(int)
		public ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+62p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jnz	short loc_5F6F
		mov	ecx, [ebp+var_8]
		or	ecx, 4
		mov	[ebp+var_8], ecx

loc_5F6F:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+24j
		mov	edx, [ebp+arg_0]
		and	edx, 2
		jnz	short loc_5F80
		mov	eax, [ebp+var_8]
		or	eax, 2
		mov	[ebp+var_8], eax

loc_5F80:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+35j
		mov	ecx, [ebp+arg_0]
		and	ecx, 8
		jz	short loc_5F91
		mov	edx, [ebp+var_8]
		or	edx, 8
		mov	[ebp+var_8], edx

loc_5F91:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+46j
		mov	eax, [ebp+arg_0]
		and	eax, 4
		jz	short loc_5FA2
		mov	ecx, [ebp+var_8]
		or	ecx, 10h
		mov	[ebp+var_8], ecx

loc_5FA2:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+57j
		mov	eax, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5FACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
		public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+78p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+66p

var_C		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_5FDF
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)

loc_5FDF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+29j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_5FFF
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
		jmp	short loc_6049
; ---------------------------------------------------------------------------

loc_5FFF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
		movzx	edx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_6039
		cmp	[ebp+arg_0], 10h
		jnb	short loc_6039
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+14h]
		jnb	short loc_6020
		mov	edx, [ebp+arg_0]
		mov	[ebp+Size], edx
		jmp	short loc_6029
; ---------------------------------------------------------------------------

loc_6020:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+6Aj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		mov	[ebp+Size], ecx

loc_6029:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+72j
		mov	edx, [ebp+Size]
		push	edx		; Size
		push	1		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		jmp	short loc_6049
; ---------------------------------------------------------------------------

loc_6039:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+59j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Fj
		cmp	[ebp+arg_0], 0
		jnz	short loc_6049
		push	0
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_6049:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+51j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Bj ...
		cmp	[ebp+arg_0], 0
		jbe	short loc_6058
		mov	[ebp+var_C], 1
		jmp	short loc_605F
; ---------------------------------------------------------------------------

loc_6058:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+A1j
		mov	[ebp+var_C], 0

loc_605F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+AAj
		mov	al, byte ptr [ebp+var_C]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6074h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(void *Src, size_t	Size, int)
		public ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+6Fp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+32p

var_C		= dword	ptr -0Ch
Dst		= dword	ptr -8
var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	esi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Dst], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+38h], 0
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+arg_8]
		mov	[ecx+3Ch], edx
		cmp	[ebp+Size], 0
		jz	loc_61A9
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 6
		cmp	ecx, 6
		jz	loc_61A9
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		mov	[ebp+Dst], eax
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		add	eax, [ebp+Size]
		mov	ecx, [ebp+var_4]
		mov	[ecx+38h], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx+3Ch]
		and	eax, 4
		jnz	short loc_6120
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+Size]
		mov	esi, esp
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6120:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+89j
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+3Ch]
		and	edx, 2
		jnz	short loc_619A
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 18h
		jz	short loc_6141
		mov	edx, [ebp+Dst]
		add	edx, [ebp+Size]
		mov	[ebp+var_C], edx
		jmp	short loc_6147
; ---------------------------------------------------------------------------

loc_6141:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+C0j
		mov	eax, [ebp+Dst]
		mov	[ebp+var_C], eax

loc_6147:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+CBj
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+Size]
		mov	esi, esp
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_619A
		mov	esi, esp
		mov	ecx, [ebp+Dst]
		push	ecx
		push	0
		mov	edx, [ebp+Dst]
		push	edx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_619A:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+B5j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+108j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		or	ecx, 1
		mov	edx, [ebp+var_4]
		mov	[edx+3Ch], ecx

loc_61A9:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+36j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+48j
		pop	esi
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61BCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
		public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+31p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_61F0
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		cmp	[ebp+arg_0], eax
		jb	short loc_61F0
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+var_4]
		add	eax, [ecx+14h]
		cmp	eax, [ebp+arg_0]
		ja	short loc_61F6

loc_61F0:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+12j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+1Fj
		xor	al, al
		jmp	short loc_61F8
; ---------------------------------------------------------------------------
		jmp	short loc_61F8
; ---------------------------------------------------------------------------

loc_61F6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+32j
		mov	al, 1

loc_61F8:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+36j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+38j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6208h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
					; CODE XREF: $LN19+14p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+2Bp ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_623C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_6245
; ---------------------------------------------------------------------------

loc_623C:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_6245:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6258h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+8Bp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_628C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_6295
; ---------------------------------------------------------------------------

loc_628C:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_6295:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 62A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Store_relaxed_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Store_relaxed_4@std@@YAXPCKK@Z
?_Store_relaxed_4@std@@YAXPCKK@Z proc near
					; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+2Ep

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		pop	ebp
		retn
?_Store_relaxed_4@std@@YAXPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 62B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Store_release_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Store_release_4@std@@YAXPCKK@Z
?_Store_release_4@std@@YAXPCKK@Z proc near
					; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+43p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		pop	ebp
		retn
?_Store_release_4@std@@YAXPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 62C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Store_seq_cst_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Store_seq_cst_4@std@@YAXPCKK@Z
?_Store_seq_cst_4@std@@YAXPCKK@Z proc near
					; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+58p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		xchg	eax, [ecx]
		pop	ebp
		retn
?_Store_seq_cst_4@std@@YAXPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 62D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t	Size)
		public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+33p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+55p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_6300
		jmp	short loc_6373
; ---------------------------------------------------------------------------

loc_6300:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+24j
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+18h], 10h
		jb	short loc_6373
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		add	ecx, 4
		push	ecx
		lea	edx, [ebp+var_C+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
		cmp	[ebp+Size], 0
		jbe	short loc_6352
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		push	ecx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		push	eax		; Src
		mov	edx, [ebp+var_4]
		add	edx, 4
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_6352:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+58j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		add	ecx, 1
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; void *
		lea	eax, [ebp+var_C+2]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)

loc_6373:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+26j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+2Fj
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0Fh
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 639Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::_Tidy(void)
		public ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)+1Bp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 1
		jz	short loc_6437
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_63EC
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		jmp	short loc_6401
; ---------------------------------------------------------------------------

loc_63EC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+37j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax

loc_6401:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+4Ej
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_8]
		sub	edx, eax
		push	edx		; int
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; void *
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)

loc_6437:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+21j
		mov	esi, esp
		push	0
		push	0
		push	0
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0
		push	0
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+38h], 0
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+3Ch]
		and	edx, 0FFFFFFFEh
		mov	eax, [ebp+var_4]
		mov	[eax+3Ch], edx
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6490h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
		public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+2Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
		public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+27p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+1Cp	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
		call	dword ptr ds:__imp_?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicAddSub<unsigned	int, 2>::add(struct std::atomic<unsigned int> &, unsigned int)
		public ?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z
?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicIncDec<uint,2>::inc(std::atomic<uint> &)+9p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z ; std::atomic_uint::fetch_add(uint,std::memory_order)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6514h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+D0p
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+26p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6540h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
		public ?allocate@?$allocator@D@std@@QAEPADI@Z
?allocate@?$allocator@D@std@@QAEPADI@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+58p
					; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+15p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@D@std@@YAPADIPAD@Z	; std::_Allocate<char>(uint,char *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@D@std@@QAEPADI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 656Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
		public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+2Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6598h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>> const &, unsigned int, unsigned int)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+56p

Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		cmp	eax, [ebp+arg_4]
		jnb	short loc_65C4
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_65C4:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+22j
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		sub	eax, [ebp+arg_4]
		mov	[ebp+Size], eax
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+Size]
		jnb	short loc_65E0
		mov	ecx, [ebp+arg_8]
		mov	[ebp+Size], ecx

loc_65E0:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
		mov	edx, [ebp+var_4]
		cmp	edx, [ebp+arg_0]
		jnz	short loc_6607
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
		jmp	short loc_6649
; ---------------------------------------------------------------------------

loc_6607:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Ej
		push	0
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	eax, al
		test	eax, eax
		jz	short loc_6649
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	ecx, [ebp+arg_0]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_4]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_6649:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+82j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 665Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+61p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	490h		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Str]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	?length@?$char_traits@D@std@@SAIPBD@Z ;	std::char_traits<char>::length(char const *)
		add	esp, 4
		push	eax		; Size
		mov	edx, [ebp+Str]
		push	edx		; Src
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char	const *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 66ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)+65p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+38p

var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+Size], 0
		jz	short loc_66D6
		push	47Fh		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Src]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch

loc_66D6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12j
		mov	ecx, [ebp+Src]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
		movzx	edx, al
		test	edx, edx
		jz	short loc_6709
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+Src]
		sub	ecx, eax
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
		jmp	short loc_6746
; ---------------------------------------------------------------------------

loc_6709:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+3Bj
		push	0
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_6743
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+Src]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Size]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_6743:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+70j
		mov	eax, [ebp+var_4]

loc_6746:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Bj
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6758h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::char_traits<char>::assign(char &, char const	&)
		public ?assign@?$char_traits@D@std@@SAXAADABD@Z
?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+34p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx]
		mov	[eax], dl
		pop	ebp
		retn
?assign@?$char_traits@D@std@@SAXAADABD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6768h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1Bitmap>::assign_assuming_AddRef(struct ID2D1Bitmap *)
		public ?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z
?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_67A1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z ;	RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::Release(ID2D1Bitmap *)
		add	esp, 4

loc_67A1:				; CODE XREF: RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 67B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1RenderTarget>::assign_assuming_AddRef(struct ID2D1RenderTarget *)
		public ?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z
?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_67ED
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	; RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::Release(ID2D1RenderTarget	*)
		add	esp, 4

loc_67ED:				; CODE XREF: RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6800h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1SolidColorBrush>::assign_assuming_AddRef(struct ID2D1SolidColorBrush *)
		public ?assign_assuming_AddRef@?$RefPtr@UID2D1SolidColorBrush@@@@AAEXPAUID2D1SolidColorBrush@@@Z
?assign_assuming_AddRef@?$RefPtr@UID2D1SolidColorBrush@@@@AAEXPAUID2D1SolidColorBrush@@@Z proc near
					; CODE XREF: RefPtr<ID2D1SolidColorBrush>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6839
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID2D1SolidColorBrush@@@?$RefPtr@UID2D1SolidColorBrush@@@@SAXPAUID2D1SolidColorBrush@@@Z ; RefPtr<ID2D1SolidColorBrush>::AddRefTraits<ID2D1SolidColorBrush>::Release(ID2D1SolidColorBrush *)
		add	esp, 4

loc_6839:				; CODE XREF: RefPtr<ID2D1SolidColorBrush>::assign_assuming_AddRef(ID2D1SolidColorBrush *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID2D1SolidColorBrush@@@@AAEXPAUID2D1SolidColorBrush@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 684Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID3D10Device>::assign_assuming_AddRef(struct ID3D10Device *)
		public ?assign_assuming_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z
?assign_assuming_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Device>::StartAssignment(void)+13p
					; RefPtr<ID3D10Device>::assign_with_AddRef(ID3D10Device	*)+27p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6885
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::AddRefTraits<ID3D10Device>::Release(ID3D10Device *)
		add	esp, 4

loc_6885:				; CODE XREF: RefPtr<ID3D10Device>::assign_assuming_AddRef(ID3D10Device *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6898h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID3D10Texture2D>::assign_assuming_AddRef(struct ID3D10Texture2D *)
		public ?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z
?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::StartAssignment(void)+13p
					; RefPtr<ID3D10Texture2D>::assign_with_AddRef(ID3D10Texture2D *)+27p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_68D1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::Release(ID3D10Texture2D *)
		add	esp, 4

loc_68D1:				; CODE XREF: RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct IDXGISurface>::assign_assuming_AddRef(struct IDXGISurface *)
		public ?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z
?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z proc near
					; CODE XREF: RefPtr<IDXGISurface>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_691D
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::AddRefTraits<IDXGISurface>::Release(IDXGISurface *)
		add	esp, 4

loc_691D:				; CODE XREF: RefPtr<IDXGISurface>::assign_assuming_AddRef(IDXGISurface *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6930h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID3D10Device>::assign_with_AddRef(struct ID3D10Device *)
		public ?assign_with_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z
?assign_with_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Device>::operator=(ID3D10Device *)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_6950
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRef@?$AddRefTraits@UID3D10Device@@@?$RefPtr@UID3D10Device@@@@SAXPAUID3D10Device@@@Z	; RefPtr<ID3D10Device>::AddRefTraits<ID3D10Device>::AddRef(ID3D10Device	*)
		add	esp, 4

loc_6950:				; CODE XREF: RefPtr<ID3D10Device>::assign_with_AddRef(ID3D10Device *)+12j
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z ; RefPtr<ID3D10Device>::assign_assuming_AddRef(ID3D10Device *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_with_AddRef@?$RefPtr@UID3D10Device@@@@AAEXPAUID3D10Device@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 696Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID3D10Texture2D>::assign_with_AddRef(struct ID3D10Texture2D *)
		public ?assign_with_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z
?assign_with_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::operator=(ID3D10Texture2D	*)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_698C
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::AddRef(ID3D10Texture2D *)
		add	esp, 4

loc_698C:				; CODE XREF: RefPtr<ID3D10Texture2D>::assign_with_AddRef(ID3D10Texture2D *)+12j
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	; RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_with_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl std::atomic_fetch_add_explicit(struct std::atomic_uint *, unsigned int, enum  std::memory_order)
		public ?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z
?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_uint::fetch_add(uint,std::memory_order)+1Ap

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z ; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl std::atomic_fetch_sub_explicit(struct std::atomic_uint *, unsigned int, enum  std::memory_order)
		public ?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z
?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_uint::fetch_sub(uint,std::memory_order)+1Ap

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z ; std::_Atomic_fetch_sub_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::atomic_store(struct	std::atomic_uint *, unsigned int)
		public ?atomic_store@std@@YAXPAUatomic_uint@1@I@Z
?atomic_store@std@@YAXPAUatomic_uint@1@I@Z proc	near
					; CODE XREF: std::atomic_uint::operator=(uint)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z ; std::atomic_store_explicit(std::atomic_uint *,uint,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_store@std@@YAXPAUatomic_uint@1@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::atomic_store_explicit(struct std::atomic_uint *, unsigned int, enum	 std::memory_order)
		public ?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z
?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_store(std::atomic_uint	*,uint)+Dp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z ; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+46p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+29p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
		public ?category@error_code@std@@QBEABVerror_category@2@XZ
?category@error_code@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_code@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A64h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
		public ?category@error_condition@std@@QBEABVerror_category@2@XZ
?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Bp
					; std::error_condition::operator==(std::error_condition	const &)+24p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_condition@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A7Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::ToStorageTypeArgument<unsigned int>::convert(unsigned int)
		public ?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z
?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z proc near
					; CODE XREF: mozilla::detail::AtomicBase<uint,2>::AtomicBase<uint,2>(uint)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::copy(void	*Dst, void *Src, size_t	Size)
		public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+6Cp ...

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_6A9D
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_6AB4
; ---------------------------------------------------------------------------

loc_6A9D:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+Fj
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[ebp+var_4], eax

loc_6AB4:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+17j
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::deallocate(void	*, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+96p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::deallocate(void *, int)
		public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+96p
					; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+19p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::deallocate(void *, int)
		public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+4Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicIncDec<unsigned	int, 2>::dec(struct std::atomic<unsigned int> &)
		public ?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z
?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z proc near
					; CODE XREF: mozilla::detail::AtomicBaseIncDec<uint,2>::operator--(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z ;	mozilla::detail::IntrinsicAddSub<uint,2>::sub(std::atomic<uint>	&,uint)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B6Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::dec(struct	std::ios_base *)
		public ?dec@std@@YAAAVios_base@1@AAV21@@Z
?dec@std@@YAAAVios_base@1@AAV21@@Z proc	near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+32o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0E00h		; int
		push	200h		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setf@ios_base@std@@QAEHHH@Z	; std::ios_base::setf(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?dec@std@@YAAAVios_base@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B9Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::_System_error_category::default_error_condition(int)const
		public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00008BC4o

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_6BDE
		call	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category(void)
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		jmp	short loc_6BF3
; ---------------------------------------------------------------------------
		jmp	short loc_6BF3
; ---------------------------------------------------------------------------

loc_6BDE:				; CODE XREF: std::_System_error_category::default_error_condition(int)+27j
		call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
		push	eax		; struct std::error_category *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]

loc_6BF3:				; CODE XREF: std::_System_error_category::default_error_condition(int)+3Ej
					; std::_System_error_category::default_error_condition(int)+40j
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C04h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::error_category::default_error_condition(int)const
		public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00008B34o
					; .rdata:00008B50o ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::empty(void)const
		public ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+64p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_6C61
		mov	[ebp+var_8], 1
		jmp	short loc_6C68
; ---------------------------------------------------------------------------

loc_6C61:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)+1Ej
		mov	[ebp+var_8], 0

loc_6C68:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)+27j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl std::char_traits<char>::eof(void)
		public ?eof@?$char_traits@D@std@@SAHXZ
?eof@?$char_traits@D@std@@SAHXZ	proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1E2p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+30Dp	...
		push	ebp
		mov	ebp, esp
		or	eax, 0FFFFFFFFh
		pop	ebp
		retn
?eof@?$char_traits@D@std@@SAHXZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl std::char_traits<char>::eq(char const &, char const &)
		public ?eq@?$char_traits@D@std@@SA_NABD0@Z
?eq@?$char_traits@D@std@@SA_NABD0@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+B0p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax]
		mov	edx, [ebp+arg_4]
		movsx	eax, byte ptr [edx]
		cmp	ecx, eax
		jnz	short loc_6C9C
		mov	[ebp+var_4], 1
		jmp	short loc_6CA3
; ---------------------------------------------------------------------------

loc_6C9C:				; CODE XREF: std::char_traits<char>::eq(char const &,char const	&)+19j
		mov	[ebp+var_4], 0

loc_6CA3:				; CODE XREF: std::char_traits<char>::eq(char const &,char const	&)+22j
		mov	al, byte ptr [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
?eq@?$char_traits@D@std@@SA_NABD0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl std::char_traits<char>::eq_int_type(int const &, int const &)
		public ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1F2p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+31Dp	...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_6CCC
		mov	[ebp+var_4], 1
		jmp	short loc_6CD3
; ---------------------------------------------------------------------------

loc_6CCC:				; CODE XREF: std::char_traits<char>::eq_int_type(int const &,int const &)+15j
		mov	[ebp+var_4], 0

loc_6CD3:				; CODE XREF: std::char_traits<char>::eq_int_type(int const &,int const &)+1Ej
		mov	al, byte ptr [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
		public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
					; DATA XREF: .rdata:00008B38o
					; .rdata:00008B54o ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_6D21
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_code@std@@QBEHXZ ;	std::error_code::value(void)
		cmp	eax, [ebp+arg_4]
		jnz	short loc_6D21
		mov	[ebp+var_8], 1
		jmp	short loc_6D28
; ---------------------------------------------------------------------------

loc_6D21:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+2Dj
					; std::error_category::equivalent(std::error_code const	&,int)+3Aj
		mov	[ebp+var_8], 0

loc_6D28:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+43j
		mov	al, byte ptr [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const	struct std::error_condition *)
		public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
					; DATA XREF: .rdata:00008B3Co
					; .rdata:00008B58o ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	esi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; std::error_condition *
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+var_4]
		mov	edx, [eax]
		mov	ecx, [ebp+var_4]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	??8error_condition@std@@QBE_NABV01@@Z ;	std::error_condition::operator==(std::error_condition const &)
		pop	esi
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_6DB9
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_6DB9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+17j
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6DD8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int,	unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+68p

var_C		= dword	ptr -0Ch
Dst		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Dst], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_6E09
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_6E09:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+27j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		ja	short loc_6E25
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		jmp	short loc_6E6B
; ---------------------------------------------------------------------------

loc_6E25:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Dj
		cmp	[ebp+arg_4], 0
		jbe	short loc_6E6B
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		mov	[ebp+Dst], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+var_C]
		sub	ecx, [ebp+arg_0]
		push	ecx		; Size
		mov	edx, [ebp+Dst]
		add	edx, [ebp+arg_4]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_6E6B:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+4Bj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+51j
		mov	eax, [ebp+var_4]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::atomic_uint::fetch_add(unsigned int, enum  std::memory_order)
		public ?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z
?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicAddSub<uint,2>::add(std::atomic<uint> &,uint)+Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		call	?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z ; std::atomic_fetch_add_explicit(std::atomic_uint *,uint,std::memory_order)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6EB4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::atomic_uint::fetch_sub(unsigned int, enum  std::memory_order)
		public ?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z
?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicAddSub<uint,2>::sub(std::atomic<uint> &,uint)+Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		call	?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z ; std::atomic_fetch_sub_explicit(std::atomic_uint *,uint,std::memory_order)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6EE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct already_AddRefed<class	mozilla::gfx::DataSourceSurfaceD2D> __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::forget(void)
		public ?forget@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@XZ
?forget@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+ADp

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_14], 0
		mov	[ebp+var_C], 0
		lea	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?swap@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::swap(mozilla::gfx::DataSourceSurfaceD2D	* &)
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2D@gfx@mozilla@@@Z ; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>::already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D>(mozilla::gfx::DataSourceSurfaceD2D *)
		mov	edx, [ebp+var_14]
		or	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?forget@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@XZ endp

; ---------------------------------------------------------------------------
$LN7_0		dd 1			; DATA XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::forget(void)+53o
		dd offset $LN6
$LN6		dd 0FFFFFFF4h, 4	; DATA XREF: .text$mn:00006F5Co
		dd offset $LN5_8	; "temp"
$LN5_8		db 'temp',0             ; DATA XREF: .text$mn:00006F68o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F74h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::generic_category()
		public ?generic_category@std@@YAABVerror_category@1@XZ
?generic_category@std@@YAABVerror_category@1@XZ	proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+29p
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
		pop	ebp
		retn
?generic_category@std@@YAABVerror_category@1@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1Bitmap * __thiscall RefPtr<struct	ID2D1Bitmap>::get(void)const
		public ?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ
?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)+11p
					; RefPtr<ID2D1Bitmap>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1RenderTarget * __thiscall	RefPtr<struct ID2D1RenderTarget>::get(void)const
		public ?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ
?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ	proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FB0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1SolidColorBrush *	__thiscall RefPtr<struct ID2D1SolidColorBrush>::get(void)const
		public ?get@?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ
?get@?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ proc near
					; CODE XREF: RefPtr<ID2D1SolidColorBrush>::operator ID2D1SolidColorBrush *(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID2D1SolidColorBrush@@@@QBEPAUID2D1SolidColorBrush@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Device *	__thiscall RefPtr<struct ID3D10Device>::get(void)const
		public ?get@?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ
?get@?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ proc near
					; CODE XREF: operator==<ID3D10Device,ID3D10Device1>(RefPtr<ID3D10Device> const &,ID3D10Device1 *)+Ep
					; RefPtr<ID3D10Device>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID3D10Device@@@@QBEPAUID3D10Device@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Texture2D * __thiscall RefPtr<struct ID3D10Texture2D>::get(void)const
		public ?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ
?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)+11p
					; RefPtr<ID3D10Texture2D>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDXGISurface *	__thiscall RefPtr<struct IDXGISurface>::get(void)const
		public ?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ
?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ proc near
					; CODE XREF: RefPtr<IDXGISurface>::operator IDXGISurface *(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7010h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::DataSourceSurfaceD2D * __thiscall	RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::get(void)const
		public ?get@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ
?get@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7028h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::hex(struct	std::ios_base *)
		public ?hex@std@@YAAAVios_base@1@AAV21@@Z
?hex@std@@YAAAVios_base@1@AAV21@@Z proc	near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+46o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0E00h		; int
		push	800h		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setf@ios_base@std@@QAEHHH@Z	; std::ios_base::setf(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?hex@std@@YAAAVios_base@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7058h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicIncDec<unsigned	int, 2>::inc(struct std::atomic<unsigned int> &)
		public ?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z
?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z proc near
					; CODE XREF: mozilla::detail::AtomicBaseIncDec<uint,2>::operator++(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z ;	mozilla::detail::IntrinsicAddSub<uint,2>::add(std::atomic<uint>	&,uint)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7074h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::length(char *Str)
		public ?length@?$char_traits@D@std@@SAIPBD@Z
?length@?$char_traits@D@std@@SAIPBD@Z proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+49p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+28p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_7092
		mov	[ebp+var_4], 0
		jmp	short loc_70A1
; ---------------------------------------------------------------------------

loc_7092:				; CODE XREF: std::char_traits<char>::length(char const *)+13j
		mov	edx, [ebp+Str]
		push	edx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_4], eax

loc_70A1:				; CODE XREF: std::char_traits<char>::length(char const *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@?$char_traits@D@std@@SAIPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+28p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
		public ?max_size@?$allocator@D@std@@QBEIXZ
?max_size@?$allocator@D@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char>	const &)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		or	eax, 0FFFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@D@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class	std::allocator<char> const &)
		public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7108h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
		public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+83p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 1
		ja	short loc_7147
		mov	[ebp+var_10], 1
		jmp	short loc_7150
; ---------------------------------------------------------------------------

loc_7147:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+34j
		mov	ecx, [ebp+var_8]
		sub	ecx, 1
		mov	[ebp+var_10], ecx

loc_7150:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+3Dj
		mov	eax, [ebp+var_10]
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7164h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
		public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; CODE XREF: std::_Iostream_error_category::message(int)+4Cp
					; DATA XREF: .rdata:00008B4Co

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_71AD
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_71B4
; ---------------------------------------------------------------------------

loc_71AD:				; CODE XREF: std::_Generic_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_71B4:				; CODE XREF: std::_Generic_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 71E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
		public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc	near
					; DATA XREF: .rdata:00008B80o

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		cmp	[ebp+arg_4], 1
		jnz	short loc_7221
		push	offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		jmp	short loc_723D
; ---------------------------------------------------------------------------
		jmp	short loc_723D
; ---------------------------------------------------------------------------

loc_7221:				; CODE XREF: std::_Iostream_error_category::message(int)+22j
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]

loc_723D:				; CODE XREF: std::_Iostream_error_category::message(int)+3Dj
					; std::_Iostream_error_category::message(int)+3Fj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7250h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
		public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; DATA XREF: .rdata:00008BC0o

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Winerror_map@std@@YAPBDH@Z	; std::_Winerror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_7299
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_72A0
; ---------------------------------------------------------------------------

loc_7299:				; CODE XREF: std::_System_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_72A0:				; CODE XREF: std::_System_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::move(void	*Dst, void *Src, size_t	Size)
		public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+38p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+7Fp

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_72E6
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_7307
; ---------------------------------------------------------------------------

loc_72E6:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
		mov	esi, esp
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], eax

loc_7307:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+18j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 731Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
		public ?name@_Generic_error_category@std@@UBEPBDXZ
?name@_Generic_error_category@std@@UBEPBDXZ proc near ;	DATA XREF: .rdata:00008B48o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Generic_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7334h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
		public ?name@_Iostream_error_category@std@@UBEPBDXZ
?name@_Iostream_error_category@std@@UBEPBDXZ proc near ; DATA XREF: .rdata:00008B7Co

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Iostream_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 734Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
		public ?name@_System_error_category@std@@UBEPBDXZ
?name@_System_error_category@std@@UBEPBDXZ proc	near ; DATA XREF: .rdata:00008BBCo

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
		mov	esp, ebp
		pop	ebp
		retn
?name@_System_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7364h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::noshowbase(struct std::ios_base *)
		public ?noshowbase@std@@YAAAVios_base@1@AAV21@@Z
?noshowbase@std@@YAAAVios_base@1@AAV21@@Z proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+39o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	8		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?unsetf@ios_base@std@@QAEXH@Z ; std::ios_base::unsetf(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?noshowbase@std@@YAAAVios_base@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 738Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl std::char_traits<char>::not_eof(int const &)
		public ?not_eof@?$char_traits@D@std@@SAHABH@Z
?not_eof@?$char_traits@D@std@@SAHABH@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+66p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+12Cp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jz	short loc_73B6
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	[ebp+var_4], eax
		jmp	short loc_73D5
; ---------------------------------------------------------------------------

loc_73B6:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+1Ej
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		test	eax, eax
		jnz	short loc_73C8
		mov	[ebp+var_8], 1
		jmp	short loc_73CF
; ---------------------------------------------------------------------------

loc_73C8:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+31j
		mov	[ebp+var_8], 0

loc_73CF:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+3Aj
		mov	ecx, [ebp+var_8]
		mov	[ebp+var_4], ecx

loc_73D5:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+28j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?not_eof@?$char_traits@D@std@@SAHABH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 73E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::overflow(int)
		public ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z proc near
					; DATA XREF: .rdata:00008E38o

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
Src		= dword	ptr -18h
Dst		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+Src], eax
		mov	[ebp+Dst], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+Size], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 2
		jz	short loc_742B
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_77CA
; ---------------------------------------------------------------------------
		jmp	short loc_745B
; ---------------------------------------------------------------------------

loc_742B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+35j
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_1C], eax
		lea	edx, [ebp+arg_0]
		push	edx
		lea	eax, [ebp+var_1C]
		push	eax
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_745B
		lea	edx, [ebp+arg_0]
		push	edx
		call	?not_eof@?$char_traits@D@std@@SAHABH@Z ; std::char_traits<char>::not_eof(int const &)
		add	esp, 4
		jmp	loc_77CA
; ---------------------------------------------------------------------------

loc_745B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+41j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+60j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 8
		jz	short loc_74D5
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_74D5
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		cmp	eax, [edx+38h]
		jnb	short loc_74D5
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+38h]
		push	ecx
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_74D5:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+7Cj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+92j ...
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7544
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jnb	short loc_7544
		lea	edx, [ebp+arg_0]
		push	edx
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	bl, al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Pninc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[eax], bl
		mov	eax, [ebp+arg_0]
		jmp	loc_77CA
; ---------------------------------------------------------------------------
		jmp	loc_77CA
; ---------------------------------------------------------------------------

loc_7544:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+101j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+12Bj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_7563
		mov	[ebp+var_20], 0
		jmp	short loc_758E
; ---------------------------------------------------------------------------

loc_7563:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+170j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	[ebp+var_20], esi

loc_758E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+179j
		mov	eax, [ebp+var_20]
		mov	[ebp+Size], eax
		mov	ecx, [ebp+Size]
		mov	[ebp+var_C], ecx
		mov	edx, [ebp+var_C]
		shr	edx, 1
		cmp	edx, 20h ; ' '
		jnb	short loc_75AD
		mov	[ebp+var_24], 20h ; ' '
		jmp	short loc_75B5
; ---------------------------------------------------------------------------

loc_75AD:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1BAj
		mov	eax, [ebp+var_C]
		shr	eax, 1
		mov	[ebp+var_24], eax

loc_75B5:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1C3j
		mov	ecx, [ebp+var_24]
		mov	[ebp+var_10], ecx

loc_75BB:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1EEj
		cmp	[ebp+var_10], 0
		jbe	short loc_75D8
		mov	edx, 7FFFFFFFh
		sub	edx, [ebp+var_10]
		cmp	edx, [ebp+var_C]
		jnb	short loc_75D8
		mov	eax, [ebp+var_10]
		shr	eax, 1
		mov	[ebp+var_10], eax
		jmp	short loc_75BB
; ---------------------------------------------------------------------------

loc_75D8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1D7j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1E4j
		cmp	[ebp+var_10], 0
		jnz	short loc_75E8
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_77CA
; ---------------------------------------------------------------------------

loc_75E8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1F4j
		mov	ecx, [ebp+var_C]
		add	ecx, [ebp+var_10]
		mov	[ebp+var_C], ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		mov	[ebp+Dst], eax
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Src], eax
		cmp	[ebp+Size], 0
		jbe	short loc_7632
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_7632:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+234j
		cmp	[ebp+Size], 0
		jnz	short loc_76AD
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+Dst]
		mov	[eax+38h], ecx
		mov	edx, [ebp+Dst]
		add	edx, [ebp+var_C]
		mov	esi, esp
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+3Ch]
		and	edx, 4
		jz	short loc_7687
		mov	esi, esp
		mov	eax, [ebp+Dst]
		push	eax
		push	0
		mov	ecx, [ebp+Dst]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_76A8
; ---------------------------------------------------------------------------

loc_7687:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+27Fj
		mov	edx, [ebp+Dst]
		add	edx, 1
		mov	esi, esp
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+Dst]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_76A8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+29Dj
		jmp	loc_7778
; ---------------------------------------------------------------------------

loc_76AD:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+24Ej
		mov	edx, [ebp+var_4]
		mov	eax, [edx+38h]
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		mov	ecx, [ebp+var_4]
		mov	[ecx+38h], eax
		mov	edx, [ebp+Dst]
		add	edx, [ebp+var_C]
		mov	esi, esp
		push	edx
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 4
		jz	short loc_7733
		mov	esi, esp
		mov	edx, [ebp+Dst]
		push	edx
		push	0
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7778
; ---------------------------------------------------------------------------

loc_7733:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+32Bj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+Dst]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7778:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int):loc_76A8j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+349j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+3Ch]
		and	eax, 1
		jz	short loc_7796
		mov	ecx, [ebp+Size]
		push	ecx		; int
		mov	edx, [ebp+Src]
		push	edx		; void *
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)

loc_7796:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+399j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		or	ecx, 1
		mov	edx, [ebp+var_4]
		mov	[edx+3Ch], ecx
		lea	eax, [ebp+arg_0]
		push	eax
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	bl, al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Pninc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[eax], bl
		mov	eax, [ebp+arg_0]

loc_77CA:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+3Cj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+6Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 24h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 77E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::pbackfail(int)
		public ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z proc	near
					; DATA XREF: .rdata:00008E3Co

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_78AA
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jbe	short loc_78AA
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_8], eax
		lea	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	edx, al
		test	edx, edx
		jnz	short loc_78B3
		lea	eax, [ebp+arg_0]
		push	eax
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	byte ptr [ebp+var_C+3],	al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, 1
		imul	edx, ecx, -1
		add	eax, edx
		push	eax
		lea	eax, [ebp+var_C+3]
		push	eax
		call	?eq@?$char_traits@D@std@@SA_NABD0@Z ; std::char_traits<char>::eq(char const &,char const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_78B3
		mov	edx, [ebp+var_4]
		mov	eax, [edx+3Ch]
		and	eax, 2
		jz	short loc_78B3

loc_78AA:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+31j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+5Fj
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	short loc_7914
; ---------------------------------------------------------------------------
		jmp	short loc_7914
; ---------------------------------------------------------------------------

loc_78B3:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+7Ej
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+BDj ...
		mov	esi, esp
		push	0FFFFFFFFh
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_10], eax
		lea	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_10]
		push	edx
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	eax, al
		test	eax, eax
		jnz	short loc_7908
		lea	ecx, [ebp+arg_0]
		push	ecx
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	bl, al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[eax], bl

loc_7908:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+104j
		lea	edx, [ebp+arg_0]
		push	edx
		call	?not_eof@?$char_traits@D@std@@SAHABH@Z ; std::char_traits<char>::not_eof(int const &)
		add	esp, 4

loc_7914:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+CFj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+D1j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7928h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual class std::fpos<int> __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::seekoff(__int64, int, int)
		public ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z proc near
					; DATA XREF: .rdata:00008E54o

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_798F
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		cmp	[ecx+38h], eax
		jnb	short loc_798F
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+38h], eax

loc_798F:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+33j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+4Dj
		mov	eax, [ebp+arg_10]
		and	eax, 1
		jz	loc_7B5B
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7B5B
		cmp	[ebp+arg_C], 2
		jnz	short loc_79E6
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7A44
; ---------------------------------------------------------------------------

loc_79E6:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+91j
		cmp	[ebp+arg_C], 1
		jnz	short loc_7A2D
		mov	eax, [ebp+arg_10]
		and	eax, 2
		jnz	short loc_7A2D
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7A44
; ---------------------------------------------------------------------------

loc_7A2D:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+C2j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+CAj
		cmp	[ebp+arg_C], 0
		jz	short loc_7A44
		mov	ecx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	edx, [ecx]
		mov	[ebp+arg_4], edx
		mov	eax, [ecx+4]
		mov	[ebp+arg_8], eax

loc_7A44:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+BCj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+103j ...
		cmp	[ebp+arg_8], 0
		jl	loc_7B46
		jg	short loc_7A5A
		cmp	[ebp+arg_4], 0
		jb	loc_7B46

loc_7A5A:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+126j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_8]
		jg	loc_7B46
		jl	short loc_7A97
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_C]
		ja	loc_7B46

loc_7A97:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+161j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+arg_10]
		and	edx, 2
		jz	short loc_7B44
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7B44
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7B44:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+1B9j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+1CFj
		jmp	short loc_7B56
; ---------------------------------------------------------------------------

loc_7B46:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+120j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+12Cj ...
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+4]
		mov	[ebp+arg_8], edx

loc_7B56:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7B44j
		jmp	loc_7CBF
; ---------------------------------------------------------------------------

loc_7B5B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+6Dj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+87j
		mov	eax, [ebp+arg_10]
		and	eax, 2
		jz	loc_7CA7
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7CA7
		cmp	[ebp+arg_C], 2
		jnz	short loc_7BB2
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7C07
; ---------------------------------------------------------------------------

loc_7BB2:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+25Dj
		cmp	[ebp+arg_C], 1
		jnz	short loc_7BF1
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7C07
; ---------------------------------------------------------------------------

loc_7BF1:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+28Ej
		cmp	[ebp+arg_C], 0
		jz	short loc_7C07
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+4]
		mov	[ebp+arg_8], edx

loc_7C07:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+288j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2C7j ...
		cmp	[ebp+arg_8], 0
		jl	loc_7C94
		jg	short loc_7C19
		cmp	[ebp+arg_4], 0
		jb	short loc_7C94

loc_7C19:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2E9j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_10]
		jg	short loc_7C94
		jl	short loc_7C4E
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_14]
		ja	short loc_7C94

loc_7C4E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+31Cj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::pbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7CA5
; ---------------------------------------------------------------------------

loc_7C94:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2E3j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2EFj ...
		mov	edx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	eax, [edx]
		mov	[ebp+arg_4], eax
		mov	ecx, [edx+4]
		mov	[ebp+arg_8], ecx

loc_7CA5:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+36Aj
		jmp	short loc_7CBF
; ---------------------------------------------------------------------------

loc_7CA7:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+239j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+253j
		mov	edx, [ebp+arg_4]
		or	edx, [ebp+arg_8]
		jz	short loc_7CBF
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+4]
		mov	[ebp+arg_8], edx

loc_7CBF:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7B56j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7CA5j ...
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$fpos@H@std@@QAE@_J@Z ; std::fpos<int>::fpos<int>(__int64)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7CE4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual class std::fpos<int> __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::seekpos(class std::fpos<int>, int)
		public ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z proc near
					; DATA XREF: .rdata:00008E58o

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 20h
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+arg_4]
		call	??B?$fpos@H@std@@QBE_JXZ ; std::fpos<int>::operator __int64(void)
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7D62
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		cmp	[ecx+38h], eax
		jnb	short loc_7D62
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+38h], eax

loc_7D62:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+4Aj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+64j
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	[ebp+var_10], eax
		mov	ecx, [ebp+var_10]
		mov	edx, [ebp+var_C]
		cmp	edx, [ecx]
		jnz	short loc_7D84
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+4]
		jnz	short loc_7D84
		jmp	loc_7F98
; ---------------------------------------------------------------------------

loc_7D84:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+8Ej
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+99j
		mov	edx, [ebp+arg_1C]
		and	edx, 1
		jz	loc_7EC1
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7EC1
		cmp	[ebp+var_8], 0
		jl	loc_7EAC
		jg	short loc_7DC0
		cmp	[ebp+var_C], 0
		jb	loc_7EAC

loc_7DC0:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+D0j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jg	loc_7EAC
		jl	short loc_7DFD
		mov	ecx, [ebp+var_C]
		cmp	ecx, [ebp+var_18]
		ja	loc_7EAC

loc_7DFD:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+10Bj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+var_C]
		adc	edx, [ebp+var_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+arg_1C]
		and	edx, 2
		jz	short loc_7EAA
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7EAA
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7EAA:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+163j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+179j
		jmp	short loc_7EBC
; ---------------------------------------------------------------------------

loc_7EAC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+CAj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+D6j ...
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+var_C], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_8], edx

loc_7EBC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int):loc_7EAAj
		jmp	loc_7F98
; ---------------------------------------------------------------------------

loc_7EC1:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+A6j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+C0j
		mov	eax, [ebp+arg_1C]
		and	eax, 2
		jz	loc_7F87
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7F87
		cmp	[ebp+var_8], 0
		jl	loc_7F74
		jg	short loc_7EF9
		cmp	[ebp+var_C], 0
		jb	short loc_7F74

loc_7EF9:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+20Dj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], edx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_1C]
		jg	short loc_7F74
		jl	short loc_7F2E
		mov	ecx, [ebp+var_C]
		cmp	ecx, [ebp+var_20]
		ja	short loc_7F74

loc_7F2E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+240j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+var_C]
		adc	edx, [ebp+var_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::pbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7F85
; ---------------------------------------------------------------------------

loc_7F74:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+207j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+213j ...
		mov	edx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	eax, [edx]
		mov	[ebp+var_C], eax
		mov	ecx, [edx+4]
		mov	[ebp+var_8], ecx

loc_7F85:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+28Ej
		jmp	short loc_7F98
; ---------------------------------------------------------------------------

loc_7F87:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+1E3j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+1FDj
		mov	edx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	eax, [edx]
		mov	[ebp+var_C], eax
		mov	ecx, [edx+4]
		mov	[ebp+var_8], ecx

loc_7F98:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+9Bj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int):loc_7EBCj ...
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$fpos@H@std@@QAE@_J@Z ; std::fpos<int>::fpos<int>(__int64)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	20h
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FC0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::showbase(struct std::ios_base *)
		public ?showbase@std@@YAAAVios_base@1@AAV21@@Z
?showbase@std@@YAAAVios_base@1@AAV21@@Z	proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+4Do

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	8		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setf@ios_base@std@@QAEHH@Z ; std::ios_base::setf(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?showbase@std@@YAAAVios_base@1@AAV21@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+1Ap
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+2Fp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+14h]
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8000h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::str(class std::basic_string<char, struct std::char_traits<char>, class	std::allocator<char>> const &)
		public ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>>	const &)+18p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ;	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		push	ecx		; int
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8048h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::basic_stringbuf<char, struct	std::char_traits<char>,	class std::allocator<char>>::str(void)const
		public ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ	proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(void)+28p

var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_70		= byte ptr -70h
var_4C		= byte ptr -4Ch
var_28		= byte ptr -28h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 7Ch
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_7C]
		mov	ecx, 1Fh
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_8], ecx
		mov	[ebp+var_78], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+3Ch]
		and	ecx, 2
		jnz	loc_8135
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_8135
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_8]
		cmp	[edx+38h], eax
		jnb	short loc_80CF
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7C], eax
		jmp	short loc_80D8
; ---------------------------------------------------------------------------

loc_80CF:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+6Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]
		mov	[ebp+var_7C], ecx

loc_80D8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+85j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_7C]
		sub	edx, eax
		push	edx		; Size
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; Src
		lea	ecx, [ebp+var_28]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)
		lea	eax, [ebp+var_28]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	ecx, [ebp+var_78]
		or	ecx, 1
		mov	[ebp+var_78], ecx
		lea	ecx, [ebp+var_28]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		jmp	loc_81E6
; ---------------------------------------------------------------------------
		jmp	loc_81E6
; ---------------------------------------------------------------------------

loc_8135:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+36j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+50j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+3Ch]
		and	eax, 4
		jnz	short loc_81BE
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_81BE
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		push	esi		; Size
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; Src
		lea	ecx, [ebp+var_4C]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)
		lea	ecx, [ebp+var_4C]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	edx, [ebp+var_78]
		or	edx, 1
		mov	[ebp+var_78], edx
		lea	ecx, [ebp+var_4C]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		jmp	short loc_81E6
; ---------------------------------------------------------------------------
		jmp	short loc_81E6
; ---------------------------------------------------------------------------

loc_81BE:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+F6j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+10Cj
		lea	ecx, [ebp+var_70]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		lea	eax, [ebp+var_70]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	ecx, [ebp+var_78]
		or	ecx, 1
		mov	[ebp+var_78], ecx
		lea	ecx, [ebp+var_70]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]

loc_81E6:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+E3j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+E8j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 7Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN18		dd 3			; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+1A2o
		dd offset $LN17_0
$LN17_0		dd 0FFFFFFD8h, 1Ch	; DATA XREF: .text$mn:00008218o
		dd offset $LN14		; "_Str"
		dd 0FFFFFFB4h, 1Ch
		dd offset $LN15		; "_Str"
		db 90h
		db 3 dup(0FFh)
		dd 1Ch
		dd offset $LN16		; "_Nul"
$LN16		db '_Nul',0             ; DATA XREF: .text$mn:0000823Co
$LN15		db '_Str',0             ; DATA XREF: .text$mn:00008230o
$LN14		db '_Str',0             ; DATA XREF: .text$mn:00008224o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8250h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::str(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+94p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		add	ecx, 18h
		call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8280h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::str(void)const
		public ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ proc	near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+55p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		add	ecx, 18h
		call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ	; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)
		mov	ecx, [ebp+var_8]
		or	ecx, 1
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicAddSub<unsigned	int, 2>::sub(struct std::atomic<unsigned int> &, unsigned int)
		public ?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z
?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicIncDec<uint,2>::dec(std::atomic<uint> &)+9p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z ; std::atomic_uint::fetch_sub(uint,std::memory_order)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2D>::swap(class mozilla::gfx::DataSourceSurfaceD2D * &)
		public ?swap@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z
?swap@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2D>::forget(void)+32p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[edx], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+var_8]
		mov	[edx], eax
		mov	esp, ebp
		pop	ebp
		retn	4
?swap@?$RefPtr@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2D@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8320h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::system_category()
		public ?system_category@std@@YAABVerror_category@1@XZ
?system_category@std@@YAABVerror_category@1@XZ proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int):loc_6BDEp
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
		pop	ebp
		retn
?system_category@std@@YAABVerror_category@1@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 832Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::DataSourceSurfaceD2D * __thiscall	already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2D>::take(void)
		public ?take@?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ
?take@?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ proc near
					; CODE XREF: already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(already_AddRefed<mozilla::gfx::DataSourceSurfaceD2D> &&)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx], 0
		mov	eax, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?take@?$already_AddRefed@VDataSourceSurfaceD2D@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2D@gfx@mozilla@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 835Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static char __cdecl std::char_traits<char>::to_char_type(int const &)
		public ?to_char_type@?$char_traits@D@std@@SADABH@Z
?to_char_type@?$char_traits@D@std@@SADABH@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+131p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+3C1p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	al, [eax]
		pop	ebp
		retn
?to_char_type@?$char_traits@D@std@@SADABH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8368h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl std::char_traits<char>::to_int_type(char const &)
		public ?to_int_type@?$char_traits@D@std@@SAHABD@Z
?to_int_type@?$char_traits@D@std@@SAHABD@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+72p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+17Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		movzx	eax, byte ptr [eax]
		pop	ebp
		retn
?to_int_type@?$char_traits@D@std@@SAHABD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8374h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::underflow(void)
		public ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ proc near
					; DATA XREF: .rdata:00008E44o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		push	edi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_83A9
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_84F8
; ---------------------------------------------------------------------------
		jmp	loc_84F8
; ---------------------------------------------------------------------------

loc_83A9:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+24j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jnb	short loc_83F8
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
		add	esp, 4
		jmp	loc_84F8
; ---------------------------------------------------------------------------
		jmp	loc_84F8
; ---------------------------------------------------------------------------

loc_83F8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+5Dj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 4
		jnz	short loc_845D
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_845D
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		ja	short loc_846C
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		cmp	[edx+38h], eax
		ja	short loc_846C

loc_845D:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+8Dj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+A3j
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_84F8
; ---------------------------------------------------------------------------
		jmp	loc_84F8
; ---------------------------------------------------------------------------

loc_846C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+CDj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+E7j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		cmp	[ecx+38h], eax
		jnb	short loc_849E
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+38h], eax

loc_849E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+110j
		mov	esi, esp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+38h]
		push	ecx
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
		add	esp, 4

loc_84F8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+2Bj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+30j ...
		pop	edi
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8508h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_code::value(std::error_code	*__hidden this)
		public ?value@error_code@std@@QBEHXZ
?value@error_code@std@@QBEHXZ proc near	; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+32p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_code@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8520h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
		public ?value@error_condition@std@@QBEHXZ
?value@error_condition@std@@QBEHXZ proc	near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+3Ap
					; std::error_condition::operator==(std::error_condition	const &)+44p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_condition@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8538h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _hypot
_hypot		proc near

var_14		= qword	ptr -14h
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		sub	esp, 8
		movsd	xmm0, [ebp+arg_8]
		movsd	[esp+0Ch+var_C], xmm0
		sub	esp, 8
		movsd	xmm0, [ebp+arg_0]
		movsd	[esp+14h+var_14], xmm0
		call	dword ptr ds:__imp___hypot
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
_hypot		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8574h
; COMDAT (pick associative to section at 2EA0)
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008584o
		dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
		dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 85A0h
; COMDAT (pick associative to section at 3204)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000085B0o
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 85CCh
; COMDAT (pick associative to section at 3150)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000085DCo
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 85F8h
; COMDAT (pick associative to section at 30A0)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008608o
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8624h
; COMDAT (pick associative to section at 5BD0)
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 dd offset $SG161859+20h
					; DATA XREF: .xdata$x:000086ACo
					; "data. Code: "
		align 10h
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 dd offset $SG161859+20h
					; DATA XREF: .xdata$x:00008698o
					; "data. Code: "
		align 10h
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:0000866Co
		dd 0FFFFFFFFh, 0
		dd 1, 0
		dd 1, 0
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 19930522h,	4
					; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
		dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 2
		dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 3 dup(0)
		dd 1
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd	2 dup(2), 3, 1
					; DATA XREF: .xdata$x:00008674o
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
		dd 2 dup(0)
		dd 3, 1
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 86B0h
; COMDAT (pick associative to section at 3DD0)
__unwindtable$??1SourceSurface@gfx@mozilla@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000086C0o
		dd offset __unwindfunclet$??1SourceSurface@gfx@mozilla@@UAE@XZ$0
__ehfuncinfo$??1SourceSurface@gfx@mozilla@@UAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ+11o
		dd offset __unwindtable$??1SourceSurface@gfx@mozilla@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 86DCh
; COMDAT (pick associative to section at 3648)
__unwindtable$??0SourceSurface@gfx@mozilla@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000086ECo
		dd offset __unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0
__ehfuncinfo$??0SourceSurface@gfx@mozilla@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ+11o
		dd offset __unwindtable$??0SourceSurface@gfx@mozilla@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8708h
; COMDAT (pick associative to section at 3374)
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008720o
		dd offset __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
		dd 0
		dd offset __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z+11o
		dd offset __unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 873Ch
; COMDAT (pick associative to section at 32A8)
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000874Co
		dd offset __unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z+11o
		dd offset __unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8768h
; COMDAT (pick associative to section at 2BB4)
__unwindtable$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008778o
		dd offset __unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0
__ehfuncinfo$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z+11o
		dd offset __unwindtable$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8794h
; COMDAT (pick associative to section at 3A08)
__unwindtable$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000087A4o
		dd offset __unwindfunclet$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0
__ehfuncinfo$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ+11o
		dd offset __unwindtable$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 87C0h
; COMDAT (pick associative to section at 4D58)
__unwindtable$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000087D8o
		dd offset __unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0
		dd 0
		dd offset __unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1
__ehfuncinfo$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ+1Bo
		dd offset __unwindtable$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 87F4h
__unwindtable$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000889Co
		dd offset __unwindfunclet$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ$0
__unwindtable$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000088C0o
		dd offset __unwindfunclet$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z$0
__unwindtable$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000088E4o
		dd offset __unwindfunclet$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ$0
		align 10h
		dd offset __unwindfunclet$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ$1
__unwindtable$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000892Co
		dd offset __unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0
		align 10h
		dd offset __unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$1
		align 8
		dd offset __unwindfunclet$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$2
__unwindtable$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008950o
		dd offset __unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z$2
__unwindtable$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008998o
		dd offset __unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$0
		align 10h
		dd offset __unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ$2
__unwindtable$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000089BCo
		dd offset __unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$0
		align 8
		dd offset __unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ$2
__unwindtable$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008974o
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3
		align 10h
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0
		align 8
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$1
		dd 2
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2
__ehfuncinfo$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ+14o
		dd offset __unwindtable$?EnsureMappedTexture@DataSourceSurfaceD2D@gfx@mozilla@@AAEXXZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z+14o
		dd offset __unwindtable$?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ+11o
		dd offset __unwindtable$??1DataSourceSurfaceD2D@gfx@mozilla@@UAE@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z	dd 19930522h, 0Ch
					; DATA XREF: __ehhandler$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z+1Eo
		dd offset __unwindtable$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z
		align 20h
		dd 1
__ehfuncinfo$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z+1Eo
		dd offset __unwindtable$?InitFromTexture@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAUID3D10Texture2D@@W4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z+1Eo
		dd offset __unwindtable$?InitFromData@SourceSurfaceD2D@gfx@mozilla@@QAE_NPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@PAUID2D1RenderTarget@@@Z
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ dd 19930522h, 4
					; DATA XREF: __ehhandler$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ+11o
		dd offset __unwindtable$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ dd	19930522h, 3
					; DATA XREF: __ehhandler$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ+11o
		dd offset __unwindtable$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ dd	19930522h, 3
					; DATA XREF: __ehhandler$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ+11o
		dd offset __unwindtable$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ
		dd 5 dup(0)
		dd 1
__unwindtable$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008908o
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$0
		dd 0
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$1
		dd 1
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$2
		dd 2
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$3
		dd 3
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$4
		dd 3
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$5
		dd 5
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$6
		dd 5
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$7
		dd 7
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$8
		dd 7
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$9
		dd 7
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$10
		dd 7
		dd offset __unwindfunclet$??0DataSourceSurfaceD2D@gfx@mozilla@@QAE@PAVSourceSurfaceD2D@12@@Z$11
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8A38h
; COMDAT (pick associative to section at 2030)
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 dd offset $SG161859+20h
					; DATA XREF: .xdata$x:00008A58o
					; "data. Code: "
		dd 2 dup(0)
		dd offset __catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z dd 2 dup(1), 2, 1
					; DATA XREF: .xdata$x:00008A84o
		dd offset __catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008A7Co
		dd offset __unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
		dd 4 dup(0)
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z+14o
		dd offset __unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		dd 1
		dd offset __tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8A98h
; COMDAT (pick associative to section at 38A8)
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008AA8o
		dd offset __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z+11o
		dd offset __unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8AC4h
; COMDAT (pick associative to section at 2808)
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00008AD4o
		dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
		dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8AF0h
; COMDAT (pick associative to section at 2710)
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008B00o
		dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
		dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 8B1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_allocator_arg	db ?
_piecewise_construct db	?
		align 10h
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 8B20h
; COMDAT (pick any)
		public ??_C@_00CNPNBAHC@?$AA@
; char `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void):loc_4DD4o
					; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,bool)+2Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B24h
; COMDAT (pick largest)
		dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
		public ??_7error_category@std@@6B@
; const	std::error_category::`vftable'
??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
					; DATA XREF: std::error_category::error_category(void)+11o
					; std::error_category::~error_category(void)+11o
					; std::error_category::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B40h
; COMDAT (pick largest)
		dd offset ??_R4_Generic_error_category@std@@6B@	; const	std::_Generic_error_category::`RTTI Complete Object Locator'
		public ??_7_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`vftable'
??_7_Generic_error_category@std@@6B@ dd	offset ??_E_Generic_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+19o
					; std::_Generic_error_category::`vector	deleting destructor'(uint)
		dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ;	std::_Generic_error_category::name(void)
		dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B5Ch
; COMDAT (pick any)
		public ??_C@_07DCLBNMLN@generic?$AA@
; `string'
??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
					; DATA XREF: std::_Generic_error_category::name(void)+Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B64h
; COMDAT (pick any)
		public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
; `string'
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
					; DATA XREF: std::_Generic_error_category::message(int):loc_71ADo
					; std::_System_error_category::message(int):loc_7299o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B74h
; COMDAT (pick largest)
		dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
		public ??_7_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`vftable'
??_7_Iostream_error_category@std@@6B@ dd offset	??_E_Iostream_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+19o
					; std::_Iostream_error_category::`vector deleting destructor'(uint)
		dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
		dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B90h
; COMDAT (pick any)
		public ??_C@_08LLGCOLLL@iostream?$AA@
; `string'
??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
					; DATA XREF: std::_Iostream_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B9Ch
; COMDAT (pick any)
		public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; char `string'[]
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	db 'iostream stream error',0
					; DATA XREF: std::_Iostream_error_category::message(int)+24o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BB4h
; COMDAT (pick largest)
		dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
		public ??_7_System_error_category@std@@6B@
; const	std::_System_error_category::`vftable'
??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_System_error_category::_System_error_category(void)+19o
					; std::_System_error_category::`vector deleting	destructor'(uint)
		dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
		dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
		dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BD0h
; COMDAT (pick any)
		public ??_C@_06FHFOAHML@system?$AA@
; `string'
??_C@_06FHFOAHML@system?$AA@ db	'system',0
					; DATA XREF: std::_System_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8BD8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8BDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; std::_Iostream_error_category	std::_Error_objects<int>::_Iostream_object
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8BE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; std::_System_error_category std::_Error_objects<int>::_System_object
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A dd	?
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8BE4h
; COMDAT (pick any)
		public ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+7Do
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+B7o ...
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xatomic.h>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8C78h
; COMDAT (pick any)
		public ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@
; wchar_t `string'
??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+82o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+71o
		unicode	0, <Invalid memory_order>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8CA4h
; COMDAT (pick any)
		public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
; `string'
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+97o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+86o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8CCCh
; COMDAT (pick any)
		public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
; `string'
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+A6o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+95o
		unicode	0, <"Standard C++ Libraries Invalid Argument" && 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D2Ch
; COMDAT (pick any)
		public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
; `string'
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+ABo
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+9Ao
		unicode	0, <%s>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D34h
; COMDAT (pick any)
		public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
; `string'
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+E7o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+D6o
		unicode	0, <"invalid argument">,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D5Ch
; COMDAT (pick any)
		public ??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@
; `string'
??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@:
					; DATA XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+D1o
		unicode	0, <std::_Atomic_store_4>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D88h
; COMDAT (pick any)
		public ??_C@_1DC@FMPHIJPC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAf?$AAe?$AAt?$AAc?$AAh?$AA_?$AAa?$AAd?$AAd?$AA_?$AA4?$AA?$AA@
; `string'
??_C@_1DC@FMPHIJPC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAf?$AAe?$AAt?$AAc?$AAh?$AA_?$AAa?$AAd?$AAd?$AA_?$AA4?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+E2o
		unicode	0, <std::_Atomic_fetch_add_4>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8DBCh
; COMDAT (pick largest)
		dd offset ??_R4SourceSurface@gfx@mozilla@@6B@ ;	const mozilla::gfx::SourceSurface::`RTTI Complete Object Locator'
		public ??_7SourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurface::`vftable'
??_7SourceSurface@gfx@mozilla@@6B@ dd offset ??_ESourceSurface@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+42o
					; mozilla::gfx::SourceSurface::~SourceSurface(void)+30o
					; mozilla::gfx::SourceSurface::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset __purecall
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8DE0h
; COMDAT (pick largest)
		dd offset ??_R4DataSourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurface::`RTTI Complete Object Locator'
		public ??_7DataSourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurface::`vftable'
??_7DataSourceSurface@gfx@mozilla@@6B@ dd offset ??_EDataSourceSurface@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::DataSourceSurface::DataSourceSurface(void)+19o
					; mozilla::gfx::DataSourceSurface::`vector deleting destructor'(uint)
		dd offset ?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ ; mozilla::gfx::DataSourceSurface::GetType(void)
		dd offset __purecall
		dd offset __purecall
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset ?GetDataSurface@DataSourceSurface@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ ; mozilla::gfx::DataSourceSurface::GetDataSurface(void)
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
		dd offset __purecall
		dd offset __purecall
		dd offset ?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z ; mozilla::gfx::DataSourceSurface::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface	*)
		dd offset ?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ ; mozilla::gfx::DataSourceSurface::Unmap(void)
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8E14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8E18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E1Ch
; COMDAT (pick any)
		public ??_C@_01EEMJAFIK@?6?$AA@
; `string'
??_C@_01EEMJAFIK@?6?$AA@ db 0Ah, 0	; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool):loc_52B2o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E20h
; COMDAT (pick any)
		public ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
; char `string'[]
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ db '%s%s',0
					; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+4Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E28h
; COMDAT (pick largest)
		dd offset ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; const std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Complete Object Locator'
		public ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>>::`vftable'
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@	dd offset ??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+4Ao
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)+12o
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vector deleting destructor'(uint)
		dd offset ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Lock(void)
		dd offset ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Unlock(void)
		dd offset ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)
		dd offset ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)
		dd offset ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char>>::showmanyc(void)
		dd offset ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)
		dd offset ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::uflow(void)
		dd offset ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::xsgetn(char *,__int64)
		dd offset ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::xsputn(char const *,__int64)
		dd offset ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)
		dd offset ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)
		dd offset ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char>>::setbuf(char *,__int64)
		dd offset ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ;	std::basic_streambuf<char,std::char_traits<char>>::sync(void)
		dd offset ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char>>::imbue(std::locale const	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E68h
; COMDAT (pick largest)
		dd offset ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ;	const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Complete	Object Locator'
		public ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vftable'
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ dd offset ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+A9o
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)+1Bo
_rdata		ends			; [thunk]:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vector deleting destructor'`vtordisp{4294967292,0}' (uint)

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E70h
; COMDAT (pick any)
		public ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vbtable'{for `std::basic_istream<char, struct std::char_traits<char>>'}
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ dd	0
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+47o
		dd offset $SG161864+18h	; "2D bitmap. Code: "
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E78h
; COMDAT (pick any)
		public ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vbtable'{for `std::basic_ostream<char, struct std::char_traits<char>>'}
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ dd	0
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+50o
		dd offset $SG161864+8	; "o copy data to D2D bitmap. Code: "
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E80h
; COMDAT (pick largest)
		dd offset ??_R4SourceSurfaceD2D@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurfaceD2D::`RTTI Complete	Object Locator'
		public ??_7SourceSurfaceD2D@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurfaceD2D::`vftable'
??_7SourceSurfaceD2D@gfx@mozilla@@6B@ dd offset	??_ESourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+3Fo
					; mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+30o
					; mozilla::gfx::SourceSurfaceD2D::`vector deleting destructor'(uint)
		dd offset ?GetType@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ ; mozilla::gfx::SourceSurfaceD2D::GetType(void)
		dd offset ?GetSize@SourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ	; mozilla::gfx::SourceSurfaceD2D::GetSize(void)
		dd offset ?GetFormat@SourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ ;	mozilla::gfx::SourceSurfaceD2D::GetFormat(void)
		dd offset ?IsValid@SourceSurfaceD2D@gfx@mozilla@@UBE_NXZ ; mozilla::gfx::SourceSurfaceD2D::IsValid(void)
		dd offset ?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ ;	mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8EA4h
; COMDAT (pick largest)
		dd offset ??_R4DataSourceSurfaceD2D@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurfaceD2D::`RTTI Complete	Object Locator'
		public ??_7DataSourceSurfaceD2D@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurfaceD2D::`vftable'
??_7DataSourceSurfaceD2D@gfx@mozilla@@6B@ dd offset ??_EDataSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+56o
					; mozilla::gfx::DataSourceSurfaceD2D::~DataSourceSurfaceD2D(void)+3Ao
					; mozilla::gfx::DataSourceSurfaceD2D::`vector deleting destructor'(uint)
		dd offset ?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ ; mozilla::gfx::DataSourceSurface::GetType(void)
		dd offset ?GetSize@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ ; mozilla::gfx::DataSourceSurfaceD2D::GetSize(void)
		dd offset ?GetFormat@DataSourceSurfaceD2D@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ ; mozilla::gfx::DataSourceSurfaceD2D::GetFormat(void)
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset ?GetDataSurface@DataSourceSurface@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ ; mozilla::gfx::DataSourceSurface::GetDataSurface(void)
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
		dd offset ?GetData@DataSourceSurfaceD2D@gfx@mozilla@@UAEPAEXZ ;	mozilla::gfx::DataSourceSurfaceD2D::GetData(void)
		dd offset ?Stride@DataSourceSurfaceD2D@gfx@mozilla@@UAEHXZ ; mozilla::gfx::DataSourceSurfaceD2D::Stride(void)
		dd offset ?Map@DataSourceSurfaceD2D@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z ; mozilla::gfx::DataSourceSurfaceD2D::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)
		dd offset ?Unmap@DataSourceSurfaceD2D@gfx@mozilla@@UAEXXZ ; mozilla::gfx::DataSourceSurfaceD2D::Unmap(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8ED8h
; COMDAT (pick any)
		public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+13o
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+19o
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xstring>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F68h
; COMDAT (pick any)
		public ??_C@_04HGKILAJC@?$FLGFX?$AA@
; char `string'[]
??_C@_04HGKILAJC@?$FLGFX?$AA@ db '[GFX',0
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+91o
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+D4o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F70h
; COMDAT (pick any)
		public ??_C@_01JOAMLHOP@?9?$AA@
; char `string'[]
??_C@_01JOAMLHOP@?9?$AA@ db 2Dh, 0	; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason):loc_4FB3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F74h
; COMDAT (pick any)
		public ??_C@_01CLKCMJKC@?5?$AA@
; char `string'[]
??_C@_01CLKCMJKC@?5?$AA@ db 20h, 0	; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+13Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F78h
; COMDAT (pick any)
		public ??_C@_03FLKELDHI@?$FN?3?5?$AA@
; char `string'[]
??_C@_03FLKELDHI@?$FN?3?5?$AA@ dd 203A5Dh
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason):loc_505Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F7Ch
; COMDAT (pick any)
		public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
; char `string'[]
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F8Ch
; COMDAT (pick any)
		public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
; char `string'[]
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FA4h
; COMDAT (pick any)
		public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; wchar_t `string'
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+14o
		unicode	0, <invalid null pointer>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FD0h
; COMDAT (pick any)
		public __GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
__GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec dd 0CAFCB56Ch, 48896AC3h, 239E47BFh, 0EC60D2BBh
					; DATA XREF: IUnknown::QueryInterface<IDXGISurface>(IDXGISurface * *)+Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8FE0h
; COMDAT (pick any)
		public ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>>::`RTTI Complete Object Locator'
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ dd 3 dup(0)
					; DATA XREF: .rdata:00008E28o
		dd offset ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd offset ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 8FF4h
; COMDAT (pick any)
		public ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
; class	std::basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00008FECo
					; .rdata$r:std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_str	db '.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@st'
		db 'd@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9044h
; COMDAT (pick any)
		public ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00008FF0o
					; .rdata$r:00009078o
		dd 2
		dd offset ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9054h
; COMDAT (pick any)
		public ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Array'
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
					; DATA XREF: .rdata$r:00009050o
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9060h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8	dd offset ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
					; DATA XREF: .rdata$r:std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'o
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 907Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; std::basic_streambuf<char, struct std::char_traits<char>>::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 dd offset ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:00009058o
					; .rdata$r:std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base Class Array'o
					; std::basic_streambuf<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8	; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9098h
; COMDAT (pick any)
		public ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_streambuf<char, struct std::char_traits<char>> `RTTI	Type Descriptor'
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Basic_s_0	db '.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 90D4h
; COMDAT (pick any)
		public ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; std::basic_streambuf<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00009094o
		dd 1
		dd offset ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8	; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 90E4h
; COMDAT (pick any)
		public ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; std::basic_streambuf<char, struct std::char_traits<char>>::`RTTI Base	Class Array'
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 dd offset	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:000090E0o
					; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 90ECh
; COMDAT (pick any)
		public ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI	Complete Object	Locator'
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ dd 0
					; DATA XREF: .rdata:00008E68o
		dd offset $SG161864+18h	; "2D bitmap. Code: "
		dd 4
		dd offset ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8	; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd offset ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 9100h
; COMDAT (pick any)
		public ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
; class	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: .rdata$r:000090F8o
					; .rdata$r:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?av?Basic_s_1	db '.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@'
		db '@std@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9150h
; COMDAT (pick any)
		public ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`RTTI Class	Hierarchy Descriptor'
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd 0
					; DATA XREF: .rdata$r:000090FCo
					; .rdata$r:000091A4o
		dd 3, 0Ah
		dd offset ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9160h
; COMDAT (pick any)
		public ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Array'
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
					; DATA XREF: .rdata$r:0000915Co
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8	; std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char>>::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		dd offset ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8	; std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (16,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 918Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd offset ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
					; DATA XREF: .rdata$r:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'o
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd 9, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 91A8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
; std::basic_iostream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 dd offset	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:00009164o
					; .rdata$r:std::basic_iostream<char,std::char_traits<char>>::`RTTI Base	Class Array'o
					; std::basic_iostream<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 8, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 91C4h
; COMDAT (pick any)
		public ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_iostream<char, struct std::char_traits<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_ios	db '.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9200h
; COMDAT (pick any)
		public ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
; std::basic_iostream<char, struct std::char_traits<char>>::`RTTI Class	Hierarchy Descriptor'
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 dd	0 ; DATA XREF: .rdata$r:000091C0o
		dd 3, 9
		dd offset ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9210h
; COMDAT (pick any)
		public ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
; std::basic_iostream<char, struct std::char_traits<char>>::`RTTI Base Class Array'
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 dd	offset ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:0000920Co
					; std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char>>::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		dd offset ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8	; std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (16,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9238h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
; std::basic_istream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 dd	offset ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:00009168o
					; .rdata$r:00009214o ...
					; std::basic_istream<char,std::char_traits<char>> `RTTI	Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_istream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9254h
; COMDAT (pick any)
		public ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_istream<char, struct	std::char_traits<char>>	`RTTI Type Descriptor'
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_istream<char,std::char_traits<char>>::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_ist	db '.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9290h
; COMDAT (pick any)
		public ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
; std::basic_istream<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00009250o
		dd 4
		dd offset ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_istream<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 92A0h
; COMDAT (pick any)
		public ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
; std::basic_istream<char, struct std::char_traits<char>>::`RTTI Base Class Array'
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:0000929Co
					; std::basic_istream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 92B4h
; COMDAT (pick any)
		public ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Base Class	Descriptor at (0, 0, 4,	80)'
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8	dd offset ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:0000916Co
					; .rdata$r:0000917Co ...
					; std::basic_ios<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 2, 2	dup(0)
		dd 4, 50h
		dd offset ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 92D0h
; COMDAT (pick any)
		public ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_ios<char, struct std::char_traits<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,0,4,80)'o
					; .rdata$r:std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?av?Basic_i_0	db '.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9308h
; COMDAT (pick any)
		public ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	dd 2 dup(0) ; DATA XREF: .rdata$r:000092CCo
					; .rdata$r:00009340o
		dd 3
		dd offset ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9318h
; COMDAT (pick any)
		public ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Base Class	Array'
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	dd offset ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:00009314o
					; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@ios_base@std@@8	; std::ios_base::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R17?0A@EA@?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9328h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 dd offset ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Array'o
					; std::basic_ios<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9344h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@ios_base@std@@8
; std::ios_base::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@ios_base@std@@8 dd offset	??_R0?AVios_base@std@@@8
					; DATA XREF: .rdata$r:0000931Co
					; .rdata$r:std::ios_base::`RTTI	Base Class Array'o
					; std::ios_base	`RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3ios_base@std@@8 ; std::ios_base::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9360h
; COMDAT (pick any)
		public ??_R0?AVios_base@std@@@8
; class	std::ios_base `RTTI Type Descriptor'
??_R0?AVios_base@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::ios_base::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; .rdata$r:std::ios_base::`RTTI	Base Class Descriptor at (0,0,4,64)'o
					; const	type_info::`vftable'
		align 8
a_?avios_base@s	db '.?AVios_base@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 937Ch
; COMDAT (pick any)
		public ??_R3ios_base@std@@8
; std::ios_base::`RTTI Class Hierarchy Descriptor'
??_R3ios_base@std@@8 dd	2 dup(0)	; DATA XREF: .rdata$r:0000935Co
					; .rdata$r:0000941Co
		dd 2
		dd offset ??_R2ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 938Ch
; COMDAT (pick any)
		public ??_R2ios_base@std@@8
; std::ios_base::`RTTI Base Class Array'
??_R2ios_base@std@@8 dd	offset ??_R1A@?0A@EA@ios_base@std@@8 ; DATA XREF: .rdata$r:00009388o
					; std::ios_base::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R17?0A@EA@?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9398h
; COMDAT (pick any)
		public ??_R17?0A@EA@?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
??_R17?0A@EA@?$_Iosb@H@std@@8 dd offset	??_R0?AV?$_Iosb@H@std@@@8
					; DATA XREF: .rdata$r:00009320o
					; .rdata$r:00009390o
					; std::_Iosb<int> `RTTI	Type Descriptor'
		align 10h
		dd 8, 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 93B4h
; COMDAT (pick any)
		public ??_R0?AV?$_Iosb@H@std@@@8
; class	std::_Iosb<int>	`RTTI Type Descriptor'
??_R0?AV?$_Iosb@H@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::_Iosb<int>::`RTTI Base Class	Descriptor at (8,-1,0,64)'o
					; .rdata$r:std::_Iosb<int>::`RTTI Base Class Descriptor	at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		dd 0
a_?av?_iosb@h@s	db '.?AV?$_Iosb@H@std@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 93D0h
; COMDAT (pick any)
		public ??_R3?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
??_R3?$_Iosb@H@std@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000093B0o
					; .rdata$r:00009400o ...
		dd 1
		dd offset ??_R2?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 93E0h
; COMDAT (pick any)
		public ??_R2?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Array'
??_R2?$_Iosb@H@std@@8 dd offset	??_R1A@?0A@EA@?$_Iosb@H@std@@8
					; DATA XREF: .rdata$r:000093DCo
					; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 93E8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$_Iosb@H@std@@8 dd offset ??_R0?AV?$_Iosb@H@std@@@8
					; DATA XREF: .rdata$r:std::_Iosb<int>::`RTTI Base Class	Array'o
					; std::_Iosb<int> `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9404h
; COMDAT (pick any)
		public ??_R1A@A@3EA@ios_base@std@@8
; std::ios_base::`RTTI Base Class Descriptor at	(0, 0, 4, 64)'
??_R1A@A@3EA@ios_base@std@@8 dd	offset ??_R0?AVios_base@std@@@8
					; DATA XREF: .rdata$r:00009170o
					; .rdata$r:00009180o ...
					; std::ios_base	`RTTI Type Descriptor'
		dd 1, 2	dup(0)
		dd 4, 40h
		dd offset ??_R3ios_base@std@@8 ; std::ios_base::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9420h
; COMDAT (pick any)
		public ??_R17A@3EA@?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Descriptor at (8, 0, 4, 64)'
??_R17A@3EA@?$_Iosb@H@std@@8 dd	offset ??_R0?AV?$_Iosb@H@std@@@8
					; DATA XREF: .rdata$r:00009174o
					; .rdata$r:00009184o ...
					; std::_Iosb<int> `RTTI	Type Descriptor'
		align 8
		dd 8, 0
		dd 4, 40h
		dd offset ??_R3?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 943Ch
; COMDAT (pick any)
		public ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor at (16, -1, 0, 64)'
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd offset	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:00009178o
					; .rdata$r:00009224o
					; std::basic_ostream<char,std::char_traits<char>> `RTTI	Type Descriptor'
		dd 3, 10h, 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_ostream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9458h
; COMDAT (pick any)
		public ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_ostream<char, struct	std::char_traits<char>>	`RTTI Type Descriptor'
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class	Descriptor at (16,-1,0,64)'o
					; .rdata$r:std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Basic_ost	db '.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9494h
; COMDAT (pick any)
		public ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00009454o
					; .rdata$r:000094D0o
		dd 4
		dd offset ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94A4h
; COMDAT (pick any)
		public ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Base Class Array'
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:000094A0o
					; std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94B8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd	offset ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class	Array'o
					; std::basic_ostream<char,std::char_traits<char>> `RTTI	Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_ostream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94D4h
; COMDAT (pick any)
		public ??_R4error_category@std@@6B@
; const	std::error_category::`RTTI Complete Object Locator'
??_R4error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00008B24o
		dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 94E8h
; COMDAT (pick any)
		public ??_R0?AVerror_category@std@@@8
; class	std::error_category `RTTI Type Descriptor'
??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:000094E0o
					; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?averror_cate	db '.?AVerror_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 950Ch
; COMDAT (pick any)
		public ??_R3error_category@std@@8
; std::error_category::`RTTI Class Hierarchy Descriptor'
??_R3error_category@std@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:000094E4o
					; .rdata$r:0000953Co
		dd 1
		dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 951Ch
; COMDAT (pick any)
		public ??_R2error_category@std@@8
; std::error_category::`RTTI Base Class	Array'
??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
					; DATA XREF: .rdata$r:00009518o
					; std::error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9524h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@error_category@std@@8
; std::error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
					; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
					; .rdata$r:00009594o ...
					; std::error_category `RTTI Type Descriptor'
		align 10h
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9540h
; COMDAT (pick any)
		public ??_R4_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`RTTI Complete Object Locator'
??_R4_Generic_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00008B40o
		dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9554h
; COMDAT (pick any)
		public ??_R0?AV_Generic_error_category@std@@@8
; class	std::_Generic_error_category `RTTI Type	Descriptor'
??_R0?AV_Generic_error_category@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000954Co
					; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av_generic_e	db '.?AV_Generic_error_category@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9580h
; COMDAT (pick any)
		public ??_R3_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Generic_error_category@std@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00009550o
					; .rdata$r:000095B4o
		dd 2
		dd offset ??_R2_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9590h
; COMDAT (pick any)
		public ??_R2_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Array'
??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
					; DATA XREF: .rdata$r:0000958Co
					; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 959Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_Generic_error_category@std@@8 dd	offset ??_R0?AV_Generic_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
					; .rdata$r:0000960Co ...
					; std::_Generic_error_category `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 95B8h
; COMDAT (pick any)
		public ??_R4_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`RTTI Complete Object Locator'
??_R4_Iostream_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00008B74o
		dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 95CCh
; COMDAT (pick any)
		public ??_R0?AV_Iostream_error_category@std@@@8
; class	std::_Iostream_error_category `RTTI Type Descriptor'
??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000095C4o
					; .rdata$r:std::_Iostream_error_category::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av_iostream_	db '.?AV_Iostream_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 95F8h
; COMDAT (pick any)
		public ??_R3_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Iostream_error_category@std@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:000095C8o
					; .rdata$r:00009630o
		dd 3
		dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9608h
; COMDAT (pick any)
		public ??_R2_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Array'
??_R2_Iostream_error_category@std@@8 dd	offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
					; DATA XREF: .rdata$r:00009604o
					; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9618h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset	??_R0?AV_Iostream_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base	Class Array'o
					; std::_Iostream_error_category	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9634h
; COMDAT (pick any)
		public ??_R4_System_error_category@std@@6B@
; const	std::_System_error_category::`RTTI Complete Object Locator'
??_R4_System_error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00008BB4o
		dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9648h
; COMDAT (pick any)
		public ??_R0?AV_System_error_category@std@@@8
; class	std::_System_error_category `RTTI Type Descriptor'
??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009640o
					; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av_system_er	db '.?AV_System_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9674h
; COMDAT (pick any)
		public ??_R3_System_error_category@std@@8
; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_System_error_category@std@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00009644o
					; .rdata$r:000096ACo
		dd 3
		dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9684h
; COMDAT (pick any)
		public ??_R2_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Array'
??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
					; DATA XREF: .rdata$r:00009680o
					; std::_System_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9694h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
					; std::_System_error_category `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96B0h
; COMDAT (pick any)
		public ??_R4SourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurface::`RTTI Complete Object Locator'
??_R4SourceSurface@gfx@mozilla@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00008DBCo
		dd offset ??_R0?AVSourceSurface@gfx@mozilla@@@8	; mozilla::gfx::SourceSurface `RTTI Type Descriptor'
		dd offset ??_R3SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 96C4h
; COMDAT (pick any)
		public ??_R0?AVSourceSurface@gfx@mozilla@@@8
; class	mozilla::gfx::SourceSurface `RTTI Type Descriptor'
??_R0?AVSourceSurface@gfx@mozilla@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: .rdata$r:000096BCo
					; .rdata$r:mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avsourcesurf	db '.?AVSourceSurface@gfx@mozilla@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96ECh
; COMDAT (pick any)
		public ??_R3SourceSurface@gfx@mozilla@@8
; mozilla::gfx::SourceSurface::`RTTI Class Hierarchy Descriptor'
??_R3SourceSurface@gfx@mozilla@@8 dd 2 dup(0) ;	DATA XREF: .rdata$r:000096C0o
					; .rdata$r:00009724o
		dd 3
		dd offset ??_R2SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96FCh
; COMDAT (pick any)
		public ??_R2SourceSurface@gfx@mozilla@@8
; mozilla::gfx::SourceSurface::`RTTI Base Class	Array'
??_R2SourceSurface@gfx@mozilla@@8 dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8
					; DATA XREF: .rdata$r:000096F8o
					; mozilla::gfx::SourceSurface::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 970Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8
; mozilla::gfx::SourceSurface::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 dd offset ??_R0?AVSourceSurface@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::SourceSurface::`RTTI Base Class Array'o
					; .rdata$r:000098BCo ...
					; mozilla::gfx::SourceSurface `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9728h
; COMDAT (pick any)
		public ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd offset ??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8
					; DATA XREF: .rdata$r:00009700o
					; .rdata$r:000098C0o ...
					; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface> `RTTI Type Descriptor'
		dd 1, 4, 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 9744h
; COMDAT (pick any)
		public ??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8
; class	mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface> `RTTI Type Descriptor'
??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class Descriptor at (4,-1,0,64)'o
					; .rdata$r:mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Atomicref	db '.?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozi'
		db 'lla@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9794h
; COMDAT (pick any)
		public ??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Class Hierarchy	Descriptor'
??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00009740o
					; .rdata$r:000097C8o
		dd 2
		dd offset ??_R2?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 97A4h
; COMDAT (pick any)
		public ??_R2?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Base Class Array'
??_R2?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd offset ??_R1A@?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
					; DATA XREF: .rdata$r:000097A0o
					; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8	; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 97B0h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd offset ??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class Array'o
					; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface> `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 97CCh
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd offset	??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8
					; DATA XREF: .rdata$r:000097A8o
					; .rdata$r:mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class	Array'o
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0> `RTTI Type	Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 97E8h
; COMDAT (pick any)
		public ??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8
; class	mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0> `RTTI	Type Descriptor'
??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; .rdata$r:mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Refcounte	db '.?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@'
		db '@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9834h
; COMDAT (pick any)
		public ??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Class Hierarchy Descriptor'
??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd	2 dup(0)
					; DATA XREF: .rdata$r:000097E4o
					; .rdata$r:00009864o
		dd 1
		dd offset ??_R2?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9844h
; COMDAT (pick any)
		public ??_R2?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Base	Class Array'
??_R2?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd	offset ??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
					; DATA XREF: .rdata$r:00009840o
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 984Ch
; COMDAT (pick any)
		public ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Base	Class Descriptor at (4,	-1, 0, 64)'
??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd	offset ??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8
					; DATA XREF: .rdata$r:00009704o
					; .rdata$r:000098C4o ...
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0> `RTTI Type	Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9868h
; COMDAT (pick any)
		public ??_R4DataSourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurface::`RTTI Complete	Object Locator'
??_R4DataSourceSurface@gfx@mozilla@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00008DE0o
		dd offset ??_R0?AVDataSourceSurface@gfx@mozilla@@@8 ; mozilla::gfx::DataSourceSurface `RTTI Type Descriptor'
		dd offset ??_R3DataSourceSurface@gfx@mozilla@@8	; mozilla::gfx::DataSourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 987Ch
; COMDAT (pick any)
		public ??_R0?AVDataSourceSurface@gfx@mozilla@@@8
; class	mozilla::gfx::DataSourceSurface	`RTTI Type Descriptor'
??_R0?AVDataSourceSurface@gfx@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009874o
					; .rdata$r:mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avdatasource	db '.?AVDataSourceSurface@gfx@mozilla@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98A8h
; COMDAT (pick any)
		public ??_R3DataSourceSurface@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurface::`RTTI Class Hierarchy Descriptor'
??_R3DataSourceSurface@gfx@mozilla@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00009878o
					; .rdata$r:000098E4o
		dd 4
		dd offset ??_R2DataSourceSurface@gfx@mozilla@@8	; mozilla::gfx::DataSourceSurface::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98B8h
; COMDAT (pick any)
		public ??_R2DataSourceSurface@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurface::`RTTI Base Class Array'
??_R2DataSourceSurface@gfx@mozilla@@8 dd offset	??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8
					; DATA XREF: .rdata$r:000098B4o
					; mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98CCh
; COMDAT (pick any)
		public ??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8 dd offset ??_R0?AVDataSourceSurface@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::DataSourceSurface::`RTTI Base Class	Array'o
					; .rdata$r:00009940o
					; mozilla::gfx::DataSourceSurface `RTTI	Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3DataSourceSurface@gfx@mozilla@@8	; mozilla::gfx::DataSourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98E8h
; COMDAT (pick any)
		public ??_R4DataSourceSurfaceD2D@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurfaceD2D::`RTTI Complete Object Locator'
??_R4DataSourceSurfaceD2D@gfx@mozilla@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00008EA4o
		dd offset ??_R0?AVDataSourceSurfaceD2D@gfx@mozilla@@@8 ; mozilla::gfx::DataSourceSurfaceD2D `RTTI Type Descriptor'
		dd offset ??_R3DataSourceSurfaceD2D@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 98FCh
; COMDAT (pick any)
		public ??_R0?AVDataSourceSurfaceD2D@gfx@mozilla@@@8
; class	mozilla::gfx::DataSourceSurfaceD2D `RTTI Type Descriptor'
??_R0?AVDataSourceSurfaceD2D@gfx@mozilla@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000098F4o
					; .rdata$r:mozilla::gfx::DataSourceSurfaceD2D::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avdatasour_0	db '.?AVDataSourceSurfaceD2D@gfx@mozilla@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 992Ch
; COMDAT (pick any)
		public ??_R3DataSourceSurfaceD2D@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Class Hierarchy Descriptor'
??_R3DataSourceSurfaceD2D@gfx@mozilla@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000098F8o
					; .rdata$r:0000996Co
		dd 5
		dd offset ??_R2DataSourceSurfaceD2D@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 993Ch
; COMDAT (pick any)
		public ??_R2DataSourceSurfaceD2D@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Base Class Array'
??_R2DataSourceSurfaceD2D@gfx@mozilla@@8 dd offset ??_R1A@?0A@EA@DataSourceSurfaceD2D@gfx@mozilla@@8
					; DATA XREF: .rdata$r:00009938o
					; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9954h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@DataSourceSurfaceD2D@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@DataSourceSurfaceD2D@gfx@mozilla@@8 dd offset ??_R0?AVDataSourceSurfaceD2D@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::DataSourceSurfaceD2D::`RTTI	Base Class Array'o
					; mozilla::gfx::DataSourceSurfaceD2D `RTTI Type	Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3DataSourceSurfaceD2D@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurfaceD2D::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9970h
; COMDAT (pick any)
		public ??_R4SourceSurfaceD2D@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurfaceD2D::`RTTI Complete Object Locator'
??_R4SourceSurfaceD2D@gfx@mozilla@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00008E80o
		dd offset ??_R0?AVSourceSurfaceD2D@gfx@mozilla@@@8 ; mozilla::gfx::SourceSurfaceD2D `RTTI Type Descriptor'
		dd offset ??_R3SourceSurfaceD2D@gfx@mozilla@@8 ; mozilla::gfx::SourceSurfaceD2D::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9984h
; COMDAT (pick any)
		public ??_R0?AVSourceSurfaceD2D@gfx@mozilla@@@8
; class	mozilla::gfx::SourceSurfaceD2D `RTTI Type Descriptor'
??_R0?AVSourceSurfaceD2D@gfx@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000997Co
					; .rdata$r:mozilla::gfx::SourceSurfaceD2D::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avsourcesu_0	db '.?AVSourceSurfaceD2D@gfx@mozilla@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 99B0h
; COMDAT (pick any)
		public ??_R3SourceSurfaceD2D@gfx@mozilla@@8
; mozilla::gfx::SourceSurfaceD2D::`RTTI	Class Hierarchy	Descriptor'
??_R3SourceSurfaceD2D@gfx@mozilla@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00009980o
					; .rdata$r:000099ECo
		dd 4
		dd offset ??_R2SourceSurfaceD2D@gfx@mozilla@@8 ; mozilla::gfx::SourceSurfaceD2D::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 99C0h
; COMDAT (pick any)
		public ??_R2SourceSurfaceD2D@gfx@mozilla@@8
; mozilla::gfx::SourceSurfaceD2D::`RTTI	Base Class Array'
??_R2SourceSurfaceD2D@gfx@mozilla@@8 dd	offset ??_R1A@?0A@EA@SourceSurfaceD2D@gfx@mozilla@@8
					; DATA XREF: .rdata$r:000099BCo
					; mozilla::gfx::SourceSurfaceD2D::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 99D4h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@SourceSurfaceD2D@gfx@mozilla@@8
; mozilla::gfx::SourceSurfaceD2D::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SourceSurfaceD2D@gfx@mozilla@@8 dd offset	??_R0?AVSourceSurfaceD2D@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::SourceSurfaceD2D::`RTTI Base Class Array'o
					; mozilla::gfx::SourceSurfaceD2D `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161859+20h	; "data. Code: "
		dd offset ??_R3SourceSurfaceD2D@gfx@mozilla@@8 ; mozilla::gfx::SourceSurfaceD2D::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 99F0h
; COMDAT (pick any)
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 99F4h
; COMDAT (pick any)
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 99F8h
; COMDAT (pick any)
		public __real@00000000
__real@00000000	dd 0			; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+2C6r
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+2D4r ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 99FCh
; COMDAT (pick any)
		public __real@3f800000
__real@3f800000	dd 3F800000h		; DATA XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+51Br
					; mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+580r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9A00h
; COMDAT (pick any)
		public __real@42c00000
__real@42c00000	dd 42C00000h		; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+107r
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+115r ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9A04h
; COMDAT (pick any)
		public __real@437f0000
__real@437f0000	dd 437F0000h		; DATA XREF: D2D1::ColorF::Init(uint,float)+47r
					; D2D1::ColorF::Init(uint,float)+82r ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 9A08h
; COMDAT (pick any)
		public __xmm@41f00000000000000000000000000000
__xmm@41f00000000000000000000000000000 dq 0 ; DATA XREF: D2D1::ColorF::Init(uint,float)+34r
					; D2D1::ColorF::Init(uint,float)+6Fr ...
		dd 0
		dd 41F00000h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A18h
_piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ	; std::`dynamic	initializer for	'piecewise_construct''(void)
_allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer	for 'allocator_arg''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A20h
; COMDAT (pick associative to section at 8BD8)
; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A24h
; COMDAT (pick associative to section at 8BDC)
; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA	dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A28h
; COMDAT (pick associative to section at 8BE0)
; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset	??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer	for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A2Ch
; COMDAT (pick associative to section at 8E14)
; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A30h
; COMDAT (pick associative to section at 8E18)
; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __purecall:near	; DATA XREF: .rdata:00008B2Co
					; .rdata:00008B30o ...
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+43p
					; std::_Allocate<char>(uint,char *)+25p ...
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: __unwindfunclet$?GetDataSurface@SourceSurfaceD2D@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0+4p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`scalar deleting destructor'(uint)+22p ...
; int __cdecl atexit(void (__cdecl *)())
		extrn _atexit:near	; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
					; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
		extrn __imp___invalid_parameter:near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+ECp
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+DBp
					; DATA XREF: ...
; int _printf(const char *Format, ...)
		extrn __imp__printf:near
					; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+51p
					; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+51r
; void __cdecl _free(void *Memory)
		extrn __imp__free:near	; CODE XREF: mozilla::gfx::UserData::Destroy(void)+7Bp
					; DATA XREF: mozilla::gfx::UserData::Destroy(void)+7Br
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+28p
					; DATA XREF: std::char_traits<char>::move(char *,char const *,uint)+28r
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+25p
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: std::char_traits<char>::length(char const *)+22p
		extrn __imp___hypot:near ; CODE	XREF: _hypot+20p
					; DATA XREF: _hypot+20r
; bool __cdecl std::uncaught_exception()
		extrn __imp_?uncaught_exception@std@@YA_NXZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+11p
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+11r
		extrn __imp___CrtDbgReportW:near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+BEp
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+ADp
					; DATA XREF: ...
; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
		extrn __imp_?_Debug_message@std@@YAXPB_W0I@Z:near
					; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+19p
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+87p ...
; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
		extrn __imp_??0_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14p
					; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14r
; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden	this)
		extrn __imp_??1_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14p
					; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14r
; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
		extrn __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28p
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28r
; void __cdecl std::_Xbad_alloc()
		extrn __imp_?_Xbad_alloc@std@@YAXXZ:near
					; CODE XREF: std::_Allocate<char>(uint,char *)+38p
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Ep
					; DATA XREF: ...
; void __cdecl std::_Xlength_error(const char *)
		extrn __imp_?_Xlength_error@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16r
; void __cdecl std::_Xout_of_range(const char *)
		extrn __imp_?_Xout_of_range@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16r
; _DWORD __thiscall std::locale::id::id(std::locale::id	*__hidden this,	unsigned int)
		extrn __imp_??0id@locale@std@@QAE@I@Z:near
					; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Dp
					; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Dp
					; DATA XREF: ...
; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
		extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::error_category::`vftable'o
; const	char *__cdecl std::_Syserror_map(int)
		extrn __imp_?_Syserror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+15p
					; std::_Generic_error_category::message(int)+28p
					; DATA XREF: ...
; const	char *__cdecl std::_Winerror_map(int)
		extrn __imp_?_Winerror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::message(int)+28p
					; DATA XREF: std::_System_error_category::message(int)+28r
; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ;	weak
					; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
; bool __thiscall std::ios_base::good(std::ios_base *__hidden this)
		extrn __imp_?good@ios_base@std@@QBE_NXZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+4Ep
					; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+DDp
					; DATA XREF: ...
; int __thiscall std::ios_base::flags(std::ios_base *__hidden this)
		extrn __imp_?flags@ios_base@std@@QBEHXZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+139p
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+139r
; int __thiscall std::ios_base::setf(std::ios_base *__hidden this, int)
		extrn __imp_?setf@ios_base@std@@QAEHH@Z:near
					; CODE XREF: std::showbase(std::ios_base &)+Bp
					; DATA XREF: std::showbase(std::ios_base &)+Br
; int __thiscall std::ios_base::setf(std::ios_base *__hidden this, int,	int)
		extrn __imp_?setf@ios_base@std@@QAEHHH@Z:near
					; CODE XREF: std::dec(std::ios_base &)+13p
					; std::hex(std::ios_base &)+13p
					; DATA XREF: ...
; void __thiscall std::ios_base::unsetf(std::ios_base *__hidden	this, int)
		extrn __imp_?unsetf@ios_base@std@@QAEXH@Z:near
					; CODE XREF: std::noshowbase(std::ios_base &)+Bp
					; DATA XREF: std::noshowbase(std::ios_base &)+Br
; __int64 __thiscall std::ios_base::width(std::ios_base	*__hidden this)
		extrn __imp_?width@ios_base@std@@QBE_JXZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+66p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+94p ...
; __int64 __thiscall std::ios_base::width(std::ios_base	*__hidden this,	__int64)
		extrn __imp_?width@ios_base@std@@QAE_J_J@Z:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+34Fp
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+34Fr
; __declspec(dllimport)	protected: __thiscall std::basic_streambuf<char, struct	std::char_traits<char>>::basic_streambuf<char, struct std::char_traits<char>>(void)
		extrn __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+33p
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+33r
; __declspec(dllimport)	public:	virtual	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::~basic_streambuf<char, struct std::char_traits<char>>(void)
		extrn __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0+5p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)+25p
					; DATA XREF: ...
; __declspec(dllimport)	public:	int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sputc(char)
		extrn __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1CCp
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+2F1p
					; DATA XREF: ...
; __declspec(dllimport)	public:	__int64	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sputn(char const *, __int64)
		extrn __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+247p
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+247r
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::eback(void)const
		extrn __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+6Ap
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+82p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::gptr(void)const
		extrn __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+F9p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+368p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::pbase(void)const
		extrn __imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+CFp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+2FEp ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::pptr(void)const
		extrn __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+28p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+83p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::egptr(void)const
		extrn __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+55p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+113p ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::gbump(int)
		extrn __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+DAp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+1A6p ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setg(char	*, char	*, char	*)
		extrn __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+9Fp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+119p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::epptr(void)const
		extrn __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+3Ep
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+B3p ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::pbump(int)
		extrn __imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+35Dp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+281p
					; DATA XREF: ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setp(char	*, char	*)
		extrn __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+BCp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+269p
					; DATA XREF: ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setp(char	*, char	*, char	*)
		extrn __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+E7p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+E0p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::_Pninc(void)
		extrn __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+140p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+3D0p
					; DATA XREF: ...
; __declspec(dllimport)	public:	virtual	__thiscall std::basic_ios<char,	struct std::char_traits<char>>::~basic_ios<char, struct	std::char_traits<char>>(void)
		extrn __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0+18p
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)+22p
					; DATA XREF: ...
; __declspec(dllimport)	public:	void __thiscall	std::basic_ios<char, struct std::char_traits<char>>::setstate(int, bool)
		extrn __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:near
					; CODE XREF: __catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0+13p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+3A7p
					; DATA XREF: ...
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> *	__thiscall std::basic_ios<char,	struct std::char_traits<char>>::tie(void)const
		extrn __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+6Fp
					; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+8Fp ...
; __declspec(dllimport)	public:	class std::basic_streambuf<char, struct	std::char_traits<char>>	* __thiscall std::basic_ios<char, struct std::char_traits<char>>::rdbuf(void)const
		extrn __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1B2p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+226p	...
; __declspec(dllimport)	public:	char __thiscall	std::basic_ios<char, struct std::char_traits<char>>::fill(void)const
		extrn __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+193p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+2B4p
					; DATA XREF: ...
; __declspec(dllimport)	protected: __thiscall std::basic_ios<char, struct std::char_traits<char>>::basic_ios<char, struct std::char_traits<char>>(void)
		extrn __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+5Fp
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+5Fr
; __declspec(dllimport)	public:	void __thiscall	std::basic_ostream<char, struct	std::char_traits<char>>::_Osfx(void)
		extrn __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+2Cp
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+2Cr
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(class std::ios_base & (__cdecl *)(class std::ios_base &))
		extrn __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z:near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+60p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+72p ...
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(int)
		extrn __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+A4p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+E7p ...
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(long)
		extrn __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z:near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+84p
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+84r
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::flush(void)
		extrn __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+C1p
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+C1r
; public: virtual void * __thiscall mozilla::gfx::SourceSurface::`vector deleting destructor'(unsigned int)
		extrn ??_ESourceSurface@gfx@mozilla@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const mozilla::gfx::SourceSurface::`vftable'o
; public: virtual struct already_AddRefed<class	mozilla::gfx::DataSourceSurface> __thiscall mozilla::gfx::DataSourceSurface::GetDataSurface(void)
		extrn ?GetDataSurface@DataSourceSurface@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ:near
					; DATA XREF: .rdata:00008DF8o
					; .rdata:00008EBCo
; public: virtual void * __thiscall mozilla::gfx::DataSourceSurface::`vector deleting destructor'(unsigned int)
		extrn ??_EDataSourceSurface@gfx@mozilla@@UAEPAXI@Z:near	; weak
					; DATA XREF: .rdata:const mozilla::gfx::DataSourceSurface::`vftable'o
; struct ID3D10Device1 *__cdecl	static mozilla::gfx::Factory::GetDirect3D10Device()
		extrn ?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::IsValid(void)+Ep
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+2F8p
; __declspec(dllimport)	public:	__thiscall std::basic_iostream<char, struct std::char_traits<char>>::basic_iostream<char, struct std::char_traits<char>>(class std::basic_streambuf<char, struct std::char_traits<char>> *)
		extrn __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+8Ap
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+8Ar
; __declspec(dllimport)	public:	virtual	__thiscall std::basic_iostream<char, struct std::char_traits<char>>::~basic_iostream<char, struct std::char_traits<char>>(void)
		extrn __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1+8p
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)+52p
					; DATA XREF: ...
; public: virtual void * __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`vector deleting destructor'(unsigned int)
		extrn ??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vftable'o
; public: virtual void * __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vector deleting destructor'(unsigned int)
		extrn ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:near ; weak
					; CODE XREF: [thunk]:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vector	deleting destructor'`vtordisp{4294967292,0}' (uint)+3j
; public: virtual void * __thiscall mozilla::gfx::SourceSurfaceD2D::`vector deleting destructor'(unsigned int)
		extrn ??_ESourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const mozilla::gfx::SourceSurfaceD2D::`vftable'o
; public: virtual void * __thiscall mozilla::gfx::DataSourceSurfaceD2D::`vector	deleting destructor'(unsigned int)
		extrn ??_EDataSourceSurfaceD2D@gfx@mozilla@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const mozilla::gfx::DataSourceSurfaceD2D::`vftable'o
; struct ID2D1Factory *__cdecl static mozilla::gfx::DrawTargetD2D::factory()
		extrn ?factory@DrawTargetD2D@gfx@mozilla@@SAPAUID2D1Factory@@XZ:near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2D::DataSourceSurfaceD2D(mozilla::gfx::SourceSurfaceD2D *)+32Ap
; public: virtual void __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Lock(void)
		extrn ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:near
					; DATA XREF: .rdata:00008E30o
; public: virtual void __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Unlock(void)
		extrn ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:near
					; DATA XREF: .rdata:00008E34o
; protected: virtual void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::imbue(class std::locale	const &)
		extrn ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:near
					; DATA XREF: .rdata:00008E64o
; protected: virtual class std::basic_streambuf<char, struct std::char_traits<char>> * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setbuf(char *, __int64)
		extrn ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:near
					; DATA XREF: .rdata:00008E5Co
; protected: virtual __int64 __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::showmanyc(void)
		extrn ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:near
					; DATA XREF: .rdata:00008E40o
; protected: virtual int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sync(void)
		extrn ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:near
					; DATA XREF: .rdata:00008E60o
; protected: virtual int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::uflow(void)
		extrn ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:near
					; DATA XREF: .rdata:00008E48o
; protected: virtual __int64 __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::xsgetn(char *, __int64)
		extrn ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:near
					; DATA XREF: .rdata:00008E4Co
; protected: virtual __int64 __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::xsputn(char const *,	__int64)
		extrn ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:near
					; DATA XREF: .rdata:00008E50o
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::GetDataSurface(void)+11Dp
					; mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar *,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget	*)+315p ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2D::InitFromData(uchar	*,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,int,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+32Ep
					; mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+328p ...
; __stdcall _CxxThrowException(x, x)
		extrn __CxxThrowException@8:near
					; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
		extrn __RTC_CheckEsp:near
					; CODE XREF: mozilla::gfx::D2DIntSize(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &)+3Ap
					; mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+49p ...
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0SourceSurfaceD2D@gfx@mozilla@@QAE@XZ+16j
					; __ehhandler$??1SourceSurfaceD2D@gfx@mozilla@@UAE@XZ+16j ...
; __declspec(dllimport)	__int64	const std::_BADOFF
		extrn __imp_?_BADOFF@std@@3_JB:near
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+10Br
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7B46r ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data$r:std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'o
					; .data$r:std::basic_streambuf<char,std::char_traits<char>> `RTTI Type Descriptor'o ...
; const	IID IID_IDXGISurface
		extrn _IID_IDXGISurface:near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::InitFromTexture(ID3D10Texture2D *,mozilla::gfx::SurfaceFormat,ID2D1RenderTarget *)+1E4o
; public: static int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		extrn ?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA:near
					; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+Cr
					; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,bool)+16r ...
; public: static unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		extrn ?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA:near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+56r
					; mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+5Er ...
		extrn ___security_cookie:near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2D::SourceSurfaceD2D(void)+19r
					; mozilla::gfx::SourceSurfaceD2D::~SourceSurfaceD2D(void)+19r ...
		extrn __fltused:near


		end
