;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	767752224D783AC92140A7188E258683
; Input	CRC32 :	8DC58BD2

; File Name   :	D:\compspace\objfiles\firefox\gfx2d\ScaledFontDWrite.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "uuid.lib"
; must resolve:	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; must resolve:	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; must resolve:	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; must resolve:	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; must resolve:	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
$SG153117	db 'Failed to create Direct2D stroke style.',0
$SG4890		db 'Assertion failure: %s, at %s:%d',0Ah,0
		align 4
$SG4896		db 'Hit MOZ_CRASH(%s) at %s:%d',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(int, struct mozilla::gfx::GlyphBuffer *, int)
		public ?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z
?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z proc near

var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= byte ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 28h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_34]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_28], 0
		mov	eax, [ebp+arg_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	al, 1
		jz	short loc_10A
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, [ebp+arg_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	al, 7
		jz	short loc_10A
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_10]
		call	?GetPathForGlyphs@ScaledFontBase@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z ; mozilla::gfx::ScaledFontBase::GetPathForGlyphs(mozilla::gfx::GlyphBuffer const &,mozilla::gfx::DrawTarget const *)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_28]
		or	ecx, 1
		mov	[ebp+var_28], ecx
		mov	eax, [ebp+arg_0]
		jmp	loc_1AE
; ---------------------------------------------------------------------------

loc_10A:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+5Aj
					; mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer const &,mozilla::gfx::DrawTarget const *)+74j
		mov	esi, esp
		push	0
		lea	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+arg_8]
		mov	edx, [eax]
		mov	ecx, [ebp+arg_8]
		mov	eax, [edx+90h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_2C]
		mov	[ebp+var_30], ecx
		mov	[ebp+var_4], 1
		mov	edx, [ebp+var_30]
		push	edx
		lea	ecx, [ebp+var_18]
		call	??$?0VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@@Z	; RefPtr<mozilla::gfx::PathBuilder>::RefPtr<mozilla::gfx::PathBuilder>(already_AddRefed<mozilla::gfx::PathBuilder> &&)
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_24]
		call	??1?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::PathBuilder>::~already_AddRefed<mozilla::gfx::PathBuilder>(void)
		lea	ecx, [ebp+var_18]
		call	?get@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ ; RefPtr<mozilla::gfx::PathBuilder>::get(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+var_20] ; this
		call	?GetSink@PathBuilderD2D@gfx@mozilla@@QAEPAUID2D1GeometrySink@@XZ ; mozilla::gfx::PathBuilderD2D::GetSink(void)
		push	eax		; struct ID2D1GeometrySink *
		mov	eax, [ebp+arg_4]
		push	eax		; struct mozilla::gfx::GlyphBuffer *
		mov	ecx, [ebp+var_10] ; this
		call	?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z ; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer const &,ID2D1GeometrySink *)
		lea	ecx, [ebp+var_18]
		call	??C?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ ; RefPtr<mozilla::gfx::PathBuilder>::operator->(void)
		mov	[ebp+var_34], eax
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_34]
		mov	eax, [edx]
		mov	ecx, [ebp+var_34]
		mov	edx, [eax+20h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_28]
		or	eax, 1
		mov	[ebp+var_28], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_18]
		call	??1?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@XZ ; RefPtr<mozilla::gfx::PathBuilder>::~RefPtr<mozilla::gfx::PathBuilder>(void)
		mov	eax, [ebp+arg_0]

loc_1AE:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+9Dj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 34h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z endp

; ---------------------------------------------------------------------------
$LN11_0		dd 1			; DATA XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+14Ao
		dd offset $LN10
$LN10		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:000001E0o
		dd offset $LN8_0	; "pathBuilder"
$LN8_0		db 'pathBuilder',0      ; DATA XREF: .text$mn:000001ECo
		db 0Ch dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void __thiscall mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(struct mozilla::gfx::GlyphBuffer const &,	class mozilla::gfx::PathBuilder	*, enum	 mozilla::gfx::BackendType, class mozilla::gfx::Matrix const *)
		public ?CopyGlyphsToBuilder@ScaledFontDWrite@gfx@mozilla@@UAEXABUGlyphBuffer@23@PAVPathBuilder@23@W4BackendType@23@PBVMatrix@23@@Z
?CopyGlyphsToBuilder@ScaledFontDWrite@gfx@mozilla@@UAEXABUGlyphBuffer@23@PAVPathBuilder@23@W4BackendType@23@PBVMatrix@23@@Z proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_8], 1
		jz	short loc_246
		cmp	[ebp+arg_8], 7
		jz	short loc_246
		mov	eax, [ebp+arg_C]
		push	eax
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?CopyGlyphsToBuilder@ScaledFontBase@gfx@mozilla@@UAEXABUGlyphBuffer@23@PAVPathBuilder@23@W4BackendType@23@PBVMatrix@23@@Z ; mozilla::gfx::ScaledFontBase::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)
		jmp	short loc_261
; ---------------------------------------------------------------------------

loc_246:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)+1Bj
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)+21j
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?GetSink@PathBuilderD2D@gfx@mozilla@@QAEPAUID2D1GeometrySink@@XZ ; mozilla::gfx::PathBuilderD2D::GetSink(void)
		push	eax		; struct ID2D1GeometrySink *
		mov	edx, [ebp+arg_0]
		push	edx		; struct mozilla::gfx::GlyphBuffer *
		mov	ecx, [ebp+var_4] ; this
		call	?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z ; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer const &,ID2D1GeometrySink *)

loc_261:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)+3Cj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?CopyGlyphsToBuilder@ScaledFontDWrite@gfx@mozilla@@UAEXABUGlyphBuffer@23@PAVPathBuilder@23@W4BackendType@23@PBVMatrix@23@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 8

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::ScaledFontDWrite *this, const struct mozilla::gfx::GlyphBuffer	*, struct ID2D1GeometrySink *)
		public ?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z
?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+104p
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)+54p

var_8C		= dword	ptr -8Ch
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_54		= byte ptr -54h
var_3C		= byte ptr -3Ch
var_24		= byte ptr -24h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 58h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_64]
		mov	ecx, 16h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_24]
		call	??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ;	std::vector<ushort,std::allocator<ushort>>::vector<ushort,std::allocator<ushort>>(void)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_3C]
		call	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ;	std::vector<float,std::allocator<float>>::vector<float,std::allocator<float>>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		call	??0?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)
		mov	byte ptr [ebp+var_4], 2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx
		lea	ecx, [ebp+var_24]
		call	?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<ushort,std::allocator<ushort>>::resize(uint)
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		push	eax
		lea	ecx, [ebp+var_3C]
		call	?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z ; std::vector<float,std::allocator<float>>::resize(uint)
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx
		lea	ecx, [ebp+var_54]
		call	?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z ;	std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		shl	ecx, 2
		push	ecx		; Size
		push	0		; Val
		lea	ecx, [ebp+var_3C]
		call	?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ ; std::vector<float,std::allocator<float>>::front(void)
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	[ebp+var_5C], 0
		jmp	short loc_336
; ---------------------------------------------------------------------------

loc_32D:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+131j
		mov	edx, [ebp+var_5C]
		add	edx, 1
		mov	[ebp+var_5C], edx

loc_336:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+B3j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_5C]
		cmp	ecx, [eax+4]
		jnb	short loc_3AB
		imul	esi, [ebp+var_5C], 0Ch
		mov	edx, [ebp+arg_0]
		mov	edi, [edx]
		mov	eax, [ebp+var_5C]
		push	eax
		lea	ecx, [ebp+var_24]
		call	??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ; std::vector<ushort,std::allocator<ushort>>::operator[](uint)
		mov	cx, [edi+esi]
		mov	[eax], cx
		imul	esi, [ebp+var_5C], 0Ch
		mov	edx, [ebp+arg_0]
		mov	edi, [edx]
		mov	eax, [ebp+var_5C]
		push	eax
		lea	ecx, [ebp+var_54]
		call	??A?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@I@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)
		mov	ecx, [edi+esi+4]
		mov	[eax], ecx
		imul	edx, [ebp+var_5C], 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movss	xmm0, dword ptr	[ecx+edx+8]
		xorps	xmm0, ds:__xmm@80000000800000008000000080000000
		mov	edx, [ebp+var_5C]
		push	edx
		lea	ecx, [ebp+var_54]
		movss	[ebp+var_60], xmm0
		call	??A?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@I@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)
		movss	xmm0, [ebp+var_60]
		movss	dword ptr [eax+4], xmm0
		jmp	short loc_32D
; ---------------------------------------------------------------------------

loc_3AB:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+C7j
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::operator->(void)
		mov	[ebp+var_64], eax
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx
		lea	ecx, [ebp+var_54]
		call	?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::front(void)
		push	eax
		lea	ecx, [ebp+var_3C]
		call	?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ ; std::vector<float,std::allocator<float>>::front(void)
		push	eax
		lea	ecx, [ebp+var_24]
		call	?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ ; std::vector<ushort,std::allocator<ushort>>::front(void)
		push	eax
		mov	eax, [ebp+var_10]
		push	ecx
		movss	xmm0, dword ptr	[eax+10h]
		movss	[esp+8Ch+var_8C], xmm0
		mov	ecx, [ebp+var_64]
		push	ecx
		mov	edx, [ebp+var_64]
		mov	eax, [edx]
		mov	ecx, [eax+38h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		call	??1?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::~vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_3C]
		call	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ;	std::vector<float,std::allocator<float>>::~vector<float,std::allocator<float>>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ;	std::vector<ushort,std::allocator<ushort>>::~vector<ushort,std::allocator<ushort>>(void)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 64h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN14		dd 3			; DATA XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+1BBo
		dd offset $LN13
$LN13		dd 0FFFFFFDCh, 10h	; DATA XREF: .text$mn:00000464o
		dd offset $LN9_0	; "indices"
		dd 0FFFFFFC4h, 10h
		dd offset $LN10_0	; "advances"
		dd 0FFFFFFACh, 10h
		dd offset $LN11_1	; "offsets"
$LN11_1		db 'offsets',0          ; DATA XREF: .text$mn:00000488o
$LN10_0		db 'advances',0         ; DATA XREF: .text$mn:0000047Co
$LN9_0		db 'indices',0          ; DATA XREF: .text$mn:00000470o
		align 4

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall mozilla::gfx::ScaledFontDWrite::GetFontFileData(mozilla::gfx::ScaledFontDWrite *this,	void (__cdecl *)(const unsigned	__int8 *, unsigned int,	unsigned int, float, void *), void *)
		public ?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z
?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z proc near

var_D4		= dword	ptr -0D4h
var_B8		= dword	ptr -0B8h
var_B4		= dword	ptr -0B4h
var_B0		= dword	ptr -0B0h
var_AC		= dword	ptr -0ACh
var_A8		= dword	ptr -0A8h
var_A4		= dword	ptr -0A4h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
var_98		= dword	ptr -98h
var_92		= byte ptr -92h
var_91		= byte ptr -91h
var_90		= byte ptr -90h
var_8C		= byte ptr -8Ch
var_88		= byte ptr -88h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_6C		= dword	ptr -6Ch
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_54		= byte ptr -54h
var_48		= byte ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= byte ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0ACh
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_B8]
		mov	ecx, 2Bh ; '+'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_18], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::operator->(void)
		mov	[ebp+var_98], eax
		mov	esi, esp
		push	0
		lea	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_98]
		push	ecx
		mov	edx, [ebp+var_98]
		mov	eax, [edx]
		mov	ecx, [eax+10h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_18], 1
		jbe	short loc_535

loc_52A:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+84j
		xor	edx, edx
		jnz	short loc_52A
		xor	al, al
		jmp	loc_7E7
; ---------------------------------------------------------------------------

loc_535:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+80j
		lea	ecx, [ebp+var_24]
		call	??0?$RefPtr@UIDWriteFontFile@@@@QAE@XZ ; RefPtr<IDWriteFontFile>::RefPtr<IDWriteFontFile>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::operator->(void)
		mov	[ebp+var_9C], eax
		lea	eax, [ebp+var_24]
		push	eax
		lea	ecx, [ebp+var_88]
		push	ecx
		call	??$getter_AddRefs@UIDWriteFontFile@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@AAV?$RefPtr@UIDWriteFontFile@@@@@Z	; getter_AddRefs<IDWriteFontFile>(RefPtr<IDWriteFontFile> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ ; RefPtrGetterAddRefs<IDWriteFontFile>::operator IDWriteFontFile * *(void)
		mov	esi, esp
		push	eax
		lea	edx, [ebp+var_18]
		push	edx
		mov	eax, [ebp+var_9C]
		push	eax
		mov	ecx, [ebp+var_9C]
		mov	edx, [ecx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_24]
		call	??C?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ ; RefPtr<IDWriteFontFile>::operator->(void)
		mov	[ebp+var_A0], eax
		mov	esi, esp
		lea	ecx, [ebp+var_3C]
		push	ecx
		lea	edx, [ebp+var_30]
		push	edx
		mov	eax, [ebp+var_A0]
		push	eax
		mov	ecx, [ebp+var_A0]
		mov	edx, [ecx]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_48]
		call	??0?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ ; RefPtr<IDWriteFontFileLoader>::RefPtr<IDWriteFontFileLoader>(void)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_24]
		call	??C?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ ; RefPtr<IDWriteFontFile>::operator->(void)
		mov	[ebp+var_A4], eax
		lea	ecx, [ebp+var_48]
		push	ecx
		lea	edx, [ebp+var_8C]
		push	edx
		call	??$getter_AddRefs@UIDWriteFontFileLoader@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z ; getter_AddRefs<IDWriteFontFileLoader>(RefPtr<IDWriteFontFileLoader>	&)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ ; RefPtrGetterAddRefs<IDWriteFontFileLoader>::operator IDWriteFontFileLoader * *(void)
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_A4]
		push	eax
		mov	ecx, [ebp+var_A4]
		mov	edx, [ecx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_54]
		call	??0?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ ; RefPtr<IDWriteFontFileStream>::RefPtr<IDWriteFontFileStream>(void)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_48]
		call	??C?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ ;	RefPtr<IDWriteFontFileLoader>::operator->(void)
		mov	[ebp+var_A8], eax
		lea	ecx, [ebp+var_54]
		push	ecx
		lea	edx, [ebp+var_90]
		push	edx
		call	??$getter_AddRefs@UIDWriteFontFileStream@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z ; getter_AddRefs<IDWriteFontFileStream>(RefPtr<IDWriteFontFileStream>	&)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ ; RefPtrGetterAddRefs<IDWriteFontFileStream>::operator IDWriteFontFileStream * *(void)
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_A8]
		push	edx
		mov	eax, [ebp+var_A8]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_54]
		call	??C?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ ;	RefPtr<IDWriteFontFileStream>::operator->(void)
		mov	[ebp+var_AC], eax
		mov	esi, esp
		lea	eax, [ebp+var_64]
		push	eax
		mov	ecx, [ebp+var_AC]
		push	ecx
		mov	edx, [ebp+var_AC]
		mov	eax, [edx]
		mov	ecx, [eax+14h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_60], 0
		ja	short loc_6AB
		cmp	[ebp+var_64], 0FFFFFFFFh
		jbe	short loc_6E8

loc_6AB:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+1FBj
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+205j
		xor	edx, edx
		jnz	short loc_6AB
		mov	[ebp+var_91], 0
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		call	??1?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ ; RefPtr<IDWriteFontFileStream>::~RefPtr<IDWriteFontFileStream>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_48]
		call	??1?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ ; RefPtr<IDWriteFontFileLoader>::~RefPtr<IDWriteFontFileLoader>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$RefPtr@UIDWriteFontFile@@@@QAE@XZ ; RefPtr<IDWriteFontFile>::~RefPtr<IDWriteFontFile>(void)
		mov	al, [ebp+var_91]
		jmp	loc_7E7
; ---------------------------------------------------------------------------

loc_6E8:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+201j
		mov	eax, [ebp+var_64]
		mov	[ebp+var_6C], eax
		lea	ecx, [ebp+var_54]
		call	??C?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ ;	RefPtr<IDWriteFontFileStream>::operator->(void)
		mov	[ebp+var_B0], eax
		mov	esi, esp
		lea	ecx, [ebp+var_80]
		push	ecx
		mov	edx, [ebp+var_6C]
		xor	eax, eax
		push	eax
		push	edx
		push	0
		push	0
		lea	ecx, [ebp+var_74]
		push	ecx
		mov	edx, [ebp+var_B0]
		push	edx
		mov	eax, [ebp+var_B0]
		mov	ecx, [eax]
		mov	edx, [ecx+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::operator->(void)
		mov	[ebp+var_B4], eax
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_10]
		push	ecx
		movss	xmm0, dword ptr	[ecx+10h]
		movss	[esp+0D4h+var_D4], xmm0
		mov	edi, esp
		mov	edx, [ebp+var_B4]
		push	edx
		mov	eax, [ebp+var_B4]
		mov	ecx, [eax]
		mov	edx, [ecx+14h]
		call	edx
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	eax, [ebp+var_6C]
		push	eax
		mov	ecx, [ebp+var_74]
		push	ecx
		call	[ebp+arg_0]
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_54]
		call	??C?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ ;	RefPtr<IDWriteFontFileStream>::operator->(void)
		mov	[ebp+var_B8], eax
		mov	esi, esp
		mov	edx, [ebp+var_80]
		push	edx
		mov	eax, [ebp+var_B8]
		push	eax
		mov	ecx, [ebp+var_B8]
		mov	edx, [ecx]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_92], 1
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		call	??1?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ ; RefPtr<IDWriteFontFileStream>::~RefPtr<IDWriteFontFileStream>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_48]
		call	??1?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ ; RefPtr<IDWriteFontFileLoader>::~RefPtr<IDWriteFontFileLoader>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_24]
		call	??1?$RefPtr@UIDWriteFontFile@@@@QAE@XZ ; RefPtr<IDWriteFontFile>::~RefPtr<IDWriteFontFile>(void)
		mov	al, [ebp+var_92]

loc_7E7:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+88j
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+23Bj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN26
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 0B8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z endp

; ---------------------------------------------------------------------------
$LN26		dd 9			; DATA XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+343o
		dd offset $LN25
$LN25		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:0000081Co
		dd offset $LN15		; "fileCount"
		dd 0FFFFFFDCh, 4
		dd offset $LN16		; "file"
		dd 0FFFFFFD0h, 4
		dd offset $LN17_0	; "referenceKey"
		dd 0FFFFFFC4h, 4
		dd offset $LN18		; "refKeySize"
		dd 0FFFFFFB8h, 4
		dd offset $LN19_0	; "loader"
		dd 0FFFFFFACh, 4
		dd offset $LN20_0	; "stream"
		dd 0FFFFFF9Ch, 8
		dd offset $LN21		; "fileSize64"
		dd 0FFFFFF8Ch, 4
		dd offset $LN22_0	; "fragmentStart"
		dd 0FFFFFF80h, 4
		dd offset $LN23_0	; "context"
$LN23_0		db 'context',0          ; DATA XREF: .text$mn:00000888o
$LN22_0		db 'fragmentStart',0    ; DATA XREF: .text$mn:0000087Co
$LN21		db 'fileSize64',0       ; DATA XREF: .text$mn:00000870o
$LN20_0		db 'stream',0           ; DATA XREF: .text$mn:00000864o
$LN19_0		db 'loader',0           ; DATA XREF: .text$mn:00000858o
$LN18		db 'refKeySize',0       ; DATA XREF: .text$mn:0000084Co
$LN17_0		db 'referenceKey',0     ; DATA XREF: .text$mn:00000840o
$LN16		db 'file',0             ; DATA XREF: .text$mn:00000834o
$LN15		db 'fileCount',0        ; DATA XREF: .text$mn:00000828o
		align 8

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::AntialiasMode __thiscall mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)
		public ?GetDefaultAAMode@ScaledFontDWrite@gfx@mozilla@@UAE?AW4AntialiasMode@23@XZ
?GetDefaultAAMode@ScaledFontDWrite@gfx@mozilla@@UAE?AW4AntialiasMode@23@XZ proc	near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	byte ptr [ebp+var_8+3],	2
		call	?GetSystemTextQuality@gfx@mozilla@@YAEXZ ; mozilla::gfx::GetSystemTextQuality(void)
		mov	byte ptr [ebp+var_C], al
		cmp	byte ptr [ebp+var_C], 0
		jz	short loc_932
		cmp	byte ptr [ebp+var_C], 4
		jz	short loc_92C
		cmp	byte ptr [ebp+var_C], 5
		jz	short loc_926
		jmp	short loc_936
; ---------------------------------------------------------------------------

loc_926:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+3Aj
		mov	byte ptr [ebp+var_8+3],	2
		jmp	short loc_936
; ---------------------------------------------------------------------------

loc_92C:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+34j
		mov	byte ptr [ebp+var_8+3],	1
		jmp	short loc_936
; ---------------------------------------------------------------------------

loc_932:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+2Ej
		mov	byte ptr [ebp+var_8+3],	0

loc_936:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+3Cj
					; mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+42j ...
		cmp	byte ptr [ebp+var_8+3],	1
		jnz	short loc_969
		mov	eax, [ebp+var_4]
		push	ecx
		movss	xmm0, dword ptr	[eax+10h]
		movss	[esp+10h+var_10], xmm0
		mov	ecx, [ebp+var_4]
		add	ecx, 1Ch
		call	??B?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::operator IDWriteFontFace *(void)
		push	eax
		call	?DoGrayscale@gfx@mozilla@@YA_NPAUIDWriteFontFace@@M@Z ;	mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_969
		mov	byte ptr [ebp+var_8+3],	0

loc_969:				; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+52j
					; mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+7Bj
		mov	al, byte ptr [ebp+var_8+3]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetDefaultAAMode@ScaledFontDWrite@gfx@mozilla@@UAE?AW4AntialiasMode@23@XZ endp

; ---------------------------------------------------------------------------
		db 0Eh dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned char	__cdecl	mozilla::gfx::GetSystemTextQuality(void)
?GetSystemTextQuality@gfx@mozilla@@YAEXZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+22p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
pvParam		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+pvParam], eax
		mov	[ebp+var_4], eax
		mov	esi, esp
		push	0		; fWinIni
		lea	eax, [ebp+pvParam]
		push	eax		; pvParam
		push	0		; uiParam
		push	4Ah ; 'J'       ; uiAction
		call	dword ptr ds:__imp__SystemParametersInfoA@16 ; SystemParametersInfoA(x,x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_9C7
		xor	al, al
		jmp	short loc_A01
; ---------------------------------------------------------------------------

loc_9C7:				; CODE XREF: mozilla::gfx::GetSystemTextQuality(void)+39j
		cmp	[ebp+pvParam], 0
		jz	short loc_9FF
		mov	esi, esp
		push	0		; fWinIni
		lea	ecx, [ebp+var_14]
		push	ecx		; pvParam
		push	0		; uiParam
		push	200Ah		; uiAction
		call	dword ptr ds:__imp__SystemParametersInfoA@16 ; SystemParametersInfoA(x,x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_9F1
		xor	al, al
		jmp	short loc_A01
; ---------------------------------------------------------------------------

loc_9F1:				; CODE XREF: mozilla::gfx::GetSystemTextQuality(void)+63j
		cmp	[ebp+var_14], 2
		jnz	short loc_9FB
		mov	al, 5
		jmp	short loc_A01
; ---------------------------------------------------------------------------

loc_9FB:				; CODE XREF: mozilla::gfx::GetSystemTextQuality(void)+6Dj
		mov	al, 4
		jmp	short loc_A01
; ---------------------------------------------------------------------------

loc_9FF:				; CODE XREF: mozilla::gfx::GetSystemTextQuality(void)+43j
		xor	al, al

loc_A01:				; CODE XREF: mozilla::gfx::GetSystemTextQuality(void)+3Dj
					; mozilla::gfx::GetSystemTextQuality(void)+67j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetSystemTextQuality@gfx@mozilla@@YAEXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN10_3		dd 2			; DATA XREF: mozilla::gfx::GetSystemTextQuality(void)+7Do
		dd offset $LN9_1
$LN9_1		dd 0FFFFFFF8h, 4	; DATA XREF: .text$mn:00000A28o
		dd offset $LN7		; "font_smoothing"
		dd 0FFFFFFECh, 4
		dd offset $LN8_2	; "smoothing_type"
$LN8_2		db 'smoothing_type',0   ; DATA XREF: .text$mn:00000A40o
$LN7		db 'font_smoothing',0   ; DATA XREF: .text$mn:00000A34o
		align 8

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short __cdecl mozilla::gfx::readShort(char const *)
?readShort@gfx@mozilla@@YAGPBD@Z proc near
					; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+7Cp
					; mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+E8p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		movsx	eax, byte ptr [eax]
		shl	eax, 8
		mov	ecx, [ebp+arg_0]
		movsx	edx, byte ptr [ecx+1]
		or	eax, edx
		pop	ebp
		retn
?readShort@gfx@mozilla@@YAGPBD@Z endp

; ---------------------------------------------------------------------------
		db 9 dup(0CCh)

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::gfx::DoGrayscale(struct	IDWriteFontFace	*, float)
?DoGrayscale@gfx@mozilla@@YA_NPAUIDWriteFontFace@@M@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+6Ep

var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= word ptr -34h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 3Ch
		push	esi
		push	edi
		lea	edi, [ebp+var_3C]
		mov	ecx, 0Fh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		lea	eax, [ebp+var_2C]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		lea	edx, [ebp+var_20]
		push	edx
		lea	eax, [ebp+var_14]
		push	eax
		push	70736167h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [edx+30h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_2C], 0
		jz	loc_BDE
		cmp	[ebp+var_20], 4
		jnb	short loc_AFD
		mov	esi, esp
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, 1
		jmp	loc_BE0
; ---------------------------------------------------------------------------

loc_AFD:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+51j
		mov	ecx, [ebp+var_14]
		add	ecx, 2
		push	ecx
		call	?readShort@gfx@mozilla@@YAGPBD@Z ; mozilla::gfx::readShort(char	const *)
		add	esp, 4
		mov	[ebp+var_34], ax
		movzx	edx, [ebp+var_34]
		lea	eax, ds:4[edx*4]
		cmp	[ebp+var_20], eax
		jnb	short loc_B42
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [eax+34h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, 1
		jmp	loc_BE0
; ---------------------------------------------------------------------------

loc_B42:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+96j
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	[ebp+var_38], eax
		mov	[ebp+var_3C], 0
		jmp	short loc_B5D
; ---------------------------------------------------------------------------

loc_B54:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float):loc_BC1j
		mov	ecx, [ebp+var_3C]
		add	ecx, 1
		mov	[ebp+var_3C], ecx

loc_B5D:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+CAj
		movzx	edx, [ebp+var_34]
		cmp	[ebp+var_3C], edx
		jge	short loc_BC3
		mov	eax, [ebp+var_3C]
		mov	ecx, [ebp+var_38]
		lea	edx, [ecx+eax*4]
		push	edx
		call	?readShort@gfx@mozilla@@YAGPBD@Z ; mozilla::gfx::readShort(char	const *)
		add	esp, 4
		movzx	eax, ax
		cvtsi2ss xmm0, eax
		comiss	xmm0, [ebp+arg_4]
		jbe	short loc_BC1
		mov	ecx, [ebp+var_3C]
		mov	edx, [ebp+var_38]
		lea	eax, [edx+ecx*4+2]
		push	eax
		call	?readShort@gfx@mozilla@@YAGPBD@Z ; mozilla::gfx::readShort(char	const *)
		add	esp, 4
		movzx	ecx, ax
		and	ecx, 2
		jnz	short loc_BBF
		mov	esi, esp
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	short loc_BE0
; ---------------------------------------------------------------------------

loc_BBF:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+116j
		jmp	short loc_BC3
; ---------------------------------------------------------------------------

loc_BC1:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+FBj
		jmp	short loc_B54
; ---------------------------------------------------------------------------

loc_BC3:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+DCj
					; mozilla::gfx::DoGrayscale(IDWriteFontFace *,float):loc_BBFj
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [eax+34h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_BDE:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+47j
		mov	al, 1

loc_BE0:				; CODE XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+70j
					; mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+B5j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		add	esp, 3Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?DoGrayscale@gfx@mozilla@@YA_NPAUIDWriteFontFace@@M@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN16_0		dd 4			; DATA XREF: mozilla::gfx::DoGrayscale(IDWriteFontFace *,float)+15Co
		dd offset $LN15_0
$LN15_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text$mn:00000C08o
		dd offset $LN11_3	; "tableContext"
		dd 0FFFFFFECh, 4
		dd offset $LN12_1	; "tableData"
		dd 0FFFFFFE0h, 4
		dd offset $LN13_2	; "tableSize"
		dd 0FFFFFFD4h, 4
		dd offset $LN14_1	; "exists"
$LN14_1		db 'exists',0           ; DATA XREF: .text$mn:00000C38o
$LN13_2		db 'tableSize',0        ; DATA XREF: .text$mn:00000C2Co
$LN12_1		db 'tableData',0        ; DATA XREF: .text$mn:00000C20o
$LN11_3		db 'tableContext',0     ; DATA XREF: .text$mn:00000C14o
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$0 proc near
					; DATA XREF: .xdata$x:00007500o
		mov	eax, [ebp-28h]
		and	eax, 1
		jz	locret_C7C
		and	dword ptr [ebp-28h], 0FFFFFFFEh
		mov	ecx, [ebp+8]
		jmp	??1?$already_AddRefed@VPath@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::Path>::~already_AddRefed<mozilla::gfx::Path>(void)
; ---------------------------------------------------------------------------

locret_C7C:				; CODE XREF: __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$0+6j
		retn
__unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$1 proc near
					; DATA XREF: .xdata$x:00007508o
		lea	ecx, [ebp-24h]
		jmp	??1?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::PathBuilder>::~already_AddRefed<mozilla::gfx::PathBuilder>(void)
__unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$2 proc near
					; DATA XREF: .xdata$x:00007510o
					; .xdata$x:00007518o
		lea	ecx, [ebp-18h]
		jmp	??1?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@XZ ; RefPtr<mozilla::gfx::PathBuilder>::~RefPtr<mozilla::gfx::PathBuilder>(void)
__unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z	proc near
					; DATA XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-34h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$0 proc near
					; DATA XREF: .xdata$x:000074E8o
		lea	ecx, [ebp-24h]
		jmp	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ;	std::vector<ushort,std::allocator<ushort>>::~vector<ushort,std::allocator<ushort>>(void)
__unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$1 proc near
					; DATA XREF: .xdata$x:000074F0o
		lea	ecx, [ebp-3Ch]
		jmp	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ;	std::vector<float,std::allocator<float>>::~vector<float,std::allocator<float>>(void)
__unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$2 proc near
					; DATA XREF: .xdata$x:000074F8o
		lea	ecx, [ebp-54h]
		jmp	??1?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::~vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)
__unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z proc	near
					; DATA XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-64h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$0 proc near
					; DATA XREF: .xdata$x:000074D0o
		lea	ecx, [ebp-24h]
		jmp	??1?$RefPtr@UIDWriteFontFile@@@@QAE@XZ ; RefPtr<IDWriteFontFile>::~RefPtr<IDWriteFontFile>(void)
__unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$1 proc near
					; DATA XREF: .xdata$x:000074D8o
		lea	ecx, [ebp-48h]
		jmp	??1?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ ; RefPtr<IDWriteFontFileLoader>::~RefPtr<IDWriteFontFileLoader>(void)
__unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$2 proc near
					; DATA XREF: .xdata$x:000074E0o
		lea	ecx, [ebp-54h]
		jmp	??1?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ ; RefPtr<IDWriteFontFileStream>::~RefPtr<IDWriteFontFileStream>(void)
__unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z proc	near
					; DATA XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0B8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z
		jmp	___CxxFrameHandler3
__ehhandler$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<class mozilla::gfx::PathBuilder>::RefPtr<class mozilla::gfx::PathBuilder>(struct already_AddRefed<class mozilla::gfx::PathBuilder> &&)
		public ??$?0VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@@Z
??$?0VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@@Z	proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+D8p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?take@?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAEPAVPathBuilder@gfx@mozilla@@XZ ; already_AddRefed<mozilla::gfx::PathBuilder>::take(void)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?0VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D44h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::_Allocate<char>(unsigned int, char *)
		public ??$_Allocate@D@std@@YAPADIPAD@Z
??$_Allocate@D@std@@YAPADIPAD@Z	proc near
					; CODE XREF: std::allocator<char>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_D5F
		jmp	short loc_D89
; ---------------------------------------------------------------------------

loc_D5F:				; CODE XREF: std::_Allocate<char>(uint,char *)+17j
		cmp	[ebp+arg_0], 0FFFFFFFFh
		ja	short loc_D7A
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_D89

loc_D7A:				; CODE XREF: std::_Allocate<char>(uint,char *)+1Fj
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_D89:				; CODE XREF: std::_Allocate<char>(uint,char *)+19j
					; std::_Allocate<char>(uint,char *)+34j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@D@std@@YAPADIPAD@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D9Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short * __cdecl std::_Allocate<unsigned short>(unsigned int,	unsigned short *)
		public ??$_Allocate@G@std@@YAPAGIPAG@Z
??$_Allocate@G@std@@YAPAGIPAG@Z	proc near
					; CODE XREF: std::allocator<ushort>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_DB7
		jmp	short loc_DE6
; ---------------------------------------------------------------------------

loc_DB7:				; CODE XREF: std::_Allocate<ushort>(uint,ushort	*)+17j
		cmp	[ebp+arg_0], 7FFFFFFFh
		ja	short loc_DD7
		mov	eax, [ebp+arg_0]
		shl	eax, 1
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_DE6

loc_DD7:				; CODE XREF: std::_Allocate<ushort>(uint,ushort	*)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_DE6:				; CODE XREF: std::_Allocate<ushort>(uint,ushort	*)+19j
					; std::_Allocate<ushort>(uint,ushort *)+39j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@G@std@@YAPAGIPAG@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; float	* __cdecl std::_Allocate<float>(unsigned int, float *)
		public ??$_Allocate@M@std@@YAPAMIPAM@Z
??$_Allocate@M@std@@YAPAMIPAM@Z	proc near
					; CODE XREF: std::allocator<float>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_E13
		jmp	short loc_E43
; ---------------------------------------------------------------------------

loc_E13:				; CODE XREF: std::_Allocate<float>(uint,float *)+17j
		cmp	[ebp+arg_0], 3FFFFFFFh
		ja	short loc_E34
		mov	eax, [ebp+arg_0]
		shl	eax, 2
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_E43

loc_E34:				; CODE XREF: std::_Allocate<float>(uint,float *)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_E43:				; CODE XREF: std::_Allocate<float>(uint,float *)+19j
					; std::_Allocate<float>(uint,float *)+3Aj
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@M@std@@YAPAMIPAM@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct DWRITE_GLYPH_OFFSET * __cdecl std::_Allocate<struct DWRITE_GLYPH_OFFSET>(unsigned int,	struct DWRITE_GLYPH_OFFSET *)
		public ??$_Allocate@UDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@IPAU1@@Z
??$_Allocate@UDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@IPAU1@@Z proc near
					; CODE XREF: std::allocator<DWRITE_GLYPH_OFFSET>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_E73
		jmp	short loc_EA3
; ---------------------------------------------------------------------------

loc_E73:				; CODE XREF: std::_Allocate<DWRITE_GLYPH_OFFSET>(uint,DWRITE_GLYPH_OFFSET *)+17j
		cmp	[ebp+arg_0], 1FFFFFFFh
		ja	short loc_E94
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_EA3

loc_E94:				; CODE XREF: std::_Allocate<DWRITE_GLYPH_OFFSET>(uint,DWRITE_GLYPH_OFFSET *)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_EA3:				; CODE XREF: std::_Allocate<DWRITE_GLYPH_OFFSET>(uint,DWRITE_GLYPH_OFFSET *)+19j
					; std::_Allocate<DWRITE_GLYPH_OFFSET>(uint,DWRITE_GLYPH_OFFSET *)+3Aj
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@UDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@IPAU1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
		public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
					; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_ED3
		jmp	short loc_F03
; ---------------------------------------------------------------------------

loc_ED3:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+17j
		cmp	[ebp+arg_0], 1FFFFFFFh
		ja	short loc_EF4
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_F03

loc_EF4:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F03:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+19j
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Aj
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<char>(int, wchar_t *,	unsigned int)
		public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+1Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+22p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_F41
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F41:				; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<unsigned short>(int, wchar_t *, unsigned int)
		public ??$_Debug_pointer@G@std@@YAXPAGPB_WI@Z
??$_Debug_pointer@G@std@@YAXPAGPB_WI@Z proc near
					; CODE XREF: std::_Debug_range2<ushort *>(ushort *,ushort *,wchar_t const *,uint,std::random_access_iterator_tag)+18p
					; std::_Debug_range2<ushort *>(ushort *,ushort *,wchar_t const *,uint,std::random_access_iterator_tag)+2Cp ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_F75
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_F75:				; CODE XREF: std::_Debug_pointer<ushort>(ushort	*,wchar_t const	*,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@G@std@@YAXPAGPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<float>(int, wchar_t *, unsigned int)
		public ??$_Debug_pointer@M@std@@YAXPAMPB_WI@Z
??$_Debug_pointer@M@std@@YAXPAMPB_WI@Z proc near
					; CODE XREF: std::_Debug_range2<float *>(float *,float *,wchar_t const *,uint,std::random_access_iterator_tag)+18p
					; std::_Debug_range2<float *>(float *,float *,wchar_t const *,uint,std::random_access_iterator_tag)+2Cp ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_FA9
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_FA9:				; CODE XREF: std::_Debug_pointer<float>(float *,wchar_t	const *,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@M@std@@YAXPAMPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FB4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<DWRITE_GLYPH_OFFSET>(int, wchar_t *, unsigned	int)
		public ??$_Debug_pointer@UDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@PB_WI@Z
??$_Debug_pointer@UDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@PB_WI@Z proc near
					; CODE XREF: std::_Debug_range2<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,wchar_t const *,uint,std::random_access_iterator_tag)+18p
					; std::_Debug_range2<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,wchar_t	const *,uint,std::random_access_iterator_tag)+2Cp ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_FDD
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_FDD:				; CODE XREF: std::_Debug_pointer<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,wchar_t const *,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@UDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@PB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_range2<unsigned short	*>(int,	int, wchar_t *,	unsigned int)
		public ??$_Debug_range2@PAG@std@@YAXPAG0PB_WIUrandom_access_iterator_tag@0@@Z
??$_Debug_range2@PAG@std@@YAXPAG0PB_WIUrandom_access_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Debug_range<ushort *>(ushort	*,ushort *,wchar_t const *,uint)+31p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jz	short loc_1043
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	??$_Debug_pointer@G@std@@YAXPAGPB_WI@Z ; std::_Debug_pointer<ushort>(ushort *,wchar_t const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	??$_Debug_pointer@G@std@@YAXPAGPB_WI@Z ; std::_Debug_pointer<ushort>(ushort *,wchar_t const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_1043
		mov	esi, esp
		mov	edx, [ebp+arg_C]
		push	edx		; unsigned int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		push	offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator	range"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1043:				; CODE XREF: std::_Debug_range2<ushort *>(ushort *,ushort *,wchar_t const *,uint,std::random_access_iterator_tag)+Aj
					; std::_Debug_range2<ushort *>(ushort *,ushort *,wchar_t const *,uint,std::random_access_iterator_tag)+3Aj
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_range2@PAG@std@@YAXPAG0PB_WIUrandom_access_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1050h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_range2<float *>(int, int, wchar_t *, unsigned	int)
		public ??$_Debug_range2@PAM@std@@YAXPAM0PB_WIUrandom_access_iterator_tag@0@@Z
??$_Debug_range2@PAM@std@@YAXPAM0PB_WIUrandom_access_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Debug_range<float *>(float *,float *,wchar_t	const *,uint)+31p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jz	short loc_10AB
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	??$_Debug_pointer@M@std@@YAXPAMPB_WI@Z ; std::_Debug_pointer<float>(float *,wchar_t const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	??$_Debug_pointer@M@std@@YAXPAMPB_WI@Z ; std::_Debug_pointer<float>(float *,wchar_t const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_10AB
		mov	esi, esp
		mov	edx, [ebp+arg_C]
		push	edx		; unsigned int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		push	offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator	range"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_10AB:				; CODE XREF: std::_Debug_range2<float *>(float *,float *,wchar_t const *,uint,std::random_access_iterator_tag)+Aj
					; std::_Debug_range2<float *>(float *,float *,wchar_t const *,uint,std::random_access_iterator_tag)+3Aj
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_range2@PAM@std@@YAXPAM0PB_WIUrandom_access_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_range2<DWRITE_GLYPH_OFFSET *>(int, int, wchar_t *, unsigned int)
		public ??$_Debug_range2@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WIUrandom_access_iterator_tag@0@@Z
??$_Debug_range2@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Debug_range<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,wchar_t const	*,uint)+31p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jz	short loc_1113
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		call	??$_Debug_pointer@UDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@PB_WI@Z ; std::_Debug_pointer<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,wchar_t const	*,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	??$_Debug_pointer@UDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@PB_WI@Z ; std::_Debug_pointer<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,wchar_t const	*,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_1113
		mov	esi, esp
		mov	edx, [ebp+arg_C]
		push	edx		; unsigned int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		push	offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator	range"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1113:				; CODE XREF: std::_Debug_range2<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,wchar_t const *,uint,std::random_access_iterator_tag)+Aj
					; std::_Debug_range2<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,wchar_t	const *,uint,std::random_access_iterator_tag)+3Aj
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_range2@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WIUrandom_access_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1120h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_range<unsigned short *>(int, int, wchar_t *, unsigned	int)
		public ??$_Debug_range@PAG@std@@YAXPAG0PB_WI@Z
??$_Debug_range@PAG@std@@YAXPAG0PB_WI@Z	proc near
					; CODE XREF: std::_Uninit_move<ushort,ushort,ushort>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &,ushort *,std::_Scalar_ptr_iterator_tag)+1Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		lea	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_4+3]
		push	ecx
		call	??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z	; std::_Iter_cat<ushort	*>(ushort * const &)
		add	esp, 8
		mov	dl, [eax]
		movzx	eax, dl
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	??$_Debug_range2@PAG@std@@YAXPAG0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<ushort *>(ushort *,ushort *,wchar_t	const *,uint,std::random_access_iterator_tag)
		add	esp, 14h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Debug_range@PAG@std@@YAXPAG0PB_WI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1168h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_range<float *>(int, int, wchar_t *, unsigned int)
		public ??$_Debug_range@PAM@std@@YAXPAM0PB_WI@Z
??$_Debug_range@PAM@std@@YAXPAM0PB_WI@Z	proc near
					; CODE XREF: std::_Uninit_move<float,float,float>(float	*,float	*,float	*,std::_Wrap_alloc<std::allocator<float>> &,float *,std::_Scalar_ptr_iterator_tag)+1Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		lea	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_4+3]
		push	ecx
		call	??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z	; std::_Iter_cat<float *>(float	* const	&)
		add	esp, 8
		mov	dl, [eax]
		movzx	eax, dl
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	??$_Debug_range2@PAM@std@@YAXPAM0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<float *>(float *,float *,wchar_t const *,uint,std::random_access_iterator_tag)
		add	esp, 14h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Debug_range@PAM@std@@YAXPAM0PB_WI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11B0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_range<DWRITE_GLYPH_OFFSET *>(int, int, wchar_t *, unsigned int)
		public ??$_Debug_range@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WI@Z
??$_Debug_range@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WI@Z proc near
					; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+43p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		lea	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_4+3]
		push	ecx
		call	??$_Iter_cat@PAUDWRITE_GLYPH_OFFSET@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUDWRITE_GLYPH_OFFSET@@@Z ; std::_Iter_cat<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *	const &)
		add	esp, 8
		mov	dl, [eax]
		movzx	eax, dl
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	??$_Debug_range2@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,wchar_t const *,uint,std::random_access_iterator_tag)
		add	esp, 14h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Debug_range@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned short>>>(unsigned short *, unsigned short *, struct std::_Wrap_alloc<class std::allocator<unsigned short>> &)
		public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z proc	near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Destroy(ushort *,ushort *)+32p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z ; std::_Ptr_cat<ushort,ushort>(ushort *,ushort *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &,std::_Scalar_ptr_iterator_tag)
		add	esp, 10h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1240h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned short>>>(unsigned short *, unsigned short *, struct std::_Wrap_alloc<class std::allocator<unsigned short>> &, struct std::_Scalar_ptr_iterator_tag)
		public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+2Fp
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1248h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<float>>>(float *, float	*, struct std::_Wrap_alloc<class std::allocator<float>>	&)
		public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z proc	near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Destroy(float *,float *)+32p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ; std::_Ptr_cat<float,float>(float *,float *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<float>>>(float *,float *,std::_Wrap_alloc<std::allocator<float>> &,std::_Scalar_ptr_iterator_tag)
		add	esp, 10h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1290h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<float>>>(float *, float	*, struct std::_Wrap_alloc<class std::allocator<float>>	&, struct std::_Scalar_ptr_iterator_tag)
		public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<float>>>(float	*,float	*,std::_Wrap_alloc<std::allocator<float>> &)+2Fp
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1298h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>>(struct DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *, struct std::_Wrap_alloc<class	std::allocator<struct DWRITE_GLYPH_OFFSET>> &)
		public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Destroy(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *)+32p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@UDWRITE_GLYPH_OFFSET@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDWRITE_GLYPH_OFFSET@@0@Z ; std::_Ptr_cat<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>	&,std::_Nonscalar_ptr_iterator_tag)
		add	esp, 10h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 12E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>>(struct DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *, struct std::_Wrap_alloc<class	std::allocator<struct DWRITE_GLYPH_OFFSET>> &, struct std::_Nonscalar_ptr_iterator_tag)
		public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+2Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		jmp	short loc_12EE
; ---------------------------------------------------------------------------

loc_12E5:				; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,std::_Nonscalar_ptr_iterator_tag)+22j
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	[ebp+arg_0], eax

loc_12EE:				; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,std::_Nonscalar_ptr_iterator_tag)+3j
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [ebp+arg_4]
		jz	short loc_1304
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+arg_8]
		call	??$destroy@UDWRITE_GLYPH_OFFSET@@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z ;	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::destroy<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*)
		jmp	short loc_12E5
; ---------------------------------------------------------------------------

loc_1304:				; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,std::_Nonscalar_ptr_iterator_tag)+14j
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1310h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short * __cdecl std::_Fill_n<unsigned short *, unsigned int,	unsigned short>(unsigned short *, unsigned int,	unsigned short const &)
		public ??$_Fill_n@PAGIG@std@@YAPAGPAGIABG@Z
??$_Fill_n@PAGIG@std@@YAPAGPAGIABG@Z proc near
					; CODE XREF: std::_Uninit_def_fill_n<ushort,uint,ushort>(ushort	*,uint,std::_Wrap_alloc<std::allocator<ushort>>	&,ushort *,std::_Scalar_ptr_iterator_tag)+1Dp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		jmp	short loc_1327
; ---------------------------------------------------------------------------

loc_1315:				; CODE XREF: std::_Fill_n<ushort *,uint,ushort>(ushort *,uint,ushort const &)+29j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 2
		mov	[ebp+arg_0], ecx

loc_1327:				; CODE XREF: std::_Fill_n<ushort *,uint,ushort>(ushort *,uint,ushort const &)+3j
		cmp	[ebp+arg_4], 0
		jbe	short loc_133B
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_8]
		mov	cx, [eax]
		mov	[edx], cx
		jmp	short loc_1315
; ---------------------------------------------------------------------------

loc_133B:				; CODE XREF: std::_Fill_n<ushort *,uint,ushort>(ushort *,uint,ushort const &)+1Bj
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Fill_n@PAGIG@std@@YAPAGPAGIABG@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1340h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; float	* __cdecl std::_Fill_n<float *,	unsigned int, float>(float *, unsigned int, float const	&)
		public ??$_Fill_n@PAMIM@std@@YAPAMPAMIABM@Z
??$_Fill_n@PAMIM@std@@YAPAMPAMIABM@Z proc near
					; CODE XREF: std::_Uninit_def_fill_n<float,uint,float>(float *,uint,std::_Wrap_alloc<std::allocator<float>> &,float *,std::_Scalar_ptr_iterator_tag)+24p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		jmp	short loc_1357
; ---------------------------------------------------------------------------

loc_1345:				; CODE XREF: std::_Fill_n<float	*,uint,float>(float *,uint,float const &)+27j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		mov	[ebp+arg_0], ecx

loc_1357:				; CODE XREF: std::_Fill_n<float	*,uint,float>(float *,uint,float const &)+3j
		cmp	[ebp+arg_4], 0
		jbe	short loc_1369
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		mov	[edx], ecx
		jmp	short loc_1345
; ---------------------------------------------------------------------------

loc_1369:				; CODE XREF: std::_Fill_n<float	*,uint,float>(float *,uint,float const &)+1Bj
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Fill_n@PAMIM@std@@YAPAMPAMIABM@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1370h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<unsigned short *>(unsigned short * const &)
		public ??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z
??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z	proc near
					; CODE XREF: std::_Debug_range<ushort *>(ushort	*,ushort *,wchar_t const *,uint)+13p

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		mov	cl, byte ptr [ebp+var_8+3]
		mov	[eax], cl
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_14		dd 1			; DATA XREF: std::_Iter_cat<ushort *>(ushort * const &)+2Ao
		dd offset $LN4_14
$LN4_14		dd 0FFFFFFFBh, 1	; DATA XREF: .text$mn:000013B0o
		dd offset $LN3_14	; "_Cat"
$LN3_14		db '_Cat',0             ; DATA XREF: .text$mn:000013BCo
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 13C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<float *>(float * const &)
		public ??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z	proc near
					; CODE XREF: std::_Debug_range<float *>(float *,float *,wchar_t	const *,uint)+13p

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		mov	cl, byte ptr [ebp+var_8+3]
		mov	[eax], cl
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_18
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_18		dd 1			; DATA XREF: std::_Iter_cat<float *>(float * const &)+2Ao
		dd offset $LN4_18
$LN4_18		dd 0FFFFFFFBh, 1	; DATA XREF: .text$mn:00001408o
		dd offset $LN3_18	; "_Cat"
$LN3_18		db '_Cat',0             ; DATA XREF: .text$mn:00001414o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1420h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct DWRITE_GLYPH_OFFSET *>(struct DWRITE_GLYPH_OFFSET * const &)
		public ??$_Iter_cat@PAUDWRITE_GLYPH_OFFSET@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUDWRITE_GLYPH_OFFSET@@@Z
??$_Iter_cat@PAUDWRITE_GLYPH_OFFSET@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUDWRITE_GLYPH_OFFSET@@@Z proc near
					; CODE XREF: std::_Debug_range<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,wchar_t const	*,uint)+13p

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		mov	cl, byte ptr [ebp+var_8+3]
		mov	[eax], cl
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_19
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$_Iter_cat@PAUDWRITE_GLYPH_OFFSET@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUDWRITE_GLYPH_OFFSET@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_19		dd 1			; DATA XREF: std::_Iter_cat<DWRITE_GLYPH_OFFSET	*>(DWRITE_GLYPH_OFFSET * const &)+2Ao
		dd offset $LN4_19
$LN4_19		dd 0FFFFFFFBh, 1	; DATA XREF: .text$mn:00001460o
		dd offset $LN3_19	; "_Cat"
$LN3_19		db '_Cat',0             ; DATA XREF: .text$mn:0000146Co
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1478h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned short, unsigned short>(unsigned short *, unsigned	short *)
		public ??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z
??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z proc	near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+13p
					; std::_Uninit_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort	*,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+13p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, byte ptr [ebp+var_8+3]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_16
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_16		dd 1			; DATA XREF: std::_Ptr_cat<ushort,ushort>(ushort *,ushort *)+22o
		dd offset $LN4_16
$LN4_16		dd 0FFFFFFFBh, 1	; DATA XREF: .text$mn:000014B0o
		dd offset $LN3_16	; "_Cat"
$LN3_16		db '_Cat',0             ; DATA XREF: .text$mn:000014BCo
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 14C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<float, float>(float *, float *)
		public ??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z
??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z proc	near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<float>>>(float	*,float	*,std::_Wrap_alloc<std::allocator<float>> &)+13p
					; std::_Uninit_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)+13p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, byte ptr [ebp+var_8+3]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_15
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_15		dd 1			; DATA XREF: std::_Ptr_cat<float,float>(float *,float *)+22o
		dd offset $LN4_15
$LN4_15		dd 0FFFFFFFBh, 1	; DATA XREF: .text$mn:00001500o
		dd offset $LN3_15	; "_Cat"
$LN3_15		db '_Cat',0             ; DATA XREF: .text$mn:0000150Co
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1518h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct DWRITE_GLYPH_OFFSET, struct DWRITE_GLYPH_OFFSET>(struct DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *)
		public ??$_Ptr_cat@UDWRITE_GLYPH_OFFSET@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDWRITE_GLYPH_OFFSET@@0@Z
??$_Ptr_cat@UDWRITE_GLYPH_OFFSET@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDWRITE_GLYPH_OFFSET@@0@Z proc near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+13p
					; std::_Uninit_move<DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+13p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, byte ptr [ebp+var_8+3]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$_Ptr_cat@UDWRITE_GLYPH_OFFSET@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDWRITE_GLYPH_OFFSET@@0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_17		dd 1			; DATA XREF: std::_Ptr_cat<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *)+22o
		dd offset $LN4_17
$LN4_17		dd 0FFFFFFFBh, 1	; DATA XREF: .text$mn:00001550o
		dd offset $LN3_17	; "_Cat"
$LN3_17		db '_Cat',0             ; DATA XREF: .text$mn:0000155Co
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1568h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short * & __cdecl std::_Rechecked<unsigned short *, unsigned	short *>(unsigned short	* &, unsigned short *)
		public ??$_Rechecked@PAGPAG@std@@YAAAPAGAAPAGPAG@Z
??$_Rechecked@PAGPAG@std@@YAAAPAGAAPAGPAG@Z proc near
					; CODE XREF: std::_Uninitialized_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+3Bp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Rechecked@PAGPAG@std@@YAAAPAGAAPAGPAG@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1578h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; float	* & __cdecl std::_Rechecked<float *, float *>(float * &, float *)
		public ??$_Rechecked@PAMPAM@std@@YAAAPAMAAPAMPAM@Z
??$_Rechecked@PAMPAM@std@@YAAAPAMAAPAMPAM@Z proc near
					; CODE XREF: std::_Uninitialized_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)+3Bp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Rechecked@PAMPAM@std@@YAAAPAMAAPAMPAM@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1588h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct DWRITE_GLYPH_OFFSET * & __cdecl std::_Rechecked<struct	DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *>(struct DWRITE_GLYPH_OFFSET	* &, struct DWRITE_GLYPH_OFFSET	*)
		public ??$_Rechecked@PAUDWRITE_GLYPH_OFFSET@@PAU1@@std@@YAAAPAUDWRITE_GLYPH_OFFSET@@AAPAU1@PAU1@@Z
??$_Rechecked@PAUDWRITE_GLYPH_OFFSET@@PAU1@@std@@YAAAPAUDWRITE_GLYPH_OFFSET@@AAPAU1@PAU1@@Z proc near
					; CODE XREF: std::_Uninitialized_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+3Bp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Rechecked@PAUDWRITE_GLYPH_OFFSET@@PAU1@@std@@YAAAPAUDWRITE_GLYPH_OFFSET@@AAPAU1@PAU1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1598h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: unsigned short * __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Umove<unsigned short *>(unsigned short *, unsigned	short *, unsigned short	*)
		public ??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z	proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+76p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		lea	ecx, [ebp+var_C+3]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Uninitialized_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Uninitialized_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort	*,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)
		add	esp, 10h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_12		dd 1			; DATA XREF: std::vector<ushort,std::allocator<ushort>>::_Umove<ushort *>(ushort *,ushort *,ushort *)+42o
		dd offset $LN4_12
$LN4_12		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000015FCo
		dd offset $LN3_12	; "_Alval"
$LN3_12		db '_Alval',0           ; DATA XREF: .text$mn:00001608o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1614h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: float * __thiscall	std::vector<float, class std::allocator<float>>::_Umove<float *>(float *, float	*, float *)
		public ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z
??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z	proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+76p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		lea	ecx, [ebp+var_C+3]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Uninitialized_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ; std::_Uninitialized_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)
		add	esp, 10h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_11		dd 1			; DATA XREF: std::vector<float,std::allocator<float>>::_Umove<float *>(float *,float *,float *)+42o
		dd offset $LN4_11
$LN4_11		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00001678o
		dd offset $LN3_11	; "_Alval"
$LN3_11		db '_Alval',0           ; DATA XREF: .text$mn:00001684o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1690h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: struct DWRITE_GLYPH_OFFSET	* __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Umove<struct DWRITE_GLYPH_OFFSET *>(struct DWRITE_GLYPH_OFFSET	*, struct DWRITE_GLYPH_OFFSET *, struct	DWRITE_GLYPH_OFFSET *)
		public ??$_Umove@PAUDWRITE_GLYPH_OFFSET@@@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEPAUDWRITE_GLYPH_OFFSET@@PAU2@00@Z
??$_Umove@PAUDWRITE_GLYPH_OFFSET@@@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEPAUDWRITE_GLYPH_OFFSET@@PAU2@00@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+76p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		lea	ecx, [ebp+var_C+3]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Uninitialized_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z ; std::_Uninitialized_move<DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)
		add	esp, 10h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_13
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??$_Umove@PAUDWRITE_GLYPH_OFFSET@@@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEPAUDWRITE_GLYPH_OFFSET@@PAU2@00@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_13		dd 1			; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Umove<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+42o
		dd offset $LN4_13
$LN4_13		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000016F4o
		dd offset $LN3_13	; "_Alval"
$LN3_13		db '_Alval',0           ; DATA XREF: .text$mn:00001700o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 170Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short * __cdecl std::_Unchecked<unsigned short *>(unsigned short *)
		public ??$_Unchecked@PAG@std@@YAPAGPAG@Z
??$_Unchecked@PAG@std@@YAPAGPAG@Z proc near
					; CODE XREF: std::_Uninitialized_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+Bp
					; std::_Uninitialized_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort	*,std::_Wrap_alloc<std::allocator<ushort>> &)+18p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Unchecked@PAG@std@@YAPAGPAG@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1714h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; float	* __cdecl std::_Unchecked<float	*>(float *)
		public ??$_Unchecked@PAM@std@@YAPAMPAM@Z
??$_Unchecked@PAM@std@@YAPAMPAM@Z proc near
					; CODE XREF: std::_Uninitialized_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)+Bp
					; std::_Uninitialized_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)+18p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Unchecked@PAM@std@@YAPAMPAM@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 171Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct DWRITE_GLYPH_OFFSET * __cdecl std::_Unchecked<struct DWRITE_GLYPH_OFFSET *>(struct DWRITE_GLYPH_OFFSET	*)
		public ??$_Unchecked@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z
??$_Unchecked@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z proc near
					; CODE XREF: std::_Uninitialized_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+Bp
					; std::_Uninitialized_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+18p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$_Unchecked@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1724h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Uninit_def_fill_n<unsigned	short, unsigned	int, unsigned short>(unsigned short *, unsigned	int, struct std::_Wrap_alloc<class std::allocator<unsigned short>> &, unsigned short *,	struct std::_Scalar_ptr_iterator_tag)
		public ??$_Uninit_def_fill_n@GIG@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
??$_Uninit_def_fill_n@GIG@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Uninitialized_default_fill_n<ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>> &)+3Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	word ptr [ebp+var_4+2],	ax
		lea	ecx, [ebp+var_4+2]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Fill_n@PAGIG@std@@YAPAGPAGIABG@Z ; std::_Fill_n<ushort *,uint,ushort>(ushort *,uint,ushort const &)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_def_fill_n@GIG@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1758h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Uninit_def_fill_n<float, unsigned int, float>(float *, unsigned int, struct std::_Wrap_alloc<class	std::allocator<float>> &, float	*, struct std::_Scalar_ptr_iterator_tag)
		public ??$_Uninit_def_fill_n@MIM@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
??$_Uninit_def_fill_n@MIM@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Uninitialized_default_fill_n<float *,uint,std::_Wrap_alloc<std::allocator<float>>>(float *,uint,std::_Wrap_alloc<std::allocator<float>> &)+3Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		movss	xmm0, ds:__real@00000000
		movss	[ebp+var_4], xmm0
		lea	eax, [ebp+var_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	??$_Fill_n@PAMIM@std@@YAPAMPAMIABM@Z ; std::_Fill_n<float *,uint,float>(float *,uint,float const &)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_def_fill_n@MIM@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1794h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,unsigned int,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(void *, int, int)
		public ??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
					; CODE XREF: std::_Uninitialized_default_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+3Cp

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

; FUNCTION CHUNK AT 0000182C SIZE 00000009 BYTES
; FUNCTION CHUNK AT 0000183C SIZE 0000001C BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		push	ecx
		push	ebx
		push	esi
		push	edi
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0
		jmp	short loc_17E6
; ---------------------------------------------------------------------------

loc_17D4:				; CODE XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag)+64j
		mov	ecx, [ebp+arg_4]
		sub	ecx, 1
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 8
		mov	[ebp+arg_0], edx

loc_17E6:				; CODE XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag)+3Ej
		cmp	[ebp+arg_4], 0
		jbe	short loc_17FA
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+arg_8]
		call	?construct@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z ; std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct(DWRITE_GLYPH_OFFSET *)
		jmp	short loc_17D4
; ---------------------------------------------------------------------------

loc_17FA:				; CODE XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag)+56j
		jmp	short loc_182C
??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
					; DATA XREF: .xdata$x:000079E0o
		jmp	short loc_1807
; ---------------------------------------------------------------------------

loc_17FE:				; CODE XREF: __catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
		mov	ecx, [ebp-14h]
		add	ecx, 8
		mov	[ebp-14h], ecx

loc_1807:				; CODE XREF: __catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
		mov	edx, [ebp-14h]
		cmp	edx, [ebp+8]
		jz	short loc_181D
		mov	eax, [ebp-14h]
		push	eax
		mov	ecx, [ebp+10h]
		call	??$destroy@UDWRITE_GLYPH_OFFSET@@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z ;	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::destroy<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*)
		jmp	short loc_17FE
; ---------------------------------------------------------------------------

loc_181D:				; CODE XREF: __catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN13_7
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z

loc_182C:				; CODE XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag):loc_17FAj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_183C
; END OF FUNCTION CHUNK	FOR ??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z

; =============== S U B	R O U T	I N E =======================================


$LN13_7		proc near		; DATA XREF: .text$mn:00001826o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN13_7		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z

loc_183C:				; CODE XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag)+9Fj
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
; END OF FUNCTION CHUNK	FOR ??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1858h
; COMDAT (pick associative to section at 1794)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
					; DATA XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-18h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1874h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_move<unsigned short,unsigned	short,unsigned short>(void *Src, int, void *Dst)
		public ??$_Uninit_move@GGG@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
??$_Uninit_move@GGG@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc	near
					; CODE XREF: std::_Uninit_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+40p

var_4		= dword	ptr -4
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		push	1D6h		; unsigned int
		push	offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; int
		call	??$_Debug_range@PAG@std@@YAXPAG0PB_WI@Z	; std::_Debug_range<ushort *>(ushort *,ushort *,wchar_t	const *,uint)
		add	esp, 10h
		push	1D7h		; unsigned int
		push	offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	edx, [ebp+Dst]
		push	edx		; int
		call	??$_Debug_pointer@G@std@@YAXPAGPB_WI@Z ; std::_Debug_pointer<ushort>(ushort *,wchar_t const *,uint)
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+Src]
		sar	eax, 1
		mov	[ebp+var_4], eax
		mov	ecx, [ebp+var_4]
		shl	ecx, 1
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		lea	eax, [eax+ecx*2]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_move@GGG@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 18F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_move<float,float,float>(void	*Src, int, void	*Dst)
		public ??$_Uninit_move@MMM@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
??$_Uninit_move@MMM@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc	near
					; CODE XREF: std::_Uninit_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>>	&)+40p

var_4		= dword	ptr -4
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		push	1D6h		; unsigned int
		push	offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; int
		call	??$_Debug_range@PAM@std@@YAXPAM0PB_WI@Z	; std::_Debug_range<float *>(float *,float *,wchar_t const *,uint)
		add	esp, 10h
		push	1D7h		; unsigned int
		push	offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	edx, [ebp+Dst]
		push	edx		; int
		call	??$_Debug_pointer@M@std@@YAXPAMPB_WI@Z ; std::_Debug_pointer<float>(float *,wchar_t const *,uint)
		add	esp, 0Ch
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+Src]
		sar	eax, 2
		mov	[ebp+var_4], eax
		mov	ecx, [ebp+var_4]
		shl	ecx, 2
		mov	esi, esp
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		lea	eax, [eax+ecx*4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_move@MMM@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1970h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_move<unsigned short *,unsigned short	*,std::_Wrap_alloc<std::allocator<unsigned short>>>(void *Src, int, void *Dst, int)
		public ??$_Uninit_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
??$_Uninit_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z proc near
					; CODE XREF: std::_Uninitialized_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+2Ep

var_4		= dword	ptr -4
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+Src]
		push	ecx
		call	??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z ; std::_Ptr_cat<ushort,ushort>(ushort *,ushort *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+Src]
		push	eax
		call	??$_Val_type@PAG@std@@YAPAGPAG@Z ; std::_Val_type<ushort *>(ushort *)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		call	??$_Uninit_move@GGG@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ushort,ushort,ushort>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &,ushort *,std::_Scalar_ptr_iterator_tag)
		add	esp, 18h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 19C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(void *Src, int, void *Dst, int)
		public ??$_Uninit_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
??$_Uninit_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z proc near
					; CODE XREF: std::_Uninitialized_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)+2Ep

var_4		= dword	ptr -4
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch
Dst		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+Src]
		push	ecx
		call	??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ; std::_Ptr_cat<float,float>(float *,float *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+Src]
		push	eax
		call	??$_Val_type@PAM@std@@YAPAMPAM@Z ; std::_Val_type<float	*>(float *)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		call	??$_Uninit_move@MMM@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<float,float,float>(float	*,float	*,float	*,std::_Wrap_alloc<std::allocator<float>> &,float *,std::_Scalar_ptr_iterator_tag)
		add	esp, 18h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(int,	int, void *, int)
		public ??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z
??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z proc near
					; CODE XREF: std::_Uninitialized_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+2Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@UDWRITE_GLYPH_OFFSET@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDWRITE_GLYPH_OFFSET@@0@Z ; std::_Ptr_cat<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Val_type@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z ; std::_Val_type<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; void *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z	; std::_Uninit_move<DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)
		add	esp, 18h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(int, int, void *, int)
		public ??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z	proc near
					; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+40p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

; FUNCTION CHUNK AT 00001B46 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00001B56 SIZE 0000001F BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		push	ecx
		push	ebx
		push	esi
		push	edi
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		push	1B6h		; unsigned int
		push	offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		call	??$_Debug_range@PAUDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0PB_WI@Z ; std::_Debug_range<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,wchar_t const *,uint)
		add	esp, 10h
		push	1B7h		; unsigned int
		push	offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	edx, [ebp+arg_8]
		push	edx		; int
		call	??$_Debug_pointer@UDWRITE_GLYPH_OFFSET@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@PB_WI@Z ; std::_Debug_pointer<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,wchar_t const	*,uint)
		add	esp, 0Ch
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0
		jmp	short loc_1AFA
; ---------------------------------------------------------------------------

loc_1AE8:				; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+9Aj
		mov	ecx, [ebp+arg_8]
		add	ecx, 8
		mov	[ebp+arg_8], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 8
		mov	[ebp+arg_0], edx

loc_1AFA:				; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+6Ej
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jz	short loc_1B14
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; void *
		mov	ecx, [ebp+arg_C]
		call	??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	&&)
		jmp	short loc_1AE8
; ---------------------------------------------------------------------------

loc_1B14:				; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+88j
		jmp	short loc_1B46
??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
					; DATA XREF: .xdata$x:00007A64o
		jmp	short loc_1B21
; ---------------------------------------------------------------------------

loc_1B18:				; CODE XREF: __catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
		mov	eax, [ebp-14h]
		add	eax, 8
		mov	[ebp-14h], eax

loc_1B21:				; CODE XREF: __catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
		mov	ecx, [ebp-14h]
		cmp	ecx, [ebp+10h]
		jz	short loc_1B37
		mov	edx, [ebp-14h]
		push	edx
		mov	ecx, [ebp+14h]
		call	??$destroy@UDWRITE_GLYPH_OFFSET@@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z ;	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::destroy<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*)
		jmp	short loc_1B18
; ---------------------------------------------------------------------------

loc_1B37:				; CODE XREF: __catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN13_8
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z

loc_1B46:				; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag):loc_1B14j
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_1B56
; END OF FUNCTION CHUNK	FOR ??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z

; =============== S U B	R O U T	I N E =======================================


$LN13_8		proc near		; DATA XREF: .text$mn:00001B40o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN13_8		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z

loc_1B56:				; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+D5j
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
; END OF FUNCTION CHUNK	FOR ??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1B78h
; COMDAT (pick associative to section at 1A78)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
					; DATA XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-18h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B94h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Uninitialized_default_fill_n<unsigned short *, unsigned int, struct std::_Wrap_alloc<class	std::allocator<unsigned	short>>>(unsigned short	*, unsigned int, struct	std::_Wrap_alloc<class std::allocator<unsigned short>> &)
		public ??$_Uninitialized_default_fill_n@PAGIU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
??$_Uninitialized_default_fill_n@PAGIU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+B9p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@GG@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAG0@Z ; std::_Ptr_cat<ushort,ushort>(ushort *,ushort *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Val_type@PAG@std@@YAPAGPAG@Z ; std::_Val_type<ushort *>(ushort *)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Uninit_def_fill_n@GIG@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ;	std::_Uninit_def_fill_n<ushort,uint,ushort>(ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>> &,ushort *,std::_Scalar_ptr_iterator_tag)
		add	esp, 14h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninitialized_default_fill_n@PAGIU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Uninitialized_default_fill_n<float	*, unsigned int, struct	std::_Wrap_alloc<class std::allocator<float>>>(float *,	unsigned int, struct std::_Wrap_alloc<class std::allocator<float>> &)
		public ??$_Uninitialized_default_fill_n@PAMIU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
??$_Uninitialized_default_fill_n@PAMIU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+B9p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@MM@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAM0@Z ; std::_Ptr_cat<float,float>(float *,float *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Val_type@PAM@std@@YAPAMPAM@Z ; std::_Val_type<float	*>(float *)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Uninit_def_fill_n@MIM@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ;	std::_Uninit_def_fill_n<float,uint,float>(float	*,uint,std::_Wrap_alloc<std::allocator<float>> &,float *,std::_Scalar_ptr_iterator_tag)
		add	esp, 14h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninitialized_default_fill_n@PAMIU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Uninitialized_default_fill_n<DWRITE_GLYPH_OFFSET *,unsigned	int,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(void	*, int,	int)
		public ??$_Uninitialized_default_fill_n@PAUDWRITE_GLYPH_OFFSET@@IU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z
??$_Uninitialized_default_fill_n@PAUDWRITE_GLYPH_OFFSET@@IU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+B9p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$_Ptr_cat@UDWRITE_GLYPH_OFFSET@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUDWRITE_GLYPH_OFFSET@@0@Z ; std::_Ptr_cat<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		add	esp, 8
		mov	byte ptr [ebp+var_4+3],	al
		movzx	edx, byte ptr [ebp+var_4+3]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Val_type@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z ; std::_Val_type<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)
		add	esp, 14h
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Uninitialized_default_fill_n@PAUDWRITE_GLYPH_OFFSET@@IU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short * __cdecl std::_Uninitialized_move<unsigned short *, unsigned short *,	struct std::_Wrap_alloc<class std::allocator<unsigned short>>>(unsigned	short *, unsigned short	*, unsigned short *, struct std::_Wrap_alloc<class std::allocator<unsigned short>> &)
		public ??$_Uninitialized_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
??$_Uninitialized_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Umove<ushort *>(ushort *,ushort *,ushort *)+36p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	??$_Unchecked@PAG@std@@YAPAGPAG@Z ; std::_Unchecked<ushort *>(ushort *)
		add	esp, 4
		push	eax		; Dst
		mov	edx, [ebp+arg_4]
		push	edx
		call	??$_Unchecked@PAG@std@@YAPAGPAG@Z ; std::_Unchecked<ushort *>(ushort *)
		add	esp, 4
		push	eax		; int
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Unchecked@PAG@std@@YAPAGPAG@Z ; std::_Unchecked<ushort *>(ushort *)
		add	esp, 4
		push	eax		; Src
		call	??$_Uninit_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Uninit_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)
		add	esp, 10h
		push	eax
		lea	ecx, [ebp+arg_8]
		push	ecx
		call	??$_Rechecked@PAGPAG@std@@YAAAPAGAAPAGPAG@Z ; std::_Rechecked<ushort *,ushort *>(ushort	* &,ushort *)
		add	esp, 8
		mov	eax, [eax]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Uninitialized_move@PAGPAGU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1CE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; float	* __cdecl std::_Uninitialized_move<float *, float *, struct std::_Wrap_alloc<class std::allocator<float>>>(float *, float *, float *, struct std::_Wrap_alloc<class std::allocator<float>> &)
		public ??$_Uninitialized_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
??$_Uninitialized_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Umove<float *>(float *,float *,float *)+36p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	??$_Unchecked@PAM@std@@YAPAMPAM@Z ; std::_Unchecked<float *>(float *)
		add	esp, 4
		push	eax		; Dst
		mov	edx, [ebp+arg_4]
		push	edx
		call	??$_Unchecked@PAM@std@@YAPAMPAM@Z ; std::_Unchecked<float *>(float *)
		add	esp, 4
		push	eax		; int
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Unchecked@PAM@std@@YAPAMPAM@Z ; std::_Unchecked<float *>(float *)
		add	esp, 4
		push	eax		; Src
		call	??$_Uninit_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ; std::_Uninit_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &)
		add	esp, 10h
		push	eax
		lea	ecx, [ebp+arg_8]
		push	ecx
		call	??$_Rechecked@PAMPAM@std@@YAAAPAMAAPAMPAM@Z ; std::_Rechecked<float *,float *>(float * &,float *)
		add	esp, 8
		mov	eax, [eax]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Uninitialized_move@PAMPAMU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAPAMPAM00AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct DWRITE_GLYPH_OFFSET * __cdecl std::_Uninitialized_move<struct DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *, struct std::_Wrap_alloc<class std::allocator<struct	DWRITE_GLYPH_OFFSET>>>(struct DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET	*, struct DWRITE_GLYPH_OFFSET *, struct	std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>> &)
		public ??$_Uninitialized_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z
??$_Uninitialized_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Umove<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+36p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	??$_Unchecked@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z ;	std::_Unchecked<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *)
		add	esp, 4
		push	eax		; void *
		mov	edx, [ebp+arg_4]
		push	edx
		call	??$_Unchecked@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z ;	std::_Unchecked<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *)
		add	esp, 4
		push	eax		; int
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Unchecked@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z ;	std::_Unchecked<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *)
		add	esp, 4
		push	eax		; int
		call	??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z ; std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)
		add	esp, 10h
		push	eax
		lea	ecx, [ebp+arg_8]
		push	ecx
		call	??$_Rechecked@PAUDWRITE_GLYPH_OFFSET@@PAU1@@std@@YAAAPAUDWRITE_GLYPH_OFFSET@@AAPAU1@PAU1@@Z ; std::_Rechecked<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*>(DWRITE_GLYPH_OFFSET * &,DWRITE_GLYPH_OFFSET *)
		add	esp, 8
		mov	eax, [eax]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Uninitialized_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned short * __cdecl std::_Val_type<unsigned short *>(unsigned short *)
		public ??$_Val_type@PAG@std@@YAPAGPAG@Z
??$_Val_type@PAG@std@@YAPAGPAG@Z proc near
					; CODE XREF: std::_Uninit_move<ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)+27p
					; std::_Uninitialized_default_fill_n<ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>> &)+27p
		push	ebp
		mov	ebp, esp
		xor	eax, eax
		pop	ebp
		retn
??$_Val_type@PAG@std@@YAPAGPAG@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; float	* __cdecl std::_Val_type<float *>(float	*)
		public ??$_Val_type@PAM@std@@YAPAMPAM@Z
??$_Val_type@PAM@std@@YAPAMPAM@Z proc near
					; CODE XREF: std::_Uninit_move<float *,float *,std::_Wrap_alloc<std::allocator<float>>>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>>	&)+27p
					; std::_Uninitialized_default_fill_n<float *,uint,std::_Wrap_alloc<std::allocator<float>>>(float *,uint,std::_Wrap_alloc<std::allocator<float>>	&)+27p
		push	ebp
		mov	ebp, esp
		xor	eax, eax
		pop	ebp
		retn
??$_Val_type@PAM@std@@YAPAMPAM@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct DWRITE_GLYPH_OFFSET * __cdecl std::_Val_type<struct DWRITE_GLYPH_OFFSET *>(struct DWRITE_GLYPH_OFFSET *)
		public ??$_Val_type@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z
??$_Val_type@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z proc near
					; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)+27p
					; std::_Uninitialized_default_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>	&)+27p
		push	ebp
		mov	ebp, esp
		xor	eax, eax
		pop	ebp
		retn
??$_Val_type@PAUDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::addressof<char>(char &)
		public ??$addressof@D@std@@YAPADAAD@Z
??$addressof@D@std@@YAPADAAD@Z proc near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p
					; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p	...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$addressof@D@std@@YAPADAAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::construct<char *,char *	&>(void	*, int)
		public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: $LN19+4Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_4]
		push	edx		; int
		call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ;	std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::construct<char *,char * &>(void *, int)
		public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char	* &>(std::allocator<char> &,char * *,char * &)+17p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	4		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_1E4E
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		mov	edx, [ebp+var_18]
		mov	eax, [eax]
		mov	[edx], eax
		mov	ecx, [ebp+var_18]
		mov	[ebp+var_1C], ecx
		jmp	short loc_1E55
; ---------------------------------------------------------------------------

loc_1E4E:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+55j
		mov	[ebp+var_1C], 0

loc_1E55:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+70j
		mov	edx, [ebp+var_1C]
		mov	[ebp+var_14], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1E80h
; COMDAT (pick associative to section at 1DDC)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
					; DATA XREF: .xdata$x:00007A30o
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void	*, int)
		public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+23p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		mov	ecx, [ebp+arg_0]
		call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char	* &>(char * *,char * &)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ED4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ___construct_UDWRITE_GLYPH_OFFSET_____V___allocator_traits_V__allocator_UDWRITE_GLYPH_OFFSET___std___std__SAXAAV__allocator_UDWRITE_GLYPH_OFFSET___1_PAUDWRITE_GLYPH_OFFSET___Z(int, void	*)
		public ??$construct@UDWRITE_GLYPH_OFFSET@@$$$V@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z
??$construct@UDWRITE_GLYPH_OFFSET@@$$$V@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct(DWRITE_GLYPH_OFFSET *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax		; void *
		mov	ecx, [ebp+arg_0]
		call	?construct@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z ; std::allocator<DWRITE_GLYPH_OFFSET>::construct(DWRITE_GLYPH_OFFSET *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@UDWRITE_GLYPH_OFFSET@@$$$V@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(void *, int)
		public ??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z
??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z proc near
					; CODE XREF: std::_Uninit_move<DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET *,std::_Nonscalar_ptr_iterator_tag)+95p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	??$forward@UDWRITE_GLYPH_OFFSET@@@std@@YA$$QAUDWRITE_GLYPH_OFFSET@@AAU1@@Z ; std::forward<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_4]
		push	edx		; int
		call	??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@$$QAU3@@Z ;	std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(std::allocator<DWRITE_GLYPH_OFFSET> &,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(void *,	int)
		public ??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z
??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(std::allocator<DWRITE_GLYPH_OFFSET>	&,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+17p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	8		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_1FA0
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@UDWRITE_GLYPH_OFFSET@@@std@@YA$$QAUDWRITE_GLYPH_OFFSET@@AAU1@@Z ; std::forward<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET &)
		add	esp, 4
		mov	edx, [eax]
		mov	eax, [eax+4]
		mov	ecx, [ebp+var_18]
		mov	[ecx], edx
		mov	[ecx+4], eax
		mov	edx, [ebp+var_18]
		mov	[ebp+var_1C], edx
		jmp	short loc_1FA7
; ---------------------------------------------------------------------------

loc_1FA0:				; CODE XREF: std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+55j
		mov	[ebp+var_1C], 0

loc_1FA7:				; CODE XREF: std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+76j
		mov	eax, [ebp+var_1C]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1FD0h
; COMDAT (pick associative to section at 1F28)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z$0 proc near
					; DATA XREF: .xdata$x:00007AB4o
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z proc near
					; DATA XREF: std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1FFCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(int, void *, int)
		public ??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@$$QAU3@@Z
??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@$$QAU3@@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+23p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	??$forward@UDWRITE_GLYPH_OFFSET@@@std@@YA$$QAUDWRITE_GLYPH_OFFSET@@AAU1@@Z ; std::forward<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		mov	ecx, [ebp+arg_0]
		call	??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z ; std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@$$QAU3@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2024h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *,	int)
		public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Alloc_proxy(void)+49p
					; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Alloc_proxy(void)+49p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_4]
		push	edx		; int
		call	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2060h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
		public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy>	&,std::_Container_proxy	*,std::_Container_proxy	&&)+17p
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+49p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	8		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_20D8
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
		add	esp, 4
		mov	edx, [eax]
		mov	eax, [eax+4]
		mov	ecx, [ebp+var_18]
		mov	[ecx], edx
		mov	[ecx+4], eax
		mov	edx, [ebp+var_18]
		mov	[ebp+var_1C], edx
		jmp	short loc_20DF
; ---------------------------------------------------------------------------

loc_20D8:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+55j
		mov	[ebp+var_1C], 0

loc_20DF:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+76j
		mov	eax, [ebp+var_1C]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2108h
; COMDAT (pick associative to section at 2060)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
					; DATA XREF: .xdata$x:000079ACo
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc	near
					; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2134h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int,	void *,	int)
		public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+23p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		mov	ecx, [ebp+arg_0]
		call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 215Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+4Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		push	ecx
		call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 218Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char *	*)+Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
		public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ;	std::allocator<char>::destroy<char *>(char * *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>::destroy<struct DWRITE_GLYPH_OFFSET>(struct DWRITE_GLYPH_OFFSET *)
		public ??$destroy@UDWRITE_GLYPH_OFFSET@@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z
??$destroy@UDWRITE_GLYPH_OFFSET@@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z proc near
					; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
					; __catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		push	ecx
		call	??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z ; std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::destroy<DWRITE_GLYPH_OFFSET>(std::allocator<DWRITE_GLYPH_OFFSET> &,DWRITE_GLYPH_OFFSET *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@UDWRITE_GLYPH_OFFSET@@@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<struct	DWRITE_GLYPH_OFFSET>::destroy<struct DWRITE_GLYPH_OFFSET>(struct DWRITE_GLYPH_OFFSET *)
		public ??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z
??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::destroy<DWRITE_GLYPH_OFFSET>(std::allocator<DWRITE_GLYPH_OFFSET> &,DWRITE_GLYPH_OFFSET	*)+Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::allocator_traits<class std::allocator<struct	DWRITE_GLYPH_OFFSET>>::destroy<struct DWRITE_GLYPH_OFFSET>(class std::allocator<struct DWRITE_GLYPH_OFFSET> &, struct DWRITE_GLYPH_OFFSET *)
		public ??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z
??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::destroy<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z ; std::allocator<DWRITE_GLYPH_OFFSET>::destroy<DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$destroy@UDWRITE_GLYPH_OFFSET@@@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2214h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
		public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Free_proxy(void)+3Ep
					; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Free_proxy(void)+3Ep ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		push	ecx
		call	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy>	&,std::_Container_proxy	*)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2244h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<struct	std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
		public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy>	&,std::_Container_proxy	*)+Ap
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+3Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2258h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::allocator_traits<class std::allocator<struct	std::_Container_proxy>>::destroy<struct	std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
		public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc	near
					; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2270h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * & __cdecl std::forward<char * &>(char * &)
		public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+12p
					; std::allocator<char>::construct<char *,char *	&>(char	* *,char * &)+5Bp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2278h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct DWRITE_GLYPH_OFFSET &&	__cdecl	std::forward<struct DWRITE_GLYPH_OFFSET>(struct	DWRITE_GLYPH_OFFSET &)
		public ??$forward@UDWRITE_GLYPH_OFFSET@@@std@@YA$$QAUDWRITE_GLYPH_OFFSET@@AAU1@@Z
??$forward@UDWRITE_GLYPH_OFFSET@@@std@@YA$$QAUDWRITE_GLYPH_OFFSET@@AAU1@@Z proc	near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+12p
					; std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+5Bp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@UDWRITE_GLYPH_OFFSET@@@std@@YA$$QAUDWRITE_GLYPH_OFFSET@@AAU1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2280h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
		public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc	near
					; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+12p
					; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5Bp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2288h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct IDWriteFontFile> __cdecl getter_AddRefs<struct IDWriteFontFile>(class RefPtr<struct IDWriteFontFile>	&)
		public ??$getter_AddRefs@UIDWriteFontFile@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@AAV?$RefPtr@UIDWriteFontFile@@@@@Z
??$getter_AddRefs@UIDWriteFontFile@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@AAV?$RefPtr@UIDWriteFontFile@@@@@Z	proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+B8p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAE@AAV?$RefPtr@UIDWriteFontFile@@@@@Z ; RefPtrGetterAddRefs<IDWriteFontFile>::RefPtrGetterAddRefs<IDWriteFontFile>(RefPtr<IDWriteFontFile> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UIDWriteFontFile@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@AAV?$RefPtr@UIDWriteFontFile@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct IDWriteFontFileLoader> __cdecl getter_AddRefs<struct	IDWriteFontFileLoader>(class RefPtr<struct IDWriteFontFileLoader> &)
		public ??$getter_AddRefs@UIDWriteFontFileLoader@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z
??$getter_AddRefs@UIDWriteFontFileLoader@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+141p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAE@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z	; RefPtrGetterAddRefs<IDWriteFontFileLoader>::RefPtrGetterAddRefs<IDWriteFontFileLoader>(RefPtr<IDWriteFontFileLoader> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UIDWriteFontFileLoader@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct IDWriteFontFileStream> __cdecl getter_AddRefs<struct	IDWriteFontFileStream>(class RefPtr<struct IDWriteFontFileStream> &)
		public ??$getter_AddRefs@UIDWriteFontFileStream@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z
??$getter_AddRefs@UIDWriteFontFileStream@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+193p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAE@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z	; RefPtrGetterAddRefs<IDWriteFontFileStream>::RefPtrGetterAddRefs<IDWriteFontFileStream>(RefPtr<IDWriteFontFileStream> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UIDWriteFontFileStream@@@@YA?AV?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFile>::RefPtr<struct IDWriteFontFile>(void)
		public ??0?$RefPtr@UIDWriteFontFile@@@@QAE@XZ
??0?$RefPtr@UIDWriteFontFile@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+90p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UIDWriteFontFile@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFileLoader>::RefPtr<struct IDWriteFontFileLoader>(void)
		public ??0?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ
??0?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+11Fp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 231Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFileStream>::RefPtr<struct IDWriteFontFileStream>(void)
		public ??0?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ
??0?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+171p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 233Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDWriteFontFile>::RefPtrGetterAddRefs<struct IDWriteFontFile>(class RefPtr<struct IDWriteFontFile> &)
		public ??0?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAE@AAV?$RefPtr@UIDWriteFontFile@@@@@Z
??0?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAE@AAV?$RefPtr@UIDWriteFontFile@@@@@Z proc near
					; CODE XREF: getter_AddRefs<IDWriteFontFile>(RefPtr<IDWriteFontFile> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAE@AAV?$RefPtr@UIDWriteFontFile@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 235Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDWriteFontFileLoader>::RefPtrGetterAddRefs<struct IDWriteFontFileLoader>(class	RefPtr<struct IDWriteFontFileLoader> &)
		public ??0?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAE@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z
??0?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAE@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z	proc near
					; CODE XREF: getter_AddRefs<IDWriteFontFileLoader>(RefPtr<IDWriteFontFileLoader> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAE@AAV?$RefPtr@UIDWriteFontFileLoader@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 237Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDWriteFontFileStream>::RefPtrGetterAddRefs<struct IDWriteFontFileStream>(class	RefPtr<struct IDWriteFontFileStream> &)
		public ??0?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAE@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z
??0?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAE@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z	proc near
					; CODE XREF: getter_AddRefs<IDWriteFontFileStream>(RefPtr<IDWriteFontFileStream> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAE@AAV?$RefPtr@UIDWriteFontFileStream@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 239Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, unsigned	short, int, unsigned short const *, unsigned short const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag,	unsigned short,	int, unsigned short const *, unsigned short const &, struct std::_Iterator_base12>(void)
		public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ
??0?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(ushort *,std::_Container_base12 const *)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Iterator_base12@std@@QAE@XZ	; std::_Iterator_base12::_Iterator_base12(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, float, int, float const *, float	const &, struct	std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, float, int, float const *,	float const &, struct std::_Iterator_base12>(void)
		public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ
??0?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(float *,std::_Container_base12 const	*)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Iterator_base12@std@@QAE@XZ	; std::_Iterator_base12::_Iterator_base12(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct DWRITE_GLYPH_OFFSET, int,	struct DWRITE_GLYPH_OFFSET const *, struct DWRITE_GLYPH_OFFSET const &,	struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct DWRITE_GLYPH_OFFSET,	int, struct DWRITE_GLYPH_OFFSET	const *, struct	DWRITE_GLYPH_OFFSET const &, struct std::_Iterator_base12>(void)
		public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,std::_Container_base12 const *)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Iterator_base12@std@@QAE@XZ	; std::_Iterator_base12::_Iterator_base12(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2414h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
		public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+42p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2480h
; COMDAT (pick associative to section at 2414)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
					; DATA XREF: .xdata$x:000073ECo
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
		public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+14h], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned	short, class std::allocator<unsigned short>>>::_Vector_alloc<0,	struct std::_Vec_base_types<unsigned short, class std::allocator<unsigned short>>>(class std::allocator<unsigned short>	const &)
		public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::vector<ushort,std::allocator<ushort>>(void)+23p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ;	std::_Vector_val<std::_Simple_types<ushort>>::_Vector_val<std::_Simple_types<ushort>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2558h
; COMDAT (pick associative to section at 24EC)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z$0 proc near
					; DATA XREF: .xdata$x:000076ECo
		mov	ecx, [ebp-10h]
		jmp	??1?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ;	std::_Vector_val<std::_Simple_types<ushort>>::~_Vector_val<std::_Simple_types<ushort>>(void)
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z proc near
					; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(std::allocator<ushort> const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 257Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<float, class std::allocator<float>>>::_Vector_alloc<0, struct std::_Vec_base_types<float, class std::allocator<float>>>(class std::allocator<float> const &)
		public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::vector<float,std::allocator<float>>(void)+23p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ ;	std::_Vector_val<std::_Simple_types<float>>::_Vector_val<std::_Simple_types<float>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 25E8h
; COMDAT (pick associative to section at 257C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z$0 proc near
					; DATA XREF: .xdata$x:0000758Co
		mov	ecx, [ebp-10h]
		jmp	??1?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ ;	std::_Vector_val<std::_Simple_types<float>>::~_Vector_val<std::_Simple_types<float>>(void)
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z proc near
					; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(std::allocator<float> const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 260Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>>::_Vector_alloc<0,	struct std::_Vec_base_types<struct DWRITE_GLYPH_OFFSET,	class std::allocator<struct DWRITE_GLYPH_OFFSET>>>(class std::allocator<struct DWRITE_GLYPH_OFFSET> const &)
		public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)+23p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2678h
; COMDAT (pick associative to section at 260C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00007820o
		mov	ecx, [ebp-10h]
		jmp	??1?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>::~_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>(void)
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z	proc near
					; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(std::allocator<DWRITE_GLYPH_OFFSET> const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 269Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned short>>>(int, struct std::_Container_base12 *)
		public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z	proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(ushort	*,std::_Container_base12 const *)+19p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const	*,ushort const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort	const *,ushort const &,std::_Iterator_base12>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	edx, [ebp+arg_4]
		push	edx		; struct std::_Container_base12	*
		mov	ecx, [ebp+var_10] ; this
		call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2714h
; COMDAT (pick associative to section at 269C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00007954o
		mov	ecx, [ebp-10h]
		jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const	*,ushort const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const *,ushort	const &,std::_Iterator_base12>(void)
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z proc near
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(ushort *,std::_Container_base12 const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2738h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(int, struct std::_Container_base12 *)
		public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z	proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>(float *,std::_Container_base12 const *)+19p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,float,int,float	const *,float const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base12>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	edx, [ebp+arg_4]
		push	edx		; struct std::_Container_base12	*
		mov	ecx, [ebp+var_10] ; this
		call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 27B0h
; COMDAT (pick associative to section at 2738)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z$0 proc near
					; DATA XREF: .xdata$x:000076C0o
		mov	ecx, [ebp-10h]
		jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,float,int,float	const *,float const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,float,int,float const *,float const	&,std::_Iterator_base12>(void)
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z proc near
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(float *,std::_Container_base12 const	*)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 27D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(int, struct std::_Container_base12 *)
		public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,std::_Container_base12	const *)+19p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DWRITE_GLYPH_OFFSET,int,DWRITE_GLYPH_OFFSET const *,DWRITE_GLYPH_OFFSET const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DWRITE_GLYPH_OFFSET,int,DWRITE_GLYPH_OFFSET const	*,DWRITE_GLYPH_OFFSET const &,std::_Iterator_base12>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		mov	edx, [ebp+arg_4]
		push	edx		; struct std::_Container_base12	*
		mov	ecx, [ebp+var_10] ; this
		call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 284Ch
; COMDAT (pick associative to section at 27D4)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00007980o
		mov	ecx, [ebp-10h]
		jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DWRITE_GLYPH_OFFSET,int,DWRITE_GLYPH_OFFSET const *,DWRITE_GLYPH_OFFSET const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DWRITE_GLYPH_OFFSET,int,DWRITE_GLYPH_OFFSET const *,DWRITE_GLYPH_OFFSET const &,std::_Iterator_base12>(void)
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z proc near
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,std::_Container_base12 const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2870h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned short>>>(int, struct	std::_Container_base12 *)
		public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::begin(void)+1Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; struct std::_Container_base12	*
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_4]
		call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z	; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(ushort *,std::_Container_base12 const	*)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>(int, struct std::_Container_base12 *)
		public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::begin(void)+1Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; struct std::_Container_base12	*
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_4]
		call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z	; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(float *,std::_Container_base12 const *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(int, struct std::_Container_base12 *)
		public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::begin(void)+1Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; struct std::_Container_base12	*
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_4]
		call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,std::_Container_base12 const *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 290Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned short>>::_Vector_val<struct std::_Simple_types<unsigned short>>(void)
		public ??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(std::allocator<ushort> const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+8], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+0Ch], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2960h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_val<struct std::_Simple_types<float>>::_Vector_val<struct std::_Simple_types<float>>(void)
		public ??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(std::allocator<float> const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+8], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+0Ch], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 29B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>(void)
		public ??0?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ
??0?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ proc	near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(std::allocator<DWRITE_GLYPH_OFFSET> const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+8], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+0Ch], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>>::_Wrap_alloc<class std::allocator<unsigned short>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@G@std@@QAE@XZ ; std::allocator<ushort>::allocator<ushort>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<float>>::_Wrap_alloc<class std::allocator<float>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@M@std@@QAE@XZ ; std::allocator<float>::allocator<float>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAE@XZ ; std::allocator<DWRITE_GLYPH_OFFSET>::allocator<DWRITE_GLYPH_OFFSET>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Alloc_proxy(void)+23p
					; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Alloc_proxy(void)+23p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<char>::allocator<char>(void)
		public ??0?$allocator@D@std@@QAE@XZ
??0?$allocator@D@std@@QAE@XZ proc near	; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+11p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+39p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@D@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<unsigned short>::allocator<unsigned	short>(void)
		public ??0?$allocator@G@std@@QAE@XZ
??0?$allocator@G@std@@QAE@XZ proc near	; CODE XREF: std::_Wrap_alloc<std::allocator<ushort>>::_Wrap_alloc<std::allocator<ushort>>(void)+11p
					; std::vector<ushort,std::allocator<ushort>>::vector<ushort,std::allocator<ushort>>(void)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@G@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B00h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<float>::allocator<float>(void)
		public ??0?$allocator@M@std@@QAE@XZ
??0?$allocator@M@std@@QAE@XZ proc near	; CODE XREF: std::_Wrap_alloc<std::allocator<float>>::_Wrap_alloc<std::allocator<float>>(void)+11p
					; std::vector<float,std::allocator<float>>::vector<float,std::allocator<float>>(void)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@M@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<struct DWRITE_GLYPH_OFFSET>::allocator<struct DWRITE_GLYPH_OFFSET>(void)
		public ??0?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAE@XZ
??0?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>(void)+11p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
		public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc	near
					; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+11p
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B48h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; CODE XREF: std::_Generic_error_category::message(int)+57p
					; std::_Iostream_error_category::message(int)+2Cp ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	eax, [ebp+Str]
		push	eax		; Str
		mov	ecx, [ebp+var_10]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2BD4h
; COMDAT (pick associative to section at 2B48)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
					; DATA XREF: .xdata$x:00007418o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::vector<unsigned	short, class std::allocator<unsigned short>>(void)
		public ??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+3Ep

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_8+3]
		call	??0?$allocator@G@std@@QAE@XZ ; std::allocator<ushort>::allocator<ushort>(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(std::allocator<ushort> const &)
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::vector<float,	class std::allocator<float>>::vector<float, class std::allocator<float>>(void)
		public ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+4Dp

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_8+3]
		call	??0?$allocator@M@std@@QAE@XZ ; std::allocator<float>::allocator<float>(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(std::allocator<float> const &)
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::vector<struct DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>(void)
		public ??0?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ
??0?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+59p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_8+3]
		call	??0?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAE@XZ ; std::allocator<DWRITE_GLYPH_OFFSET>::allocator<DWRITE_GLYPH_OFFSET>(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(std::allocator<DWRITE_GLYPH_OFFSET> const &)
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
		public ??0_Container_proxy@std@@QAE@XZ
??0_Container_proxy@std@@QAE@XZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+3Ap
					; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Alloc_proxy(void)+3Ap ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0_Container_proxy@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
		public ??0_Generic_error_category@std@@QAE@XZ
??0_Generic_error_category@std@@QAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+11p
					; std::_System_error_category::_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0error_category@std@@QAE@XZ ;	std::error_category::error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Generic_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D04h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??0_Iostream_error_category@std@@QAE@XZ
??0_Iostream_error_category@std@@QAE@XZ	proc near
					; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Iostream_error_category@std@@6B@ ;	const std::_Iostream_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Iostream_error_category@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
		public ??0_Iterator_base12@std@@QAE@XZ
??0_Iterator_base12@std@@QAE@XZ	proc near
					; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const *,ushort	const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const *,ushort const &,std::_Iterator_base12>(void)+11p
					; std::_Iterator012<std::random_access_iterator_tag,float,int,float const *,float const	&,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base12>(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0_Iterator_base12@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D5Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
		public ??0_System_error_category@std@@QAE@XZ
??0_System_error_category@std@@QAE@XZ proc near
					; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_System_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
		public ??0error_category@std@@QAE@XZ
??0error_category@std@@QAE@XZ proc near	; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0error_category@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct	std::error_category *)
		public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+36p
					; std::_System_error_category::default_error_condition(int)+4Fp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFile>::~RefPtr<struct IDWriteFontFile>(void)
		public ??1?$RefPtr@UIDWriteFontFile@@@@QAE@XZ
??1?$RefPtr@UIDWriteFontFile@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+230p
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+334p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_2DF8
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UIDWriteFontFile@@@?$RefPtr@UIDWriteFontFile@@@@SAXPAUIDWriteFontFile@@@Z ; RefPtr<IDWriteFontFile>::AddRefTraits<IDWriteFontFile>::Release(IDWriteFontFile *)
		add	esp, 4

loc_2DF8:				; CODE XREF: RefPtr<IDWriteFontFile>::~RefPtr<IDWriteFontFile>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UIDWriteFontFile@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFileLoader>::~RefPtr<struct IDWriteFontFileLoader>(void)
		public ??1?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ
??1?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+221p
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+325p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_2E2C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UIDWriteFontFileLoader@@@?$RefPtr@UIDWriteFontFileLoader@@@@SAXPAUIDWriteFontFileLoader@@@Z ; RefPtr<IDWriteFontFileLoader>::AddRefTraits<IDWriteFontFileLoader>::Release(IDWriteFontFileLoader	*)
		add	esp, 4

loc_2E2C:				; CODE XREF: RefPtr<IDWriteFontFileLoader>::~RefPtr<IDWriteFontFileLoader>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UIDWriteFontFileLoader@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFileStream>::~RefPtr<struct IDWriteFontFileStream>(void)
		public ??1?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ
??1?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+215p
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+319p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_2E60
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UIDWriteFontFileStream@@@?$RefPtr@UIDWriteFontFileStream@@@@SAXPAUIDWriteFontFileStream@@@Z ; RefPtr<IDWriteFontFileStream>::AddRefTraits<IDWriteFontFileStream>::Release(IDWriteFontFileStream	*)
		add	esp, 4

loc_2E60:				; CODE XREF: RefPtr<IDWriteFontFileStream>::~RefPtr<IDWriteFontFileStream>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UIDWriteFontFileStream@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<class mozilla::gfx::PathBuilder>::~RefPtr<class mozilla::gfx::PathBuilder>(void)
		public ??1?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@XZ
??1?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+13Ep
					; __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$2+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_2E94
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@SAXPAVPathBuilder@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::PathBuilder>::AddRefTraits<mozilla::gfx::PathBuilder>::Release(mozilla::gfx::PathBuilder *)
		add	esp, 4

loc_2E94:				; CODE XREF: RefPtr<mozilla::gfx::PathBuilder>::~RefPtr<mozilla::gfx::PathBuilder>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@VPathBuilder@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, unsigned	short, int, unsigned short const *, unsigned short const &, struct std::_Iterator_base12>::~_Iterator012<struct	std::random_access_iterator_tag, unsigned short, int, unsigned short const *, unsigned short const &, struct std::_Iterator_base12>(void)
		public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ
??1?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z$0+3j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iterator_base12@std@@QAE@XZ	; std::_Iterator_base12::~_Iterator_base12(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, float, int, float const *, float	const &, struct	std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, float, int, float	const *, float const &,	struct std::_Iterator_base12>(void)
		public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ
??1?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z$0+3j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iterator_base12@std@@QAE@XZ	; std::_Iterator_base12::~_Iterator_base12(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct DWRITE_GLYPH_OFFSET, int,	struct DWRITE_GLYPH_OFFSET const *, struct DWRITE_GLYPH_OFFSET const &,	struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct DWRITE_GLYPH_OFFSET, int, struct DWRITE_GLYPH_OFFSET const *, struct DWRITE_GLYPH_OFFSET const &, struct std::_Iterator_base12>(void)
		public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z$0+3j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iterator_base12@std@@QAE@XZ	; std::_Iterator_base12::~_Iterator_base12(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F10h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::~_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>(void)
		public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
		public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F6Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned	short, class std::allocator<unsigned short>>>::~_Vector_alloc<0, struct	std::_Vec_base_types<unsigned short, class std::allocator<unsigned short>>>(void)
		public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::~vector<ushort,std::allocator<ushort>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ;	std::_Vector_val<std::_Simple_types<ushort>>::~_Vector_val<std::_Simple_types<ushort>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<float, class std::allocator<float>>>::~_Vector_alloc<0, struct std::_Vec_base_types<float, class	std::allocator<float>>>(void)
		public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::~vector<float,std::allocator<float>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ ;	std::_Vector_val<std::_Simple_types<float>>::~_Vector_val<std::_Simple_types<float>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>>::~_Vector_alloc<0, struct	std::_Vec_base_types<struct DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>>(void)
		public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::~vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ ;	std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>::~_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FF0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned short>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned short>>>(void)
		public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@GHPBGABGU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const	*,ushort const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const *,ushort	const &,std::_Iterator_base12>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3014h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>(void)
		public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@MHPBMABMU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,float,int,float	const *,float const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,float,int,float const *,float const	&,std::_Iterator_base12>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3038h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>>(void)
		public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ proc	near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UDWRITE_GLYPH_OFFSET@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DWRITE_GLYPH_OFFSET,int,DWRITE_GLYPH_OFFSET const *,DWRITE_GLYPH_OFFSET const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DWRITE_GLYPH_OFFSET,int,DWRITE_GLYPH_OFFSET const *,DWRITE_GLYPH_OFFSET const &,std::_Iterator_base12>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 305Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned short>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned short>>>(void)
		public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ	proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::front(void)+73p
					; __unwindfunclet$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ ;	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3080h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>(void)
		public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ	proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::front(void)+73p
					; __unwindfunclet$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ ;	std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>>(void)
		public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::front(void)+73p
					; __unwindfunclet$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned short>>::~_Vector_val<struct std::_Simple_types<unsigned short>>(void)
		public ??1?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ
??1?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z$0+3j
					; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::~_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_val<struct std::_Simple_types<float>>::~_Vector_val<struct std::_Simple_types<float>>(void)
		public ??1?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ
??1?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z$0+3j
					; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::~_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3128h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>::~_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>(void)
		public ??1?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ
??1?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ proc	near
					; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z$0+3j
					; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::~_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3158h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::Path>::~already_AddRefed<class mozilla::gfx::Path>(void)
		public ??1?$already_AddRefed@VPath@gfx@mozilla@@@@QAE@XZ
??1?$already_AddRefed@VPath@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$0+13j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_3166:				; CODE XREF: already_AddRefed<mozilla::gfx::Path>::~already_AddRefed<mozilla::gfx::Path>(void)+10j
		xor	eax, eax
		jnz	short loc_3166
		mov	esp, ebp
		pop	ebp
		retn
??1?$already_AddRefed@VPath@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3170h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::PathBuilder>::~already_AddRefed<class	mozilla::gfx::PathBuilder>(void)
		public ??1?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAE@XZ
??1?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+E4p
					; __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$1+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_317E:				; CODE XREF: already_AddRefed<mozilla::gfx::PathBuilder>::~already_AddRefed<mozilla::gfx::PathBuilder>(void)+10j
		xor	eax, eax
		jnz	short loc_317E
		mov	esp, ebp
		pop	ebp
		retn
??1?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3188h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::~vector<unsigned short,	class std::allocator<unsigned short>>(void)
		public ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+1B2p
					; __unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<ushort,std::allocator<ushort>>::_Tidy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::~_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 31B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::vector<float,	class std::allocator<float>>::~vector<float, class std::allocator<float>>(void)
		public ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+1A3p
					; __unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$1+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float>>::_Tidy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::~_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 31E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::~vector<struct DWRITE_GLYPH_OFFSET, class std::allocator<struct	DWRITE_GLYPH_OFFSET>>(void)
		public ??1?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ
??1?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+197p
					; __unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$2+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Tidy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::~_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 320Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category	*__hidden this)
		public ??1_Generic_error_category@std@@UAE@XZ
??1_Generic_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+11p
					; std::_System_error_category::~_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Generic_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3230h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??1_Iostream_error_category@std@@UAE@XZ
??1_Iostream_error_category@std@@UAE@XZ	proc near
					; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Iostream_error_category@std@@UAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3254h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
		public ??1_Iterator_base12@std@@QAE@XZ
??1_Iterator_base12@std@@QAE@XZ	proc near
					; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,ushort,int,ushort const *,ushort	const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,ushort,int,ushort	const *,ushort const &,std::_Iterator_base12>(void)+11p
					; std::_Iterator012<std::random_access_iterator_tag,float,int,float const *,float const	&,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,float,int,float	const *,float const &,std::_Iterator_base12>(void)+11p	...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	3		; int
		lea	ecx, [ebp+var_C] ; this
		call	dword ptr ds:__imp_??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4] ; this
		call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
		mov	esi, esp
		lea	ecx, [ebp+var_C] ; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Iterator_base12@std@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
$LN5		dd 1			; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Do
		dd offset $LN4
$LN4		dd 0FFFFFFF4h, 4	; DATA XREF: .text$mn:000032C4o
		dd offset $LN3		; "_Lock"
$LN3		db '_Lock',0            ; DATA XREF: .text$mn:000032D0o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 32DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
		public ??1_System_error_category@std@@UAE@XZ
??1_System_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_System_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3300h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
		public ??1error_category@std@@UAE@XZ
??1error_category@std@@UAE@XZ proc near	; CODE XREF: std::_Generic_error_category::~_Generic_error_category(void)+11p
					; std::error_category::`scalar deleting	destructor'(uint)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	esp, ebp
		pop	ebp
		retn
??1error_category@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 331Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int, void	*)
		public ??2@YAPAXIPAX@Z
??2@YAPAXIPAX@Z	proc near		; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+3Fp
					; std::allocator<DWRITE_GLYPH_OFFSET>::construct<DWRITE_GLYPH_OFFSET,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET &&)+3Fp ...

arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		pop	ebp
		retn
??2@YAPAXIPAX@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3324h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX0@Z
??3@YAXPAX0@Z	proc near		; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
					; __unwindfunclet$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z$0+8p ...
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
??3@YAXPAX0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 332Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::error_category::operator==(class	std::error_category const &)const
		public ??8error_category@std@@QBE_NABV01@@Z
??8error_category@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Bp
					; std::error_category::equivalent(std::error_code const	&,int)+23p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_3354
		mov	[ebp+var_8], 1
		jmp	short loc_335B
; ---------------------------------------------------------------------------

loc_3354:				; CODE XREF: std::error_category::operator==(std::error_category const &)+1Dj
		mov	[ebp+var_8], 0

loc_335B:				; CODE XREF: std::error_category::operator==(std::error_category const &)+26j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_category@std@@QBE_NABV01@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3364h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::error_condition::operator==(std::error_condition *)
		public ??8error_condition@std@@QBE_NABV01@@Z
??8error_condition@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+43p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		push	eax
		mov	ecx, [ebp+var_4] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		mov	ecx, eax
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_33BA
		mov	ecx, [ebp+var_4] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		cmp	esi, eax
		jnz	short loc_33BA
		mov	[ebp+var_8], 1
		jmp	short loc_33C1
; ---------------------------------------------------------------------------

loc_33BA:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+35j
					; std::error_condition::operator==(std::error_condition	const &)+4Bj
		mov	[ebp+var_8], 0

loc_33C1:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+54j
		mov	al, byte ptr [ebp+var_8]
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_condition@std@@QBE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned short & __thiscall std::vector<unsigned short, class	std::allocator<unsigned	short>>::operator[](unsigned int)
		public ??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+D9p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		cmp	eax, [ebp+arg_0]
		ja	loc_347E
		mov	esi, esp
		push	4B1h		; unsigned int
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard	C++ Libraries Out of Range"
		test	eax, eax
		jz	short loc_3426
		xor	ecx, ecx
		jnz	short loc_3456

loc_3426:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+48j
		mov	esi, esp
		push	offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	4B2h
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_3456
		int	3		; Trap to Debugger

loc_3456:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+4Cj
					; std::vector<ushort,std::allocator<ushort>>::operator[](uint)+7Bj
		mov	esi, esp
		push	0
		push	4B2h
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1JO@FGONLMHN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::vector<unsigned short,class std::a"...
		push	offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_347E:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+1Aj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		lea	eax, [ecx+edx*2]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 349Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct DWRITE_GLYPH_OFFSET & __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::operator[](unsigned int)
		public ??A?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@I@Z
??A?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@I@Z	proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+F5p
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer const &,ID2D1GeometrySink *)+122p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		cmp	eax, [ebp+arg_0]
		ja	loc_3542
		mov	esi, esp
		push	4B1h		; unsigned int
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard	C++ Libraries Out of Range"
		test	eax, eax
		jz	short loc_34EA
		xor	ecx, ecx
		jnz	short loc_351A

loc_34EA:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+48j
		mov	esi, esp
		push	offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	4B2h
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_351A
		int	3		; Trap to Debugger

loc_351A:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+4Cj
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+7Bj
		mov	esi, esp
		push	0
		push	4B2h
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1MO@LBFDOFFK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAD?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAG?$AAL?$AAY?$AAP?$AAH?$AA_@ ; "std::vector<struct	DWRITE_GLYPH_OFFSET,"...
		push	offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3542:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+1Aj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		lea	eax, [ecx+edx*8]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@I@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3560h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1GeometrySink>::operator	struct ID2D1GeometrySink *(void)const
		public ??B?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ
??B?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ proc near
					; CODE XREF: mozilla::gfx::PathBuilderD2D::GetSink(void)+14p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ	; RefPtr<ID2D1GeometrySink>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3584h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDWriteFontFace>::operator struct IDWriteFontFace *(void)const
		public ??B?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ
??B?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetDefaultAAMode(void)+68p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDWriteFontFile>::operator struct IDWriteFontFile * *(void)
		public ??B?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ
??B?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+C2p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ ; RefPtr<IDWriteFontFile>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDWriteFontFileLoader>::operator struct	IDWriteFontFileLoader *	*(void)
		public ??B?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ
??B?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+14Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ ;	RefPtr<IDWriteFontFileLoader>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDWriteFontFileStream>::operator struct	IDWriteFontFileStream *	*(void)
		public ??B?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ
??B?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+19Dp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ ;	RefPtr<IDWriteFontFileStream>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3620h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFace * __thiscall RefPtr<struct IDWriteFontFace>::operator->(void)const
		public ??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ
??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+139p
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+4Ep ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_362E:				; CODE XREF: RefPtr<IDWriteFontFace>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_362E
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ ; RefPtr<IDWriteFontFace>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3648h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFile * __thiscall RefPtr<struct IDWriteFontFile>::operator->(void)const
		public ??C?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ
??C?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+ECp
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+12Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_3656:				; CODE XREF: RefPtr<IDWriteFontFile>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_3656
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ ; RefPtr<IDWriteFontFile>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3670h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFileLoader * __thiscall RefPtr<struct IDWriteFontFileLoader>::operator->(void)const
		public ??C?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ
??C?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+17Dp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_367E:				; CODE XREF: RefPtr<IDWriteFontFileLoader>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_367E
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ	; RefPtr<IDWriteFontFileLoader>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3698h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFileStream * __thiscall RefPtr<struct IDWriteFontFileStream>::operator->(void)const
		public ??C?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ
??C?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+1CBp
					; mozilla::gfx::ScaledFontDWrite::GetFontFileData(void (*)(uchar const *,uint,uint,float,void *),void *)+249p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_36A6:				; CODE XREF: RefPtr<IDWriteFontFileStream>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_36A6
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ	; RefPtr<IDWriteFontFileStream>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::PathBuilder * __thiscall RefPtr<class mozilla::gfx::PathBuilder>::operator->(void)const
		public ??C?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ
??C?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+10Cp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_36CE:				; CODE XREF: RefPtr<mozilla::gfx::PathBuilder>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_36CE
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ ; RefPtr<mozilla::gfx::PathBuilder>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned short const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned short>>>::operator*(void)const
		public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ	proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		test	eax, eax
		jz	short loc_3732
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+8], 0
		jz	short loc_3732
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		cmp	edx, [eax+4]
		jb	short loc_3732
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		mov	ecx, [ebp+var_4]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		ja	short loc_37AF

loc_3732:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+19j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+22j ...
		mov	esi, esp
		push	48h ; 'H'       ; unsigned int
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard	C++ Libraries Out of Range"
		test	eax, eax
		jz	short loc_375D
		xor	ecx, ecx
		jnz	short loc_378A

loc_375D:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+6Fj
		mov	esi, esp
		push	offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	49h ; 'I'
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_378A
		int	3		; Trap to Debugger

loc_378A:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+73j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+9Fj
		mov	esi, esp
		push	0
		push	49h ; 'I'
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1NK@FKBBKPEM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
		push	offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_37AF:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+48j
		mov	eax, [ebp+var_4]
		mov	eax, [eax+8]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 37C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: float	const &	__thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>::operator*(void)const
		public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEABMXZ
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEABMXZ	proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		test	eax, eax
		jz	short loc_380E
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+8], 0
		jz	short loc_380E
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		cmp	edx, [eax+4]
		jb	short loc_380E
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		mov	ecx, [ebp+var_4]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		ja	short loc_388B

loc_380E:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+19j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+22j ...
		mov	esi, esp
		push	48h ; 'H'       ; unsigned int
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard	C++ Libraries Out of Range"
		test	eax, eax
		jz	short loc_3839
		xor	ecx, ecx
		jnz	short loc_3866

loc_3839:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+6Fj
		mov	esi, esp
		push	offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	49h ; 'I'
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_3866
		int	3		; Trap to Debugger

loc_3866:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+73j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+9Fj
		mov	esi, esp
		push	0
		push	49h ; 'I'
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1MI@FEBILKEM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
		push	offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_388B:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+48j
		mov	eax, [ebp+var_4]
		mov	eax, [eax+8]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEABMXZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct DWRITE_GLYPH_OFFSET const & __thiscall	std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>>::operator*(void)const
		public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEABUDWRITE_GLYPH_OFFSET@@XZ
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEABUDWRITE_GLYPH_OFFSET@@XZ proc near
					; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		test	eax, eax
		jz	short loc_38EA
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+8], 0
		jz	short loc_38EA
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		cmp	edx, [eax+4]
		jb	short loc_38EA
		mov	ecx, [ebp+var_4] ; this
		call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
		mov	ecx, [ebp+var_4]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		ja	short loc_3967

loc_38EA:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+19j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+22j ...
		mov	esi, esp
		push	48h ; 'H'       ; unsigned int
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard	C++ Libraries Out of Range"
		test	eax, eax
		jz	short loc_3915
		xor	ecx, ecx
		jnz	short loc_3942

loc_3915:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+6Fj
		mov	esi, esp
		push	offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	49h ; 'I'
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_3942
		int	3		; Trap to Debugger

loc_3942:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+73j
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+9Fj
		mov	esi, esp
		push	0
		push	49h ; 'I'
		push	offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1PC@GDILINHJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
		push	offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3967:				; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+48j
		mov	eax, [ebp+var_4]
		mov	eax, [eax+8]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEABUDWRITE_GLYPH_OFFSET@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 397Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned short & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned short>>>::operator*(void)const
		public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::front(void)+61p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEABGXZ	; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: float	& __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>::operator*(void)const
		public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEAAMXZ
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEAAMXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::front(void)+61p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEABMXZ	; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEAAMXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct DWRITE_GLYPH_OFFSET & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct	DWRITE_GLYPH_OFFSET>>>::operator*(void)const
		public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEAAUDWRITE_GLYPH_OFFSET@@XZ
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEAAUDWRITE_GLYPH_OFFSET@@XZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::front(void)+61p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEABUDWRITE_GLYPH_OFFSET@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEAAUDWRITE_GLYPH_OFFSET@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Generic_error_category@std@@UAEPAXI@Z
??_G_Generic_error_category@std@@UAEPAXI@Z proc	near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3A12
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_3A12:				; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Generic_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Iostream_error_category@std@@UAEPAXI@Z
??_G_Iostream_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3A52
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_3A52:				; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Iostream_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_System_error_category@std@@UAEPAXI@Z
??_G_System_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3A92
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_3A92:				; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_System_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3AA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
		public ??_Gerror_category@std@@UAEPAXI@Z
??_Gerror_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3AD2
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_3AD2:				; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_Gerror_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3AE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		push	offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3B0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category(void)
		push	offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3B30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??0_System_error_category@std@@QAE@XZ ;	std::_System_error_category::_System_error_category(void)
		push	offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ	; void (__cdecl	*)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3B54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3B78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3B9Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
??__Eallocator_arg@std@@YAXXZ proc near	; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Eallocator_arg@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 3BB0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
??__Epiecewise_construct@std@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Epiecewise_construct@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 3BC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 3BDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 3BF4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct IDWriteFontFile>::AddRefTraitsReleaseHelper(struct	IDWriteFontFile	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFile@@@@CAXPAUIDWriteFontFile@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFile@@@@CAXPAUIDWriteFontFile@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFile>::AddRefTraits<IDWriteFontFile>::Release(IDWriteFontFile *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFile@@@@CAXPAUIDWriteFontFile@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct IDWriteFontFileLoader>::AddRefTraitsReleaseHelper(struct IDWriteFontFileLoader *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileLoader@@@@CAXPAUIDWriteFontFileLoader@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileLoader@@@@CAXPAUIDWriteFontFileLoader@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFileLoader>::AddRefTraits<IDWriteFontFileLoader>::Release(IDWriteFontFileLoader *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileLoader@@@@CAXPAUIDWriteFontFileLoader@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C5Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct IDWriteFontFileStream>::AddRefTraitsReleaseHelper(struct IDWriteFontFileStream *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileStream@@@@CAXPAUIDWriteFontFileStream@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileStream@@@@CAXPAUIDWriteFontFileStream@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFileStream>::AddRefTraits<IDWriteFontFileStream>::Release(IDWriteFontFileStream *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileStream@@@@CAXPAUIDWriteFontFileStream@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::PathBuilder>::AddRefTraitsReleaseHelper(class	mozilla::gfx::PathBuilder *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@VPathBuilder@gfx@mozilla@@@@CAXPAVPathBuilder@gfx@mozilla@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@VPathBuilder@gfx@mozilla@@@@CAXPAVPathBuilder@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::PathBuilder>::AddRefTraits<mozilla::gfx::PathBuilder>::Release(mozilla::gfx::PathBuilder *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?Release@?$RefCounted@VPathSink@gfx@mozilla@@$00@detail@mozilla@@QBEXXZ	; mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@VPathBuilder@gfx@mozilla@@@@CAXPAVPathBuilder@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C9Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct ID2D1GeometrySink *__thiscall mozilla::gfx::PathBuilderD2D::GetSink(mozilla::gfx::PathBuilderD2D *__hidden this)
		public ?GetSink@PathBuilderD2D@gfx@mozilla@@QAEPAUID2D1GeometrySink@@XZ
?GetSink@PathBuilderD2D@gfx@mozilla@@QAEPAUID2D1GeometrySink@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+F7p
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)+47p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		add	ecx, 8
		call	??B?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ ;	RefPtr<ID2D1GeometrySink>::operator ID2D1GeometrySink *(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetSink@PathBuilderD2D@gfx@mozilla@@QAEPAUID2D1GeometrySink@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct IDWriteFontFile>::AddRefTraits<struct IDWriteFontFile>::Release(struct IDWriteFontFile *)
		public ?Release@?$AddRefTraits@UIDWriteFontFile@@@?$RefPtr@UIDWriteFontFile@@@@SAXPAUIDWriteFontFile@@@Z
?Release@?$AddRefTraits@UIDWriteFontFile@@@?$RefPtr@UIDWriteFontFile@@@@SAXPAUIDWriteFontFile@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFile>::~RefPtr<IDWriteFontFile>(void)+1Cp
					; RefPtr<IDWriteFontFile>::assign_assuming_AddRef(IDWriteFontFile *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFile@@@@CAXPAUIDWriteFontFile@@@Z ; RefPtr<IDWriteFontFile>::AddRefTraitsReleaseHelper(IDWriteFontFile *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UIDWriteFontFile@@@?$RefPtr@UIDWriteFontFile@@@@SAXPAUIDWriteFontFile@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct IDWriteFontFileLoader>::AddRefTraits<struct	IDWriteFontFileLoader>::Release(struct IDWriteFontFileLoader *)
		public ?Release@?$AddRefTraits@UIDWriteFontFileLoader@@@?$RefPtr@UIDWriteFontFileLoader@@@@SAXPAUIDWriteFontFileLoader@@@Z
?Release@?$AddRefTraits@UIDWriteFontFileLoader@@@?$RefPtr@UIDWriteFontFileLoader@@@@SAXPAUIDWriteFontFileLoader@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFileLoader>::~RefPtr<IDWriteFontFileLoader>(void)+1Cp
					; RefPtr<IDWriteFontFileLoader>::assign_assuming_AddRef(IDWriteFontFileLoader *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileLoader@@@@CAXPAUIDWriteFontFileLoader@@@Z ;	RefPtr<IDWriteFontFileLoader>::AddRefTraitsReleaseHelper(IDWriteFontFileLoader *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UIDWriteFontFileLoader@@@?$RefPtr@UIDWriteFontFileLoader@@@@SAXPAUIDWriteFontFileLoader@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CF4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct IDWriteFontFileStream>::AddRefTraits<struct	IDWriteFontFileStream>::Release(struct IDWriteFontFileStream *)
		public ?Release@?$AddRefTraits@UIDWriteFontFileStream@@@?$RefPtr@UIDWriteFontFileStream@@@@SAXPAUIDWriteFontFileStream@@@Z
?Release@?$AddRefTraits@UIDWriteFontFileStream@@@?$RefPtr@UIDWriteFontFileStream@@@@SAXPAUIDWriteFontFileStream@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFileStream>::~RefPtr<IDWriteFontFileStream>(void)+1Cp
					; RefPtr<IDWriteFontFileStream>::assign_assuming_AddRef(IDWriteFontFileStream *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UIDWriteFontFileStream@@@@CAXPAUIDWriteFontFileStream@@@Z ;	RefPtr<IDWriteFontFileStream>::AddRefTraitsReleaseHelper(IDWriteFontFileStream *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UIDWriteFontFileStream@@@?$RefPtr@UIDWriteFontFileStream@@@@SAXPAUIDWriteFontFileStream@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::PathBuilder>::AddRefTraits<class mozilla::gfx::PathBuilder>::Release(class mozilla::gfx::PathBuilder *)
		public ?Release@?$AddRefTraits@VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@SAXPAVPathBuilder@gfx@mozilla@@@Z
?Release@?$AddRefTraits@VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@SAXPAVPathBuilder@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::PathBuilder>::~RefPtr<mozilla::gfx::PathBuilder>(void)+1Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@VPathBuilder@gfx@mozilla@@@@CAXPAVPathBuilder@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::PathBuilder>::AddRefTraitsReleaseHelper(mozilla::gfx::PathBuilder *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@VPathBuilder@gfx@mozilla@@@?$RefPtr@VPathBuilder@gfx@mozilla@@@@SAXPAVPathBuilder@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::detail::RefCounted<class mozilla::gfx::PathSink, 1>::Release(void)const
		public ?Release@?$RefCounted@VPathSink@gfx@mozilla@@$00@detail@mozilla@@QBEXXZ
?Release@?$RefCounted@VPathSink@gfx@mozilla@@$00@detail@mozilla@@QBEXXZ	proc near
					; CODE XREF: RefPtr<mozilla::gfx::PathBuilder>::AddRefTraitsReleaseHelper(mozilla::gfx::PathBuilder *)+9p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx

loc_3D48:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)+26j
		xor	eax, eax
		jnz	short loc_3D48
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		sub	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	edx, [ebp+var_14]
		mov	[ebp+var_8], edx
		cmp	[ebp+var_8], 0
		jnz	short loc_3DB8
		cmp	[ebp+var_4], 0
		jz	short loc_3D7C
		mov	eax, [ebp+var_4]
		sub	eax, 4
		mov	[ebp+var_18], eax
		jmp	short loc_3D83
; ---------------------------------------------------------------------------

loc_3D7C:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)+4Bj
		mov	[ebp+var_18], 0

loc_3D83:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)+56j
		mov	ecx, [ebp+var_18]
		mov	[ebp+var_10], ecx
		mov	edx, [ebp+var_10]
		mov	[ebp+var_C], edx
		cmp	[ebp+var_C], 0
		jz	short loc_3DB1
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C], eax
		jmp	short loc_3DB8
; ---------------------------------------------------------------------------

loc_3DB1:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)+6Fj
		mov	[ebp+var_1C], 0

loc_3DB8:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)+45j
					; mozilla::detail::RefCounted<mozilla::gfx::PathSink,1>::Release(void)+8Bj
		pop	esi
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Release@?$RefCounted@VPathSink@gfx@mozilla@@$00@detail@mozilla@@QBEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFile * * __thiscall	RefPtr<struct IDWriteFontFile>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ
?StartAssignment@?$RefPtr@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<IDWriteFontFile>::operator IDWriteFontFile * *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFile@@@@AAEXPAUIDWriteFontFile@@@Z	; RefPtr<IDWriteFontFile>::assign_assuming_AddRef(IDWriteFontFile *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UIDWriteFontFile@@@@QAEPAPAUIDWriteFontFile@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DF4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFileLoader * * __thiscall RefPtr<struct IDWriteFontFileLoader>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ
?StartAssignment@?$RefPtr@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<IDWriteFontFileLoader>::operator IDWriteFontFileLoader	* *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileLoader@@@@AAEXPAUIDWriteFontFileLoader@@@Z ; RefPtr<IDWriteFontFileLoader>::assign_assuming_AddRef(IDWriteFontFileLoader *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UIDWriteFontFileLoader@@@@QAEPAPAUIDWriteFontFileLoader@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFileStream * * __thiscall RefPtr<struct IDWriteFontFileStream>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ
?StartAssignment@?$RefPtr@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<IDWriteFontFileStream>::operator IDWriteFontFileStream	* *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileStream@@@@AAEXPAUIDWriteFontFileStream@@@Z ; RefPtr<IDWriteFontFileStream>::assign_assuming_AddRef(IDWriteFontFileStream *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UIDWriteFontFileStream@@@@QAEPAPAUIDWriteFontFileStream@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
		public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
					; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(ushort *,std::_Container_base12 const *)+4Cp
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>(float *,std::_Container_base12 const *)+4Cp ...

var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 20h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_2C], eax
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_3ED6
		mov	esi, esp
		push	3		; int
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10] ; this
		call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_3F41
; ---------------------------------------------------------------------------

loc_3ED6:				; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const	*)+4Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	edx, [ebp+var_10]
		mov	eax, [edx]
		cmp	eax, [ebp+var_20]
		jz	short loc_3F41
		mov	esi, esp
		push	3		; int
		lea	ecx, [ebp+var_28] ; this
		call	dword ptr ds:__imp_??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_10] ; this
		call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
		mov	ecx, [ebp+var_10]
		mov	edx, [ebp+var_20]
		mov	eax, [edx+4]
		mov	[ecx+4], eax
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_10]
		mov	[ecx+4], edx
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_28] ; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3F41:				; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const	*)+88j
					; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+9Aj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 2Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN12		dd 2			; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const	*)+F9o
		dd offset $LN11
$LN11		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:00003F74o
		dd offset $LN8		; "_Lock"
		dd 0FFFFFFD8h, 4
		dd offset $LN9		; "_Lock"
$LN9		db '_Lock',0            ; DATA XREF: .text$mn:00003F8Co
$LN8		db '_Lock',0            ; DATA XREF: .text$mn:00003F80o
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3F9Ch
; COMDAT (pick associative to section at 3E4C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
					; DATA XREF: .xdata$x:000073B8o
		mov	esi, esp
		lea	ecx, [ebp-18h]	; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
					; DATA XREF: .xdata$x:000073C0o
		mov	esi, esp
		lea	ecx, [ebp-28h]	; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z	proc near
					; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const	*)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-28h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	; std::allocator<std::_Container_proxy>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_0		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4_0
$LN4_0		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00004058o
		dd offset $LN3_0	; "_Alproxy"
$LN3_0		db '_Alproxy',0         ; DATA XREF: .text$mn:00004064o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4074h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<unsigned short, class std::allocator<unsigned short>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(std::allocator<ushort> const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN5_5		dd 1			; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4_5
$LN4_5		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000040F0o
		dd offset $LN3_5	; "_Alproxy"
$LN3_5		db '_Alproxy',0         ; DATA XREF: .text$mn:000040FCo
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 410Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<float, class std::allocator<float>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(std::allocator<float> const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN5_2		dd 1			; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4_2
$LN4_2		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00004188o
		dd offset $LN3_2	; "_Alproxy"
$LN3_2		db '_Alproxy',0         ; DATA XREF: .text$mn:00004194o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<struct DWRITE_GLYPH_OFFSET,	class std::allocator<struct DWRITE_GLYPH_OFFSET>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(std::allocator<DWRITE_GLYPH_OFFSET> const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN5_8		dd 1			; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4_8
$LN4_8		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00004220o
		dd offset $LN3_8	; "_Alproxy"
$LN3_8		db '_Alproxy',0         ; DATA XREF: .text$mn:0000422Co
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 423Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12	*__hidden this)
		public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+A9p
					; std::vector<float,std::allocator<float>>::_Orphan_range(float	*,float	*)+A9p	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	esp, ebp
		pop	ebp
		retn
?_Clrcont@_Iterator_base12@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4258h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
		public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Cp

var_38		= byte ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_25		= byte ptr -25h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 0000439F SIZE 00000009 BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 28h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_38]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		or	eax, 0Fh
		mov	[ebp+var_18], eax
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+var_18]
		jnb	short loc_42B6
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_18], ecx
		jmp	short loc_4308
; ---------------------------------------------------------------------------

loc_42B6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+54j
		mov	eax, [ebp+var_18]
		xor	edx, edx
		mov	ecx, 3
		div	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+18h]
		shr	ecx, 1
		cmp	ecx, eax
		ja	short loc_42D0
		jmp	short loc_4308
; ---------------------------------------------------------------------------

loc_42D0:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+74j
		mov	edx, [ebp+var_14]
		mov	esi, [edx+18h]
		shr	esi, 1
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		sub	eax, esi
		mov	ecx, [ebp+var_14]
		cmp	[ecx+18h], eax
		ja	short loc_42FD
		mov	edx, [ebp+var_14]
		mov	eax, [edx+18h]
		shr	eax, 1
		mov	ecx, [ebp+var_14]
		add	eax, [ecx+18h]
		mov	[ebp+var_18], eax
		jmp	short loc_4308
; ---------------------------------------------------------------------------

loc_42FD:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+90j
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		mov	[ebp+var_18], eax

loc_4308:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5Cj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+76j ...
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_25]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_18]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_2C]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp+var_30], eax
		mov	ecx, [ebp+var_30]
		mov	[ebp+var_20], ecx
		jmp	short loc_439F
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp


; =============== S U B	R O U T	I N E =======================================


__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
					; DATA XREF: .xdata$x:0000744Co

; FUNCTION CHUNK AT 00004389 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00004399 SIZE 00000006 BYTES

		mov	[ebp-10h], esp
		mov	edx, [ebp+8]
		mov	[ebp-18h], edx
		mov	byte ptr [ebp-4], 2
		lea	eax, [ebp-26h]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp-34h], eax
		mov	ecx, [ebp-18h]
		add	ecx, 1
		push	ecx
		mov	ecx, [ebp-34h]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp-38h], eax
		mov	edx, [ebp-38h]
		mov	[ebp-20h], edx
		jmp	short loc_4389
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
					; DATA XREF: .xdata$x:0000745Co
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN17
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_4389:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+34j
		mov	dword ptr [ebp-4], 1
		jmp	short loc_4399
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

; =============== S U B	R O U T	I N E =======================================


$LN17		proc near		; DATA XREF: .text$mn:00004383o
		mov	dword ptr [ebp-4], 1
$LN17		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_4399:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+58j
		mov	eax, offset $LN19
		retn
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

loc_439F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+DEj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_43AF
; END OF FUNCTION CHUNK	FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

; =============== S U B	R O U T	I N E =======================================


$LN19		proc near		; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_4399o
		mov	dword ptr [ebp-4], 0FFFFFFFFh

loc_43AF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+14Ej
		cmp	dword ptr [ebp+0Ch], 0
		jbe	short loc_43CE
		mov	eax, [ebp+0Ch]
		push	eax		; Size
		mov	ecx, [ebp-14h]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Src
		mov	ecx, [ebp-20h]
		push	ecx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_43CE:				; CODE XREF: $LN19+Bj
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		lea	edx, [ebp-20h]
		push	edx		; int
		mov	eax, [ebp-14h]
		add	eax, 4
		push	eax		; void *
		lea	ecx, [ebp-27h]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char	*,char * &>(char * *,char * &)
		mov	edx, [ebp-14h]
		mov	eax, [ebp-18h]
		mov	[edx+18h], eax
		mov	ecx, [ebp+0Ch]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp-0Ch]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 38h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
$LN19		endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN23		dd 1			; DATA XREF: $LN19+69o
		dd offset $LN22
$LN22		dd 0FFFFFFE0h, 4	; DATA XREF: .text$mn:00004440o
		dd offset $LN20		; "_Ptr"
$LN20		db '_Ptr',0             ; DATA XREF: .text$mn:0000444Co
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4458h
; COMDAT (pick associative to section at 4258)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-3Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4474h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Destroy(unsigned short	*, unsigned short *)
		public ?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Pop_back_n(uint)+48p
					; std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+DCp ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		lea	ecx, [ebp+var_C+3]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &)
		add	esp, 0Ch
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_7		dd 1			; DATA XREF: std::vector<ushort,std::allocator<ushort>>::_Destroy(ushort *,ushort *)+3Eo
		dd offset $LN4_7
$LN4_7		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000044D4o
		dd offset $LN3_7	; "_Alval"
$LN3_7		db '_Alval',0           ; DATA XREF: .text$mn:000044E0o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 44ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<float,	class std::allocator<float>>::_Destroy(float *,	float *)
		public ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Pop_back_n(uint)+49p
					; std::vector<float,std::allocator<float>>::_Reallocate(uint)+DCp ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		lea	ecx, [ebp+var_C+3]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAM0AAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<float>>>(float	*,float	*,std::_Wrap_alloc<std::allocator<float>> &)
		add	esp, 0Ch
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_4		dd 1			; DATA XREF: std::vector<float,std::allocator<float>>::_Destroy(float *,float *)+3Eo
		dd offset $LN4_4
$LN4_4		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:0000454Co
		dd offset $LN3_4	; "_Alval"
$LN3_4		db '_Alval',0           ; DATA XREF: .text$mn:00004558o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4564h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Destroy(struct	DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *)
		public ?_Destroy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXPAUDWRITE_GLYPH_OFFSET@@0@Z
?_Destroy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXPAUDWRITE_GLYPH_OFFSET@@0@Z	proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Pop_back_n(uint)+49p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+DCp ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		lea	ecx, [ebp+var_C+3]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@0AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)
		add	esp, 0Ch
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Destroy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXPAUDWRITE_GLYPH_OFFSET@@0@Z	endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_10		dd 1			; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Destroy(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *)+3Eo
		dd offset $LN4_10
$LN4_10		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000045C4o
		dd offset $LN3_10	; "_Alval"
$LN3_10		db '_Alval',0           ; DATA XREF: .text$mn:000045D0o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 45DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
		public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc	near
					; CODE XREF: $LN19+60p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+98p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	byte ptr [ebp+var_8+3],	0
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		lea	edx, [ebp+var_8+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		push	eax
		call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
		add	esp, 8
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4628h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_1		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+60o
		dd offset $LN4_1
$LN4_1		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000046A8o
		dd offset $LN3_1	; "_Alproxy"
$LN3_1		db '_Alproxy',0         ; DATA XREF: .text$mn:000046B4o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<unsigned short, class std::allocator<unsigned short>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::~_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ;	std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_6		dd 1			; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Free_proxy(void)+60o
		dd offset $LN4_6
$LN4_6		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00004744o
		dd offset $LN3_6	; "_Alproxy"
$LN3_6		db '_Alproxy',0         ; DATA XREF: .text$mn:00004750o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4760h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<float, class std::allocator<float>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::~_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ;	std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_3		dd 1			; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Free_proxy(void)+60o
		dd offset $LN4_3
$LN4_3		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000047E0o
		dd offset $LN3_3	; "_Alproxy"
$LN3_3		db '_Alproxy',0         ; DATA XREF: .text$mn:000047ECo
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 47FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<struct DWRITE_GLYPH_OFFSET,	class std::allocator<struct DWRITE_GLYPH_OFFSET>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::~_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ;	std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z	; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_9		dd 1			; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Free_proxy(void)+60o
		dd offset $LN4_9
$LN4_9		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:0000487Co
		dd offset $LN3_9	; "_Alproxy"
$LN3_9		db '_Alproxy',0         ; DATA XREF: .text$mn:00004888o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4898h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
		public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BEp
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+14p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<unsigned	short>>	__thiscall std::_Vector_alloc<0, struct	std::_Vec_base_types<unsigned short, class std::allocator<unsigned short>>>::_Getal(void)const
		public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Umove<ushort *>(ushort *,ushort *,ushort *)+21p
					; std::vector<ushort,std::allocator<ushort>>::_Destroy(ushort *,ushort *)+21p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<ushort>>::_Wrap_alloc<std::allocator<ushort>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<float>> __thiscall std::_Vector_alloc<0,	struct std::_Vec_base_types<float, class std::allocator<float>>>::_Getal(void)const
		public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Umove<float *>(float *,float *,float *)+21p
					; std::vector<float,std::allocator<float>>::_Destroy(float *,float *)+21p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<float>>::_Wrap_alloc<std::allocator<float>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 491Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<struct DWRITE_GLYPH_OFFSET>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>>::_Getal(void)const
		public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Umove<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+21p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Destroy(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+21p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4948h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12	*__hidden this)
		public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
					; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+12p
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+27p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jnz	short loc_4970
		mov	[ebp+var_8], 0
		jmp	short loc_497A
; ---------------------------------------------------------------------------

loc_4970:				; CODE XREF: std::_Iterator_base12::_Getcont(void)+1Dj
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [edx]
		mov	[ebp+var_8], eax

loc_497A:				; CODE XREF: std::_Iterator_base12::_Getcont(void)+26j
		mov	eax, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4984h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
		public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+9Ap
					; std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+B3p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	esp, ebp
		pop	ebp
		retn
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 499Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
		public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+78p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+66p

var_C		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_49CF
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)

loc_49CF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+29j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_49EF
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
		jmp	short loc_4A39
; ---------------------------------------------------------------------------

loc_49EF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
		movzx	edx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_4A29
		cmp	[ebp+arg_0], 10h
		jnb	short loc_4A29
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+14h]
		jnb	short loc_4A10
		mov	edx, [ebp+arg_0]
		mov	[ebp+Size], edx
		jmp	short loc_4A19
; ---------------------------------------------------------------------------

loc_4A10:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+6Aj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		mov	[ebp+Size], ecx

loc_4A19:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+72j
		mov	edx, [ebp+Size]
		push	edx		; Size
		push	1		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		jmp	short loc_4A39
; ---------------------------------------------------------------------------

loc_4A29:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+59j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Fj
		cmp	[ebp+arg_0], 0
		jnz	short loc_4A39
		push	0
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_4A39:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+51j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Bj ...
		cmp	[ebp+arg_0], 0
		jbe	short loc_4A48
		mov	[ebp+var_C], 1
		jmp	short loc_4A4F
; ---------------------------------------------------------------------------

loc_4A48:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+A1j
		mov	[ebp+var_C], 0

loc_4A4F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+AAj
		mov	al, byte ptr [ebp+var_C]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A64h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: unsigned int __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Grow_to(unsigned int)const
		public ?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z
?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+4Cp

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::capacity(void)
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		call	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::max_size(void)
		mov	ecx, [ebp+var_8]
		shr	ecx, 1
		sub	eax, ecx
		cmp	eax, [ebp+var_8]
		jnb	short loc_4AAA
		mov	[ebp+var_C], 0
		jmp	short loc_4AB5
; ---------------------------------------------------------------------------

loc_4AAA:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Grow_to(uint)+3Bj
		mov	edx, [ebp+var_8]
		shr	edx, 1
		add	edx, [ebp+var_8]
		mov	[ebp+var_C], edx

loc_4AB5:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Grow_to(uint)+44j
		mov	eax, [ebp+var_C]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_8]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_4AC9
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], edx

loc_4AC9:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Grow_to(uint)+5Dj
		mov	eax, [ebp+var_8]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4ADCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: unsigned int __thiscall std::vector<float,	class std::allocator<float>>::_Grow_to(unsigned	int)const
		public ?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IBEII@Z
?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IBEII@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reserve(uint)+4Cp

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::capacity(void)
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		call	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::max_size(void)
		mov	ecx, [ebp+var_8]
		shr	ecx, 1
		sub	eax, ecx
		cmp	eax, [ebp+var_8]
		jnb	short loc_4B22
		mov	[ebp+var_C], 0
		jmp	short loc_4B2D
; ---------------------------------------------------------------------------

loc_4B22:				; CODE XREF: std::vector<float,std::allocator<float>>::_Grow_to(uint)+3Bj
		mov	edx, [ebp+var_8]
		shr	edx, 1
		add	edx, [ebp+var_8]
		mov	[ebp+var_C], edx

loc_4B2D:				; CODE XREF: std::vector<float,std::allocator<float>>::_Grow_to(uint)+44j
		mov	eax, [ebp+var_C]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_8]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_4B41
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], edx

loc_4B41:				; CODE XREF: std::vector<float,std::allocator<float>>::_Grow_to(uint)+5Dj
		mov	eax, [ebp+var_8]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IBEII@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: unsigned int __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Grow_to(unsigned int)const
		public ?_Grow_to@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEII@Z
?_Grow_to@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEII@Z	proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+4Cp

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::capacity(void)
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		call	?max_size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(void)
		mov	ecx, [ebp+var_8]
		shr	ecx, 1
		sub	eax, ecx
		cmp	eax, [ebp+var_8]
		jnb	short loc_4B9A
		mov	[ebp+var_C], 0
		jmp	short loc_4BA5
; ---------------------------------------------------------------------------

loc_4B9A:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Grow_to(uint)+3Bj
		mov	edx, [ebp+var_8]
		shr	edx, 1
		add	edx, [ebp+var_8]
		mov	[ebp+var_C], edx

loc_4BA5:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Grow_to(uint)+44j
		mov	eax, [ebp+var_C]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_8]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_4BB9
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], edx

loc_4BB9:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Grow_to(uint)+5Dj
		mov	eax, [ebp+var_8]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Grow_to@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEII@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4BCCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
		public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+31p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_4C00
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		cmp	[ebp+arg_0], eax
		jb	short loc_4C00
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+var_4]
		add	eax, [ecx+14h]
		cmp	eax, [ebp+arg_0]
		ja	short loc_4C06

loc_4C00:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+12j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+1Fj
		xor	al, al
		jmp	short loc_4C08
; ---------------------------------------------------------------------------
		jmp	short loc_4C08
; ---------------------------------------------------------------------------

loc_4C06:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+32j
		mov	al, 1

loc_4C08:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+36j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+38j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
					; CODE XREF: $LN19+14p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+2Bp ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_4C4C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_4C55
; ---------------------------------------------------------------------------

loc_4C4C:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_4C55:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+8Bp

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_4C9C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_4CA5
; ---------------------------------------------------------------------------

loc_4C9C:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_4CA5:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4CB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
		public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
					; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+32p
					; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+6Ap ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_4D3F
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		add	edx, 4
		mov	[ebp+var_8], edx

loc_4CE3:				; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+48j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 0
		jz	short loc_4D02
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		cmp	edx, [ebp+var_4]
		jz	short loc_4D02
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, 4
		mov	[ebp+var_8], ecx
		jmp	short loc_4CE3
; ---------------------------------------------------------------------------

loc_4D02:				; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+31j
					; std::_Iterator_base12::_Orphan_me(void)+3Bj
		mov	edx, [ebp+var_8]
		cmp	dword ptr [edx], 0
		jnz	short loc_4D2B
		mov	esi, esp
		push	0C9h ; ''      ; unsigned int
		push	offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ;	"C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4D2B:				; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+50j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		mov	[eax], edx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0

loc_4D3F:				; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+1Ej
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Orphan_range(unsigned short *,	unsigned short *)const
		public ?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z
?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Pop_back_n(uint)+35p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	esi, esp
		push	3		; int
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_10] ; this
		call	dword ptr ds:__imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_4E11

loc_4DC3:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *):loc_4E0Fj
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax], 0
		jz	short loc_4E11
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	eax, [edx+8]
		cmp	eax, [ebp+arg_0]
		jb	short loc_4DE5
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_4]
		cmp	eax, [edx+8]
		jnb	short loc_4DF4

loc_4DE5:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+86j
		mov	ecx, [ebp+var_20]
		mov	ecx, [ecx]	; this
		call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
		mov	[ebp+var_20], eax
		jmp	short loc_4E0F
; ---------------------------------------------------------------------------

loc_4DF4:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+93j
		mov	edx, [ebp+var_20]
		mov	ecx, [edx]	; this
		call	?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]	; this
		call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
		mov	ecx, [ebp+var_20]
		mov	edx, [eax]
		mov	[ecx], edx

loc_4E0F:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+A2j
		jmp	short loc_4DC3
; ---------------------------------------------------------------------------

loc_4E11:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+71j
					; std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+79j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN13_4		dd 1			; DATA XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+DEo
		dd offset $LN12_2
$LN12_2		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:00004E5Co
		dd offset $LN10_5	; "_Lock"
$LN10_5		db '_Lock',0            ; DATA XREF: .text$mn:00004E68o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4E74h
; COMDAT (pick associative to section at 4D50)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z$0	proc near
					; DATA XREF: .xdata$x:000077F4o
		mov	esi, esp
		lea	ecx, [ebp-18h]	; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z proc near
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4EA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<float,	class std::allocator<float>>::_Orphan_range(float *, float *)const
		public ?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Pop_back_n(uint)+36p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	esi, esp
		push	3		; int
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_10] ; this
		call	dword ptr ds:__imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_4F65

loc_4F17:				; CODE XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *):loc_4F63j
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax], 0
		jz	short loc_4F65
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	eax, [edx+8]
		cmp	eax, [ebp+arg_0]
		jb	short loc_4F39
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_4]
		cmp	eax, [edx+8]
		jnb	short loc_4F48

loc_4F39:				; CODE XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)+86j
		mov	ecx, [ebp+var_20]
		mov	ecx, [ecx]	; this
		call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
		mov	[ebp+var_20], eax
		jmp	short loc_4F63
; ---------------------------------------------------------------------------

loc_4F48:				; CODE XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)+93j
		mov	edx, [ebp+var_20]
		mov	ecx, [edx]	; this
		call	?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]	; this
		call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
		mov	ecx, [ebp+var_20]
		mov	edx, [eax]
		mov	[ecx], edx

loc_4F63:				; CODE XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)+A2j
		jmp	short loc_4F17
; ---------------------------------------------------------------------------

loc_4F65:				; CODE XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)+71j
					; std::vector<float,std::allocator<float>>::_Orphan_range(float	*,float	*)+79j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN13_1		dd 1			; DATA XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)+DEo
		dd offset $LN12_0
$LN12_0		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:00004FB0o
		dd offset $LN10_2	; "_Lock"
$LN10_2		db '_Lock',0            ; DATA XREF: .text$mn:00004FBCo
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4FC8h
; COMDAT (pick associative to section at 4EA4)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z$0	proc near
					; DATA XREF: .xdata$x:00007694o
		mov	esi, esp
		lea	ecx, [ebp-18h]	; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z proc near
					; DATA XREF: std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4FF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Orphan_range(struct DWRITE_GLYPH_OFFSET *, struct DWRITE_GLYPH_OFFSET *)const
		public ?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z
?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Pop_back_n(uint)+36p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	esi, esp
		push	3		; int
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	esi, esp
		mov	ecx, [ebp+var_10] ; this
		call	dword ptr ds:__imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_50B9

loc_506B:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *):loc_50B7j
		mov	eax, [ebp+var_20]
		cmp	dword ptr [eax], 0
		jz	short loc_50B9
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	eax, [edx+8]
		cmp	eax, [ebp+arg_0]
		jb	short loc_508D
		mov	ecx, [ebp+var_20]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_4]
		cmp	eax, [edx+8]
		jnb	short loc_509C

loc_508D:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+86j
		mov	ecx, [ebp+var_20]
		mov	ecx, [ecx]	; this
		call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
		mov	[ebp+var_20], eax
		jmp	short loc_50B7
; ---------------------------------------------------------------------------

loc_509C:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+93j
		mov	edx, [ebp+var_20]
		mov	ecx, [edx]	; this
		call	?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
		mov	eax, [ebp+var_20]
		mov	ecx, [eax]	; this
		call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
		mov	ecx, [ebp+var_20]
		mov	edx, [eax]
		mov	[ecx], edx

loc_50B7:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+A2j
		jmp	short loc_506B
; ---------------------------------------------------------------------------

loc_50B9:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+71j
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET	*)+79j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	esi, esp
		lea	ecx, [ebp+var_18] ; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN13_6		dd 1			; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+DEo
		dd offset $LN12_3
$LN12_3		dd 0FFFFFFE8h, 4	; DATA XREF: .text$mn:00005104o
		dd offset $LN10_7	; "_Lock"
$LN10_7		db '_Lock',0            ; DATA XREF: .text$mn:00005110o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 511Ch
; COMDAT (pick associative to section at 4FF8)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z$0 proc near
					; DATA XREF: .xdata$x:00007928o
		mov	esi, esp
		lea	ecx, [ebp-18h]	; this
		call	dword ptr ds:__imp_??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z proc near
					; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 514Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Pop_back_n(unsigned int)
		public ?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+5Cp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 1
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		sub	edx, eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z ;	std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<ushort,std::allocator<ushort>>::_Destroy(ushort *,ushort	*)
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 51B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::vector<float, class std::allocator<float>>::_Pop_back_n(unsigned	int)
		public ?_Pop_back_n@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
?_Pop_back_n@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+5Cp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 2
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		sub	edx, eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z ;	std::vector<float,std::allocator<float>>::_Orphan_range(float *,float *)
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float>>::_Destroy(float *,float *)
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Pop_back_n@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 521Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Pop_back_n(unsigned int)
		public ?_Pop_back_n@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
?_Pop_back_n@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z proc	near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+5Cp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		sub	edx, eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Orphan_range(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Destroy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXPAUDWRITE_GLYPH_OFFSET@@0@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Destroy(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Pop_back_n@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5284h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Reallocate(unsigned int)
		public ?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+55p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 0000532B SIZE 00000009 BYTES
; FUNCTION CHUNK AT 0000533B SIZE 000000AA BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_20+3]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		mov	ecx, eax
		call	?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z ; std::_Wrap_alloc<std::allocator<ushort>>::allocate(uint)
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		mov	edx, [ebp+var_18]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_14]
		call	??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z	; std::vector<ushort,std::allocator<ushort>>::_Umove<ushort *>(ushort *,ushort *,ushort	*)
		jmp	short loc_532B
?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z$0 proc	near
					; DATA XREF: .xdata$x:000077A4o
		mov	ecx, [ebp+8]
		push	ecx		; int
		mov	edx, [ebp-18h]
		push	edx		; void *
		lea	eax, [ebp-1Eh]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z ; std::_Wrap_alloc<std::allocator<ushort>>::deallocate(ushort *,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN8_3
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z

loc_532B:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+7Bj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_533B
; END OF FUNCTION CHUNK	FOR ?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z

; =============== S U B	R O U T	I N E =======================================


$LN8_3		proc near		; DATA XREF: .text$mn:00005325o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN8_3		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z

loc_533B:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+AEj
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		mov	[ebp+var_1C], eax
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+4], 0
		jz	short loc_538E
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<ushort,std::allocator<ushort>>::_Destroy(ushort *,ushort	*)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+4]
		sar	edx, 1
		push	edx		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		push	ecx		; void *
		lea	edx, [ebp+var_20+1]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z ; std::_Wrap_alloc<std::allocator<ushort>>::deallocate(ushort *,uint)

loc_538E:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+C9j
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+var_14]
		mov	[eax+0Ch], edx
		mov	ecx, [ebp+var_1C]
		mov	edx, [ebp+var_18]
		lea	eax, [edx+ecx*2]
		mov	ecx, [ebp+var_14]
		mov	[ecx+8], eax
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_18]
		mov	[edx+4], eax
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
; END OF FUNCTION CHUNK	FOR ?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 53E8h
; COMDAT (pick associative to section at 5284)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z proc near
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5404h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<float,	class std::allocator<float>>::_Reallocate(unsigned int)
		public ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reserve(uint)+55p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 000054AB SIZE 00000009 BYTES
; FUNCTION CHUNK AT 000054BB SIZE 000000AB BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_20+3]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		mov	ecx, eax
		call	?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEPAMI@Z ; std::_Wrap_alloc<std::allocator<float>>::allocate(uint)
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		mov	edx, [ebp+var_18]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_14]
		call	??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z	; std::vector<float,std::allocator<float>>::_Umove<float *>(float *,float *,float *)
		jmp	short loc_54AB
?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z$0 proc	near
					; DATA XREF: .xdata$x:00007644o
		mov	ecx, [ebp+8]
		push	ecx		; int
		mov	edx, [ebp-18h]
		push	edx		; void *
		lea	eax, [ebp-1Eh]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEXPAMI@Z ; std::_Wrap_alloc<std::allocator<float>>::deallocate(float *,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN8_1
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z

loc_54AB:				; CODE XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+7Bj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_54BB
; END OF FUNCTION CHUNK	FOR ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z

; =============== S U B	R O U T	I N E =======================================


$LN8_1		proc near		; DATA XREF: .text$mn:000054A5o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN8_1		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z

loc_54BB:				; CODE XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+AEj
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		mov	[ebp+var_1C], eax
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+4], 0
		jz	short loc_550F
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float>>::_Destroy(float *,float *)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+4]
		sar	edx, 2
		push	edx		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		push	ecx		; void *
		lea	edx, [ebp+var_20+1]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEXPAMI@Z ; std::_Wrap_alloc<std::allocator<float>>::deallocate(float *,uint)

loc_550F:				; CODE XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+C9j
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		lea	edx, [ecx+eax*4]
		mov	eax, [ebp+var_14]
		mov	[eax+0Ch], edx
		mov	ecx, [ebp+var_1C]
		mov	edx, [ebp+var_18]
		lea	eax, [edx+ecx*4]
		mov	ecx, [ebp+var_14]
		mov	[ecx+8], eax
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_18]
		mov	[edx+4], eax
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
; END OF FUNCTION CHUNK	FOR ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5568h
; COMDAT (pick associative to section at 5404)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z proc near
					; DATA XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5584h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Reallocate(unsigned int)
		public ?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z proc	near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+55p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 0000562B SIZE 00000009 BYTES
; FUNCTION CHUNK AT 0000563B SIZE 000000AB BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_20+3]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		mov	ecx, eax
		call	?allocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z ;	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::allocate(uint)
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		mov	edx, [ebp+var_18]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_14]
		call	??$_Umove@PAUDWRITE_GLYPH_OFFSET@@@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEPAUDWRITE_GLYPH_OFFSET@@PAU2@00@Z ;	std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Umove<DWRITE_GLYPH_OFFSET *>(DWRITE_GLYPH_OFFSET	*,DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		jmp	short loc_562B
?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z$0 proc near
					; DATA XREF: .xdata$x:000078D8o
		mov	ecx, [ebp+8]
		push	ecx		; int
		mov	edx, [ebp-18h]
		push	edx		; void *
		lea	eax, [ebp-1Eh]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z ; std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::deallocate(DWRITE_GLYPH_OFFSET *,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN8_4
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z

loc_562B:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+7Bj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_563B
; END OF FUNCTION CHUNK	FOR ?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z

; =============== S U B	R O U T	I N E =======================================


$LN8_4		proc near		; DATA XREF: .text$mn:00005625o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN8_4		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z

loc_563B:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+AEj
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		mov	[ebp+var_1C], eax
		mov	ecx, [ebp+var_14]
		cmp	dword ptr [ecx+4], 0
		jz	short loc_568F
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+4]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Destroy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXPAUDWRITE_GLYPH_OFFSET@@0@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Destroy(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+4]
		sar	edx, 3
		push	edx		; int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+4]
		push	ecx		; void *
		lea	edx, [ebp+var_20+1]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z ; std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::deallocate(DWRITE_GLYPH_OFFSET *,uint)

loc_568F:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+C9j
		mov	esi, esp
		mov	ecx, [ebp+var_14] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		lea	edx, [ecx+eax*8]
		mov	eax, [ebp+var_14]
		mov	[eax+0Ch], edx
		mov	ecx, [ebp+var_1C]
		mov	edx, [ebp+var_18]
		lea	eax, [edx+ecx*8]
		mov	ecx, [ebp+var_14]
		mov	[ecx+8], eax
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_18]
		mov	[edx+4], eax
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
; END OF FUNCTION CHUNK	FOR ?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 56E8h
; COMDAT (pick associative to section at 5584)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z proc near
					; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5704h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Reserve(unsigned int)
		public ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+94p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::_Unused_capacity(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_575E
		mov	ecx, [ebp+var_4]
		call	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::max_size(void)
		mov	esi, eax
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		sub	esi, eax
		cmp	esi, [ebp+arg_0]
		jnb	short loc_5741
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ ; std::vector<ushort,std::allocator<ushort>>::_Xlen(void)

loc_5741:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+33j
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		add	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z ;	std::vector<ushort,std::allocator<ushort>>::_Grow_to(uint)
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)

loc_575E:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+1Aj
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5770h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<float,	class std::allocator<float>>::_Reserve(unsigned	int)
		public ?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+94p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::_Unused_capacity(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_57CA
		mov	ecx, [ebp+var_4]
		call	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::max_size(void)
		mov	esi, eax
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		sub	esi, eax
		cmp	esi, [ebp+arg_0]
		jnb	short loc_57AD
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ ; std::vector<float,std::allocator<float>>::_Xlen(void)

loc_57AD:				; CODE XREF: std::vector<float,std::allocator<float>>::_Reserve(uint)+33j
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		add	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IBEII@Z ;	std::vector<float,std::allocator<float>>::_Grow_to(uint)
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z ; std::vector<float,std::allocator<float>>::_Reallocate(uint)

loc_57CA:				; CODE XREF: std::vector<float,std::allocator<float>>::_Reserve(uint)+1Aj
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 57DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Reserve(unsigned int)
		public ?_Reserve@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
?_Reserve@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z	proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+94p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Unused_capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Unused_capacity(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_5836
		mov	ecx, [ebp+var_4]
		call	?max_size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(void)
		mov	esi, eax
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		sub	esi, eax
		cmp	esi, [ebp+arg_0]
		jnb	short loc_5819
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Xlen(void)

loc_5819:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+33j
		mov	ecx, [ebp+var_4]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		add	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow_to@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEII@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Grow_to(uint)
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)

loc_5836:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+1Aj
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Reserve@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5848h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t	Size)
		public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+55p
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+7p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_5870
		jmp	short loc_58E3
; ---------------------------------------------------------------------------

loc_5870:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+24j
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+18h], 10h
		jb	short loc_58E3
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		add	ecx, 4
		push	ecx
		lea	edx, [ebp+var_C+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
		cmp	[ebp+Size], 0
		jbe	short loc_58C2
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		push	ecx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		push	eax		; Src
		mov	edx, [ebp+var_4]
		add	edx, 4
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_58C2:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+58j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		add	ecx, 1
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; void *
		lea	eax, [ebp+var_C+2]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)

loc_58E3:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+26j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+2Fj
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0Fh
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 590Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Tidy(void)
		public ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::~vector<ushort,std::allocator<ushort>>(void)+11p
					; __catch$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z$0+3p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+4], 0
		jz	short loc_599C
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<ushort,std::allocator<ushort>>::_Destroy(ushort *,ushort	*)
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+var_4]
		mov	ecx, [edx+0Ch]
		sub	ecx, [eax+4]
		sar	ecx, 1
		push	ecx		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		push	eax		; void *
		lea	ecx, [ebp+var_8+3]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z ; std::_Wrap_alloc<std::allocator<ushort>>::deallocate(ushort *,uint)
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+4], 0
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+0Ch], 0

loc_599C:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Tidy(void)+1Fj
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 59ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<float,	class std::allocator<float>>::_Tidy(void)
		public ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::~vector<float,std::allocator<float>>(void)+11p
					; __catch$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z$0+3p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+4], 0
		jz	short loc_5A3D
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float>>::_Destroy(float *,float *)
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+var_4]
		mov	ecx, [edx+0Ch]
		sub	ecx, [eax+4]
		sar	ecx, 2
		push	ecx		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		push	eax		; void *
		lea	ecx, [ebp+var_8+3]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEXPAMI@Z ; std::_Wrap_alloc<std::allocator<float>>::deallocate(float *,uint)
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+4], 0
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+0Ch], 0

loc_5A3D:				; CODE XREF: std::vector<float,std::allocator<float>>::_Tidy(void)+1Fj
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5A4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Tidy(void)
		public ?_Tidy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXXZ
?_Tidy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXXZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::~vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>(void)+11p
					; __catch$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z$0+3p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+4], 0
		jz	short loc_5ADD
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+8]
		push	edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Destroy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXPAUDWRITE_GLYPH_OFFSET@@0@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Destroy(DWRITE_GLYPH_OFFSET *,DWRITE_GLYPH_OFFSET *)
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+var_4]
		mov	ecx, [edx+0Ch]
		sub	ecx, [eax+4]
		sar	ecx, 3
		push	ecx		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		push	eax		; void *
		lea	ecx, [ebp+var_8+3]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z ; std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::deallocate(DWRITE_GLYPH_OFFSET *,uint)
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+4], 0
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+0Ch], 0

loc_5ADD:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Tidy(void)+1Fj
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Tidy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5AECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Unused_capacity(void)const
		public ?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+12p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+0Ch]
		sub	eax, [ecx+8]
		sar	eax, 1
		mov	esp, ebp
		pop	ebp
		retn
?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<float, class std::allocator<float>>::_Unused_capacity(void)const
		public ?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reserve(uint)+12p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+0Ch]
		sub	eax, [ecx+8]
		sar	eax, 2
		mov	esp, ebp
		pop	ebp
		retn
?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Unused_capacity(void)const
		public ?_Unused_capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ
?_Unused_capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+12p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+0Ch]
		sub	eax, [ecx+8]
		sar	eax, 3
		mov	esp, ebp
		pop	ebp
		retn
?_Unused_capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
		public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+2Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::_Xlen(void)const
		public ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+38p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5BBCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<float,	class std::allocator<float>>::_Xlen(void)const
		public ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reserve(uint)+38p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IBEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5BF0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::vector<struct	DWRITE_GLYPH_OFFSET, class std::allocator<struct DWRITE_GLYPH_OFFSET>>::_Xlen(void)const
		public ?_Xlen@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXXZ
?_Xlen@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXXZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+38p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5C24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
		public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+27p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+1Cp	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
		call	dword ptr ds:__imp_?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5C58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+D0p
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+26p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5C84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned short * __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>>::allocate(unsigned	int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z
?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+52p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@G@std@@QAEPAGI@Z ; std::allocator<ushort>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5CB0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: float	* __thiscall std::_Wrap_alloc<class std::allocator<float>>::allocate(unsigned int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEPAMI@Z
?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEPAMI@Z proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+52p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@M@std@@QAEPAMI@Z ; std::allocator<float>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEPAMI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5CDCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct DWRITE_GLYPH_OFFSET * __thiscall std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>::allocate(unsigned	int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z
?allocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+52p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z ; std::allocator<DWRITE_GLYPH_OFFSET>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Alloc_proxy(void)+2Dp
					; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Alloc_proxy(void)+2Dp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	; std::allocator<std::_Container_proxy>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
		public ?allocate@?$allocator@D@std@@QAEPADI@Z
?allocate@?$allocator@D@std@@QAEPADI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@D@std@@YAPADIPAD@Z	; std::_Allocate<char>(uint,char *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@D@std@@QAEPADI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned short * __thiscall std::allocator<unsigned short>::allocate(unsigned	int)
		public ?allocate@?$allocator@G@std@@QAEPAGI@Z
?allocate@?$allocator@G@std@@QAEPAGI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<ushort>>::allocate(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@G@std@@YAPAGIPAG@Z	; std::_Allocate<ushort>(uint,ushort *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@G@std@@QAEPAGI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: float	* __thiscall std::allocator<float>::allocate(unsigned int)
		public ?allocate@?$allocator@M@std@@QAEPAMI@Z
?allocate@?$allocator@M@std@@QAEPAMI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<float>>::allocate(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@M@std@@YAPAMIPAM@Z	; std::_Allocate<float>(uint,float *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@M@std@@QAEPAMI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct DWRITE_GLYPH_OFFSET * __thiscall std::allocator<struct	DWRITE_GLYPH_OFFSET>::allocate(unsigned	int)
		public ?allocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z
?allocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::allocate(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@UDWRITE_GLYPH_OFFSET@@@std@@YAPAUDWRITE_GLYPH_OFFSET@@IPAU1@@Z ; std::_Allocate<DWRITE_GLYPH_OFFSET>(uint,DWRITE_GLYPH_OFFSET *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEPAUDWRITE_GLYPH_OFFSET@@I@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DE4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
		public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+2Dp
					; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E10h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>> const &, unsigned int, unsigned int)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+56p

Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		cmp	eax, [ebp+arg_4]
		jnb	short loc_5E3C
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_5E3C:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+22j
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		sub	eax, [ebp+arg_4]
		mov	[ebp+Size], eax
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+Size]
		jnb	short loc_5E58
		mov	ecx, [ebp+arg_8]
		mov	[ebp+Size], ecx

loc_5E58:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
		mov	edx, [ebp+var_4]
		cmp	edx, [ebp+arg_0]
		jnz	short loc_5E7F
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
		jmp	short loc_5EC1
; ---------------------------------------------------------------------------

loc_5E7F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Ej
		push	0
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	eax, al
		test	eax, eax
		jz	short loc_5EC1
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	ecx, [ebp+arg_0]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_4]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_5EC1:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+82j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5ED4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+61p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	490h		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Str]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	?length@?$char_traits@D@std@@SAIPBD@Z ;	std::char_traits<char>::length(char const *)
		add	esp, 4
		push	eax		; Size
		mov	edx, [ebp+Str]
		push	edx		; Src
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char	const *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5F24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+38p

var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+Size], 0
		jz	short loc_5F4E
		push	47Fh		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Src]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch

loc_5F4E:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12j
		mov	ecx, [ebp+Src]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
		movzx	edx, al
		test	edx, edx
		jz	short loc_5F81
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+Src]
		sub	ecx, eax
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
		jmp	short loc_5FBE
; ---------------------------------------------------------------------------

loc_5F81:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+3Bj
		push	0
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_5FBB
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+Src]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Size]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_5FBB:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+70j
		mov	eax, [ebp+var_4]

loc_5FBE:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Bj
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5FD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::char_traits<char>::assign(char &, char const	&)
		public ?assign@?$char_traits@D@std@@SAXAADABD@Z
?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+34p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx]
		mov	[eax], dl
		pop	ebp
		retn
?assign@?$char_traits@D@std@@SAXAADABD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5FE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct IDWriteFontFile>::assign_assuming_AddRef(struct IDWriteFontFile *)
		public ?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFile@@@@AAEXPAUIDWriteFontFile@@@Z
?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFile@@@@AAEXPAUIDWriteFontFile@@@Z	proc near
					; CODE XREF: RefPtr<IDWriteFontFile>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6019
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UIDWriteFontFile@@@?$RefPtr@UIDWriteFontFile@@@@SAXPAUIDWriteFontFile@@@Z ; RefPtr<IDWriteFontFile>::AddRefTraits<IDWriteFontFile>::Release(IDWriteFontFile *)
		add	esp, 4

loc_6019:				; CODE XREF: RefPtr<IDWriteFontFile>::assign_assuming_AddRef(IDWriteFontFile *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFile@@@@AAEXPAUIDWriteFontFile@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 602Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct IDWriteFontFileLoader>::assign_assuming_AddRef(struct IDWriteFontFileLoader *)
		public ?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileLoader@@@@AAEXPAUIDWriteFontFileLoader@@@Z
?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileLoader@@@@AAEXPAUIDWriteFontFileLoader@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFileLoader>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6065
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UIDWriteFontFileLoader@@@?$RefPtr@UIDWriteFontFileLoader@@@@SAXPAUIDWriteFontFileLoader@@@Z ; RefPtr<IDWriteFontFileLoader>::AddRefTraits<IDWriteFontFileLoader>::Release(IDWriteFontFileLoader	*)
		add	esp, 4

loc_6065:				; CODE XREF: RefPtr<IDWriteFontFileLoader>::assign_assuming_AddRef(IDWriteFontFileLoader *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileLoader@@@@AAEXPAUIDWriteFontFileLoader@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6078h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct IDWriteFontFileStream>::assign_assuming_AddRef(struct IDWriteFontFileStream *)
		public ?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileStream@@@@AAEXPAUIDWriteFontFileStream@@@Z
?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileStream@@@@AAEXPAUIDWriteFontFileStream@@@Z proc near
					; CODE XREF: RefPtr<IDWriteFontFileStream>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_60B1
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UIDWriteFontFileStream@@@?$RefPtr@UIDWriteFontFileStream@@@@SAXPAUIDWriteFontFileStream@@@Z ; RefPtr<IDWriteFontFileStream>::AddRefTraits<IDWriteFontFileStream>::Release(IDWriteFontFileStream	*)
		add	esp, 4

loc_60B1:				; CODE XREF: RefPtr<IDWriteFontFileStream>::assign_assuming_AddRef(IDWriteFontFileStream *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UIDWriteFontFileStream@@@@AAEXPAUIDWriteFontFileStream@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 60C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned	short>>> __thiscall std::vector<unsigned short,	class std::allocator<unsigned short>>::begin(void)
		public ?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::front(void)+49p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::_Container_base12	*
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+arg_0]
		call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(ushort *,std::_Container_base12	const *)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 60F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<float>>>	__thiscall std::vector<float, class std::allocator<float>>::begin(void)
		public ?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::front(void)+49p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::_Container_base12	*
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+arg_0]
		call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>(float *,std::_Container_base12 const *)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 612Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<struct DWRITE_GLYPH_OFFSET>>> __thiscall	std::vector<struct DWRITE_GLYPH_OFFSET,	class std::allocator<struct DWRITE_GLYPH_OFFSET>>::begin(void)
		public ?begin@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@2@XZ
?begin@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@2@XZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::front(void)+49p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::_Container_base12	*
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+arg_0]
		call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET	*,std::_Container_base12 const *)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?begin@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6160h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::capacity(void)const
		public ?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Grow_to(uint)+21p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+0Ch]
		sub	eax, [ecx+4]
		sar	eax, 1
		mov	esp, ebp
		pop	ebp
		retn
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6180h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<float, class std::allocator<float>>::capacity(void)const
		public ?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Grow_to(uint)+21p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+0Ch]
		sub	eax, [ecx+4]
		sar	eax, 2
		mov	esp, ebp
		pop	ebp
		retn
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::capacity(void)const
		public ?capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ
?capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Grow_to(uint)+21p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+0Ch]
		sub	eax, [ecx+4]
		sar	eax, 3
		mov	esp, ebp
		pop	ebp
		retn
?capacity@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
		public ?category@error_code@std@@QBEABVerror_category@2@XZ
?category@error_code@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_code@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
		public ?category@error_condition@std@@QBEABVerror_category@2@XZ
?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Bp
					; std::error_condition::operator==(std::error_condition	const &)+24p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_condition@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::construct(void *)
		public ?construct@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z
?construct@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z proc near
					; CODE XREF: std::_Uninit_def_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::allocator<DWRITE_GLYPH_OFFSET>,DWRITE_GLYPH_OFFSET>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &,DWRITE_GLYPH_OFFSET	*,std::_Nonscalar_ptr_iterator_tag)+5Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_4]
		push	ecx		; int
		call	??$construct@UDWRITE_GLYPH_OFFSET@@$$$V@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?construct@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6228h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<DWRITE_GLYPH_OFFSET>::construct(void *)
		public ?construct@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z
?construct@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z proc near
					; CODE XREF: ??$construct@UDWRITE_GLYPH_OFFSET@@$$$V@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAXAAV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@PAUDWRITE_GLYPH_OFFSET@@@Z+Ap

var_10		= dword	ptr -10h
Dst		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+Dst], eax
		mov	[ebp+Size], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+Size], 8
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+Size]
		push	ecx		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_627C
		mov	edx, [ebp+Size]
		push	edx		; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset_0
		add	esp, 0Ch
		mov	ecx, [ebp+Dst]
		mov	[ebp+var_10], ecx
		jmp	short loc_6283
; ---------------------------------------------------------------------------

loc_627C:				; CODE XREF: std::allocator<DWRITE_GLYPH_OFFSET>::construct(DWRITE_GLYPH_OFFSET	*)+38j
		mov	[ebp+var_10], 0

loc_6283:				; CODE XREF: std::allocator<DWRITE_GLYPH_OFFSET>::construct(DWRITE_GLYPH_OFFSET	*)+52j
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?construct@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6294h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::copy(void	*Dst, void *Src, size_t	Size)
		public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+72p ...

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_62AD
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_62C4
; ---------------------------------------------------------------------------

loc_62AD:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+Fj
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[ebp+var_4], eax

loc_62C4:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+17j
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 62D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::deallocate(void	*, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+96p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6308h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<unsigned short>>::deallocate(void *, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z
?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z proc near
					; CODE XREF: __catch$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z$0+16p
					; std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+105p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@G@std@@QAEXPAGI@Z ; std::allocator<ushort>::deallocate(ushort *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6338h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<float>>::deallocate(void *, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEXPAMI@Z
?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEXPAMI@Z proc near
					; CODE XREF: __catch$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z$0+16p
					; std::vector<float,std::allocator<float>>::_Reallocate(uint)+106p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@M@std@@QAEXPAMI@Z ; std::allocator<float>::deallocate(float *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QAEXPAMI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6368h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::deallocate(void *, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z
?deallocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z proc near
					; CODE XREF: __catch$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z$0+16p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+106p	...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z ; std::allocator<DWRITE_GLYPH_OFFSET>::deallocate(DWRITE_GLYPH_OFFSET *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6398h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z	proc near
					; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Free_proxy(void)+4Ep
					; std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Free_proxy(void)+4Ep ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 63C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::deallocate(void *, int)
		public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 63F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<unsigned	short>::deallocate(void	*, int)
		public ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
?deallocate@?$allocator@G@std@@QAEXPAGI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<ushort>>::deallocate(ushort *,uint)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@G@std@@QAEXPAGI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6420h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<float>::deallocate(void *, int)
		public ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
?deallocate@?$allocator@M@std@@QAEXPAMI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<float>>::deallocate(float *,uint)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@M@std@@QAEXPAMI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 644Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<DWRITE_GLYPH_OFFSET>::deallocate(void *,	int)
		public ?deallocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z
?deallocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::deallocate(DWRITE_GLYPH_OFFSET *,uint)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6478h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::deallocate(void *, int)
		public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+4Ep
					; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::_System_error_category::default_error_condition(int)const
		public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00007C44o

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_64E6
		call	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category(void)
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		jmp	short loc_64FB
; ---------------------------------------------------------------------------
		jmp	short loc_64FB
; ---------------------------------------------------------------------------

loc_64E6:				; CODE XREF: std::_System_error_category::default_error_condition(int)+27j
		call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
		push	eax		; struct std::error_category *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]

loc_64FB:				; CODE XREF: std::_System_error_category::default_error_condition(int)+3Ej
					; std::_System_error_category::default_error_condition(int)+40j
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 650Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::error_category::default_error_condition(int)const
		public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00007BB4o
					; .rdata:00007BD0o ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6540h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
		public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
					; DATA XREF: .rdata:00007BB8o
					; .rdata:00007BD4o ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_6585
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_code@std@@QBEHXZ ;	std::error_code::value(void)
		cmp	eax, [ebp+arg_4]
		jnz	short loc_6585
		mov	[ebp+var_8], 1
		jmp	short loc_658C
; ---------------------------------------------------------------------------

loc_6585:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+2Dj
					; std::error_category::equivalent(std::error_code const	&,int)+3Aj
		mov	[ebp+var_8], 0

loc_658C:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+43j
		mov	al, byte ptr [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 65A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const	struct std::error_condition *)
		public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
					; DATA XREF: .rdata:00007BBCo
					; .rdata:00007BD8o ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	esi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; std::error_condition *
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+var_4]
		mov	edx, [eax]
		mov	ecx, [ebp+var_4]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	??8error_condition@std@@QBE_NABV01@@Z ;	std::error_condition::operator==(std::error_condition const &)
		pop	esi
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 65FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_661D
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_661D:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+17j
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 663Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int,	unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+68p

var_C		= dword	ptr -0Ch
Dst		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Dst], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_666D
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_666D:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+27j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		ja	short loc_6689
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		jmp	short loc_66CF
; ---------------------------------------------------------------------------

loc_6689:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Dj
		cmp	[ebp+arg_4], 0
		jbe	short loc_66CF
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		mov	[ebp+Dst], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+var_C]
		sub	ecx, [ebp+arg_0]
		push	ecx		; Size
		mov	edx, [ebp+Dst]
		add	edx, [ebp+arg_4]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_66CF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+4Bj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+51j
		mov	eax, [ebp+var_4]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 66E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned short & __thiscall std::vector<unsigned short, class	std::allocator<unsigned	short>>::front(void)
		public ?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ
?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+167p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1Ch
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_10]
		call	?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@2@XZ ; std::vector<ushort,std::allocator<ushort>>::begin(void)
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+var_24]
		mov	[ebp+var_28], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_28]
		call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QBEAAGXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ	; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(void)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 28h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6778h
; COMDAT (pick associative to section at 66E4)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ$0 proc near
					; DATA XREF: .xdata$x:00007770o
		lea	ecx, [ebp-20h]
		jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@XZ	; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<ushort>>>(void)
__unwindfunclet$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ	proc near
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::front(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-20h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ
		jmp	___CxxFrameHandler3
__ehhandler$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 679Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: float	& __thiscall std::vector<float,	class std::allocator<float>>::front(void)
		public ?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ
?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+9Ep
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer const &,ID2D1GeometrySink *)+15Ep

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1Ch
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_10]
		call	?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ ; std::vector<float,std::allocator<float>>::begin(void)
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+var_24]
		mov	[ebp+var_28], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_28]
		call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QBEAAMXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ	; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>(void)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 28h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6830h
; COMDAT (pick associative to section at 679C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ$0 proc near
					; DATA XREF: .xdata$x:00007610o
		lea	ecx, [ebp-20h]
		jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@XZ	; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<float>>>(void)
__unwindfunclet$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ	proc near
					; DATA XREF: std::vector<float,std::allocator<float>>::front(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-20h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ
		jmp	___CxxFrameHandler3
__ehhandler$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6854h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct DWRITE_GLYPH_OFFSET & __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::front(void)
		public ?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ
?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ proc	near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+155p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1Ch
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_28], eax
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_10]
		call	?begin@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@2@XZ ;	std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::begin(void)
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+var_24]
		mov	[ebp+var_28], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_28]
		call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBEAAUDWRITE_GLYPH_OFFSET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_20]
		call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(void)
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 28h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 68E8h
; COMDAT (pick associative to section at 6854)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ$0 proc near
					; DATA XREF: .xdata$x:000078A4o
		lea	ecx, [ebp-20h]
		jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>(void)
__unwindfunclet$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ proc near
					; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::front(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-20h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 690Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::generic_category()
		public ?generic_category@std@@YAABVerror_category@1@XZ
?generic_category@std@@YAABVerror_category@1@XZ	proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+29p
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
		pop	ebp
		retn
?generic_category@std@@YAABVerror_category@1@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6918h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1GeometrySink * __thiscall	RefPtr<struct ID2D1GeometrySink>::get(void)const
		public ?get@?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ
?get@?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ	proc near
					; CODE XREF: RefPtr<ID2D1GeometrySink>::operator ID2D1GeometrySink *(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID2D1GeometrySink@@@@QBEPAUID2D1GeometrySink@@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6930h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFace * __thiscall RefPtr<struct IDWriteFontFace>::get(void)const
		public ?get@?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ
?get@?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ proc near
					; CODE XREF: RefPtr<IDWriteFontFace>::operator IDWriteFontFace *(void)+11p
					; RefPtr<IDWriteFontFace>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UIDWriteFontFace@@@@QBEPAUIDWriteFontFace@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6948h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFile * __thiscall RefPtr<struct IDWriteFontFile>::get(void)const
		public ?get@?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ
?get@?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ proc near
					; CODE XREF: RefPtr<IDWriteFontFile>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UIDWriteFontFile@@@@QBEPAUIDWriteFontFile@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6960h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFileLoader * __thiscall RefPtr<struct IDWriteFontFileLoader>::get(void)const
		public ?get@?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ
?get@?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ	proc near
					; CODE XREF: RefPtr<IDWriteFontFileLoader>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UIDWriteFontFileLoader@@@@QBEPAUIDWriteFontFileLoader@@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6978h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDWriteFontFileStream * __thiscall RefPtr<struct IDWriteFontFileStream>::get(void)const
		public ?get@?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ
?get@?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ	proc near
					; CODE XREF: RefPtr<IDWriteFontFileStream>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UIDWriteFontFileStream@@@@QBEPAUIDWriteFontFileStream@@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6990h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::PathBuilder * __thiscall RefPtr<class mozilla::gfx::PathBuilder>::get(void)const
		public ?get@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ
?get@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+ECp
					; RefPtr<mozilla::gfx::PathBuilder>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@VPathBuilder@gfx@mozilla@@@@QBEPAVPathBuilder@gfx@mozilla@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::length(char *Str)
		public ?length@?$char_traits@D@std@@SAIPBD@Z
?length@?$char_traits@D@std@@SAIPBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+28p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_69C6
		mov	[ebp+var_4], 0
		jmp	short loc_69D5
; ---------------------------------------------------------------------------

loc_69C6:				; CODE XREF: std::char_traits<char>::length(char const *)+13j
		mov	edx, [ebp+Str]
		push	edx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_4], eax

loc_69D5:				; CODE XREF: std::char_traits<char>::length(char const *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@?$char_traits@D@std@@SAIPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+28p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A10h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<unsigned short>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::max_size(void)+25p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z	; std::allocator_traits<std::allocator<ushort>>::max_size(std::allocator<ushort> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<float>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::max_size(void)+25p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z	; std::allocator_traits<std::allocator<float>>::max_size(std::allocator<float> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct DWRITE_GLYPH_OFFSET>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(void)+25p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAIABV?$allocator@UDWRITE_GLYPH_OFFSET@@@2@@Z ; std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(std::allocator<DWRITE_GLYPH_OFFSET> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
		public ?max_size@?$allocator@D@std@@QBEIXZ
?max_size@?$allocator@D@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char>	const &)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		or	eax, 0FFFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@D@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<unsigned short>::max_size(void)const
		public ?max_size@?$allocator@G@std@@QBEIXZ
?max_size@?$allocator@G@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<ushort>>::max_size(std::allocator<ushort> const &)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, 7FFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@G@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<float>::max_size(void)const
		public ?max_size@?$allocator@M@std@@QBEIXZ
?max_size@?$allocator@M@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<float>>::max_size(std::allocator<float> const	&)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, 3FFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@M@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AD0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<struct	DWRITE_GLYPH_OFFSET>::max_size(void)const
		public ?max_size@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QBEIXZ
?max_size@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(std::allocator<DWRITE_GLYPH_OFFSET> const &)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, 1FFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class	std::allocator<char> const &)
		public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AFCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<unsigned short>>::max_size(class std::allocator<unsigned short> const &)
		public ?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z
?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<ushort>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@G@std@@QBEIXZ ; std::allocator<ushort>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B10h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<float>>::max_size(class std::allocator<float> const &)
		public ?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z
?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<float>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@M@std@@QBEIXZ ; std::allocator<float>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct	DWRITE_GLYPH_OFFSET>>::max_size(class std::allocator<struct DWRITE_GLYPH_OFFSET> const &)
		public ?max_size@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAIABV?$allocator@UDWRITE_GLYPH_OFFSET@@@2@@Z
?max_size@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAIABV?$allocator@UDWRITE_GLYPH_OFFSET@@@2@@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QBEIXZ ; std::allocator<DWRITE_GLYPH_OFFSET>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@SAIABV?$allocator@UDWRITE_GLYPH_OFFSET@@@2@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
		public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+83p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 1
		ja	short loc_6B77
		mov	[ebp+var_10], 1
		jmp	short loc_6B80
; ---------------------------------------------------------------------------

loc_6B77:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+34j
		mov	ecx, [ebp+var_8]
		sub	ecx, 1
		mov	[ebp+var_10], ecx

loc_6B80:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+3Dj
		mov	eax, [ebp+var_10]
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B94h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::max_size(void)const
		public ?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Grow_to(uint)+2Cp
					; std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)+1Fp

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_8+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<ushort>>::max_size(void)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6BCCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<float, class std::allocator<float>>::max_size(void)const
		public ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Grow_to(uint)+2Cp
					; std::vector<float,std::allocator<float>>::_Reserve(uint)+1Fp

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_8+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<float>>::max_size(void)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C04h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::max_size(void)const
		public ?max_size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ
?max_size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Grow_to(uint)+2Cp
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)+1Fp

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_8+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ;	std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>::max_size(void)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
		public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; CODE XREF: std::_Iostream_error_category::message(int)+4Cp
					; DATA XREF: .rdata:00007BCCo

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6C85
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_6C8C
; ---------------------------------------------------------------------------

loc_6C85:				; CODE XREF: std::_Generic_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_6C8C:				; CODE XREF: std::_Generic_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
		public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc	near
					; DATA XREF: .rdata:00007C00o

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		cmp	[ebp+arg_4], 1
		jnz	short loc_6CF9
		push	offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		jmp	short loc_6D15
; ---------------------------------------------------------------------------
		jmp	short loc_6D15
; ---------------------------------------------------------------------------

loc_6CF9:				; CODE XREF: std::_Iostream_error_category::message(int)+22j
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]

loc_6D15:				; CODE XREF: std::_Iostream_error_category::message(int)+3Dj
					; std::_Iostream_error_category::message(int)+3Fj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
		public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; DATA XREF: .rdata:00007C40o

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Winerror_map@std@@YAPBDH@Z	; std::_Winerror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6D71
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_6D78
; ---------------------------------------------------------------------------

loc_6D71:				; CODE XREF: std::_System_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_6D78:				; CODE XREF: std::_System_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6DA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::move(void	*Dst, void *Src, size_t	Size)
		public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+7Fp

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_6DBE
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_6DDF
; ---------------------------------------------------------------------------

loc_6DBE:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
		mov	esi, esp
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], eax

loc_6DDF:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+18j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6DF4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
		public ?name@_Generic_error_category@std@@UBEPBDXZ
?name@_Generic_error_category@std@@UBEPBDXZ proc near ;	DATA XREF: .rdata:00007BC8o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Generic_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
		public ?name@_Iostream_error_category@std@@UBEPBDXZ
?name@_Iostream_error_category@std@@UBEPBDXZ proc near ; DATA XREF: .rdata:00007BFCo

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Iostream_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
		public ?name@_System_error_category@std@@UBEPBDXZ
?name@_System_error_category@std@@UBEPBDXZ proc	near ; DATA XREF: .rdata:00007C3Co

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
		mov	esp, ebp
		pop	ebp
		retn
?name@_System_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::resize(unsigned int)
		public ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+6Cp

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 00006F16 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00006F26 SIZE 0000004B BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_6EA2
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		sub	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<ushort,std::allocator<ushort>>::_Pop_back_n(uint)
		jmp	loc_6F42
; ---------------------------------------------------------------------------

loc_6EA2:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+4Bj
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		cmp	eax, [ebp+arg_0]
		jnb	loc_6F42
		lea	eax, [ebp+var_1C+3]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Getal(void)
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ;	std::vector<ushort,std::allocator<ushort>>::_Reserve(uint)
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_1C+3]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		push	eax
		call	??$_Uninitialized_default_fill_n@PAGIU?$_Wrap_alloc@V?$allocator@G@std@@@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ;	std::_Uninitialized_default_fill_n<ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>>>(ushort *,uint,std::_Wrap_alloc<std::allocator<ushort>> &)
		add	esp, 0Ch
		jmp	short loc_6F16
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z$0 proc near
					; DATA XREF: .xdata$x:00007720o
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<ushort,std::allocator<ushort>>::_Tidy(void)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN10_4
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z

loc_6F16:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+C1j
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_6F26
; END OF FUNCTION CHUNK	FOR ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z

; =============== S U B	R O U T	I N E =======================================


$LN10_4		proc near		; DATA XREF: .text$mn:00006F10o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN10_4		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z

loc_6F26:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+E1j
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<ushort,std::allocator<ushort>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		lea	ecx, [eax+ecx*2]
		mov	edx, [ebp+var_14]
		mov	[edx+8], ecx

loc_6F42:				; CODE XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+61j
					; std::vector<ushort,std::allocator<ushort>>::resize(uint)+71j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
; END OF FUNCTION CHUNK	FOR ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
; ---------------------------------------------------------------------------
		align 4
$LN14_2		dd 1			; DATA XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+10Ao
		dd offset $LN13_3
$LN13_3		dd 0FFFFFFE7h, 1	; DATA XREF: .text$mn:00006F78o
		dd offset $LN11_4	; "_Alval"
$LN11_4		db '_Alval',0           ; DATA XREF: .text$mn:00006F84o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6F90h
; COMDAT (pick associative to section at 6E3C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z	proc near
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::resize(uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
		jmp	___CxxFrameHandler3
__ehhandler$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::vector<float, class std::allocator<float>>::resize(unsigned int)
		public ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+7Bp

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 00007086 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00007096 SIZE 0000004B BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_7012
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		sub	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?_Pop_back_n@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z ; std::vector<float,std::allocator<float>>::_Pop_back_n(uint)
		jmp	loc_70B2
; ---------------------------------------------------------------------------

loc_7012:				; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+4Bj
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		cmp	eax, [ebp+arg_0]
		jnb	loc_70B2
		lea	eax, [ebp+var_1C+3]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ;	std::_Vector_alloc<0,std::_Vec_base_types<float,std::allocator<float>>>::_Getal(void)
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z ;	std::vector<float,std::allocator<float>>::_Reserve(uint)
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_1C+3]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		push	eax
		call	??$_Uninitialized_default_fill_n@PAMIU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YAXPAMIAAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ;	std::_Uninitialized_default_fill_n<float *,uint,std::_Wrap_alloc<std::allocator<float>>>(float *,uint,std::_Wrap_alloc<std::allocator<float>> &)
		add	esp, 0Ch
		jmp	short loc_7086
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z$0 proc near
					; DATA XREF: .xdata$x:000075C0o
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float>>::_Tidy(void)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z$0 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN10_1
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z

loc_7086:				; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+C1j
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_7096
; END OF FUNCTION CHUNK	FOR ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z

; =============== S U B	R O U T	I N E =======================================


$LN10_1		proc near		; DATA XREF: .text$mn:00007080o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN10_1		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z

loc_7096:				; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+E1j
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		lea	ecx, [eax+ecx*4]
		mov	edx, [ebp+var_14]
		mov	[edx+8], ecx

loc_70B2:				; CODE XREF: std::vector<float,std::allocator<float>>::resize(uint)+61j
					; std::vector<float,std::allocator<float>>::resize(uint)+71j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
; END OF FUNCTION CHUNK	FOR ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
; ---------------------------------------------------------------------------
		align 4
$LN14_0		dd 1			; DATA XREF: std::vector<float,std::allocator<float>>::resize(uint)+10Ao
		dd offset $LN13_0
$LN13_0		dd 0FFFFFFE7h, 1	; DATA XREF: .text$mn:000070E8o
		dd offset $LN11_2	; "_Alval"
$LN11_2		db '_Alval',0           ; DATA XREF: .text$mn:000070F4o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7100h
; COMDAT (pick associative to section at 6FAC)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z	proc near
					; DATA XREF: std::vector<float,std::allocator<float>>::resize(uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
		jmp	___CxxFrameHandler3
__ehhandler$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 711Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::resize(unsigned int)
		public ?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z proc near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+8Ap

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 000071F6 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00007206 SIZE 0000004B BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_7182
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		sub	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?_Pop_back_n@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Pop_back_n(uint)
		jmp	loc_7222
; ---------------------------------------------------------------------------

loc_7182:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+4Bj
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		cmp	eax, [ebp+arg_0]
		jnb	loc_7222
		lea	eax, [ebp+var_1C+3]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>>::_Getal(void)
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?_Reserve@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z	; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reserve(uint)
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_1C+3]
		push	edx		; int
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		push	ecx		; int
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		push	eax		; void *
		call	??$_Uninitialized_default_fill_n@PAUDWRITE_GLYPH_OFFSET@@IU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>>>(DWRITE_GLYPH_OFFSET *,uint,std::_Wrap_alloc<std::allocator<DWRITE_GLYPH_OFFSET>> &)
		add	esp, 0Ch
		jmp	short loc_71F6
?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z$0	proc near
					; DATA XREF: .xdata$x:00007854o
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Tidy(void)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z$0	endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN10_6
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z

loc_71F6:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+C1j
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_7206
; END OF FUNCTION CHUNK	FOR ?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z

; =============== S U B	R O U T	I N E =======================================


$LN10_6		proc near		; DATA XREF: .text$mn:000071F0o
		mov	dword ptr [ebp-4], 0FFFFFFFFh
$LN10_6		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z

loc_7206:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+E1j
		mov	ecx, [ebp+var_14]
		call	?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ ; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::size(void)
		mov	ecx, [ebp+arg_0]
		sub	ecx, eax
		mov	edx, [ebp+var_14]
		mov	eax, [edx+8]
		lea	ecx, [eax+ecx*8]
		mov	edx, [ebp+var_14]
		mov	[edx+8], ecx

loc_7222:				; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+61j
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+71j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
; END OF FUNCTION CHUNK	FOR ?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
; ---------------------------------------------------------------------------
		align 4
$LN14_3		dd 1			; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+10Ao
		dd offset $LN13_5
$LN13_5		dd 0FFFFFFE7h, 1	; DATA XREF: .text$mn:00007258o
		dd offset $LN11_5	; "_Alval"
$LN11_5		db '_Alval',0           ; DATA XREF: .text$mn:00007264o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7270h
; COMDAT (pick associative to section at 711C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z proc near
					; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::resize(uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-24h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
		jmp	___CxxFrameHandler3
__ehhandler$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 728Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+1Ap
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+2Fp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+14h]
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<unsigned short, class std::allocator<unsigned short>>::size(void)const
		public ?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+12p
					; std::vector<ushort,std::allocator<ushort>>::_Reallocate(uint)+BAp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+8]
		sub	eax, [ecx+4]
		sar	eax, 1
		mov	esp, ebp
		pop	ebp
		retn
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<float, class std::allocator<float>>::size(void)const
		public ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::vector<float,std::allocator<float>>::_Reallocate(uint)+BAp
					; std::vector<float,std::allocator<float>>::_Reserve(uint)+29p	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+8]
		sub	eax, [ecx+4]
		sar	eax, 2
		mov	esp, ebp
		pop	ebp
		retn
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::vector<struct DWRITE_GLYPH_OFFSET, class	std::allocator<struct DWRITE_GLYPH_OFFSET>>::size(void)const
		public ?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ
?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ proc	near
					; CODE XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+12p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::_Reallocate(uint)+BAp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	eax, [eax+8]
		sub	eax, [ecx+4]
		sar	eax, 3
		mov	esp, ebp
		pop	ebp
		retn
?size@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 730Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::system_category()
		public ?system_category@std@@YAABVerror_category@1@XZ
?system_category@std@@YAABVerror_category@1@XZ proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int):loc_64E6p
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
		pop	ebp
		retn
?system_category@std@@YAABVerror_category@1@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7318h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::PathBuilder * __thiscall already_AddRefed<class mozilla::gfx::PathBuilder>::take(void)
		public ?take@?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAEPAVPathBuilder@gfx@mozilla@@XZ
?take@?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAEPAVPathBuilder@gfx@mozilla@@XZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::PathBuilder>::RefPtr<mozilla::gfx::PathBuilder>(already_AddRefed<mozilla::gfx::PathBuilder> &&)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx], 0
		mov	eax, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?take@?$already_AddRefed@VPathBuilder@gfx@mozilla@@@@QAEPAVPathBuilder@gfx@mozilla@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7348h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_code::value(std::error_code	*__hidden this)
		public ?value@error_code@std@@QBEHXZ
?value@error_code@std@@QBEHXZ proc near	; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+32p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_code@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7360h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
		public ?value@error_condition@std@@QBEHXZ
?value@error_condition@std@@QBEHXZ proc	near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+3Ap
					; std::error_condition::operator==(std::error_condition	const &)+44p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_condition@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7378h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _hypot
_hypot		proc near

var_14		= qword	ptr -14h
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		sub	esp, 8
		movsd	xmm0, [ebp+arg_8]
		movsd	[esp+0Ch+var_C], xmm0
		sub	esp, 8
		movsd	xmm0, [ebp+arg_0]
		movsd	[esp+14h+var_14], xmm0
		call	dword ptr ds:__imp___hypot
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
_hypot		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 73B4h
; COMDAT (pick associative to section at 3E4C)
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000073CCo
		dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
		dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 73E8h
; COMDAT (pick associative to section at 2414)
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000073F8o
		dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
		dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7414h
; COMDAT (pick associative to section at 2B48)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007424o
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7440h
; COMDAT (pick associative to section at 4258)
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 dd offset $SG4890+18h
					; DATA XREF: .xdata$x:000074C8o
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 dd offset $SG4890+18h
					; DATA XREF: .xdata$x:000074B4o
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00007488o
		dd 0FFFFFFFFh, 0
		dd 1, 0
		dd 1, 0
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 19930522h,	4
					; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
		dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 2
		dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		align 10h
		dd 1
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd	2 dup(2), 3, 1
					; DATA XREF: .xdata$x:00007490o
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
		align 10h
		dd 3, 1
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 74CCh
__unwindtable$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00007524o
		dd offset __unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$0
		align 8
		dd offset __unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$1
		dd 1
		dd offset __unwindfunclet$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z$2
__unwindtable$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00007548o
		dd offset __unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$0
		align 10h
		dd offset __unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$1
		dd 1
		dd offset __unwindfunclet$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z$2
__unwindtable$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000756Co
		dd offset __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$0
		align 8
		dd offset __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$1
		dd 1
		dd offset __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$2
		align 8
		dd offset __unwindfunclet$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z$2
__ehfuncinfo$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z+14o
		dd offset __unwindtable$?GetFontFileData@ScaledFontDWrite@gfx@mozilla@@UAE_NP6AXPBEIIMPAX@Z1@Z
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z+11o
		dd offset __unwindtable$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z
		align 20h
		dd 1
__ehfuncinfo$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z dd 19930522h, 4
					; DATA XREF: __ehhandler$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z+11o
		dd offset __unwindtable$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7588h
; COMDAT (pick associative to section at 257C)
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007598o
		dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z+11o
		dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@ABV?$allocator@M@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 75B4h
; COMDAT (pick associative to section at 6FAC)
__catchsym$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z$2 dd offset $SG4890+18h
					; DATA XREF: .xdata$x:000075E4o
					; "t %s:%d\n"
		align 10h
		dd offset __catch$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z$0
__unwindtable$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:000075F0o
		dd 0FFFFFFFFh, 0
__tryblocktable$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z dd 2 dup(0)
					; DATA XREF: .xdata$x:000075F8o
		dd 2 dup(1)
		dd offset __catchsym$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z+11o
		dd offset __unwindtable$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
		dd 1
		dd offset __tryblocktable$?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 760Ch
; COMDAT (pick associative to section at 679C)
__unwindtable$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000761Co
		dd offset __unwindfunclet$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ$0
__ehfuncinfo$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ+11o
		dd offset __unwindtable$?front@?$vector@MV?$allocator@M@std@@@std@@QAEAAMXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7638h
; COMDAT (pick associative to section at 5404)
__catchsym$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z$2 dd offset	$SG4890+18h
					; DATA XREF: .xdata$x:00007668o
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00007674o
		dd 0FFFFFFFFh, 0
__tryblocktable$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z dd 2 dup(0)
					; DATA XREF: .xdata$x:0000767Co
		dd 2 dup(1)
		dd offset __catchsym$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z+11o
		dd offset __unwindtable$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
		dd 1
		dd offset __tryblocktable$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IAEXI@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7690h
; COMDAT (pick associative to section at 4EA4)
__unwindtable$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000076A0o
		dd offset __unwindfunclet$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z+11o
		dd offset __unwindtable$?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IBEXPAM0@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 76BCh
; COMDAT (pick associative to section at 2738)
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000076CCo
		dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z+11o
		dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QAE@PAMPBU_Container_base12@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 76E8h
; COMDAT (pick associative to section at 24EC)
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000076F8o
		dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z+11o
		dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7714h
; COMDAT (pick associative to section at 6E3C)
__catchsym$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z$2 dd offset $SG4890+18h
					; DATA XREF: .xdata$x:00007744o
					; "t %s:%d\n"
		align 10h
		dd offset __catch$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z$0
__unwindtable$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00007750o
		dd 0FFFFFFFFh, 0
__tryblocktable$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z dd 2 dup(0)
					; DATA XREF: .xdata$x:00007758o
		dd 2 dup(1)
		dd offset __catchsym$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z+11o
		dd offset __unwindtable$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
		dd 1
		dd offset __tryblocktable$?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 776Ch
; COMDAT (pick associative to section at 66E4)
__unwindtable$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000777Co
		dd offset __unwindfunclet$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ$0
__ehfuncinfo$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ+11o
		dd offset __unwindtable$?front@?$vector@GV?$allocator@G@std@@@std@@QAEAAGXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7798h
; COMDAT (pick associative to section at 5284)
__catchsym$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z$2 dd offset	$SG4890+18h
					; DATA XREF: .xdata$x:000077C8o
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:000077D4o
		dd 0FFFFFFFFh, 0
__tryblocktable$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z dd 2 dup(0)
					; DATA XREF: .xdata$x:000077DCo
		dd 2 dup(1)
		dd offset __catchsym$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z+11o
		dd offset __unwindtable$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
		dd 1
		dd offset __tryblocktable$?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 77F0h
; COMDAT (pick associative to section at 4D50)
__unwindtable$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007800o
		dd offset __unwindfunclet$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z+11o
		dd offset __unwindtable$?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@IBEXPAG0@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 781Ch
; COMDAT (pick associative to section at 260C)
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000782Co
		dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z+11o
		dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@ABV?$allocator@UDWRITE_GLYPH_OFFSET@@@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7848h
; COMDAT (pick associative to section at 711C)
__catchsym$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z$2 dd offset $SG4890+18h
					; DATA XREF: .xdata$x:00007878o
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z$0
__unwindtable$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00007884o
		dd 0FFFFFFFFh, 0
__tryblocktable$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z dd 2 dup(0)
					; DATA XREF: .xdata$x:0000788Co
		dd 2 dup(1)
		dd offset __catchsym$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z+11o
		dd offset __unwindtable$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
		dd 1
		dd offset __tryblocktable$?resize@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEXI@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 78A0h
; COMDAT (pick associative to section at 6854)
__unwindtable$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000078B0o
		dd offset __unwindfunclet$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ$0
__ehfuncinfo$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ+11o
		dd offset __unwindtable$?front@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@QAEAAUDWRITE_GLYPH_OFFSET@@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 78CCh
; COMDAT (pick associative to section at 5584)
__catchsym$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z$2	dd offset $SG4890+18h
					; DATA XREF: .xdata$x:000078FCo
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z dd 0FFFFFFFFh,	0
					; DATA XREF: .xdata$x:00007908o
		dd 0FFFFFFFFh, 0
__tryblocktable$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z dd 2	dup(0)
					; DATA XREF: .xdata$x:00007910o
		dd 2 dup(1)
		dd offset __catchsym$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z	dd 19930522h, 2
					; DATA XREF: __ehhandler$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z+11o
		dd offset __unwindtable$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
		dd 1
		dd offset __tryblocktable$?_Reallocate@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IAEXI@Z
		align 10h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7924h
; COMDAT (pick associative to section at 4FF8)
__unwindtable$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007934o
		dd offset __unwindfunclet$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z+11o
		dd offset __unwindtable$?_Orphan_range@?$vector@UDWRITE_GLYPH_OFFSET@@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@std@@IBEXPAUDWRITE_GLYPH_OFFSET@@0@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7950h
; COMDAT (pick associative to section at 269C)
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007960o
		dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z+11o
		dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@G@std@@@std@@@std@@QAE@PAGPBU_Container_base12@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 797Ch
; COMDAT (pick associative to section at 27D4)
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000798Co
		dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z+11o
		dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UDWRITE_GLYPH_OFFSET@@@std@@@std@@@std@@QAE@PAUDWRITE_GLYPH_OFFSET@@PBU_Container_base12@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 79A8h
; COMDAT (pick associative to section at 2060)
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000079B8o
		dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
		dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 79D4h
; COMDAT (pick associative to section at 1794)
__catchsym$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 dd offset $SG4890+18h
					; DATA XREF: .xdata$x:00007A04o
					; "t %s:%d\n"
		align 10h
		dd offset __catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00007A10o
		dd 0FFFFFFFFh, 0
__tryblocktable$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z dd	2 dup(0)
					; DATA XREF: .xdata$x:00007A18o
		dd 2 dup(1)
		dd offset __catchsym$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
		dd offset __unwindtable$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		dd 1
		dd offset __tryblocktable$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7A2Ch
; COMDAT (pick associative to section at 1DDC)
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007A3Co
		dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
		dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7A58h
; COMDAT (pick associative to section at 1A78)
__catchsym$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 dd	offset $SG4890+18h
					; DATA XREF: .xdata$x:00007A88o
					; "t %s:%d\n"
		dd 2 dup(0)
		dd offset __catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00007A94o
		dd 0FFFFFFFFh, 0
__tryblocktable$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z	dd 2 dup(0)
					; DATA XREF: .xdata$x:00007A9Co
		dd 2 dup(1)
		dd offset __catchsym$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z dd	19930522h, 2
					; DATA XREF: __ehhandler$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
		dd offset __unwindtable$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		dd 1
		dd offset __tryblocktable$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7AB0h
; COMDAT (pick associative to section at 1F28)
__unwindtable$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007AC0o
		dd offset __unwindfunclet$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z$0
__ehfuncinfo$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z+11o
		dd offset __unwindtable$??$construct@UDWRITE_GLYPH_OFFSET@@U1@@?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@QAEXPAUDWRITE_GLYPH_OFFSET@@$$QAU2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 7ADCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_allocator_arg	db ?
_piecewise_construct db	?
		align 10h
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7AE0h
; COMDAT (pick any)
		public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+59o
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xutility>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7B70h
; COMDAT (pick any)
		public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
; wchar_t `string'
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
					; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+5Eo
		unicode	0, <ITERATOR LIST CORRUPTED!>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7BA4h
; COMDAT (pick largest)
		dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
		public ??_7error_category@std@@6B@
; const	std::error_category::`vftable'
??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
					; DATA XREF: std::error_category::error_category(void)+11o
					; std::error_category::~error_category(void)+11o
					; std::error_category::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7BC0h
; COMDAT (pick largest)
		dd offset ??_R4_Generic_error_category@std@@6B@	; const	std::_Generic_error_category::`RTTI Complete Object Locator'
		public ??_7_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`vftable'
??_7_Generic_error_category@std@@6B@ dd	offset ??_E_Generic_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+19o
					; std::_Generic_error_category::`vector	deleting destructor'(uint)
		dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ;	std::_Generic_error_category::name(void)
		dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7BDCh
; COMDAT (pick any)
		public ??_C@_07DCLBNMLN@generic?$AA@
; `string'
??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
					; DATA XREF: std::_Generic_error_category::name(void)+Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7BE4h
; COMDAT (pick any)
		public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
; `string'
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
					; DATA XREF: std::_Generic_error_category::message(int):loc_6C85o
					; std::_System_error_category::message(int):loc_6D71o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7BF4h
; COMDAT (pick largest)
		dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
		public ??_7_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`vftable'
??_7_Iostream_error_category@std@@6B@ dd offset	??_E_Iostream_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+19o
					; std::_Iostream_error_category::`vector deleting destructor'(uint)
		dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
		dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7C10h
; COMDAT (pick any)
		public ??_C@_08LLGCOLLL@iostream?$AA@
; `string'
??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
					; DATA XREF: std::_Iostream_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7C1Ch
; COMDAT (pick any)
		public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; char `string'[]
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	db 'iostream stream error',0
					; DATA XREF: std::_Iostream_error_category::message(int)+24o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7C34h
; COMDAT (pick largest)
		dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
		public ??_7_System_error_category@std@@6B@
; const	std::_System_error_category::`vftable'
??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_System_error_category::_System_error_category(void)+19o
					; std::_System_error_category::`vector deleting	destructor'(uint)
		dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
		dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
		dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7C50h
; COMDAT (pick any)
		public ??_C@_06FHFOAHML@system?$AA@
; `string'
??_C@_06FHFOAHML@system?$AA@ db	'system',0
					; DATA XREF: std::_System_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 7C58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 7C5Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; std::_Iostream_error_category	std::_Error_objects<int>::_Iostream_object
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 7C60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; std::_System_error_category std::_Error_objects<int>::_System_object
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A dd	?
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7C64h
; COMDAT (pick any)
		public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
; `string'
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+55o
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+55o ...
		unicode	0, <%s>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 7C6Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 7C70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7C74h
; COMDAT (pick any)
		public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+13o
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+19o
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xstring>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7D04h
; COMDAT (pick any)
		public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+27o
					; std::vector<ushort,std::allocator<ushort>>::operator[](uint)+61o ...
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\vector>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7D90h
; COMDAT (pick any)
		public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
; wchar_t `string'
??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+2Co
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+2Co
		unicode	0, <vector subscript out of range>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7DCCh
; COMDAT (pick any)
		public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
; `string'
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@	db 'Standard C++ Libraries Out of Range',0
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+41o
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+41o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7DF0h
; COMDAT (pick any)
		public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
; `string'
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+50o
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+50o ...
		unicode	0, <"Standard C++ Libraries Out	of Range" && 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7E48h
; COMDAT (pick any)
		public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
; `string'
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+91o
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+91o ...
		unicode	0, <"out of range">,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7E68h
; COMDAT (pick any)
		public ??_C@_1JO@FGONLMHN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
; `string'
??_C@_1JO@FGONLMHN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@:
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+8Co
		unicode	0, <std::vector>
		dw 3Ch
		unicode	0, <unsigned short,class std::allocator>
		dw 3Ch
		unicode	0, <unsigned short>
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, <::operator []>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7F08h
; COMDAT (pick any)
		public ??_C@_1MO@LBFDOFFK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAD?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAG?$AAL?$AAY?$AAP?$AAH?$AA_@
; `string'
??_C@_1MO@LBFDOFFK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAD?$AAW?$AAR?$AAI?$AAT?$AAE?$AA_?$AAG?$AAL?$AAY?$AAP?$AAH?$AA_@:
					; DATA XREF: std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+8Co
		unicode	0, <std::vector>
		dw 3Ch
		unicode	0, <struct DWRITE_GLYPH_OFFSET,class std::allocator>
		dw 3Ch
		unicode	0, <struct DWRITE_GLYPH_OFFSET>
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, <::operator []>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7FD8h
; COMDAT (pick any)
		public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
; wchar_t `string'
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+53o
					; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+53o ...
		unicode	0, <vector iterator not	dereferencable>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8020h
; COMDAT (pick any)
		public ??_C@_1MI@FEBILKEM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
; `string'
??_C@_1MI@FEBILKEM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float>>>::operator*(void)+ADo
		unicode	0, <std::_Vector_const_iterator>
		dw 3Ch
		unicode	0, <class std::_Vector_val>
		dw 3Ch
		unicode	0, <struct std::_Simple_types>
		dw 3Ch
		unicode	0, <float>
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, <::operator *>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80E8h
; COMDAT (pick any)
		public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
; char `string'[]
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80F8h
; COMDAT (pick any)
		public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
; char `string'[]
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8110h
; COMDAT (pick any)
		public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; char `string'[]
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
					; DATA XREF: std::vector<ushort,std::allocator<ushort>>::_Xlen(void)+11o
					; std::vector<float,std::allocator<float>>::_Xlen(void)+11o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8124h
; COMDAT (pick any)
		public ??_C@_1NK@FKBBKPEM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
; `string'
??_C@_1NK@FKBBKPEM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<ushort>>>::operator*(void)+ADo
		unicode	0, <std::_Vector_const_iterator>
		dw 3Ch
		unicode	0, <class std::_Vector_val>
		dw 3Ch
		unicode	0, <struct std::_Simple_types>
		dw 3Ch
		unicode	0, <unsigned short>
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, <::operator *>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8200h
; COMDAT (pick any)
		public ??_C@_1PC@GDILINHJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
; `string'
??_C@_1PC@GDILINHJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
					; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DWRITE_GLYPH_OFFSET>>>::operator*(void)+ADo
		unicode	0, <std::_Vector_const_iterator>
		dw 3Ch
		unicode	0, <class std::_Vector_val>
		dw 3Ch
		unicode	0, <struct std::_Simple_types>
		dw 3Ch
		unicode	0, <struct DWRITE_GLYPH_OFFSET>
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, < >
		dw 3Eh
		unicode	0, <::operator *>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 82F4h
; COMDAT (pick any)
		public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; wchar_t `string'
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+14o
					; std::_Debug_pointer<ushort>(ushort *,wchar_t const *,uint)+14o ...
		unicode	0, <invalid null pointer>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8320h
; COMDAT (pick any)
		public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
; wchar_t `string'
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
					; DATA XREF: std::_Debug_range2<ushort *>(ushort *,ushort *,wchar_t const *,uint,std::random_access_iterator_tag)+46o
					; std::_Debug_range2<float *>(float *,float *,wchar_t const *,uint,std::random_access_iterator_tag)+46o ...
		unicode	0, <invalid iterator range>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8350h
; COMDAT (pick any)
		public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::_Uninit_move<ushort,ushort,ushort>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &,ushort *,std::_Scalar_ptr_iterator_tag)+11o
					; std::_Uninit_move<ushort,ushort,ushort>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &,ushort *,std::_Scalar_ptr_iterator_tag)+2Bo ...
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xmemory>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 83E0h
; COMDAT (pick any)
		public ??_R4error_category@std@@6B@
; const	std::error_category::`RTTI Complete Object Locator'
??_R4error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00007BA4o
		dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 83F4h
; COMDAT (pick any)
		public ??_R0?AVerror_category@std@@@8
; class	std::error_category `RTTI Type Descriptor'
??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:000083ECo
					; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?averror_cate	db '.?AVerror_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8418h
; COMDAT (pick any)
		public ??_R3error_category@std@@8
; std::error_category::`RTTI Class Hierarchy Descriptor'
??_R3error_category@std@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:000083F0o
					; .rdata$r:00008448o
		dd 1
		dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8428h
; COMDAT (pick any)
		public ??_R2error_category@std@@8
; std::error_category::`RTTI Base Class	Array'
??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
					; DATA XREF: .rdata$r:00008424o
					; std::error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8430h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@error_category@std@@8
; std::error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
					; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
					; .rdata$r:000084A0o ...
					; std::error_category `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG4890+18h	; "t %s:%d\n"
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 844Ch
; COMDAT (pick any)
		public ??_R4_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`RTTI Complete Object Locator'
??_R4_Generic_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00007BC0o
		dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 8460h
; COMDAT (pick any)
		public ??_R0?AV_Generic_error_category@std@@@8
; class	std::_Generic_error_category `RTTI Type	Descriptor'
??_R0?AV_Generic_error_category@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00008458o
					; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?av_generic_e	db '.?AV_Generic_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 848Ch
; COMDAT (pick any)
		public ??_R3_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Generic_error_category@std@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000845Co
					; .rdata$r:000084C0o
		dd 2
		dd offset ??_R2_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 849Ch
; COMDAT (pick any)
		public ??_R2_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Array'
??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
					; DATA XREF: .rdata$r:00008498o
					; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 84A8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_Generic_error_category@std@@8 dd	offset ??_R0?AV_Generic_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
					; .rdata$r:00008518o ...
					; std::_Generic_error_category `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG4890+18h	; "t %s:%d\n"
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 84C4h
; COMDAT (pick any)
		public ??_R4_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`RTTI Complete Object Locator'
??_R4_Iostream_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00007BF4o
		dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 84D8h
; COMDAT (pick any)
		public ??_R0?AV_Iostream_error_category@std@@@8
; class	std::_Iostream_error_category `RTTI Type Descriptor'
??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000084D0o
					; .rdata$r:std::_Iostream_error_category::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av_iostream_	db '.?AV_Iostream_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8504h
; COMDAT (pick any)
		public ??_R3_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Iostream_error_category@std@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:000084D4o
					; .rdata$r:0000853Co
		dd 3
		dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8514h
; COMDAT (pick any)
		public ??_R2_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Array'
??_R2_Iostream_error_category@std@@8 dd	offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
					; DATA XREF: .rdata$r:00008510o
					; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8524h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset	??_R0?AV_Iostream_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base	Class Array'o
					; std::_Iostream_error_category	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG4890+18h	; "t %s:%d\n"
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8540h
; COMDAT (pick any)
		public ??_R4_System_error_category@std@@6B@
; const	std::_System_error_category::`RTTI Complete Object Locator'
??_R4_System_error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00007C34o
		dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 8554h
; COMDAT (pick any)
		public ??_R0?AV_System_error_category@std@@@8
; class	std::_System_error_category `RTTI Type Descriptor'
??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000854Co
					; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av_system_er	db '.?AV_System_error_category@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8580h
; COMDAT (pick any)
		public ??_R3_System_error_category@std@@8
; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_System_error_category@std@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00008550o
					; .rdata$r:000085B8o
		dd 3
		dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 8590h
; COMDAT (pick any)
		public ??_R2_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Array'
??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
					; DATA XREF: .rdata$r:0000858Co
					; std::_System_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 85A0h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
					; std::_System_error_category `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG4890+18h	; "t %s:%d\n"
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 85BCh
; COMDAT (pick any)
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 85C0h
; COMDAT (pick any)
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 85C4h
; COMDAT (pick any)
		public __real@00000000
__real@00000000	dd 0			; DATA XREF: std::_Uninit_def_fill_n<float,uint,float>(float *,uint,std::_Wrap_alloc<std::allocator<float>> &,float *,std::_Scalar_ptr_iterator_tag)+Br
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 85C8h
; COMDAT (pick any)
		public __xmm@80000000800000008000000080000000
__xmm@80000000800000008000000080000000 xmmword 80000000800000008000000080000000h
					; DATA XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+10Fr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 85D8h
_piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ	; std::`dynamic	initializer for	'piecewise_construct''(void)
_allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer	for 'allocator_arg''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 85E0h
; COMDAT (pick associative to section at 7C58)
; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 85E4h
; COMDAT (pick associative to section at 7C5C)
; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA	dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 85E8h
; COMDAT (pick associative to section at 7C60)
; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset	??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer	for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 85ECh
; COMDAT (pick associative to section at 7C6C)
; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 85F0h
; COMDAT (pick associative to section at 7C70)
; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __purecall:near	; DATA XREF: .rdata:00007BACo
					; .rdata:00007BB0o
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: std::_Allocate<char>(uint,char *)+25p
					; std::_Allocate<ushort>(uint,ushort *)+2Ap ...
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+22p
					; std::_Iostream_error_category::`scalar deleting destructor'(uint)+22p ...
; int __cdecl atexit(void (__cdecl *)())
		extrn _atexit:near	; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
					; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
		extrn __imp___invalid_parameter:near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+96p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+96p ...
; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
		extrn __imp_??0_Lockit@std@@QAE@H@Z:near
					; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+22p
					; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+53p ...
; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit	*__hidden this)
		extrn __imp_??1_Lockit@std@@QAE@XZ:near
					; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
					; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+7Bp ...
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: std::_Uninit_move<ushort,ushort,ushort>(ushort *,ushort *,ushort *,std::_Wrap_alloc<std::allocator<ushort>> &,ushort *,std::_Scalar_ptr_iterator_tag)+57p
					; std::_Uninit_move<float,float,float>(float *,float *,float *,std::_Wrap_alloc<std::allocator<float>> &,float *,std::_Scalar_ptr_iterator_tag)+59p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+25p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer	const &,ID2D1GeometrySink *)+A4p
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: std::char_traits<char>::length(char const *)+22p
		extrn __imp___hypot:near ; CODE	XREF: _hypot+20p
					; DATA XREF: _hypot+20r
		extrn __imp___CrtDbgReportW:near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::operator[](uint)+68p
					; std::vector<DWRITE_GLYPH_OFFSET,std::allocator<DWRITE_GLYPH_OFFSET>>::operator[](uint)+68p ...
; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
		extrn __imp_?_Debug_message@std@@YAXPB_W0I@Z:near
					; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+19p
					; std::_Debug_pointer<ushort>(ushort *,wchar_t const *,uint)+19p ...
; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
		extrn __imp_??0_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14p
					; std::_Vector_val<std::_Simple_types<ushort>>::_Vector_val<std::_Simple_types<ushort>>(void)+14p ...
; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden	this)
		extrn __imp_??1_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14p
					; std::_Vector_val<std::_Simple_types<ushort>>::~_Vector_val<std::_Simple_types<ushort>>(void)+14p ...
; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden	this)
		extrn __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ:near
					; CODE XREF: std::vector<ushort,std::allocator<ushort>>::_Orphan_range(ushort *,ushort *)+5Dp
					; std::vector<float,std::allocator<float>>::_Orphan_range(float	*,float	*)+5Dp	...
; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
		extrn __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28p
					; std::_Vector_alloc<0,std::_Vec_base_types<ushort,std::allocator<ushort>>>::_Free_proxy(void)+28p ...
; void __cdecl std::_Xbad_alloc()
		extrn __imp_?_Xbad_alloc@std@@YAXXZ:near
					; CODE XREF: std::_Allocate<char>(uint,char *)+38p
					; std::_Allocate<ushort>(uint,ushort *)+3Dp ...
; void __cdecl std::_Xlength_error(const char *)
		extrn __imp_?_Xlength_error@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16p
					; std::vector<ushort,std::allocator<ushort>>::_Xlen(void)+16p ...
; void __cdecl std::_Xout_of_range(const char *)
		extrn __imp_?_Xout_of_range@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16r
; _DWORD __thiscall std::locale::id::id(std::locale::id	*__hidden this,	unsigned int)
		extrn __imp_??0id@locale@std@@QAE@I@Z:near
					; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Dp
					; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Dp
					; DATA XREF: ...
; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
		extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::error_category::`vftable'o
; const	char *__cdecl std::_Syserror_map(int)
		extrn __imp_?_Syserror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+15p
					; std::_Generic_error_category::message(int)+28p
					; DATA XREF: ...
; const	char *__cdecl std::_Winerror_map(int)
		extrn __imp_?_Winerror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::message(int)+28p
					; DATA XREF: std::_System_error_category::message(int)+28r
; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ;	weak
					; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
; BOOL __stdcall SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT	fWinIni)
		extrn __imp__SystemParametersInfoA@16:near
					; CODE XREF: mozilla::gfx::GetSystemTextQuality(void)+2Ap
					; mozilla::gfx::GetSystemTextQuality(void)+54p
					; DATA XREF: ...
; public: virtual struct already_AddRefed<class	mozilla::gfx::Path> __thiscall mozilla::gfx::ScaledFontBase::GetPathForGlyphs(struct mozilla::gfx::GlyphBuffer const &,	class mozilla::gfx::DrawTarget const *)
		extrn ?GetPathForGlyphs@ScaledFontBase@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z:near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+85p
; void __thiscall __high mozilla::gfx::ScaledFontBase::CopyGlyphsToBuilder(const struct	mozilla::gfx::GlyphBuffer *, struct mozilla::gfx::PathBuilder *, enum mozilla::gfx::BackendType, const struct mozilla::gfx::Matrix *)
		extrn ?CopyGlyphsToBuilder@ScaledFontBase@gfx@mozilla@@UAEXABUGlyphBuffer@23@PAVPathBuilder@23@W4BackendType@23@PBVMatrix@23@@Z:near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::CopyGlyphsToBuilder(mozilla::gfx::GlyphBuffer const &,mozilla::gfx::PathBuilder *,mozilla::gfx::BackendType,mozilla::gfx::Matrix const *)+37p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+150p
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer const &,ID2D1GeometrySink *)+1C1p	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z+Cp
					; __ehhandler$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z+Cp ...
; __stdcall _CxxThrowException(x, x)
		extrn __CxxThrowException@8:near
					; CODE XREF: __catch$??$_Uninit_def_fill_n@PAUDWRITE_GLYPH_OFFSET@@IV?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAXPAUDWRITE_GLYPH_OFFSET@@IAAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p
					; __catch$??$_Uninit_move@PAUDWRITE_GLYPH_OFFSET@@PAU1@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@U1@@std@@YAPAUDWRITE_GLYPH_OFFSET@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UDWRITE_GLYPH_OFFSET@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+53p
					; mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer const &,mozilla::gfx::DrawTarget const *)+6Dp ...
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$?GetPathForGlyphs@ScaledFontDWrite@gfx@mozilla@@UAE?AU?$already_AddRefed@VPath@gfx@mozilla@@@@ABUGlyphBuffer@23@PBVDrawTarget@23@@Z+16j
					; __ehhandler$?CopyGlyphsToSink@ScaledFontDWrite@gfx@mozilla@@QAEXABUGlyphBuffer@23@PAUID2D1GeometrySink@@@Z+16j ...
; void *__cdecl	memset_0(void *Dst, int	Val, size_t Size)
		extrn _memset_0:near	; CODE XREF: std::allocator<DWRITE_GLYPH_OFFSET>::construct(DWRITE_GLYPH_OFFSET	*)+44p
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
					; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
		extrn ___security_cookie:near
					; DATA XREF: mozilla::gfx::ScaledFontDWrite::GetPathForGlyphs(mozilla::gfx::GlyphBuffer	const &,mozilla::gfx::DrawTarget const *)+27r
					; mozilla::gfx::ScaledFontDWrite::CopyGlyphsToSink(mozilla::gfx::GlyphBuffer const &,ID2D1GeometrySink *)+27r ...
		extrn __fltused:near


		end
