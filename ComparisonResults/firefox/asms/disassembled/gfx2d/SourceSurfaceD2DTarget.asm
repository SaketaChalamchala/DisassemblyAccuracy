;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	98F80E638EC2C0469ECAB02037F56175
; Input	CRC32 :	ED024AD3

; File Name   :	D:\compspace\objfiles\firefox\gfx2d\SourceSurfaceD2DTarget.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "uuid.lib"
; must resolve:	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; must resolve:	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; must resolve:	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; must resolve:	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; must resolve:	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
; char _SG161947[]
$SG161947	db 'Failed to query interface texture to DXGISurface. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+103o
		align 4
; char _SG161963[]
$SG161963	db 'Failed in CreateBitmap. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+34Fo
					; .xdata$x:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5o ...
		align 4
; char _SG161981[]
$SG161981	db 'Failed to QI texture to surface.',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+452o
					; .rdata:00008EC8o ...
		align 10h
; char _SG162010[]
$SG162010	db 'Failed to create D2D render target for texture.',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+5A1o
; char _SG162072[]
$SG162072	db 'Texture map failed with code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+DDo
		align 10h
; char _SG162092[]
$SG162092	db 'Failed to map texture to memory. Code: ',0
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)+AEo
$SG152979	db 'Failed to create Direct2D stroke style.',0
$SG4890		db 'Assertion failure: %s, at %s:%d',0Ah,0
		align 4
$SG4896		db 'Hit MOZ_CRASH(%s) at %s:%d',0Ah,0
; char _SG161626[]
$SG161626	db 'Invalid D3D10 device in D2D target surface (GDS)',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+101o
		align 4
$SG161676	db 'Failed to create staging texture for SourceSurface. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+1FBo
		align 10h
; char _SG161738[]
$SG161738	db 'Invalid D3D10 device in D2D target surface (SRV)',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+69o
		align 4
; char _SG161769[]
$SG161769	db 'Failed to create ShaderResourceView. Code: ',0
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+139o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 230h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mozilla::gfx::BytesPerPixel(enum	mozilla::gfx::SurfaceFormat)
?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+73p
					; mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+11Ap

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 6
		jz	short loc_256
		cmp	byte ptr [ebp+var_4], 7
		jz	short loc_24F
		jmp	short loc_25D
; ---------------------------------------------------------------------------

loc_24F:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+1Bj
		mov	eax, 1
		jmp	short loc_262
; ---------------------------------------------------------------------------

loc_256:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 2
		jmp	short loc_262
; ---------------------------------------------------------------------------

loc_25D:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+1Dj
		mov	eax, 4

loc_262:				; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+24j
					; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+2Bj
		mov	esp, ebp
		pop	ebp
		retn
?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	DXGI_FORMAT __cdecl mozilla::gfx::DXGIFormat(enum  mozilla::gfx::SurfaceFormat)
?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+27p

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 0
		jz	short loc_295
		cmp	byte ptr [ebp+var_4], 1
		jz	short loc_29C
		cmp	byte ptr [ebp+var_4], 7
		jz	short loc_2A3
		jmp	short loc_2AA
; ---------------------------------------------------------------------------

loc_295:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 57h ; 'W'
		jmp	short loc_2AC
; ---------------------------------------------------------------------------

loc_29C:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+1Bj
		mov	eax, 57h ; 'W'
		jmp	short loc_2AC
; ---------------------------------------------------------------------------

loc_2A3:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+21j
		mov	eax, 41h ; 'A'
		jmp	short loc_2AC
; ---------------------------------------------------------------------------

loc_2AA:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+23j
		xor	eax, eax

loc_2AC:				; CODE XREF: mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+2Aj
					; mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)+31j ...
		mov	esp, ebp
		pop	ebp
		retn
?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; enum	D2D1_ALPHA_MODE	__cdecl	mozilla::gfx::D2DAlphaModeForFormat(enum  mozilla::gfx::SurfaceFormat)
?D2DAlphaModeForFormat@gfx@mozilla@@YA?AW4D2D1_ALPHA_MODE@@W4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+19p

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 1
		jz	short loc_2C9
		jmp	short loc_2D0
; ---------------------------------------------------------------------------

loc_2C9:				; CODE XREF: mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 3
		jmp	short loc_2D5
; ---------------------------------------------------------------------------

loc_2D0:				; CODE XREF: mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)+17j
		mov	eax, 1

loc_2D5:				; CODE XREF: mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)+1Ej
		mov	esp, ebp
		pop	ebp
		retn
?D2DAlphaModeForFormat@gfx@mozilla@@YA?AW4D2D1_ALPHA_MODE@@W4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_PIXEL_FORMAT __cdecl mozilla::gfx::D2DPixelFormat(enum  mozilla::gfx::SurfaceFormat)
?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+183p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+26Cp ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		movzx	eax, [ebp+arg_0]
		push	eax
		call	?D2DAlphaModeForFormat@gfx@mozilla@@YA?AW4D2D1_ALPHA_MODE@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DAlphaModeForFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		push	eax
		movzx	ecx, [ebp+arg_0]
		push	ecx
		call	?DXGIFormat@gfx@mozilla@@YA?AW4DXGI_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::DXGIFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		push	eax
		call	?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	; D2D1::PixelFormat(DXGI_FORMAT,D2D1_ALPHA_MODE)
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], edx
		mov	eax, [ebp+var_8]
		mov	edx, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(class	mozilla::gfx::DrawTargetD2D *, struct ID3D10Texture2D *, enum  mozilla::gfx::SurfaceFormat)
		public ??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z
??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z proc near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10] ; this
		call	??0SourceSurface@gfx@mozilla@@QAE@XZ ; mozilla::gfx::SourceSurface::SourceSurface(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurfaceD2DTarget@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurfaceD2DTarget::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??0?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	; RefPtr<ID3D10ShaderResourceView>::RefPtr<ID3D10ShaderResourceView>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::RefPtr<ID2D1Bitmap>(void)
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_10]
		mov	edx, [ebp+arg_0]
		mov	[ecx+18h], edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(ID3D10Texture2D *)
		mov	ecx, [ebp+var_10]
		mov	dl, [ebp+arg_8]
		mov	[ecx+20h], dl
		mov	eax, [ebp+var_10]
		mov	byte ptr [eax+21h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(mozilla::gfx::SourceSurfaceD2DTarget *__hidden this)
		public ??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::`scalar deleting destructor'(uint)+11p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurfaceD2DTarget@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurfaceD2DTarget::`vftable'
		mov	[ebp+var_4], 3
		mov	ecx, [ebp+var_10]
		movzx	edx, byte ptr [ecx+21h]
		test	edx, edx
		jz	short loc_489
		lea	eax, [ebp+var_1C]
		push	eax
		mov	ecx, [ebp+var_10]
		call	?GetSize@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ ; mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)
		mov	esi, [ebp+var_1C]
		imul	esi, [ebp+var_18]
		mov	ecx, [ebp+var_10]
		movzx	edx, byte ptr [ecx+20h]
		push	edx
		call	?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		imul	eax, esi
		cdq
		mov	ecx, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		sub	ecx, eax
		mov	eax, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4 ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		sbb	eax, edx
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA, ecx	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4, eax ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS

loc_489:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+56j
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??1?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	; RefPtr<ID3D10ShaderResourceView>::~RefPtr<ID3D10ShaderResourceView>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10] ; this
		call	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
$LN11		dd 1			; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+D9o
		dd offset $LN10_1
$LN10_1		dd 0FFFFFFE4h, 8	; DATA XREF: .text$mn:000004F4o
		dd offset $LN8		; "size"
$LN8		db 'size',0             ; DATA XREF: .text$mn:00000500o
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> __thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)const
		public ?GetSize@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ
?GetSize@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+5Fp
					; DATA XREF: .rdata:00008EE0o

var_40		= dword	ptr -40h
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 40h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_40]
		mov	ecx, 10h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 1Ch
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_40], eax
		mov	esi, esp
		lea	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_40]
		push	ecx
		mov	edx, [ebp+var_40]
		mov	eax, [edx]
		mov	ecx, [eax+30h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_34]
		push	edx
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z ; mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(int,int)
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?GetSize@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_7		dd 1			; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)+66o
		dd offset $LN4_6
$LN4_6		dd 0FFFFFFC8h, 2Ch	; DATA XREF: .text$mn:000005A4o
		dd offset $LN3_6	; "desc"
$LN3_6		db 'desc',0             ; DATA XREF: .text$mn:000005B0o
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceFormat __thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetFormat(void)const
		public ?GetFormat@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ
?GetFormat@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ proc near
					; DATA XREF: .rdata:00008EE4o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+20h]
		mov	esp, ebp
		pop	ebp
		retn
?GetFormat@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual struct already_AddRefed<class	mozilla::gfx::DataSourceSurface> __thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)
		public ?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ proc near
					; DATA XREF: .rdata:00008EECo

var_15C		= dword	ptr -15Ch
var_158		= dword	ptr -158h
var_154		= dword	ptr -154h
var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
var_148		= dword	ptr -148h
var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_13C		= dword	ptr -13Ch
var_138		= dword	ptr -138h
var_134		= dword	ptr -134h
var_130		= byte ptr -130h
var_12C		= byte ptr -12Ch
var_125		= byte ptr -125h
var_124		= byte ptr -124h
var_120		= byte ptr -120h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_50		= byte ptr -50h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_1C		= byte ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 150h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_15C]
		mov	ecx, 54h ; 'T'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_134], 0
		push	28h ; '('       ; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_60], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_60], 0
		jz	short loc_660
		mov	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax+20h]
		push	ecx
		mov	ecx, [ebp+var_60]
		call	??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z ; mozilla::gfx::DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(mozilla::gfx::SurfaceFormat)
		mov	[ebp+var_138], eax
		jmp	short loc_66A
; ---------------------------------------------------------------------------

loc_660:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+66j
		mov	[ebp+var_138], 0

loc_66A:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+7Ej
		mov	edx, [ebp+var_138]
		mov	[ebp+var_5C], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_5C]
		push	eax
		lea	ecx, [ebp+var_1C]
		call	??0?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(mozilla::gfx::DataSourceSurfaceD2DTarget *)
		mov	[ebp+var_4], 2
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_13C], eax
		mov	esi, esp
		lea	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_13C]
		push	edx
		mov	eax, [ebp+var_13C]
		mov	ecx, [eax]
		mov	edx, [ecx+30h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], 20000h
		mov	[ebp+var_34], 3
		mov	[ebp+var_30], 0
		mov	[ebp+var_28], 0
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		test	eax, eax
		jnz	short loc_75B
		push	offset $SG161626 ; "Invalid D3D10 device in D2D	target surf"...
		push	0FFFFFFFFh
		push	1
		call	?DefaultOptions@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_120]
		call	??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ;	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Log<1,mozilla::gfx::CriticalLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_140], eax
		mov	eax, [ebp+var_140]
		mov	[ebp+var_144], eax
		mov	byte ptr [ebp+var_4], 3
		mov	ecx, [ebp+var_144]
		call	??6?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char const * const)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_120]
		call	??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ;	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::~Log<1,mozilla::gfx::CriticalLogger>(void)
		push	0
		mov	ecx, [ebp+arg_0]
		call	??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z ; already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(void (already_AddRefed<mozilla::gfx::DataSourceSurface>::*)(double,float))
		mov	ecx, [ebp+var_134]
		or	ecx, 1
		mov	[ebp+var_134], ecx
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_1C]
		call	??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
		mov	eax, [ebp+arg_0]
		jmp	loc_8FA
; ---------------------------------------------------------------------------

loc_75B:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+FFj
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		mov	[ebp+var_148], eax
		lea	ecx, [ebp+var_1C]
		call	??C?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ	; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::operator->(void)
		add	eax, 14h
		push	eax
		lea	edx, [ebp+var_124]
		push	edx
		call	??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	; getter_AddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ ; RefPtrGetterAddRefs<ID3D10Texture2D>::operator ID3D10Texture2D * *(void)
		mov	esi, esp
		push	eax
		push	0
		lea	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+var_148]
		push	ecx
		mov	edx, [ebp+var_148]
		mov	eax, [edx]
		mov	ecx, [eax+124h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		cmp	[ebp+var_58], 0
		jge	loc_84F
		mov	edx, 1
		test	edx, edx
		jz	short loc_7C7
		jmp	short loc_822
; ---------------------------------------------------------------------------

loc_7C7:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+1E3j
		mov	eax, [ebp+var_58]
		push	eax
		lea	ecx, [ebp+var_12C]
		push	ecx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		push	eax
		push	offset $SG161676 ; "Failed to create staging texture for So"...
		lea	ecx, [ebp+var_125] ; this
		call	??0NoLog@gfx@mozilla@@QAE@XZ ; mozilla::gfx::NoLog::NoLog(void)
		mov	[ebp+var_14C], eax
		mov	edx, [ebp+var_14C]
		mov	[ebp+var_150], edx
		mov	byte ptr [ebp+var_4], 4
		mov	ecx, [ebp+var_150]
		call	??$?6$$BY0DL@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0DL@$$CBD@Z ; mozilla::gfx::NoLog::operator<<<char const [59]>(char const (&)[59])
		mov	ecx, eax
		call	??$?6U?$Hexa@J@gfx@mozilla@@@NoLog@gfx@mozilla@@QAEAAV012@ABU?$Hexa@J@12@@Z ; mozilla::gfx::NoLog::operator<<<mozilla::gfx::Hexa<long>>(mozilla::gfx::Hexa<long> const &)
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_125] ; this
		call	??1NoLog@gfx@mozilla@@QAE@XZ ; mozilla::gfx::NoLog::~NoLog(void)

loc_822:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+1E5j
		push	0
		mov	ecx, [ebp+arg_0]
		call	??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z ; already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(void (already_AddRefed<mozilla::gfx::DataSourceSurface>::*)(double,float))
		mov	eax, [ebp+var_134]
		or	eax, 1
		mov	[ebp+var_134], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_1C]
		call	??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
		mov	eax, [ebp+arg_0]
		jmp	loc_8FA
; ---------------------------------------------------------------------------

loc_84F:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+1D6j
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		mov	[ebp+var_154], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_1C]
		call	??C?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ	; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::operator->(void)
		add	eax, 14h
		mov	ecx, eax
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		push	eax
		mov	ecx, [ebp+var_154]
		push	ecx
		mov	edx, [ebp+var_154]
		mov	eax, [edx]
		mov	ecx, [eax+84h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	edx, [ebp+var_130]
		push	edx
		lea	ecx, [ebp+var_1C]
		call	?forget@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@XZ ; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::forget(void)
		mov	[ebp+var_158], eax
		mov	eax, [ebp+var_158]
		mov	[ebp+var_15C], eax
		mov	byte ptr [ebp+var_4], 5
		mov	ecx, [ebp+var_15C]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??$?0VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@@Z ;	already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>	&&)
		mov	edx, [ebp+var_134]
		or	edx, 1
		mov	[ebp+var_134], edx
		mov	byte ptr [ebp+var_4], 2
		lea	ecx, [ebp+var_130]
		call	??1?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ	; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>::~already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_1C]
		call	??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
		mov	eax, [ebp+arg_0]

loc_8FA:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+176j
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+26Aj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 15Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ endp

; ---------------------------------------------------------------------------
		align 4
$LN20_0		dd 2			; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+31Eo
		dd offset $LN19_0
$LN19_0		dd 0FFFFFFE4h, 4	; DATA XREF: .text$mn:0000093Co
		dd offset $LN16_0	; "dataSurf"
		dd 0FFFFFFB0h, 2Ch
		dd offset $LN17_1	; "desc"
$LN17_1		db 'desc',0             ; DATA XREF: .text$mn:00000954o
$LN16_0		db 'dataSurf',0         ; DATA XREF: .text$mn:00000948o
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetNativeSurface(enum	 mozilla::gfx::NativeSurfaceType)
		public ?GetNativeSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z
?GetNativeSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z proc near
					; DATA XREF: .rdata:00008EF0o

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_991
		mov	ecx, [ebp+var_4]
		add	ecx, 1Ch
		call	?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::get(void)
		jmp	short loc_993
; ---------------------------------------------------------------------------

loc_991:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetNativeSurface(mozilla::gfx::NativeSurfaceType)+12j
		xor	eax, eax

loc_993:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetNativeSurface(mozilla::gfx::NativeSurfaceType)+1Fj
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?GetNativeSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct ID2D1Bitmap *__thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(mozilla::gfx::SourceSurfaceD2DTarget *this, struct ID2D1RenderTarget *)
		public ?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z
?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z proc	near

var_4CC		= dword	ptr -4CCh
var_4C8		= dword	ptr -4C8h
var_4C4		= dword	ptr -4C4h
var_4C0		= dword	ptr -4C0h
var_4B0		= dword	ptr -4B0h
var_4AC		= dword	ptr -4ACh
var_4A8		= dword	ptr -4A8h
var_4A4		= dword	ptr -4A4h
var_4A0		= dword	ptr -4A0h
var_49C		= dword	ptr -49Ch
var_498		= dword	ptr -498h
var_494		= dword	ptr -494h
var_490		= dword	ptr -490h
var_48C		= dword	ptr -48Ch
var_488		= dword	ptr -488h
var_484		= dword	ptr -484h
var_480		= dword	ptr -480h
var_47C		= byte ptr -47Ch
var_3BC		= byte ptr -3BCh
var_3B8		= byte ptr -3B8h
var_39C		= dword	ptr -39Ch
var_398		= dword	ptr -398h
var_394		= dword	ptr -394h
var_390		= byte ptr -390h
var_2D0		= byte ptr -2D0h
var_2CC		= dword	ptr -2CCh
var_2C8		= byte ptr -2C8h
var_2C4		= byte ptr -2C4h
var_204		= dword	ptr -204h
var_200		= dword	ptr -200h
var_1FC		= byte ptr -1FCh
var_1EC		= dword	ptr -1ECh
var_1E8		= dword	ptr -1E8h
var_1E4		= byte ptr -1E4h
var_1E0		= byte ptr -1E0h
var_1DC		= byte ptr -1DCh
var_1CC		= dword	ptr -1CCh
var_1C8		= dword	ptr -1C8h
var_1C4		= dword	ptr -1C4h
var_1C0		= byte ptr -1C0h
var_1BC		= byte ptr -1BCh
var_FC		= byte ptr -0FCh
var_F8		= byte ptr -0F8h
var_D8		= byte ptr -0D8h
var_B4		= byte ptr -0B4h
var_A8		= byte ptr -0A8h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
var_98		= dword	ptr -98h
var_94		= dword	ptr -94h
var_90		= dword	ptr -90h
var_8C		= dword	ptr -8Ch
var_88		= dword	ptr -88h
var_84		= dword	ptr -84h
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_64		= byte ptr -64h
var_58		= byte ptr -58h
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 4A4h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_4B0]
		mov	ecx, 129h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		test	eax, eax
		jz	short loc_A13
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		jmp	loc_108A
; ---------------------------------------------------------------------------

loc_A13:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+51j
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_48C], eax
		mov	esi, esp
		lea	eax, [ebp+var_48]
		push	eax
		mov	ecx, [ebp+var_48C]
		push	ecx
		mov	edx, [ebp+var_48C]
		mov	eax, [edx]
		mov	ecx, [eax+30h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+var_48]
		push	eax
		lea	ecx, [ebp+var_58]
		call	??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z ; mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(int,int)
		lea	ecx, [ebp+var_64]
		call	??0?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::RefPtr<IDXGISurface>(void)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_64]
		push	ecx
		lea	edx, [ebp+var_FC]
		push	edx
		call	??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z ; getter_AddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ ; RefPtrGetterAddRefs<IDXGISurface>::operator IDXGISurface *	*(void)
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		push	eax
		call	??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z ;	IUnknown::QueryInterface<IDXGISurface>(IDXGISurface * *)
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_B2B
		mov	eax, [ebp+var_18]
		push	eax
		lea	ecx, [ebp+var_1C0]
		push	ecx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	edx, [eax]
		push	edx
		push	offset $SG161947 ; "Failed to query interface texture to DX"...
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_1BC]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_490], eax
		mov	eax, [ebp+var_490]
		mov	[ebp+var_494], eax
		mov	byte ptr [ebp+var_4], 1
		mov	ecx, [ebp+var_494]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_1BC]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	[ebp+var_1C4], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_64]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	eax, [ebp+var_1C4]
		jmp	loc_108A
; ---------------------------------------------------------------------------

loc_B2B:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+E7j
		mov	ecx, [ebp+var_14]
		movzx	edx, byte ptr [ecx+20h]
		push	edx
		call	?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		mov	[ebp+var_1CC], eax
		mov	[ebp+var_1C8], edx
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+4C0h+var_4C0], xmm0
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+4C4h+var_4C4], xmm0
		lea	eax, [ebp+var_1CC]
		push	eax
		lea	ecx, [ebp+var_1DC]
		push	ecx
		call	?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	; D2D1::BitmapProperties(D2D1_PIXEL_FORMAT const &,float,float)
		add	esp, 10h
		mov	edx, [eax]
		mov	[ebp+var_90], edx
		mov	ecx, [eax+4]
		mov	[ebp+var_8C], ecx
		mov	edx, [eax+8]
		mov	[ebp+var_88], edx
		mov	eax, [eax+0Ch]
		mov	[ebp+var_84], eax
		mov	ecx, [ebp+var_90]
		mov	[ebp+var_7C], ecx
		mov	edx, [ebp+var_8C]
		mov	[ebp+var_78], edx
		mov	eax, [ebp+var_88]
		mov	[ebp+var_74], eax
		mov	ecx, [ebp+var_84]
		mov	[ebp+var_70], ecx
		mov	edx, [ebp+var_14]
		add	edx, 14h
		push	edx
		lea	eax, [ebp+var_1E0]
		push	eax
		call	??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z ; getter_AddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ ; RefPtrGetterAddRefs<ID2D1Bitmap>::operator ID2D1Bitmap * *(void)
		mov	esi, esp
		push	eax
		lea	ecx, [ebp+var_7C]
		push	ecx
		lea	ecx, [ebp+var_64]
		call	??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ ; RefPtr<IDXGISurface>::operator IDXGISurface *(void)
		push	eax
		push	offset _IID_IDXGISurface
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [eax+18h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_1064
		mov	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax+20h]
		push	ecx
		call	?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		mov	[ebp+var_1EC], eax
		mov	[ebp+var_1E8], edx
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+4C0h+var_4C0], xmm0
		push	ecx
		movss	xmm0, ds:__real@42c00000
		movss	[esp+4C4h+var_4C4], xmm0
		lea	edx, [ebp+var_1EC]
		push	edx
		lea	eax, [ebp+var_1FC]
		push	eax
		call	?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	; D2D1::BitmapProperties(D2D1_PIXEL_FORMAT const &,float,float)
		add	esp, 10h
		mov	ecx, [eax]
		mov	[ebp+var_A0], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_9C], edx
		mov	ecx, [eax+8]
		mov	[ebp+var_98], ecx
		mov	edx, [eax+0Ch]
		mov	[ebp+var_94], edx
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_48]
		push	ecx
		call	?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z ; D2D1::SizeU(uint,uint)
		add	esp, 8
		mov	[ebp+var_204], eax
		mov	[ebp+var_200], edx
		mov	edx, [ebp+var_14]
		add	edx, 14h
		push	edx
		lea	eax, [ebp+var_1E4]
		push	eax
		call	??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z ; getter_AddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ ; RefPtrGetterAddRefs<ID2D1Bitmap>::operator ID2D1Bitmap * *(void)
		push	eax
		lea	ecx, [ebp+var_A0]
		push	ecx
		mov	edx, [ebp+var_200]
		push	edx
		mov	eax, [ebp+var_204]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z ; ID2D1RenderTarget::CreateBitmap(D2D_SIZE_U,D2D1_BITMAP_PROPERTIES const &,ID2D1Bitmap * *)
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_D77
		mov	ecx, [ebp+var_18]
		push	ecx
		lea	edx, [ebp+var_2C8]
		push	edx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	eax, [eax]
		push	eax
		push	offset $SG161963 ; "Failed in CreateBitmap. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_2C4]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_498], eax
		mov	ecx, [ebp+var_498]
		mov	[ebp+var_49C], ecx
		mov	byte ptr [ebp+var_4], 2
		mov	ecx, [ebp+var_49C]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_2C4]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	[ebp+var_2CC], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_64]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	eax, [ebp+var_2CC]
		jmp	loc_108A
; ---------------------------------------------------------------------------

loc_D77:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+333j
		lea	ecx, [ebp+var_A8]
		call	??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::RefPtr<ID2D1RenderTarget>(void)
		mov	byte ptr [ebp+var_4], 3
		mov	edx, [ebp+var_14]
		cmp	dword ptr [edx+18h], 0
		jz	short loc_DA4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+18h]
		add	ecx, 64h ; 'd'
		push	ecx
		lea	ecx, [ebp+var_A8]
		call	??4?$RefPtr@UID2D1RenderTarget@@@@QAEAAV0@ABV0@@Z ; RefPtr<ID2D1RenderTarget>::operator=(RefPtr<ID2D1RenderTarget> const &)

loc_DA4:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+3DDj
		lea	ecx, [ebp+var_A8]
		call	??B?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator ID2D1RenderTarget *(void)
		test	eax, eax
		jnz	loc_FEF
		lea	ecx, [ebp+var_B4]
		call	??0?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 4
		lea	edx, [ebp+var_B4]
		push	edx
		lea	eax, [ebp+var_2D0]
		push	eax
		call	??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z ; getter_AddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ ; RefPtrGetterAddRefs<IDXGISurface>::operator IDXGISurface *	*(void)
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		push	eax
		call	??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z ;	IUnknown::QueryInterface<IDXGISurface>(IDXGISurface * *)
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_E91
		push	offset $SG161981 ; "Failed to QI texture to surface."
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_390]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_4A0], eax
		mov	ecx, [ebp+var_4A0]
		mov	[ebp+var_4A4], ecx
		mov	byte ptr [ebp+var_4], 5
		mov	ecx, [ebp+var_4A4]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_390]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	[ebp+var_394], 0
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_B4]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_A8]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_64]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	eax, [ebp+var_394]
		jmp	loc_108A
; ---------------------------------------------------------------------------

loc_E91:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+44Cj
		mov	edx, [ebp+var_14]
		movzx	eax, byte ptr [edx+20h]
		push	eax
		call	?D2DPixelFormat@gfx@mozilla@@YA?AUD2D1_PIXEL_FORMAT@@W4SurfaceFormat@12@@Z ; mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		mov	[ebp+var_39C], eax
		mov	[ebp+var_398], edx
		push	0
		push	0
		push	ecx
		movss	xmm0, ds:__real@00000000
		movss	[esp+4C8h+var_4C8], xmm0
		push	ecx
		movss	xmm0, ds:__real@00000000
		movss	[esp+4CCh+var_4CC], xmm0
		lea	ecx, [ebp+var_39C]
		push	ecx
		push	0
		lea	edx, [ebp+var_3B8]
		push	edx
		call	?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z ; D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE,D2D1_PIXEL_FORMAT const &,float,float,D2D1_RENDER_TARGET_USAGE,D2D1_FEATURE_LEVEL)
		add	esp, 1Ch
		mov	ecx, 7
		mov	esi, eax
		lea	edi, [ebp+var_F8]
		rep movsd
		mov	ecx, 7
		lea	esi, [ebp+var_F8]
		lea	edi, [ebp+var_D8]
		rep movsd
		lea	eax, [ebp+var_A8]
		push	eax
		lea	ecx, [ebp+var_3BC]
		push	ecx
		call	??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z ;	getter_AddRefs<ID2D1RenderTarget>(RefPtr<ID2D1RenderTarget> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ ; RefPtrGetterAddRefs<ID2D1RenderTarget>::operator	ID2D1RenderTarget * *(void)
		push	eax		; struct ID2D1RenderTarget **
		lea	edx, [ebp+var_D8]
		push	edx		; struct D2D1_RENDER_TARGET_PROPERTIES *
		lea	ecx, [ebp+var_B4]
		call	??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ ; RefPtr<IDXGISurface>::operator IDXGISurface *(void)
		push	eax		; struct IDXGISurface *
		call	?factory@DrawTargetD2D@gfx@mozilla@@SAPAUID2D1Factory@@XZ ; mozilla::gfx::DrawTargetD2D::factory(void)
		mov	ecx, eax	; this
		call	?CreateDxgiSurfaceRenderTarget@ID2D1Factory@@QAEJPAUIDXGISurface@@ABUD2D1_RENDER_TARGET_PROPERTIES@@PAPAUID2D1RenderTarget@@@Z ; ID2D1Factory::CreateDxgiSurfaceRenderTarget(IDXGISurface *,D2D1_RENDER_TARGET_PROPERTIES const	&,ID2D1RenderTarget * *)
		mov	[ebp+var_18], eax
		cmp	[ebp+var_18], 0
		jge	loc_FE0
		push	offset $SG162010 ; "Failed to create D2D render	target for "...
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_47C]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_4A8], eax
		mov	eax, [ebp+var_4A8]
		mov	[ebp+var_4AC], eax
		mov	byte ptr [ebp+var_4], 6
		mov	ecx, [ebp+var_4AC]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	byte ptr [ebp+var_4], 4
		lea	ecx, [ebp+var_47C]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		mov	[ebp+var_480], 0
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_B4]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_A8]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_64]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	eax, [ebp+var_480]
		jmp	loc_108A
; ---------------------------------------------------------------------------

loc_FE0:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+59Bj
		mov	byte ptr [ebp+var_4], 3
		lea	ecx, [ebp+var_B4]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)

loc_FEF:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+401j
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator->(void)
		mov	[ebp+var_4B0], eax
		mov	esi, esp
		push	0
		lea	ecx, [ebp+var_A8]
		call	??B?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::operator ID2D1RenderTarget *(void)
		push	eax
		push	0
		mov	ecx, [ebp+var_4B0]
		push	ecx
		mov	edx, [ebp+var_4B0]
		mov	eax, [edx]
		mov	ecx, [eax+24h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		mov	[ebp+var_484], eax
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_A8]
		call	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_64]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	eax, [ebp+var_484]
		jmp	short loc_108A
; ---------------------------------------------------------------------------

loc_1064:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+25Ej
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)
		mov	[ebp+var_488], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_64]
		call	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
		mov	eax, [ebp+var_488]

loc_108A:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+5Ej
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+176j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN27
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 4B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN27		dd 7			; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+6DEo
		dd offset $LN26
$LN26		dd 0FFFFFFB8h, 2Ch	; DATA XREF: .text$mn:000010CCo
		dd offset $LN18_0	; "desc"
		dd 0FFFFFFA8h, 8
		dd offset $LN19_1	; "size"
		dd 0FFFFFF9Ch, 4
		dd offset $LN20_1	; "surf"
		dd 0FFFFFF84h, 10h
		dd offset $LN21		; "props"
		dd 0FFFFFF58h, 4
		dd offset $LN22_0	; "rt"
		dd 0FFFFFF4Ch, 4
		dd offset $LN23_0	; "surface"
		dd 0FFFFFF28h, 1Ch
		dd offset $LN24		; "props"
$LN24		db 'props',0            ; DATA XREF: .text$mn:00001120o
$LN23_0		db 'surface',0          ; DATA XREF: .text$mn:00001114o
$LN22_0		db 'rt',0               ; DATA XREF: .text$mn:00001108o
$LN21		db 'props',0            ; DATA XREF: .text$mn:000010FCo
$LN20_1		db 'surf',0             ; DATA XREF: .text$mn:000010F0o
$LN19_1		db 'size',0             ; DATA XREF: .text$mn:000010E4o
$LN18_0		db 'desc',0             ; DATA XREF: .text$mn:000010D8o
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct ID3D10ShaderResourceView *__thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(mozilla::gfx::SourceSurfaceD2DTarget *__hidden this)
		public ?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ
?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ proc near

var_1B0		= dword	ptr -1B0h
var_1AC		= dword	ptr -1ACh
var_1A8		= dword	ptr -1A8h
var_1A4		= dword	ptr -1A4h
var_1A0		= dword	ptr -1A0h
var_19C		= byte ptr -19Ch
var_198		= byte ptr -198h
var_D8		= byte ptr -0D8h
var_D4		= byte ptr -0D4h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 1A4h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1B0]
		mov	ecx, 69h ; 'i'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??B?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ ; RefPtr<ID3D10ShaderResourceView>::operator ID3D10ShaderResourceView *(void)
		test	eax, eax
		jz	short loc_11B0
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??B?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ ; RefPtr<ID3D10ShaderResourceView>::operator ID3D10ShaderResourceView *(void)
		jmp	loc_12EE
; ---------------------------------------------------------------------------

loc_11B0:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+4Ej
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		test	eax, eax
		jnz	short loc_1213
		push	offset $SG161738 ; "Invalid D3D10 device in D2D	target surf"...
		push	0FFFFFFFFh
		push	1
		call	?DefaultOptions@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_D4]
		call	??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ;	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Log<1,mozilla::gfx::CriticalLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_1A0], eax
		mov	eax, [ebp+var_1A0]
		mov	[ebp+var_1A4], eax
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_1A4]
		call	??6?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char const * const)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_D4]
		call	??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ;	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::~Log<1,mozilla::gfx::CriticalLogger>(void)
		xor	eax, eax
		jmp	loc_12EE
; ---------------------------------------------------------------------------

loc_1213:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+67j
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		mov	[ebp+var_1A8], eax
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		push	ecx
		lea	edx, [ebp+var_D8]
		push	edx
		call	??$getter_AddRefs@UID3D10ShaderResourceView@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z ; getter_AddRefs<ID3D10ShaderResourceView>(RefPtr<ID3D10ShaderResourceView> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ ; RefPtrGetterAddRefs<ID3D10ShaderResourceView>::operator ID3D10ShaderResourceView *	*(void)
		mov	esi, esp
		push	eax
		push	0
		mov	ecx, [ebp+var_10]
		add	ecx, 1Ch
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		push	eax
		mov	eax, [ebp+var_1A8]
		push	eax
		mov	ecx, [ebp+var_1A8]
		mov	edx, [ecx]
		mov	eax, [edx+12Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_12E3
		mov	ecx, [ebp+var_14]
		push	ecx
		lea	edx, [ebp+var_19C]
		push	edx
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	eax, [eax]
		push	eax
		push	offset $SG161769 ; "Failed to create ShaderResourceView. Co"...
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_198]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_1AC]
		mov	[ebp+var_1B0], ecx
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_1B0]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_198]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)

loc_12E3:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+121j
		mov	ecx, [ebp+var_10]
		add	ecx, 10h
		call	??B?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ ; RefPtr<ID3D10ShaderResourceView>::operator ID3D10ShaderResourceView *(void)

loc_12EE:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+5Bj
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+BEj
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 1B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(mozilla::gfx::SourceSurfaceD2DTarget *__hidden this)
		public ?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ proc near

var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= byte ptr -58h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_28		= dword	ptr -28h
var_1C		= byte ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 58h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_64]
		mov	ecx, 16h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		add	eax, 1Ch
		push	eax
		lea	ecx, [ebp+var_1C]
		call	??0?$RefPtr@UID3D10Texture2D@@@@QAE@ABV0@@Z ; RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> const &)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_5C], eax
		mov	esi, esp
		lea	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_5C]
		push	edx
		mov	eax, [ebp+var_5C]
		mov	ecx, [eax]
		mov	edx, [ecx+30h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_28], 0
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		mov	[ebp+var_60], eax
		mov	eax, [ebp+var_14]
		add	eax, 1Ch
		push	eax
		lea	ecx, [ebp+var_58]
		push	ecx
		call	??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	; getter_AddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)
		add	esp, 8
		mov	ecx, eax
		call	??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ ; RefPtrGetterAddRefs<ID3D10Texture2D>::operator ID3D10Texture2D * *(void)
		mov	esi, esp
		push	eax
		push	0
		lea	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+var_60]
		mov	edx, [ecx]
		mov	eax, [edx+124h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		call	?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ ; mozilla::gfx::Factory::GetDirect3D10Device(void)
		mov	[ebp+var_64], eax
		lea	ecx, [ebp+var_1C]
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1Ch
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		push	eax
		mov	ecx, [ebp+var_64]
		push	ecx
		mov	edx, [ebp+var_64]
		mov	eax, [edx]
		mov	ecx, [eax+84h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0
		mov	ecx, [ebp+var_14]
		add	ecx, 14h
		call	??4?$RefPtr@UID2D1Bitmap@@@@QAEAAV0@PAUID2D1Bitmap@@@Z ; RefPtr<ID2D1Bitmap>::operator=(ID2D1Bitmap *)
		mov	esi, [ebp+var_50]
		imul	esi, [ebp+var_4C]
		mov	edx, [ebp+var_14]
		movzx	eax, byte ptr [edx+20h]
		push	eax
		call	?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		imul	esi, eax
		xor	ecx, ecx
		add	esi, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		adc	ecx, dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4 ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA, esi	; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	dword ptr ds:?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA+4, ecx ; unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		mov	edx, [ebp+var_14]
		mov	byte ptr [edx+21h], 1
		mov	ecx, [ebp+var_14] ; this
		call	?MarkIndependent@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ ; mozilla::gfx::SourceSurfaceD2DTarget::MarkIndependent(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_1C]
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 64h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN8_0		dd 2			; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+161o
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFE4h, 4	; DATA XREF: .text$mn:000014A8o
		dd offset $LN4_7	; "oldTexture"
		dd 0FFFFFFB0h, 2Ch
		dd offset $LN5_8	; "desc"
$LN5_8		db 'desc',0             ; DATA XREF: .text$mn:000014C0o
$LN4_7		db 'oldTexture',0       ; DATA XREF: .text$mn:000014B4o
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::SourceSurfaceD2DTarget::MarkIndependent(mozilla::gfx::SourceSurfaceD2DTarget *__hidden this)
		public ?MarkIndependent@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
?MarkIndependent@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+149p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_1518

loc_14F7:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::MarkIndependent(void)+19j
		xor	ecx, ecx
		jnz	short loc_14F7
		push	0
		mov	edx, [ebp+var_4]
		mov	ecx, [edx+18h]
		add	ecx, 0A8h ; ''
		call	??4?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEAAV0@PAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::operator=(mozilla::gfx::SourceSurfaceD2DTarget *)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+18h], 0

loc_1518:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::MarkIndependent(void)+15j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?MarkIndependent@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(enum	mozilla::gfx::SurfaceFormat)
		public ??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z
??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+73p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10] ; this
		call	??0DataSourceSurface@gfx@mozilla@@QAE@XZ ; mozilla::gfx::DataSourceSurface::DataSourceSurface(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@	; const	mozilla::gfx::DataSourceSurfaceD2DTarget::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(void)
		mov	ecx, [ebp+var_10]
		mov	dl, [ebp+arg_0]
		mov	[ecx+18h], dl
		mov	eax, [ebp+var_10]
		mov	byte ptr [eax+24h], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget(mozilla::gfx::DataSourceSurfaceD2DTarget *__hidden this)
		public ??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::`scalar deleting	destructor'(uint)+11p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		push	esi
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@	; const	mozilla::gfx::DataSourceSurfaceD2DTarget::`vftable'
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		movzx	edx, byte ptr [ecx+24h]
		test	edx, edx
		jz	short loc_1639
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_14], eax
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1639:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget(void)+50j
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10] ; this
		call	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::GetSize(void)const
		public ?GetSize@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ
?GetSize@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ	proc near
					; DATA XREF: .rdata:00008F04o

var_40		= dword	ptr -40h
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 40h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_40]
		mov	ecx, 10h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_40], eax
		mov	esi, esp
		lea	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_40]
		push	ecx
		mov	edx, [ebp+var_40]
		mov	eax, [edx]
		mov	ecx, [eax+30h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_34]
		push	edx
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z ; mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(int,int)
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?GetSize@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_9		dd 1			; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::GetSize(void)+66o
		dd offset $LN4_8
$LN4_8		dd 0FFFFFFC8h, 2Ch	; DATA XREF: .text$mn:00001714o
		dd offset $LN3_7	; "desc"
$LN3_7		db 'desc',0             ; DATA XREF: .text$mn:00001720o
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceFormat __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::GetFormat(void)const
		public ?GetFormat@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ
?GetFormat@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ proc near
					; DATA XREF: .rdata:00008F08o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+18h]
		mov	esp, ebp
		pop	ebp
		retn
?GetFormat@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int8 *__thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::GetData(mozilla::gfx::DataSourceSurfaceD2DTarget *__hidden this)
		public ?GetData@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAEXZ
?GetData@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAEXZ proc near
					; DATA XREF: .rdata:00008F1Co

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)
		mov	eax, [ebp+var_4]
		mov	eax, [eax+1Ch]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GetData@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAEXZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::Stride(mozilla::gfx::DataSourceSurfaceD2DTarget *__hidden this)
		public ?Stride@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEHXZ
?Stride@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEHXZ proc near
					; DATA XREF: .rdata:00008F20o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)
		mov	eax, [ebp+var_4]
		mov	eax, [eax+20h]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Stride@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEHXZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual bool __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::Map(enum  mozilla::gfx::DataSourceSurface::MapType,	struct mozilla::gfx::DataSourceSurface::MappedSurface *)
		public ?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z proc near
					; DATA XREF: .rdata:00008F24o

var_FC		= dword	ptr -0FCh
var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_F0		= dword	ptr -0F0h
var_EC		= byte ptr -0ECh
var_E8		= byte ptr -0E8h
var_28		= dword	ptr -28h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F0h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx

loc_17F1:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+43j
		xor	eax, eax
		jnz	short loc_17F1

loc_17F5:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+47j
		xor	ecx, ecx
		jnz	short loc_17F5
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)
		test	eax, eax
		jnz	short loc_180F
		xor	al, al
		jmp	loc_192C
; ---------------------------------------------------------------------------

loc_180F:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+56j
		cmp	[ebp+arg_0], 0
		jnz	short loc_181E
		mov	[ebp+var_14], 1
		jmp	short loc_1834
; ---------------------------------------------------------------------------

loc_181E:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+63j
		cmp	[ebp+arg_0], 1
		jnz	short loc_182D
		mov	[ebp+var_14], 2
		jmp	short loc_1834
; ---------------------------------------------------------------------------

loc_182D:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+72j
		mov	[ebp+var_14], 3

loc_1834:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+6Cj
					; mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface	*)+7Bj
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_F0], eax
		mov	esi, esp
		lea	edx, [ebp+var_20]
		push	edx
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		push	0
		mov	ecx, [ebp+var_F0]
		push	ecx
		mov	edx, [ebp+var_F0]
		mov	eax, [edx]
		mov	ecx, [eax+28h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_28], eax
		cmp	[ebp+var_28], 0
		jge	short loc_18EB
		mov	edx, [ebp+var_28]
		push	edx
		lea	eax, [ebp+var_EC]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162072 ; "Texture map	failed with code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_E8]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_F4], eax
		mov	edx, [ebp+var_F4]
		mov	[ebp+var_F8], edx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_F8]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_E8]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		xor	al, al
		jmp	short loc_192C
; ---------------------------------------------------------------------------

loc_18EB:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+C5j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+var_1C]
		mov	[edx+4], eax
		mov	ecx, [ebp+arg_4]
		cmp	dword ptr [ecx], 0
		jz	short loc_1910
		mov	[ebp+var_FC], 1
		jmp	short loc_191A
; ---------------------------------------------------------------------------

loc_1910:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+152j
		mov	[ebp+var_FC], 0

loc_191A:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+15Ej
		mov	edx, [ebp+var_10]
		mov	al, byte ptr [ebp+var_FC]
		mov	[edx+10h], al
		mov	ecx, [ebp+var_10]
		mov	al, [ecx+10h]

loc_192C:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+5Aj
					; mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface	*)+139j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN21_0		dd 1			; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+180o
		dd offset $LN20_2
$LN20_2		dd 0FFFFFFE0h, 8	; DATA XREF: .text$mn:00001964o
		dd offset $LN18_1
$LN18_1		dd 70616Dh, 2 dup(0CCCCCCCCh) ;	DATA XREF: .text$mn:00001970o

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::Unmap(mozilla::gfx::DataSourceSurfaceD2DTarget *__hidden this)
		public ?Unmap@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEXXZ
?Unmap@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEXXZ proc near
					; DATA XREF: .rdata:00008F28o

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_1998:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Unmap(void)+1Aj
		xor	eax, eax
		jnz	short loc_1998
		mov	ecx, [ebp+var_4]
		mov	byte ptr [ecx+10h], 0
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_8], eax
		mov	esi, esp
		push	0
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ecx+2Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Unmap@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(mozilla::gfx::DataSourceSurfaceD2DTarget *__hidden this)
		public ?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::GetData(void)+11p
					; mozilla::gfx::DataSourceSurfaceD2DTarget::Stride(void)+11p

var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_D8		= byte ptr -0D8h
var_D4		= byte ptr -0D4h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx

loc_1A21:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)+43j
		xor	eax, eax
		jnz	short loc_1A21
		mov	ecx, [ebp+var_10]
		movzx	edx, byte ptr [ecx+24h]
		test	edx, edx
		jnz	loc_1AF1
		mov	ecx, [ebp+var_10]
		add	ecx, 14h
		call	??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::operator->(void)
		mov	[ebp+var_DC], eax
		mov	eax, [ebp+var_10]
		add	eax, 1Ch
		mov	esi, esp
		push	eax
		push	0
		push	1
		push	0
		mov	ecx, [ebp+var_DC]
		push	ecx
		mov	edx, [ebp+var_DC]
		mov	eax, [edx]
		mov	ecx, [eax+28h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_1AEA
		mov	edx, [ebp+var_14]
		push	edx
		lea	eax, [ebp+var_D8]
		push	eax
		call	??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z ; mozilla::gfx::hexa<long>(long)
		add	esp, 8
		mov	ecx, [eax]
		push	ecx
		push	offset $SG162092 ; "Failed to map texture to memory. Code: "
		push	0FFFFFFFFh
		push	0
		call	?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		add	esp, 4
		push	eax
		lea	ecx, [ebp+var_D4]
		call	??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)
		mov	[ebp+var_E0], eax
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_E4], edx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_E4]
		call	??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)
		mov	ecx, eax
		call	??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_D4]
		call	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
		jmp	short loc_1AF1
; ---------------------------------------------------------------------------

loc_1AEA:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)+96j
		mov	eax, [ebp+var_10]
		mov	byte ptr [eax+24h], 1

loc_1AF1:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)+4Ej
					; mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)+108j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 1B10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$0 proc	near
					; DATA XREF: .xdata$x:00008888o
		mov	ecx, [ebp-10h]	; this
		jmp	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
__unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$1 proc	near
					; DATA XREF: .xdata$x:00008890o
		mov	ecx, [ebp-10h]
		add	ecx, 10h
		jmp	??1?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	; RefPtr<ID3D10ShaderResourceView>::~RefPtr<ID3D10ShaderResourceView>(void)
__unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$2 proc	near
					; DATA XREF: .xdata$x:00008898o
		mov	ecx, [ebp-10h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)
__unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$0	proc near
					; DATA XREF: .xdata$x:000088A0o
		mov	ecx, [ebp-10h]	; this
		jmp	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$1	proc near
					; DATA XREF: .xdata$x:000088A8o
		mov	ecx, [ebp-10h]
		add	ecx, 10h
		jmp	??1?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	; RefPtr<ID3D10ShaderResourceView>::~RefPtr<ID3D10ShaderResourceView>(void)
__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$1	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$2	proc near
					; DATA XREF: .xdata$x:000088B0o
		mov	ecx, [ebp-10h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ ; RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)
__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$2	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$3	proc near
					; DATA XREF: .xdata$x:000088B8o
		mov	ecx, [ebp-10h]
		add	ecx, 1Ch
		jmp	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
__unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$3	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0 proc near
					; DATA XREF: .xdata$x:00008A30o
		mov	eax, [ebp-60h]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		pop	ecx
		retn
__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$1 proc near
					; DATA XREF: .xdata$x:00008A38o
		lea	ecx, [ebp-1Ch]
		jmp	??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2 proc near
					; DATA XREF: .xdata$x:00008A40o
		lea	ecx, [ebp-120h]
		jmp	??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ;	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::~Log<1,mozilla::gfx::CriticalLogger>(void)
__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3 proc near
					; DATA XREF: .xdata$x:00008A28o
		mov	eax, [ebp-134h]
		and	eax, 1
		jz	locret_1BC9
		and	dword ptr [ebp-134h], 0FFFFFFFEh
		mov	ecx, [ebp+8]
		jmp	??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ ; already_AddRefed<mozilla::gfx::DataSourceSurface>::~already_AddRefed<mozilla::gfx::DataSourceSurface>(void)
; ---------------------------------------------------------------------------

locret_1BC9:				; CODE XREF: __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3+9j
		retn
__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$4 proc near
					; DATA XREF: .xdata$x:00008A48o
		lea	ecx, [ebp-125h]	; this
		jmp	??1NoLog@gfx@mozilla@@QAE@XZ ; mozilla::gfx::NoLog::~NoLog(void)
__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$5 proc near
					; DATA XREF: .xdata$x:00008A50o
		lea	ecx, [ebp-130h]
		jmp	??1?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ	; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>::~already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
__unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$5 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-15Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008A58o
		lea	ecx, [ebp-64h]
		jmp	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$1 proc near
					; DATA XREF: .xdata$x:00008A60o
		lea	ecx, [ebp-1BCh]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$2 proc near
					; DATA XREF: .xdata$x:00008A68o
		lea	ecx, [ebp-2C4h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$3 proc near
					; DATA XREF: .xdata$x:00008A70o
		lea	ecx, [ebp-0A8h]
		jmp	??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ ; RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$3 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$4 proc near
					; DATA XREF: .xdata$x:00008A78o
		lea	ecx, [ebp-0B4h]
		jmp	??1?$RefPtr@UIDXGISurface@@@@QAE@XZ ; RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$4 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$5 proc near
					; DATA XREF: .xdata$x:00008A80o
		lea	ecx, [ebp-390h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$5 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$6 proc near
					; DATA XREF: .xdata$x:00008A88o
		lea	ecx, [ebp-47Ch]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$6 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-4B0h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ$0 proc near
					; DATA XREF: .xdata$x:00008878o
		lea	ecx, [ebp-0D4h]
		jmp	??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ;	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::~Log<1,mozilla::gfx::CriticalLogger>(void)
__unwindfunclet$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ$1 proc near
					; DATA XREF: .xdata$x:00008880o
		lea	ecx, [ebp-198h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1B0h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ$0 proc	near
					; DATA XREF: .xdata$x:00008860o
		lea	ecx, [ebp-1Ch]
		jmp	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
__unwindfunclet$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ proc near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-64h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z$0 proc near
					; DATA XREF: .xdata$x:00008858o
		mov	ecx, [ebp-10h]	; this
		jmp	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
__unwindfunclet$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(mozilla::gfx::SurfaceFormat)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008868o
		mov	ecx, [ebp-10h]	; this
		jmp	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
__unwindfunclet$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$1 proc near
					; DATA XREF: .xdata$x:00008870o
		mov	ecx, [ebp-10h]
		add	ecx, 14h
		jmp	??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ ; RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)
__unwindfunclet$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-10h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z$0 proc	near
					; DATA XREF: .xdata$x:00008850o
		lea	ecx, [ebp-0E8h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0FCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ$0 proc near
					; DATA XREF: .xdata$x:00008848o
		lea	ecx, [ebp-0D4h]
		jmp	??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)
__unwindfunclet$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ proc near
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::EnsureMapped(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E4h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::already_AddRefed<class mozilla::gfx::DataSourceSurface>(struct already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2DTarget> &&)
		public ??$?0VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@@Z
??$?0VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+2E8p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?take@?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ ; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>::take(void)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?0VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@$$QAU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DB0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::NoLog & __thiscall mozilla::gfx::NoLog::operator<<<char const [59]>(char const (&)[59])
		public ??$?6$$BY0DL@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0DL@$$CBD@Z
??$?6$$BY0DL@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0DL@$$CBD@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+227p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??$?6$$BY0DL@$$CBD@NoLog@gfx@mozilla@@QAEAAV012@AAY0DL@$$CBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger> & __thiscall mozilla::gfx::Log<2, struct	mozilla::gfx::BasicLogger>::operator<<<long>(struct mozilla::gfx::Hexa<long>)
		public ??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z
??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+143p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+38Fp ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	ebx
		push	esi
		push	edi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_1E77
		mov	esi, esp
		push	offset ?dec@std@@YAAAVios_base@1@AAV21@@Z ; std::dec(std::ios_base &)
		mov	edi, esp
		push	offset ?noshowbase@std@@YAAAVios_base@1@AAV21@@Z ; std::noshowbase(std::ios_base &)
		mov	ebx, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	eax, esp
		push	offset ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex(std::ios_base &)
		mov	ecx, esp
		push	offset ?showbase@std@@YAAAVios_base@1@AAV21@@Z ; std::showbase(std::ios_base &)
		mov	edx, [ebp+var_4]
		add	edx, 10h
		mov	[ebp+var_8], ecx
		mov	ecx, edx
		mov	[ebp+var_C], eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		mov	ecx, [ebp+var_8]
		cmp	ecx, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		mov	ecx, [ebp+var_C]
		cmp	ecx, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(long)
		cmp	ebx, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		cmp	edi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(std::ios_base & (*)(std::ios_base	&))
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1E77:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+2Ej
		mov	eax, [ebp+var_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?6J@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@U?$Hexa@J@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::NoLog & __thiscall mozilla::gfx::NoLog::operator<<<struct	mozilla::gfx::Hexa<long>>(struct mozilla::gfx::Hexa<long> const	&)
		public ??$?6U?$Hexa@J@gfx@mozilla@@@NoLog@gfx@mozilla@@QAEAAV012@ABU?$Hexa@J@12@@Z
??$?6U?$Hexa@J@gfx@mozilla@@@NoLog@gfx@mozilla@@QAEAAV012@ABU?$Hexa@J@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+22Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??$?6U?$Hexa@J@gfx@mozilla@@@NoLog@gfx@mozilla@@QAEAAV012@ABU?$Hexa@J@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::operator<<<std::char_traits<char>>(int, char	*Str)
		public ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char	const *	const)+46p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const	* const)+46p ...

var_88		= dword	ptr -88h
var_84		= dword	ptr -84h
var_7D		= byte ptr -7Dh
var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_65		= byte ptr -65h
var_64		= dword	ptr -64h
var_60		= qword	ptr -60h
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_30		= byte ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch

; FUNCTION CHUNK AT 0000222C SIZE 00000009 BYTES
; FUNCTION CHUNK AT 0000223C SIZE 00000068 BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 78h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_88]
		mov	ecx, 1Eh
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], 0
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?length@?$char_traits@D@std@@SAIPBD@Z ;	std::char_traits<char>::length(char const *)
		add	esp, 4
		xor	ecx, ecx
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [eax+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?width@ios_base@std@@QBE_JXZ	; std::ios_base::width(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	[ebp+var_4C], edx
		cmp	[ebp+var_4C], 0
		jl	short loc_1F89
		jg	short loc_1F2F
		cmp	[ebp+var_50], 0
		jbe	short loc_1F89

loc_1F2F:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+7Fj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?width@ios_base@std@@QBE_JXZ	; std::ios_base::width(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_58], eax
		mov	[ebp+var_54], edx
		mov	eax, [ebp+var_54]
		cmp	eax, [ebp+var_18]
		jl	short loc_1F89
		jg	short loc_1F61
		mov	ecx, [ebp+var_58]
		cmp	ecx, [ebp+var_1C]
		jbe	short loc_1F89

loc_1F61:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+AFj
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [eax+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?width@ios_base@std@@QBE_JXZ	; std::ios_base::width(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+var_1C]
		sbb	edx, [ebp+var_18]
		mov	dword ptr [ebp+var_60],	eax
		mov	dword ptr [ebp+var_60+4], edx
		jmp	short loc_1F92
; ---------------------------------------------------------------------------

loc_1F89:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+7Dj
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+85j ...
		xorpd	xmm0, xmm0
		movlpd	[ebp+var_60], xmm0

loc_1F92:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+DFj
		mov	ecx, dword ptr [ebp+var_60]
		mov	[ebp+var_24], ecx
		mov	edx, dword ptr [ebp+var_60+4]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_30]
		call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_30]
		call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(void)
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_1FCE
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx
		jmp	loc_223C
; ---------------------------------------------------------------------------

loc_1FCE:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+116j
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx	; this
		call	dword ptr ds:__imp_?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_64], eax
		mov	eax, [ebp+var_64]
		and	eax, 1C0h
		cmp	eax, 40h ; '@'
		jz	loc_20B9
		jmp	short loc_2016
; ---------------------------------------------------------------------------

loc_2004:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *):loc_20B4j
		mov	ecx, [ebp+var_24]
		sub	ecx, 1
		mov	edx, [ebp+var_20]
		sbb	edx, 0
		mov	[ebp+var_24], ecx
		mov	[ebp+var_20], edx

loc_2016:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+15Aj
		cmp	[ebp+var_20], 0
		jl	loc_20B9
		jg	short loc_202C
		cmp	[ebp+var_24], 0
		jbe	loc_20B9

loc_202C:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+178j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char>>::fill(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_65], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_6C], eax
		mov	esi, esp
		movzx	eax, [ebp+var_65]
		push	eax
		mov	ecx, [ebp+var_6C]
		call	dword ptr ds:__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char>>::sputc(char)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_70], eax
		mov	ecx, [ebp+var_70]
		mov	[ebp+var_38], ecx
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_3C], eax
		lea	edx, [ebp+var_38]
		push	edx
		lea	eax, [ebp+var_3C]
		push	eax
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_20B4
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx
		jmp	short loc_20B9
; ---------------------------------------------------------------------------

loc_20B4:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1FFj
		jmp	loc_2004
; ---------------------------------------------------------------------------

loc_20B9:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+154j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+172j	...
		cmp	[ebp+var_14], 0
		jnz	short loc_211B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_74], eax
		mov	esi, esp
		mov	eax, [ebp+var_18]
		push	eax
		mov	ecx, [ebp+var_1C]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		mov	ecx, [ebp+var_74]
		call	dword ptr ds:__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::sputn(char const *,__int64)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7C], eax
		mov	[ebp+var_78], edx
		mov	eax, [ebp+var_7C]
		cmp	eax, [ebp+var_1C]
		jnz	short loc_2112
		mov	ecx, [ebp+var_78]
		cmp	ecx, [ebp+var_18]
		jz	short loc_211B

loc_2112:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+260j
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx

loc_211B:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+215j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+268j
		cmp	[ebp+var_14], 0
		jnz	loc_21E4
		jmp	short loc_2139
; ---------------------------------------------------------------------------

loc_2127:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *):loc_21DFj
		mov	eax, [ebp+var_24]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		sbb	ecx, 0
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], ecx

loc_2139:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+27Dj
		cmp	[ebp+var_20], 0
		jl	loc_21E4
		jg	short loc_214F
		cmp	[ebp+var_24], 0
		jbe	loc_21E4

loc_214F:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+29Bj
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [eax+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char>>::fill(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7D], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_84], eax
		mov	esi, esp
		movzx	eax, [ebp+var_7D]
		push	eax
		mov	ecx, [ebp+var_84]
		call	dword ptr ds:__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char>>::sputc(char)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_88], eax
		mov	ecx, [ebp+var_88]
		mov	[ebp+var_40], ecx
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_44], eax
		lea	edx, [ebp+var_40]
		push	edx
		lea	eax, [ebp+var_44]
		push	eax
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_21DF
		mov	edx, [ebp+var_14]
		or	edx, 4
		mov	[ebp+var_14], edx
		jmp	short loc_21E4
; ---------------------------------------------------------------------------

loc_21DF:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+32Aj
		jmp	loc_2127
; ---------------------------------------------------------------------------

loc_21E4:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+277j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+295j	...
		mov	esi, esp
		push	0
		push	0		; __int64
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	ecx, edx	; this
		call	dword ptr ds:__imp_?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width(__int64)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_222C
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z endp


; =============== S U B	R O U T	I N E =======================================


__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0 proc near
					; DATA XREF: .xdata$x:00008A98o
		mov	esi, esp
		push	1
		push	4
		mov	eax, [ebp+8]
		mov	ecx, [eax]
		mov	edx, [ebp+8]
		add	edx, [ecx+4]
		mov	ecx, edx
		call	dword ptr ds:__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z	; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, offset $LN23_1
		retn
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0 endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z

loc_222C:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+35Cj
		mov	[ebp+var_4], 0
		jmp	short loc_223C
; END OF FUNCTION CHUNK	FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z

; =============== S U B	R O U T	I N E =======================================


$LN23_1		proc near		; DATA XREF: __catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0+20o
		mov	dword ptr [ebp-4], 0
$LN23_1		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z

loc_223C:				; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+121j
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+38Bj
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]
		call	dword ptr ds:__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z	; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_48], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_30]
		call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ;	std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)
		mov	eax, [ebp+var_48]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN32
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 88h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
; END OF FUNCTION CHUNK	FOR ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
; ---------------------------------------------------------------------------
$LN32		dd 1			; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+3D0o
		dd offset $LN31
$LN31		dd 0FFFFFFD0h, 8	; DATA XREF: .text$mn:000022A8o
		dd offset $LN29
$LN29		dd 6B4F5Fh		; DATA XREF: .text$mn:000022B4o
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 22BCh
; COMDAT (pick associative to section at 1EA8)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 proc near
					; DATA XREF: .xdata$x:00008AB4o
		lea	ecx, [ebp-30h]
		jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ;	std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z	proc near
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: long __stdcall IUnknown::QueryInterface<struct IDXGISurface>(struct IDXGISurface * *)
		public ??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z
??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+DBp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+440p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		push	offset __GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [edx]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn	8
??$QueryInterface@UIDXGISurface@@@IUnknown@@QAGJPAPAUIDXGISurface@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2314h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_SIZE_U __cdecl D2D1::Size<unsigned	int>(unsigned int, unsigned int)
		public ??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z
??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z proc near	; CODE XREF: D2D1::SizeU(uint,uint)+1Cp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5_2		dd 1			; DATA XREF: D2D1::Size<uint>(uint,uint)+2Do
		dd offset $LN4_2
$LN4_2		dd 0FFFFFFF4h, 8	; DATA XREF: .text$mn:00002358o
		dd offset $LN3_2	; "size"
$LN3_2		db 'size',0             ; DATA XREF: .text$mn:00002364o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2370h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::_Allocate<char>(unsigned int, char *)
		public ??$_Allocate@D@std@@YAPADIPAD@Z
??$_Allocate@D@std@@YAPADIPAD@Z	proc near
					; CODE XREF: std::allocator<char>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_238B
		jmp	short loc_23B5
; ---------------------------------------------------------------------------

loc_238B:				; CODE XREF: std::_Allocate<char>(uint,char *)+17j
		cmp	[ebp+arg_0], 0FFFFFFFFh
		ja	short loc_23A6
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_23B5

loc_23A6:				; CODE XREF: std::_Allocate<char>(uint,char *)+1Fj
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_23B5:				; CODE XREF: std::_Allocate<char>(uint,char *)+19j
					; std::_Allocate<char>(uint,char *)+34j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@D@std@@YAPADIPAD@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
		public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
					; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_23E3
		jmp	short loc_2413
; ---------------------------------------------------------------------------

loc_23E3:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+17j
		cmp	[ebp+arg_0], 1FFFFFFFh
		ja	short loc_2404
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_2413

loc_2404:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2413:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+19j
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Aj
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2428h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<char>(int, wchar_t *,	unsigned int)
		public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+1Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+22p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_2451
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_2451:				; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 245Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::addressof<char>(char &)
		public ??$addressof@D@std@@YAPADAAD@Z
??$addressof@D@std@@YAPADAAD@Z proc near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p
					; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p	...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$addressof@D@std@@YAPADAAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2464h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::construct<char *,char *	&>(void	*, int)
		public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+5Ep
					; $LN19+4Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_4]
		push	edx		; int
		call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ;	std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::construct<char *,char * &>(void *, int)
		public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char	* &>(std::allocator<char> &,char * *,char * &)+17p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	4		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_2512
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		mov	edx, [ebp+var_18]
		mov	eax, [eax]
		mov	[edx], eax
		mov	ecx, [ebp+var_18]
		mov	[ebp+var_1C], ecx
		jmp	short loc_2519
; ---------------------------------------------------------------------------

loc_2512:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+55j
		mov	[ebp+var_1C], 0

loc_2519:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+70j
		mov	edx, [ebp+var_1C]
		mov	[ebp+var_14], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2544h
; COMDAT (pick associative to section at 24A0)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
					; DATA XREF: .xdata$x:00008B48o
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2570h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void	*, int)
		public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+23p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		mov	ecx, [ebp+arg_0]
		call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char	* &>(char * *,char * &)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2598h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
		public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+49p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	8		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_2610
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
		add	esp, 4
		mov	edx, [eax]
		mov	eax, [eax+4]
		mov	ecx, [ebp+var_18]
		mov	[ecx], edx
		mov	[ecx+4], eax
		mov	edx, [ebp+var_18]
		mov	[ebp+var_1C], edx
		jmp	short loc_2617
; ---------------------------------------------------------------------------

loc_2610:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+55j
		mov	[ebp+var_1C], 0

loc_2617:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+76j
		mov	eax, [ebp+var_1C]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2640h
; COMDAT (pick associative to section at 2598)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
					; DATA XREF: .xdata$x:00008B1Co
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc	near
					; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 266Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+4Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		push	ecx
		call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 269Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char *	*)+Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26B0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
		public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ;	std::allocator<char>::destroy<char *>(char * *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<struct	std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
		public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+3Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * & __cdecl std::forward<char * &>(char * &)
		public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+12p
					; std::allocator<char>::construct<char *,char *	&>(char	* *,char * &)+5Bp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
		public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc	near
					; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5Bp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> && __cdecl std::forward<class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>>>(class std::basic_string<char, struct std::char_traits<char>, class	std::allocator<char>> &)
		public ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+3Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID2D1Bitmap>	__cdecl	getter_AddRefs<struct ID2D1Bitmap>(class RefPtr<struct ID2D1Bitmap> &)
		public ??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z
??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+21Ep
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+2FFp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z ; RefPtrGetterAddRefs<ID2D1Bitmap>::RefPtrGetterAddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID2D1Bitmap@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@AAV?$RefPtr@UID2D1Bitmap@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2710h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID2D1RenderTarget> __cdecl getter_AddRefs<struct ID2D1RenderTarget>(class RefPtr<struct ID2D1RenderTarget> &)
		public ??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z
??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+565p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z	; RefPtrGetterAddRefs<ID2D1RenderTarget>::RefPtrGetterAddRefs<ID2D1RenderTarget>(RefPtr<ID2D1RenderTarget> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID2D1RenderTarget@@@@YA?AV?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 272Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID3D10ShaderResourceView> __cdecl getter_AddRefs<struct ID3D10ShaderResourceView>(class RefPtr<struct ID3D10ShaderResourceView> &)
		public ??$getter_AddRefs@UID3D10ShaderResourceView@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z
??$getter_AddRefs@UID3D10ShaderResourceView@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+DCp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAE@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z ;	RefPtrGetterAddRefs<ID3D10ShaderResourceView>::RefPtrGetterAddRefs<ID3D10ShaderResourceView>(RefPtr<ID3D10ShaderResourceView> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID3D10ShaderResourceView@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2748h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct ID3D10Texture2D> __cdecl getter_AddRefs<struct ID3D10Texture2D>(class RefPtr<struct ID3D10Texture2D>	&)
		public ??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z
??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+199p
					; mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+97p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z ; RefPtrGetterAddRefs<ID3D10Texture2D>::RefPtrGetterAddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UID3D10Texture2D@@@@YA?AV?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@AAV?$RefPtr@UID3D10Texture2D@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2764h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	RefPtrGetterAddRefs<struct IDXGISurface> __cdecl getter_AddRefs<struct IDXGISurface>(class RefPtr<struct IDXGISurface> &)
		public ??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z
??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+BFp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+424p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z ;	RefPtrGetterAddRefs<IDXGISurface>::RefPtrGetterAddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$getter_AddRefs@UIDXGISurface@@@@YA?AV?$RefPtrGetterAddRefs@UIDXGISurface@@@@AAV?$RefPtr@UIDXGISurface@@@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2780h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct mozilla::gfx::Hexa<long> __cdecl mozilla::gfx::hexa<long>(long)
		public ??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z
??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+1F2p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+F8p ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$Hexa@J@gfx@mozilla@@QAE@J@Z ; mozilla::gfx::Hexa<long>::Hexa<long>(long)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$hexa@J@gfx@mozilla@@YA?AU?$Hexa@J@01@J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 279Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::Atomic<unsigned int, 2, void>::Atomic<unsigned int, 2, void>(unsigned int)
		public ??0?$Atomic@I$01X@mozilla@@QAE@I@Z
??0?$Atomic@I$01X@mozilla@@QAE@I@Z proc	near
					; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::RefCounted<mozilla::gfx::SourceSurface,0>(void)+13p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z ; mozilla::detail::AtomicBaseIncDec<uint,2>::AtomicBaseIncDec<uint,2>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$Atomic@I$01X@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 27CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::detail::AtomicBase<unsigned int, 2>::AtomicBase<unsigned int, 2>(unsigned	int)
		public ??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z
??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z proc near
					; CODE XREF: mozilla::detail::AtomicBaseIncDec<uint,2>::AtomicBaseIncDec<uint,2>(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z ; mozilla::detail::ToStorageTypeArgument<uint>::convert(uint)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$atomic@I@std@@QAE@I@Z ; std::atomic<uint>::atomic<uint>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2804h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::detail::AtomicBaseIncDec<unsigned	int, 2>::AtomicBaseIncDec<unsigned int,	2>(unsigned int)
		public ??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z
??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z proc	near
					; CODE XREF: mozilla::Atomic<uint,2,void>::Atomic<uint,2,void>(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$AtomicBase@I$01@detail@mozilla@@QAE@I@Z ; mozilla::detail::AtomicBase<uint,2>::AtomicBase<uint,2>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$AtomicBaseIncDec@I$01@detail@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2834h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::AtomicRefCounted<class mozilla::gfx::SourceSurface>(void)
		public ??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ
??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+33p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::RefCounted<mozilla::gfx::SourceSurface,0>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 285Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::BaseSize<int, struct	mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>::BaseSize<int, struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>(int, int)
		public ??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z
??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z proc near
					; CODE XREF: mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>::IntSizeTyped<mozilla::gfx::UnknownUnits>(int,int)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2884h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Hexa<long>::Hexa<long>(long)
		public ??0?$Hexa@J@gfx@mozilla@@QAE@J@Z
??0?$Hexa@J@gfx@mozilla@@QAE@J@Z proc near ; CODE XREF:	mozilla::gfx::hexa<long>(long)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$Hexa@J@gfx@mozilla@@QAE@J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>::IntSizeTyped<struct	mozilla::gfx::UnknownUnits>(int, int)
		public ??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z
??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)+5Ap
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+A0p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	??0?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z ; mozilla::gfx::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>(int,int)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@QAE@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::Log<1, struct mozilla::gfx::CriticalLogger>(int, enum  mozilla::gfx::LogReason)
		public ??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+119p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+81p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		push	1
		push	3
		mov	ecx, [ebp+var_10]
		call	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax+0B0h], 0
		mov	ecx, [ebp+var_10]
		mov	byte ptr [ecx+0B8h], 0
		mov	edx, [ebp+arg_4]
		push	edx
		push	1		; int
		call	?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z ;	mozilla::gfx::BasicLogger::ShouldOutputMessage(int)
		add	esp, 4
		movzx	eax, al
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		call	?Init@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2974h
; COMDAT (pick associative to section at 28D8)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0	proc near
					; DATA XREF: .xdata$x:00008730o
		mov	ecx, [ebp-10h]
		jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
__unwindfunclet$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z proc near
					; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Log<1,mozilla::gfx::CriticalLogger>(int,mozilla::gfx::LogReason)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2998h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::Log<2, struct mozilla::gfx::BasicLogger>(int, enum	 mozilla::gfx::LogReason)
		public ??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+11Bp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+367p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		push	1
		push	3
		mov	ecx, [ebp+var_10]
		call	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax+0B0h], 0
		mov	ecx, [ebp+var_10]
		mov	byte ptr [ecx+0B8h], 0
		mov	edx, [ebp+arg_4]
		push	edx
		push	2		; int
		call	?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z ;	mozilla::gfx::BasicLogger::ShouldOutputMessage(int)
		add	esp, 4
		movzx	eax, al
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		call	?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2A34h
; COMDAT (pick associative to section at 2998)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0 proc near
					; DATA XREF: .xdata$x:000087BCo
		mov	ecx, [ebp-10h]
		jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
__unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::RefCounted<class mozilla::gfx::SourceSurface, 0>(void)
		public ??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ
??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	proc near
					; CODE XREF: mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::AtomicRefCounted<mozilla::gfx::SourceSurface>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	??0?$Atomic@I$01X@mozilla@@QAE@I@Z ; mozilla::Atomic<uint,2,void>::Atomic<uint,2,void>(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1Bitmap>::RefPtr<struct ID2D1Bitmap>(void)
		public ??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ
??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+5Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID2D1Bitmap@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1RenderTarget>::RefPtr<struct ID2D1RenderTarget>(void)
		public ??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ
??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+3CDp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10ShaderResourceView>::RefPtr<struct ID3D10ShaderResourceView>(void)
		public ??0?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ
??0?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+4Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AE4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::RefPtr<struct ID3D10Texture2D>(class RefPtr<struct	ID3D10Texture2D> const &)
		public ??0?$RefPtr@UID3D10Texture2D@@@@QAE@ABV0@@Z
??0?$RefPtr@UID3D10Texture2D@@@@QAE@ABV0@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+48p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_2B12
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::AddRef(ID3D10Texture2D *)
		add	esp, 4

loc_2B12:				; CODE XREF: RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> const &)+1Ej
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtr@UID3D10Texture2D@@@@QAE@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::RefPtr<struct ID3D10Texture2D>(struct ID3D10Texture2D *)
		public ??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z
??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+76p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		cmp	dword ptr [edx], 0
		jz	short loc_2B54
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		call	?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::AddRef(ID3D10Texture2D *)
		add	esp, 4

loc_2B54:				; CODE XREF: RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(ID3D10Texture2D *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtr@UID3D10Texture2D@@@@QAE@PAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::RefPtr<struct ID3D10Texture2D>(void)
		public ??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ
??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(mozilla::gfx::SurfaceFormat)+4Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UID3D10Texture2D@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDXGISurface>::RefPtr<struct	IDXGISurface>(void)
		public ??0?$RefPtr@UIDXGISurface@@@@QAE@XZ
??0?$RefPtr@UIDXGISurface@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+A8p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+40Dp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$RefPtr@UIDXGISurface@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>(class mozilla::gfx::DataSourceSurfaceD2DTarget *)
		public ??0?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
??0?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+9Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		cmp	dword ptr [edx], 0
		jz	short loc_2BD4
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		call	?AddRef@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRef(mozilla::gfx::DataSourceSurfaceD2DTarget *)
		add	esp, 4

loc_2BD4:				; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(mozilla::gfx::DataSourceSurfaceD2DTarget *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1Bitmap>::RefPtrGetterAddRefs<struct ID2D1Bitmap>(class RefPtr<struct ID2D1Bitmap> &)
		public ??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z
??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID2D1Bitmap>(RefPtr<ID2D1Bitmap> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAE@AAV?$RefPtr@UID2D1Bitmap@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1RenderTarget>::RefPtrGetterAddRefs<struct ID2D1RenderTarget>(class	RefPtr<struct ID2D1RenderTarget> &)
		public ??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z
??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z	proc near
					; CODE XREF: getter_AddRefs<ID2D1RenderTarget>(RefPtr<ID2D1RenderTarget> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAE@AAV?$RefPtr@UID2D1RenderTarget@@@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10ShaderResourceView>::RefPtrGetterAddRefs<struct ID3D10ShaderResourceView>(class RefPtr<struct ID3D10ShaderResourceView> &)
		public ??0?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAE@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z
??0?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAE@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID3D10ShaderResourceView>(RefPtr<ID3D10ShaderResourceView> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAE@AAV?$RefPtr@UID3D10ShaderResourceView@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C48h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10Texture2D>::RefPtrGetterAddRefs<struct ID3D10Texture2D>(class RefPtr<struct ID3D10Texture2D> &)
		public ??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z
??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z proc near
					; CODE XREF: getter_AddRefs<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAE@AAV?$RefPtr@UID3D10Texture2D@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDXGISurface>::RefPtrGetterAddRefs<struct IDXGISurface>(class RefPtr<struct IDXGISurface> &)
		public ??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z
??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z proc near
					; CODE XREF: getter_AddRefs<IDXGISurface>(RefPtr<IDXGISurface> &)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAE@AAV?$RefPtr@UIDXGISurface@@@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
		public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+27p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+42p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2CF4h
; COMDAT (pick associative to section at 2C88)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
					; DATA XREF: .xdata$x:0000853Co
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
		public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+14h], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<char>::allocator<char>(void)
		public ??0?$allocator@D@std@@QAE@XZ
??0?$allocator@D@std@@QAE@XZ proc near	; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+11p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+39p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@D@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
		public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+1Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::already_AddRefed<class mozilla::gfx::DataSourceSurface>(void (__thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::*)(double, float))
		public ??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z
??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+153p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+247p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@P80@AEXNM@Z@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DD8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2DTarget>::already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2DTarget>(class mozilla::gfx::DataSourceSurfaceD2DTarget *)
		public ??0?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
??0?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc	near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::forget(void)+3Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::atomic<unsigned int>::atomic<unsigned	int>(unsigned int)
		public ??0?$atomic@I@std@@QAE@I@Z
??0?$atomic@I@std@@QAE@I@Z proc	near	; CODE XREF: mozilla::detail::AtomicBase<uint,2>::AtomicBase<uint,2>(uint)+1Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	??4atomic_uint@std@@QAEII@Z ; std::atomic_uint::operator=(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$atomic@I@std@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>	&&)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+CAp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+159p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_8+3]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &)
		add	esp, 4
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z	; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+84p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+84p ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	eax, [ebp+Str]
		push	eax		; Str
		mov	ecx, [ebp+var_10]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2F14h
; COMDAT (pick associative to section at 2E88)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
					; DATA XREF: .xdata$x:000085C0o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void *Src, size_t Size)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+BEp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+14Dp

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	ecx, [ebp+var_10]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char	const *,uint)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 2FC8h
; COMDAT (pick associative to section at 2F38)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0 proc near
					; DATA XREF: .xdata$x:00008594o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+179p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 306Ch
; COMDAT (pick associative to section at 2FEC)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008568o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc	near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3090h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>(int)
		public ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc	near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+D4p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		push	esi
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_10]
		call	dword ptr ds:__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::basic_streambuf<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@	; const	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 40h ; '@'
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		call	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)
		push	eax		; int
		push	0		; Size
		push	0		; Src
		mov	ecx, [ebp+var_10]
		call	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 312Ch
; COMDAT (pick associative to section at 3090)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0 proc near
					; DATA XREF: .xdata$x:00008704o
		mov	esi, esp
		mov	ecx, [ebp-10h]
		call	dword ptr ds:__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc near
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 315Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class	std::allocator<char>>::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>(int)
		public ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Log<1,mozilla::gfx::CriticalLogger>(int,mozilla::gfx::LogReason)+34p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+34p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		push	esi
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_14], 0
		cmp	[ebp+arg_4], 0
		jz	short loc_31D8
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbtable'{for `std::basic_istream<char,std::char_traits<char>>'}
		mov	ecx, [ebp+var_10]
		mov	dword ptr [ecx+10h], offset ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbtable'{for `std::basic_ostream<char,std::char_traits<char>>'}
		mov	ecx, [ebp+var_10]
		add	ecx, 68h ; 'h'
		mov	esi, esp
		call	dword ptr ds:__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::basic_ios<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 0
		mov	edx, [ebp+var_14]
		or	edx, 1
		mov	[ebp+var_14], edx

loc_31D8:				; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+42j
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_10]
		add	eax, 18h
		push	eax
		mov	ecx, [ebp+var_10]
		call	dword ptr ds:__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char>>::basic_iostream<char,std::char_traits<char>>(std::basic_streambuf<char,std::char_traits<char>> *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_10]
		mov	edx, [ecx]
		mov	eax, [edx+4]
		mov	ecx, [ebp+var_10]
		mov	dword ptr [ecx+eax], offset ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	edx, [ebp+var_10]
		mov	eax, [edx]
		mov	ecx, [eax+4]
		sub	ecx, 68h ; 'h'
		mov	edx, [ebp+var_10]
		mov	eax, [edx]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_10]
		mov	[eax+edx-4], ecx
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_10]
		add	ecx, 18h
		call	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 325Ch
; COMDAT (pick associative to section at 315C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0	proc near
					; DATA XREF: .xdata$x:000086D0o
		mov	eax, [ebp-14h]
		and	eax, 1
		jz	$LN5_6
		and	dword ptr [ebp-14h], 0FFFFFFFEh
		mov	ecx, [ebp-10h]
		add	ecx, 68h ; 'h'
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
; ---------------------------------------------------------------------------

$LN5_6:					; CODE XREF: __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0+6j
		retn
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1	proc near
					; DATA XREF: .xdata$x:000086D8o
		mov	ecx, [ebp-10h]
		add	ecx, 20h ; ' '
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(void)
		cmp	esi, esp
		jmp	__RTC_CheckEsp
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z proc near
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-10h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 32B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::fpos<int>::fpos<int>(__int64)
		public ??0?$fpos@H@std@@QAE@_J@Z
??0?$fpos@H@std@@QAE@_J@Z proc near	; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+3A2p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+2BFp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+arg_4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+10h], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0?$fpos@H@std@@QAE@_J@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 32F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurface::DataSourceSurface(mozilla::gfx::DataSourceSurface *__hidden this)
		public ??0DataSourceSurface@gfx@mozilla@@QAE@XZ
??0DataSourceSurface@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(mozilla::gfx::SurfaceFormat)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0SourceSurface@gfx@mozilla@@QAE@XZ ; mozilla::gfx::SourceSurface::SourceSurface(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7DataSourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurface::`vftable'
		mov	ecx, [ebp+var_4]
		mov	byte ptr [ecx+10h], 0
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0DataSourceSurface@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 332Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::NoLog::NoLog(mozilla::gfx::NoLog *__hidden this)
		public ??0NoLog@gfx@mozilla@@QAE@XZ
??0NoLog@gfx@mozilla@@QAE@XZ proc near	; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+206p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0NoLog@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3344h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurface::SourceSurface(mozilla::gfx::SourceSurface *__hidden this)
		public ??0SourceSurface@gfx@mozilla@@QAE@XZ
??0SourceSurface@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+30p
					; mozilla::gfx::DataSourceSurface::DataSourceSurface(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		add	ecx, 4
		call	??0?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurface::`vftable'
		mov	ecx, [ebp+var_10]
		add	ecx, 8		; this
		call	??0UserData@gfx@mozilla@@QAE@XZ	; mozilla::gfx::UserData::UserData(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0SourceSurface@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 33BCh
; COMDAT (pick associative to section at 3344)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000086A4o
		mov	ecx, [ebp-10h]
		add	ecx, 4
		jmp	??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
__unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0SourceSurface@gfx@mozilla@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::UserData::UserData(mozilla::gfx::UserData *__hidden this)
		public ??0UserData@gfx@mozilla@@QAE@XZ
??0UserData@gfx@mozilla@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+4Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0UserData@gfx@mozilla@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 340Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
		public ??0_Container_proxy@std@@QAE@XZ
??0_Container_proxy@std@@QAE@XZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+3Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0_Container_proxy@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3434h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
		public ??0_Generic_error_category@std@@QAE@XZ
??0_Generic_error_category@std@@QAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+11p
					; std::_System_error_category::_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0error_category@std@@QAE@XZ ;	std::error_category::error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Generic_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3464h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??0_Iostream_error_category@std@@QAE@XZ
??0_Iostream_error_category@std@@QAE@XZ	proc near
					; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Iostream_error_category@std@@6B@ ;	const std::_Iostream_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Iostream_error_category@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3494h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Sentry_base::_Sentry_base(class std::basic_ostream<char,	struct std::char_traits<char>> &)
		public ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+35p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		add	ecx, [edx+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_3518
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_C], ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_C]
		add	ecx, [eax+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10], eax
		mov	ecx, [ebp+var_10]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, [ebp+var_10]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3518:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char>> &)+47j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 352Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
		public ??0_System_error_category@std@@QAE@XZ
??0_System_error_category@std@@QAE@XZ proc near
					; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_System_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 355Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
		public ??0error_category@std@@QAE@XZ
??0error_category@std@@QAE@XZ proc near	; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0error_category@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 357Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct	std::error_category *)
		public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+36p
					; std::_System_error_category::default_error_condition(int)+4Fp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::sentry(class std::basic_ostream<char, struct std::char_traits<char>> &)
		public ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+FDp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		push	esi
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char>>	&)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]	; this
		mov	esi, esp
		call	dword ptr ds:__imp_?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jz	short loc_3672
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		add	ecx, [edx+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_3672
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, [ebp+arg_0]
		jz	short loc_3672
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, eax
		call	dword ptr ds:__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char>>::flush(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3672:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+60j
					; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+7Ej ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx	; this
		call	dword ptr ds:__imp_?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_10]
		mov	[ecx+4], al
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 36BCh
; COMDAT (pick associative to section at 35A4)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0 proc near
					; DATA XREF: .xdata$x:00008AF0o
		mov	ecx, [ebp-10h]
		jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z	proc near
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::~AtomicRefCounted<class mozilla::gfx::SourceSurface>(void)
		public ??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ
??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0+6j
					; mozilla::gfx::SourceSurface::~SourceSurface(void)+55p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::~RefCounted<mozilla::gfx::SourceSurface,0>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3704h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::~Log<1,	struct mozilla::gfx::CriticalLogger>(void)
		public ??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+149p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+B7p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10]
		call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3768h
; COMDAT (pick associative to section at 3704)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0	proc near
					; DATA XREF: .xdata$x:0000875Co
		mov	ecx, [ebp-10h]
		jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
__unwindfunclet$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc near
					; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::~Log<1,mozilla::gfx::CriticalLogger>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 378Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::~Log<2, struct mozilla::gfx::BasicLogger>(void)
		public ??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+152p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+39Ep ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10]
		call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 37F0h
; COMDAT (pick associative to section at 378C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0 proc near
					; DATA XREF: .xdata$x:000087E8o
		mov	ecx, [ebp-10h]
		jmp	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
__unwindfunclet$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3814h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::~RefCounted<class mozilla::gfx::SourceSurface, 0>(void)
		public ??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ
??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	proc near
					; CODE XREF: mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_3822:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::~RefCounted<mozilla::gfx::SourceSurface,0>(void)+10j
		xor	eax, eax
		jnz	short loc_3822
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@IAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 382Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1Bitmap>::~RefPtr<struct	ID2D1Bitmap>(void)
		public ??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ
??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+B2p
					; __unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$2+6j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3850
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z ;	RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::Release(ID2D1Bitmap *)
		add	esp, 4

loc_3850:				; CODE XREF: RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID2D1Bitmap@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3860h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1RenderTarget>::~RefPtr<struct ID2D1RenderTarget>(void)
		public ??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ
??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+4C2p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+611p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3884
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	; RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::Release(ID2D1RenderTarget	*)
		add	esp, 4

loc_3884:				; CODE XREF: RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID2D1RenderTarget@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3894h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10ShaderResourceView>::~RefPtr<struct ID3D10ShaderResourceView>(void)
		public ??1?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ
??1?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+C1p
					; __unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$1+6j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_38B8
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID3D10ShaderResourceView@@@?$RefPtr@UID3D10ShaderResourceView@@@@SAXPAUID3D10ShaderResourceView@@@Z ; RefPtr<ID3D10ShaderResourceView>::AddRefTraits<ID3D10ShaderResourceView>::Release(ID3D10ShaderResourceView *)
		add	esp, 4

loc_38B8:				; CODE XREF: RefPtr<ID3D10ShaderResourceView>::~RefPtr<ID3D10ShaderResourceView>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID3D10ShaderResourceView@@@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::~RefPtr<struct ID3D10Texture2D>(void)
		public ??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ
??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+A3p
					; mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+158p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_38EC
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::Release(ID3D10Texture2D *)
		add	esp, 4

loc_38EC:				; CODE XREF: RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UID3D10Texture2D@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDXGISurface>::~RefPtr<struct IDXGISurface>(void)
		public ??1?$RefPtr@UIDXGISurface@@@@QAE@XZ
??1?$RefPtr@UIDXGISurface@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+16Bp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+3B7p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3920
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::AddRefTraits<IDXGISurface>::Release(IDXGISurface *)
		add	esp, 4

loc_3920:				; CODE XREF: RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@UIDXGISurface@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3930h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
		public ??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ
??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+16Ep
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+262p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax], 0
		jz	short loc_3954
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx
		call	?Release@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2DTarget>::Release(mozilla::gfx::DataSourceSurfaceD2DTarget *)
		add	esp, 4

loc_3954:				; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)+14j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3964h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::~_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>(void)
		public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
					; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0+3j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3990h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
		public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurface>::~already_AddRefed<class mozilla::gfx::DataSourceSurface>(void)
		public ??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ
??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3+19j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_39CE:				; CODE XREF: already_AddRefed<mozilla::gfx::DataSourceSurface>::~already_AddRefed<mozilla::gfx::DataSourceSurface>(void)+10j
		xor	eax, eax
		jnz	short loc_39CE
		mov	esp, ebp
		pop	ebp
		retn
??1?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2DTarget>::~already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2DTarget>(void)
		public ??1?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ
??1?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+306p
					; __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$5+6j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_39E6:				; CODE XREF: already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>::~already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)+10j
		xor	eax, eax
		jnz	short loc_39E6
		mov	esp, ebp
		pop	ebp
		retn
??1?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
		public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+A0p
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+AFp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	ecx, [ebp+var_4]
		call	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::~basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>>(void)
		public ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)+45p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`scalar deleting destructor'(uint)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@	; const	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ;	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char>>::~basic_streambuf<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A64h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class	std::allocator<char>>::~basic_stringstream<char, struct	std::char_traits<char>,	class std::allocator<char>>(void)
		public ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax-68h]
		mov	edx, [ecx+4]
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+edx-68h], offset	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable'
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx-68h]
		mov	eax, [edx+4]
		sub	eax, 68h ; 'h'
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx-68h]
		mov	ecx, [edx+4]
		mov	edx, [ebp+var_4]
		mov	[edx+ecx-6Ch], eax
		mov	ecx, [ebp+var_4]
		sub	ecx, 50h ; 'P'
		call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	ecx, [ebp+var_4]
		sub	ecx, 48h ; 'H'
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char>>::~basic_iostream<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3AD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::DataSourceSurface::~DataSourceSurface(mozilla::gfx::DataSourceSurface	*__hidden this)
		public ??1DataSourceSurface@gfx@mozilla@@UAE@XZ
??1DataSourceSurface@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget(void)+92p
					; __unwindfunclet$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z$0+3j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1DataSourceSurface@gfx@mozilla@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3AF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::NoLog::~NoLog(mozilla::gfx::NoLog *__hidden this)
		public ??1NoLog@gfx@mozilla@@QAE@XZ
??1NoLog@gfx@mozilla@@QAE@XZ proc near	; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+23Dp
					; __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$4+6j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn
??1NoLog@gfx@mozilla@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::SourceSurface::~SourceSurface(mozilla::gfx::SourceSurface *__hidden this)
		public ??1SourceSurface@gfx@mozilla@@UAE@XZ
??1SourceSurface@gfx@mozilla@@UAE@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+D0p
					; __unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$0+3j ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+var_10]
		mov	dword ptr [eax], offset	??_7SourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurface::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		add	ecx, 8		; this
		call	??1UserData@gfx@mozilla@@QAE@XZ	; mozilla::gfx::UserData::~UserData(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_10]
		add	ecx, 4
		call	??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1SourceSurface@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 3B80h
; COMDAT (pick associative to section at 3B0C)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1SourceSurface@gfx@mozilla@@UAE@XZ$0 proc near
					; DATA XREF: .xdata$x:00008678o
		mov	ecx, [ebp-10h]
		add	ecx, 4
		jmp	??1?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@QAE@XZ ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::~AtomicRefCounted<mozilla::gfx::SourceSurface>(void)
__unwindfunclet$??1SourceSurface@gfx@mozilla@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ proc near
					; DATA XREF: mozilla::gfx::SourceSurface::~SourceSurface(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1SourceSurface@gfx@mozilla@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall mozilla::gfx::UserData::~UserData(mozilla::gfx::UserData *__hidden this)
		public ??1UserData@gfx@mozilla@@QAE@XZ
??1UserData@gfx@mozilla@@QAE@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurface::~SourceSurface(void)+43p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	?Destroy@UserData@gfx@mozilla@@QAEXXZ ;	mozilla::gfx::UserData::Destroy(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UserData@gfx@mozilla@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BCCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category	*__hidden this)
		public ??1_Generic_error_category@std@@UAE@XZ
??1_Generic_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+11p
					; std::_System_error_category::~_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Generic_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BF0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??1_Iostream_error_category@std@@UAE@XZ
??1_Iostream_error_category@std@@UAE@XZ	proc near
					; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Iostream_error_category@std@@UAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
		public ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0+3j
					; std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+3Cp

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		add	ecx, [eax+4]
		mov	esi, esp
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_3C92
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	[ebp+var_C], edx
		mov	eax, [ebp+var_C]
		mov	ecx, [eax]
		mov	edx, [ebp+var_C]
		add	edx, [ecx+4]
		mov	esi, esp
		mov	ecx, edx
		call	dword ptr ds:__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ	; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10], eax
		mov	eax, [ebp+var_10]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_10]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3C92:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)+3Fj
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
		public ??1_System_error_category@std@@UAE@XZ
??1_System_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_System_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
		public ??1error_category@std@@UAE@XZ
??1error_category@std@@UAE@XZ proc near	; CODE XREF: std::_Generic_error_category::~_Generic_error_category(void)+11p
					; std::error_category::`scalar deleting	destructor'(uint)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	esp, ebp
		pop	ebp
		retn
??1error_category@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CE4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::~sentry(void)
		public ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+3C4p
					; __unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		call	dword ptr ds:__imp_?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, al
		test	eax, eax
		jnz	short loc_3D1D
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	ecx, [ecx]
		call	dword ptr ds:__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ;	std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_3D1D:				; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+23j
		mov	ecx, [ebp+var_4]
		call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int, void	*)
		public ??2@YAPAXIPAX@Z
??2@YAPAXIPAX@Z	proc near		; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+3Fp
					; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+3Fp

arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		pop	ebp
		retn
??2@YAPAXIPAX@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX0@Z
??3@YAXPAX0@Z	proc near		; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
					; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
??3@YAXPAX0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D44h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RefPtr<struct ID2D1Bitmap> & __thiscall	RefPtr<struct ID2D1Bitmap>::operator=(struct ID2D1Bitmap *)
		public ??4?$RefPtr@UID2D1Bitmap@@@@QAEAAV0@PAUID2D1Bitmap@@@Z
??4?$RefPtr@UID2D1Bitmap@@@@QAEAAV0@PAUID2D1Bitmap@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+106p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?assign_with_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z ; RefPtr<ID2D1Bitmap>::assign_with_AddRef(ID2D1Bitmap *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$RefPtr@UID2D1Bitmap@@@@QAEAAV0@PAUID2D1Bitmap@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D74h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RefPtr<struct ID2D1RenderTarget> & __thiscall RefPtr<struct ID2D1RenderTarget>::operator=(class	RefPtr<struct ID2D1RenderTarget> const &)
		public ??4?$RefPtr@UID2D1RenderTarget@@@@QAEAAV0@ABV0@@Z
??4?$RefPtr@UID2D1RenderTarget@@@@QAEAAV0@ABV0@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+3EFp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?assign_with_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z	; RefPtr<ID2D1RenderTarget>::assign_with_AddRef(ID2D1RenderTarget *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$RefPtr@UID2D1RenderTarget@@@@QAEAAV0@ABV0@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	RefPtr<class mozilla::gfx::SourceSurfaceD2DTarget> & __thiscall	RefPtr<class mozilla::gfx::SourceSurfaceD2DTarget>::operator=(class mozilla::gfx::SourceSurfaceD2DTarget *)
		public ??4?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEAAV0@PAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
??4?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEAAV0@PAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::MarkIndependent(void)+29p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?assign_with_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_with_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEAAV0@PAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::atomic_uint::operator=(unsigned int)
		public ??4atomic_uint@std@@QAEII@Z
??4atomic_uint@std@@QAEII@Z proc near	; CODE XREF: std::atomic<uint>::atomic<uint>(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_4]
		push	ecx		; struct std::atomic_uint *
		call	?atomic_store@std@@YAXPAUatomic_uint@1@I@Z ; std::atomic_store(std::atomic_uint	*,uint)
		add	esp, 8
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4atomic_uint@std@@QAEII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char *Str)
		public ??6?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z
??6?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+13Ap
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+A5p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_3E56
		cmp	[ebp+var_4], 0
		jz	short loc_3E3F
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_8], ecx
		jmp	short loc_3E46
; ---------------------------------------------------------------------------

loc_3E3F:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char	const *	const)+2Aj
		mov	[ebp+var_8], 0

loc_3E46:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char	const *	const)+35j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_3E56:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char	const *	const)+24j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??6?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E6Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char	*Str)
		public ??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z
??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+13Cp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+388p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_3EBA
		cmp	[ebp+var_4], 0
		jz	short loc_3EA3
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_8], ecx
		jmp	short loc_3EAA
; ---------------------------------------------------------------------------

loc_3EA3:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+2Aj
		mov	[ebp+var_8], 0

loc_3EAA:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+35j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_3EBA:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const * const)+24j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??6?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEAAV012@QBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3ED0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::error_category::operator==(class	std::error_category const &)const
		public ??8error_category@std@@QBE_NABV01@@Z
??8error_category@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Bp
					; std::error_category::equivalent(std::error_code const	&,int)+23p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_3EF8
		mov	[ebp+var_8], 1
		jmp	short loc_3EFF
; ---------------------------------------------------------------------------

loc_3EF8:				; CODE XREF: std::error_category::operator==(std::error_category const &)+1Dj
		mov	[ebp+var_8], 0

loc_3EFF:				; CODE XREF: std::error_category::operator==(std::error_category const &)+26j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_category@std@@QBE_NABV01@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::error_condition::operator==(std::error_condition *)
		public ??8error_condition@std@@QBE_NABV01@@Z
??8error_condition@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+43p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		push	eax
		mov	ecx, [ebp+var_4] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		mov	ecx, eax
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_3F5E
		mov	ecx, [ebp+var_4] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		cmp	esi, eax
		jnz	short loc_3F5E
		mov	[ebp+var_8], 1
		jmp	short loc_3F65
; ---------------------------------------------------------------------------

loc_3F5E:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+35j
					; std::error_condition::operator==(std::error_condition	const &)+4Bj
		mov	[ebp+var_8], 0

loc_3F65:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+54j
		mov	al, byte ptr [ebp+var_8]
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_condition@std@@QBE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F7Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1Bitmap>::operator struct ID2D1Bitmap *(void)const
		public ??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ
??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+4Ap
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+59p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID2D1RenderTarget>::operator	struct ID2D1RenderTarget *(void)const
		public ??B?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ
??B?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+3FAp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+65Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ	; RefPtr<ID2D1RenderTarget>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10ShaderResourceView>::operator struct ID3D10ShaderResourceView *(void)const
		public ??B?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ
??B?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+47p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+56p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ ;	RefPtr<ID3D10ShaderResourceView>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct ID3D10Texture2D>::operator struct ID3D10Texture2D *(void)const
		public ??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ
??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+280p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+295p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 400Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtr<struct IDXGISurface>::operator struct IDXGISurface *(void)const
		public ??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ
??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+237p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+582p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ ;	RefPtr<IDXGISurface>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4030h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1Bitmap>::operator struct ID2D1Bitmap * *(void)
		public ??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ
??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+228p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+309p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4058h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID2D1RenderTarget>::operator struct ID2D1RenderTarget *	*(void)
		public ??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ
??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+56Fp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ ;	RefPtr<ID2D1RenderTarget>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4080h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10ShaderResourceView>::operator struct ID3D10ShaderResourceView * *(void)
		public ??B?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ
??B?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+E6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ ; RefPtr<ID3D10ShaderResourceView>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	ID3D10Texture2D>::operator struct ID3D10Texture2D * *(void)
		public ??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ
??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+1A3p
					; mozilla::gfx::SourceSurfaceD2DTarget::DrawTargetWillChange(void)+A1p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall RefPtrGetterAddRefs<struct	IDXGISurface>::operator	struct IDXGISurface * *(void)
		public ??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ
??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+C9p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+42Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		call	?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ ; RefPtr<IDXGISurface>::StartAssignment(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??B?$RefPtrGetterAddRefs@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::fpos<int>::operator __int64(void)const
		public ??B?$fpos@H@std@@QBE_JXZ
??B?$fpos@H@std@@QBE_JXZ proc near	; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+2Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	edx, [eax]
		add	edx, [ecx+8]
		mov	esi, [eax+4]
		adc	esi, [ecx+0Ch]
		mov	eax, edx
		mov	edx, esi
		pop	esi
		mov	esp, ebp
		pop	ebp
		retn
??B?$fpos@H@std@@QBE_JXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4124h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::operator bool(void)const
		public ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+10Cp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 413Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1Bitmap * __thiscall RefPtr<struct	ID2D1Bitmap>::operator->(void)const
		public ??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ
??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+645p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_414A:				; CODE XREF: RefPtr<ID2D1Bitmap>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_414A
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ ; RefPtr<ID2D1Bitmap>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4164h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Texture2D * __thiscall RefPtr<struct ID3D10Texture2D>::operator->(void)const
		public ??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ
??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)+2Cp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+B0p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_4172:				; CODE XREF: RefPtr<ID3D10Texture2D>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_4172
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ ; RefPtr<ID3D10Texture2D>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 418Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::DataSourceSurfaceD2DTarget * __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::operator->(void)const
		public ??C?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ
??C?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+189p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+28Bp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_419A:				; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::operator->(void)+10j
		xor	eax, eax
		jnz	short loc_419A
		mov	ecx, [ebp+var_4]
		call	?get@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ ; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::get(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??C?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall mozilla::detail::AtomicBaseIncDec<unsigned int, 2>::operator++(void)
		public ??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ
??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ proc near
					; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z ; mozilla::detail::IntrinsicIncDec<uint,2>::inc(std::atomic<uint> &)
		add	esp, 4
		add	eax, 1
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall mozilla::detail::AtomicBaseIncDec<unsigned int, 2>::operator--(void)
		public ??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ
??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ proc near
					; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+28p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z ; mozilla::detail::IntrinsicIncDec<uint,2>::dec(std::atomic<uint> &)
		add	esp, 4
		sub	eax, 1
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 420Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`vbase destructor(void)
		public ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ proc near
					; CODE XREF: __unwindfunclet$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0+3j
					; __unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0+3j ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		add	ecx, 68h ; 'h'
		call	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	ecx, [ebp+var_4]
		add	ecx, 68h ; 'h'
		mov	esi, esp
		call	dword ptr ds:__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ;	std::basic_ios<char,std::char_traits<char>>::~basic_ios<char,std::char_traits<char>>(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	byte public 'CODE' use32
		assume cs:_text$mn
		;org 424Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vector deleting destructor'`vtordisp{4294967292, 0}' (unsigned int)
		public ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z proc near
					; DATA XREF: .rdata:const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vftable'o
		sub	ecx, [ecx-4]
		jmp	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vector deleting destructor'(uint)
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4254h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`scalar deleting destructor'(unsigned int)
		public ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_427E
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_427E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4294h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`scalar deleting destructor'(unsigned int)
		public ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		sub	ecx, 68h ; 'h'
		call	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ;	std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_42C4
		mov	ecx, [ebp+var_4]
		sub	ecx, 68h ; 'h'
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_42C4:				; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`scalar	deleting destructor'(uint)+1Fj
		mov	eax, [ebp+var_4]
		sub	eax, 68h ; 'h'
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 42DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::DataSourceSurface::`scalar deleting destructor'(unsigned int)
		public ??_GDataSourceSurface@gfx@mozilla@@UAEPAXI@Z
??_GDataSourceSurface@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1DataSourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurface::~DataSourceSurface(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4306
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4306:				; CODE XREF: mozilla::gfx::DataSourceSurface::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDataSourceSurface@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 431Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::`scalar deleting destructor'(unsigned int)
		public ??_GDataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z
??_GDataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4346
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4346:				; CODE XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::`scalar deleting	destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GDataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 435Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurface::`scalar deleting destructor'(unsigned int)
		public ??_GSourceSurface@gfx@mozilla@@UAEPAXI@Z
??_GSourceSurface@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1SourceSurface@gfx@mozilla@@UAE@XZ ; mozilla::gfx::SourceSurface::~SourceSurface(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4386
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4386:				; CODE XREF: mozilla::gfx::SourceSurface::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSourceSurface@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 439Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurfaceD2DTarget::`scalar deleting destructor'(unsigned int)
		public ??_GSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z
??_GSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ ;	mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_43C6
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_43C6:				; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 43DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Generic_error_category@std@@UAEPAXI@Z
??_G_Generic_error_category@std@@UAEPAXI@Z proc	near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4406
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4406:				; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Generic_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 441Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Iostream_error_category@std@@UAEPAXI@Z
??_G_Iostream_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4446
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4446:				; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Iostream_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 445Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_System_error_category@std@@UAEPAXI@Z
??_G_System_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4486
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4486:				; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_System_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 449Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
		public ??_Gerror_category@std@@UAEPAXI@Z
??_Gerror_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_44C6
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_44C6:				; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_Gerror_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 44DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		push	offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4500h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category(void)
		push	offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4524h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??0_System_error_category@std@@QAE@XZ ;	std::_System_error_category::_System_error_category(void)
		push	offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ	; void (__cdecl	*)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4548h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 456Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 4590h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
??__Eallocator_arg@std@@YAXXZ proc near	; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Eallocator_arg@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 45A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
??__Epiecewise_construct@std@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Epiecewise_construct@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 45B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 45D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 45E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4600h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1Bitmap>::AddRefTraits<struct ID2D1Bitmap>::AddRef(struct ID2D1Bitmap *)
		public ?AddRef@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z
?AddRef@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::assign_with_AddRef(ID2D1Bitmap *)+18p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z ; RefPtr<ID2D1Bitmap>::AddRefTraitsAddRefHelper(ID2D1Bitmap *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4618h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1RenderTarget>::AddRefTraits<struct ID2D1RenderTarget>::AddRef(struct ID2D1RenderTarget	*)
		public ?AddRef@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z
?AddRef@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::assign_with_AddRef(ID2D1RenderTarget *)+18p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z ; RefPtr<ID2D1RenderTarget>::AddRefTraitsAddRefHelper(ID2D1RenderTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4630h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraits<struct ID3D10Texture2D>::AddRef(struct ID3D10Texture2D *)
		public ?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z
?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(RefPtr<ID3D10Texture2D> const &)+26p
					; RefPtr<ID3D10Texture2D>::RefPtr<ID3D10Texture2D>(ID3D10Texture2D *)+24p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraitsAddRefHelper(ID3D10Texture2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4648h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraits<class mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRef(class mozilla::gfx::DataSourceSurfaceD2DTarget *)
		public ?AddRef@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?AddRef@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(mozilla::gfx::DataSourceSurfaceD2DTarget *)+24p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraitsAddRefHelper(mozilla::gfx::DataSourceSurfaceD2DTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4660h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraits<class mozilla::gfx::SourceSurfaceD2DTarget>::AddRef(class mozilla::gfx::SourceSurfaceD2DTarget *)
		public ?AddRef@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?AddRef@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_with_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)+18p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsAddRefHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraitsAddRefHelper(mozilla::gfx::SourceSurfaceD2DTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRef@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4678h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::AddRef(void)const
		public ?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ
?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraitsAddRefHelper(mozilla::gfx::DataSourceSurfaceD2DTarget *)+9p
					; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraitsAddRefHelper(mozilla::gfx::SourceSurfaceD2DTarget *)+9p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_4686:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)+10j
		xor	eax, eax
		jnz	short loc_4686
		mov	ecx, [ebp+var_4]
		call	??E?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ ; mozilla::detail::AtomicBaseIncDec<uint,2>::operator++(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1Bitmap>::AddRefTraitsAddRefHelper(struct ID2D1Bitmap *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::AddRef(ID2D1Bitmap	*)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1RenderTarget>::AddRefTraitsAddRefHelper(struct ID2D1RenderTarget *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::AddRef(ID2D1RenderTarget *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraitsAddRefHelper(struct ID3D10Texture2D *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::AddRef(ID3D10Texture2D *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4718h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraitsAddRefHelper(class mozilla::gfx::DataSourceSurfaceD2DTarget *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRef(mozilla::gfx::DataSourceSurfaceD2DTarget *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4730h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraitsAddRefHelper(class mozilla::gfx::SourceSurfaceD2DTarget *)
		public ?AddRefTraitsAddRefHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?AddRefTraitsAddRefHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::SourceSurfaceD2DTarget>::AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?AddRef@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::AddRef(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsAddRefHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4748h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1Bitmap>::AddRefTraitsReleaseHelper(struct ID2D1Bitmap	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::Release(ID2D1Bitmap *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4770h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID2D1RenderTarget>::AddRefTraitsReleaseHelper(struct ID2D1RenderTarget *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::Release(ID2D1RenderTarget *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4798h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10ShaderResourceView>::AddRefTraitsReleaseHelper(struct ID3D10ShaderResourceView *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10ShaderResourceView@@@@CAXPAUID3D10ShaderResourceView@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10ShaderResourceView@@@@CAXPAUID3D10ShaderResourceView@@@Z proc near
					; CODE XREF: RefPtr<ID3D10ShaderResourceView>::AddRefTraits<ID3D10ShaderResourceView>::Release(ID3D10ShaderResourceView	*)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10ShaderResourceView@@@@CAXPAUID3D10ShaderResourceView@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 47C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraitsReleaseHelper(struct	ID3D10Texture2D	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::Release(ID3D10Texture2D *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 47E8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<struct IDXGISurface>::AddRefTraitsReleaseHelper(struct IDXGISurface *)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z proc near
					; CODE XREF: RefPtr<IDXGISurface>::AddRefTraits<IDXGISurface>::Release(IDXGISurface *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ecx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4810h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraitsReleaseHelper(class mozilla::gfx::DataSourceSurfaceD2DTarget	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z	proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::DataSourceSurfaceD2DTarget>::Release(mozilla::gfx::DataSourceSurfaceD2DTarget	*)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ ;	mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4828h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: static void __cdecl RefPtr<class mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraitsReleaseHelper(class mozilla::gfx::SourceSurfaceD2DTarget	*)
		public ?AddRefTraitsReleaseHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?AddRefTraitsReleaseHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z	proc near
					; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::SourceSurfaceD2DTarget>::Release(mozilla::gfx::SourceSurfaceD2DTarget *)+7p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		add	ecx, 4
		call	?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ ;	mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?AddRefTraitsReleaseHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4840h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::AutoPrefix(void)const
		public ?AutoPrefix@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?AutoPrefix@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+57p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 2
		jz	short loc_486B
		mov	byte ptr [ebp+var_8+3],	1
		jmp	short loc_486F
; ---------------------------------------------------------------------------

loc_486B:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::AutoPrefix(void)+23j
		mov	byte ptr [ebp+var_8+3],	0

loc_486F:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::AutoPrefix(void)+29j
		mov	al, byte ptr [ebp+var_8+3]
		mov	esp, ebp
		pop	ebp
		retn
?AutoPrefix@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4878h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::AutoPrefix(void)const
		public ?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+57p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 2
		jz	short loc_48A3
		mov	byte ptr [ebp+var_8+3],	1
		jmp	short loc_48A7
; ---------------------------------------------------------------------------

loc_48A3:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::AutoPrefix(void)+23j
		mov	byte ptr [ebp+var_8+3],	0

loc_48A7:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::AutoPrefix(void)+29j
		mov	al, byte ptr [ebp+var_8+3]
		mov	esp, ebp
		pop	ebp
		retn
?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48B0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_BITMAP_PROPERTIES	__cdecl	D2D1::BitmapProperties(struct D2D1_PIXEL_FORMAT	const &, float,	float)
		public ?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z
?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+1C1p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+2AAp

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	[ebp+var_18], ecx
		mov	[ebp+var_14], edx
		movss	xmm0, [ebp+arg_8]
		movss	[ebp+var_10], xmm0
		movss	xmm0, [ebp+arg_C]
		movss	[ebp+var_C], xmm0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_18]
		mov	[eax], ecx
		mov	edx, [ebp+var_14]
		mov	[eax+4], edx
		mov	ecx, [ebp+var_10]
		mov	[eax+8], ecx
		mov	edx, [ebp+var_C]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
?BitmapProperties@D2D1@@YA?AUD2D1_BITMAP_PROPERTIES@@ABUD2D1_PIXEL_FORMAT@@MM@Z	endp

; ---------------------------------------------------------------------------
$LN5_4		dd 1			; DATA XREF: D2D1::BitmapProperties(D2D1_PIXEL_FORMAT const &,float,float)+6Do
		dd offset $LN4_4
$LN4_4		dd 0FFFFFFE8h, 10h	; DATA XREF: .text$mn:0000493Co
		dd offset $LN3_4	; "bitmapProperties"
$LN3_4		db 'bitmapProperties',0 ; DATA XREF: .text$mn:00004948o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4960h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl mozilla::gfx::BasicLogger::CrashAction(enum  mozilla::gfx::LogReason)
		public ?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z
?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z proc	near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+70p
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4968h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: long __thiscall ID2D1RenderTarget::CreateBitmap(struct D2D_SIZE_U, struct D2D1_BITMAP_PROPERTIES const &, struct ID2D1Bitmap * *)
		public ?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z
?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+327p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		push	eax
		mov	ecx, [edx+10h]
		call	ecx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?CreateBitmap@ID2D1RenderTarget@@QAEJUD2D_SIZE_U@@ABUD2D1_BITMAP_PROPERTIES@@PAPAUID2D1Bitmap@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 49B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int32 __thiscall ID2D1Factory::CreateDxgiSurfaceRenderTarget(ID2D1Factory *this, struct IDXGISurface *, const struct D2D1_RENDER_TARGET_PROPERTIES *, struct ID2D1RenderTarget **)
		public ?CreateDxgiSurfaceRenderTarget@ID2D1Factory@@QAEJPAUIDXGISurface@@ABUD2D1_RENDER_TARGET_PROPERTIES@@PAPAUID2D1RenderTarget@@@Z
?CreateDxgiSurfaceRenderTarget@ID2D1Factory@@QAEJPAUIDXGISurface@@ABUD2D1_RENDER_TARGET_PROPERTIES@@PAPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+58Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	edx, [ebp+var_4]
		push	edx
		mov	eax, [ecx+3Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?CreateDxgiSurfaceRenderTarget@ID2D1Factory@@QAEJPAUIDXGISurface@@ABUD2D1_RENDER_TARGET_PROPERTIES@@PAPAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 49F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::DefaultOptions(bool)
		public ?DefaultOptions@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z
?DefaultOptions@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+10Ap
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSRView(void)+72p

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_4A14
		mov	[ebp+var_4], 4
		jmp	short loc_4A1B
; ---------------------------------------------------------------------------

loc_4A14:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::DefaultOptions(bool)+11j
		mov	[ebp+var_4], 0

loc_4A1B:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::DefaultOptions(bool)+1Aj
		mov	eax, [ebp+var_4]
		or	eax, 2
		mov	esp, ebp
		pop	ebp
		retn
?DefaultOptions@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::DefaultOptions(bool)
		public ?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z
?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+10Cp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+358p ...

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_4A44
		mov	[ebp+var_4], 4
		jmp	short loc_4A4B
; ---------------------------------------------------------------------------

loc_4A44:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)+11j
		mov	[ebp+var_4], 0

loc_4A4B:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::DefaultOptions(bool)+1Aj
		mov	eax, [ebp+var_4]
		or	eax, 2
		mov	esp, ebp
		pop	ebp
		retn
?DefaultOptions@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@SAH_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::UserData::Destroy(mozilla::gfx::UserData *__hidden this)
		public ?Destroy@UserData@gfx@mozilla@@QAEXXZ
?Destroy@UserData@gfx@mozilla@@QAEXXZ proc near
					; CODE XREF: mozilla::gfx::UserData::~UserData(void)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		jmp	short loc_4A82
; ---------------------------------------------------------------------------

loc_4A79:				; CODE XREF: mozilla::gfx::UserData::Destroy(void):loc_4AC8j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_4A82:				; CODE XREF: mozilla::gfx::UserData::Destroy(void)+1Fj
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+var_8]
		cmp	edx, [ecx]
		jge	short loc_4ACA
		imul	eax, [ebp+var_8], 0Ch
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		cmp	dword ptr [edx+eax+8], 0
		jz	short loc_4AC8
		imul	eax, [ebp+var_8], 0Ch
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		mov	esi, esp
		mov	eax, [edx+eax+4]
		push	eax
		imul	ecx, [ebp+var_8], 0Ch
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	ecx, [eax+ecx+8]
		call	ecx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4AC8:				; CODE XREF: mozilla::gfx::UserData::Destroy(void)+43j
		jmp	short loc_4A79
; ---------------------------------------------------------------------------

loc_4ACA:				; CODE XREF: mozilla::gfx::UserData::Destroy(void)+32j
		mov	esi, esp
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		push	eax		; Memory
		call	dword ptr ds:__imp__free
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx], 0
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Destroy@UserData@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::Flush(void)
		public ?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::~Log<1,mozilla::gfx::CriticalLogger>(void)+37p

var_54		= byte ptr -54h
var_34		= byte ptr -34h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 48h
		push	edi
		push	ecx
		lea	edi, [ebp+var_54]
		mov	ecx, 12h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	?LogIt@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jnz	short loc_4B56
		jmp	short loc_4BBC
; ---------------------------------------------------------------------------

loc_4B56:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+4Aj
		lea	ecx, [ebp+var_34]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(void)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_34]
		call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)
		movzx	edx, al
		test	edx, edx
		jnz	short loc_4B84
		lea	eax, [ebp+var_34]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?WriteLog@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)

loc_4B84:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+6Ej
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	Str
		lea	ecx, [ebp+var_54]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_54]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_34]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)

loc_4BBC:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+4Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 54h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
$LN10		dd 1			; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+B8o
		dd offset $LN9
$LN9		db 0CCh			; DATA XREF: .text$mn:00004BF8o
		db 3 dup(0FFh)
		dd 1Ch
		dd offset $LN7
; ---------------------------------------------------------------------------

$LN7:					; DATA XREF: .text$mn:00004C04o
		jnb	short loc_4C7E
		jb	short $+2
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4C0Ch
; COMDAT (pick associative to section at 4B08)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0 proc near
					; CODE XREF: .text$mn:00004C0Aj
					; DATA XREF: .xdata$x:00008788o
		lea	ecx, [ebp-34h]
		jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
__unwindfunclet$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1 proc near
					; DATA XREF: .xdata$x:00008790o
		lea	ecx, [ebp-54h]
		jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
__unwindfunclet$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ proc near
					; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-50h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C44h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::Flush(void)
		public ?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::~Log<2,mozilla::gfx::BasicLogger>(void)+37p

var_54		= byte ptr -54h
var_34		= byte ptr -34h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 48h
		push	edi
		push	ecx
		lea	edi, [ebp+var_54]
		mov	ecx, 12h
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax

loc_4C7E:				; CODE XREF: .text$mn:$LN7j
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jnz	short loc_4C92
		jmp	short loc_4CF8
; ---------------------------------------------------------------------------

loc_4C92:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+4Aj
		lea	ecx, [ebp+var_34]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(void)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_34]
		call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)
		movzx	edx, al
		test	edx, edx
		jnz	short loc_4CC0
		lea	eax, [ebp+var_34]
		push	eax
		mov	ecx, [ebp+var_14]
		call	?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)

loc_4CC0:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+6Ej
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	Str
		lea	ecx, [ebp+var_54]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	byte ptr [ebp+var_4], 1
		lea	ecx, [ebp+var_54]
		push	ecx
		mov	ecx, [ebp+var_14]
		call	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_54]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_34]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)

loc_4CF8:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+4Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 54h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
$LN10_0		dd 1			; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+B8o
		dd offset $LN9_0
$LN9_0		db 0CCh			; DATA XREF: .text$mn:00004D34o
		db 3 dup(0FFh)
		dd 1Ch
		dd offset $LN7_0
; ---------------------------------------------------------------------------

$LN7_0:					; DATA XREF: .text$mn:00004D40o
		jnb	short loc_4DBA
		jb	short $+2
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4D48h
; COMDAT (pick associative to section at 4C44)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0 proc near
					; CODE XREF: .text$mn:00004D46j
					; DATA XREF: .xdata$x:00008814o
		lea	ecx, [ebp-34h]
		jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1 proc near
					; DATA XREF: .xdata$x:0000881Co
		lea	ecx, [ebp-54h]
		jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
__unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ proc	near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-50h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall mozilla::gfx::SourceSurface::GetNativeSurface(enum	mozilla::gfx::NativeSurfaceType)
		public ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z
?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z proc near
					; DATA XREF: .rdata:00008E2Co
					; .rdata:00008E50o ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		xor	eax, eax
		mov	esp, ebp
		pop	ebp
		retn	4
?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceType __thiscall mozilla::gfx::DataSourceSurface::GetType(void)const
		public ?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ
?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ proc near
					; DATA XREF: .rdata:00008E3Co

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		xor	al, al
		mov	esp, ebp
		pop	ebp
		retn
?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4DACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceType __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::GetType(void)const
		public ?GetType@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ
?GetType@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ proc near
					; DATA XREF: .rdata:00008F00o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_4DBA:				; CODE XREF: .text$mn:$LN7_0j
		xor	al, al
		mov	esp, ebp
		pop	ebp
		retn
?GetType@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4DC0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	mozilla::gfx::SurfaceType __thiscall mozilla::gfx::SourceSurfaceD2DTarget::GetType(void)const
		public ?GetType@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ
?GetType@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ proc near
					; DATA XREF: .rdata:00008EDCo

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	al, 2
		mov	esp, ebp
		pop	ebp
		retn
?GetType@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4DD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::SourceSurface::GuaranteePersistance(mozilla::gfx::SourceSurface	*__hidden this)
		public ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ
?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ	proc near
					; DATA XREF: .rdata:00008E30o
					; .rdata:00008E54o ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn
?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4DE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall mozilla::gfx::Log<1,	struct mozilla::gfx::CriticalLogger>::Init(int,	bool, enum  mozilla::gfx::LogReason)
		public ?Init@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z
?Init@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z proc	near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Log<1,mozilla::gfx::CriticalLogger>(int,mozilla::gfx::LogReason)+70p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0B0h], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_8]
		mov	[edx+0B4h], eax
		mov	ecx, [ebp+var_4]
		mov	dl, [ebp+arg_4]
		mov	[ecx+0B8h], dl
		mov	eax, [ebp+var_4]
		movzx	ecx, byte ptr [eax+0B8h]
		test	ecx, ecx
		jz	loc_4F6F
		mov	ecx, [ebp+var_4]
		call	?AutoPrefix@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::AutoPrefix(void)
		movzx	edx, al
		test	edx, edx
		jz	loc_4EE5
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 4
		jz	short loc_4E9B
		cmp	[ebp+var_4], 0
		jz	short loc_4E6E
		mov	edx, [ebp+var_4]
		add	edx, 10h
		mov	[ebp+var_8], edx
		jmp	short loc_4E75
; ---------------------------------------------------------------------------

loc_4E6E:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+79j
		mov	[ebp+var_8], 0

loc_4E75:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+84j
		mov	esi, esp
		push	1
		push	offset ??_C@_04HGKILAJC@?$FLGFX?$AA@ ; "[GFX"
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_4EE5
; ---------------------------------------------------------------------------

loc_4E9B:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+73j
		cmp	[ebp+var_4], 0
		jz	short loc_4EAC
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_C], ecx
		jmp	short loc_4EB3
; ---------------------------------------------------------------------------

loc_4EAC:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+B7j
		mov	[ebp+var_C], 0

loc_4EB3:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+C2j
		push	offset ??_C@_01JOAMLHOP@?9?$AA@	; Str
		mov	esi, esp
		push	1
		push	offset ??_C@_04HGKILAJC@?$FLGFX?$AA@ ; "[GFX"
		mov	edx, [ebp+var_C]
		push	edx		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_4EE5:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+61j
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+B1j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 8
		jz	short loc_4F46
		mov	ecx, [ebp+var_4]
		call	?ValidReason@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::ValidReason(void)
		movzx	edx, al
		test	edx, edx
		jz	short loc_4F46
		cmp	[ebp+var_4], 0
		jz	short loc_4F13
		mov	eax, [ebp+var_4]
		add	eax, 10h
		mov	[ebp+var_10], eax
		jmp	short loc_4F1A
; ---------------------------------------------------------------------------

loc_4F13:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+11Ej
		mov	[ebp+var_10], 0

loc_4F1A:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+129j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+0B4h]
		push	edx
		push	offset ??_C@_01CLKCMJKC@?5?$AA@	; Str
		mov	eax, [ebp+var_10]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4F46:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+109j
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+118j
		cmp	[ebp+var_4], 0
		jz	short loc_4F57
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_14], ecx
		jmp	short loc_4F5E
; ---------------------------------------------------------------------------

loc_4F57:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+162j
		mov	[ebp+var_14], 0

loc_4F5E:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+16Dj
		push	offset ??_C@_03FLKELDHI@?$FN?3?5?$AA@ ;	Str
		mov	edx, [ebp+var_14]
		push	edx		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_4F6F:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+4Ej
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?Init@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4F80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall mozilla::gfx::Log<2,	struct mozilla::gfx::BasicLogger>::Init(int, bool, enum	 mozilla::gfx::LogReason)
		public ?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z
?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z	proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+70p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0B0h], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_8]
		mov	[edx+0B4h], eax
		mov	ecx, [ebp+var_4]
		mov	dl, [ebp+arg_4]
		mov	[ecx+0B8h], dl
		mov	eax, [ebp+var_4]
		movzx	ecx, byte ptr [eax+0B8h]
		test	ecx, ecx
		jz	loc_5107
		mov	ecx, [ebp+var_4]
		call	?AutoPrefix@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::AutoPrefix(void)
		movzx	edx, al
		test	edx, edx
		jz	loc_507D
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 4
		jz	short loc_5033
		cmp	[ebp+var_4], 0
		jz	short loc_5006
		mov	edx, [ebp+var_4]
		add	edx, 10h
		mov	[ebp+var_8], edx
		jmp	short loc_500D
; ---------------------------------------------------------------------------

loc_5006:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+79j
		mov	[ebp+var_8], 0

loc_500D:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+84j
		mov	esi, esp
		push	2
		push	offset ??_C@_04HGKILAJC@?$FLGFX?$AA@ ; "[GFX"
		mov	eax, [ebp+var_8]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_507D
; ---------------------------------------------------------------------------

loc_5033:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+73j
		cmp	[ebp+var_4], 0
		jz	short loc_5044
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_C], ecx
		jmp	short loc_504B
; ---------------------------------------------------------------------------

loc_5044:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+B7j
		mov	[ebp+var_C], 0

loc_504B:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+C2j
		push	offset ??_C@_01JOAMLHOP@?9?$AA@	; Str
		mov	esi, esp
		push	2
		push	offset ??_C@_04HGKILAJC@?$FLGFX?$AA@ ; "[GFX"
		mov	edx, [ebp+var_C]
		push	edx		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_507D:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+61j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+B1j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 8
		jz	short loc_50DE
		mov	ecx, [ebp+var_4]
		call	?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ;	mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)
		movzx	edx, al
		test	edx, edx
		jz	short loc_50DE
		cmp	[ebp+var_4], 0
		jz	short loc_50AB
		mov	eax, [ebp+var_4]
		add	eax, 10h
		mov	[ebp+var_10], eax
		jmp	short loc_50B2
; ---------------------------------------------------------------------------

loc_50AB:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+11Ej
		mov	[ebp+var_10], 0

loc_50B2:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+129j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+0B4h]
		push	edx
		push	offset ??_C@_01CLKCMJKC@?5?$AA@	; Str
		mov	eax, [ebp+var_10]
		push	eax		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8
		mov	ecx, eax
		call	dword ptr ds:__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z	; std::basic_ostream<char,std::char_traits<char>>::operator<<(int)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_50DE:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+109j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+118j
		cmp	[ebp+var_4], 0
		jz	short loc_50EF
		mov	ecx, [ebp+var_4]
		add	ecx, 10h
		mov	[ebp+var_14], ecx
		jmp	short loc_50F6
; ---------------------------------------------------------------------------

loc_50EF:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+162j
		mov	[ebp+var_14], 0

loc_50F6:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+16Dj
		push	offset ??_C@_03FLKELDHI@?$FN?3?5?$AA@ ;	Str
		mov	edx, [ebp+var_14]
		push	edx		; int
		call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)
		add	esp, 8

loc_5107:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+4Ej
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?Init@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXH_NW4LogReason@23@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5118h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall mozilla::gfx::SourceSurface::IsValid(mozilla::gfx::SourceSurface *__hidden this)
		public ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ
?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ proc near ;	DATA XREF: .rdata:00008E24o
					; .rdata:00008E48o ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	al, 1
		mov	esp, ebp
		pop	ebp
		retn
?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 512Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::LogIt(void)const
		public ?LogIt@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?LogIt@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc	near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::operator<<(char	const *	const)+1Ap
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+40p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+0B8h]
		mov	esp, ebp
		pop	ebp
		retn
?LogIt@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5148h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::LogIt(void)const
		public ?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+24p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<(char const	* const)+1Ap ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+0B8h]
		mov	esp, ebp
		pop	ebp
		retn
?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5164h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual bool __thiscall mozilla::gfx::DataSourceSurface::Map(enum  mozilla::gfx::DataSourceSurface::MapType, struct mozilla::gfx::DataSourceSurface::MappedSurface *)
		public ?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z
?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z proc near
					; DATA XREF: .rdata:00008E60o

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		mov	edx, [eax+24h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_4]
		mov	[ecx+4], eax
		mov	edx, [ebp+arg_4]
		cmp	dword ptr [edx], 0
		jz	short loc_51C4
		mov	[ebp+var_8], 1
		jmp	short loc_51CB
; ---------------------------------------------------------------------------

loc_51C4:				; CODE XREF: mozilla::gfx::DataSourceSurface::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+55j
		mov	[ebp+var_8], 0

loc_51CB:				; CODE XREF: mozilla::gfx::DataSourceSurface::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)+5Ej
		mov	eax, [ebp+var_4]
		mov	cl, byte ptr [ebp+var_8]
		mov	[eax+10h], cl
		mov	edx, [ebp+var_4]
		mov	al, [edx+10h]
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 51ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::NoNewline(void)const
		public ?NoNewline@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?NoNewline@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+20p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+0B0h]
		and	eax, 1
		mov	esp, ebp
		pop	ebp
		retn
?NoNewline@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 520Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::NoNewline(void)const
		public ?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+20p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+0B0h]
		and	eax, 1
		mov	esp, ebp
		pop	ebp
		retn
?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 522Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl mozilla::gfx::BasicLogger::OutputMessage(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>	const &, int, bool)
		public ?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+2Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA ;	int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		cmp	eax, [ebp+arg_4]
		jl	short loc_528D
		cmp	dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA, 4 ; int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		jge	short loc_5251
		cmp	[ebp+arg_4], 3
		jge	short loc_528D

loc_5251:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+1Dj
		movzx	ecx, [ebp+arg_8]
		test	ecx, ecx
		jz	short loc_5262
		mov	[ebp+var_4], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		jmp	short loc_5269
; ---------------------------------------------------------------------------

loc_5262:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+2Bj
		mov	[ebp+var_4], offset ??_C@_01EEMJAFIK@?6?$AA@ ; `string'

loc_5269:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+34j
		mov	esi, esp
		mov	edx, [ebp+var_4]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		push	eax
		push	offset ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@	; "%s%s"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_528D:				; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+14j
					; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,bool)+23j
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 529Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_PIXEL_FORMAT __cdecl D2D1::PixelFormat(enum  DXGI_FORMAT,	enum  D2D1_ALPHA_MODE)
		public ?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z
?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	proc near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+30p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_C]
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	esp, ebp
		pop	ebp
		retn
?PixelFormat@D2D1@@YA?AUD2D1_PIXEL_FORMAT@@W4DXGI_FORMAT@@W4D2D1_ALPHA_MODE@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_3		dd 1			; DATA XREF: D2D1::PixelFormat(DXGI_FORMAT,D2D1_ALPHA_MODE)+2Do
		dd offset $LN4_3
$LN4_3		dd 0FFFFFFF4h, 8	; DATA XREF: .text$mn:000052E0o
		dd offset $LN3_3	; "pixelFormat"
$LN3_3		db 'pixelFormat',0      ; DATA XREF: .text$mn:000052ECo
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1Bitmap>::AddRefTraits<struct ID2D1Bitmap>::Release(struct ID2D1Bitmap *)
		public ?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z
?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::~RefPtr<ID2D1Bitmap>(void)+1Cp
					; RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1Bitmap@@@@CAXPAUID2D1Bitmap@@@Z ; RefPtr<ID2D1Bitmap>::AddRefTraitsReleaseHelper(ID2D1Bitmap *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5314h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID2D1RenderTarget>::AddRefTraits<struct ID2D1RenderTarget>::Release(struct ID2D1RenderTarget *)
		public ?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z
?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::~RefPtr<ID2D1RenderTarget>(void)+1Cp
					; RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID2D1RenderTarget@@@@CAXPAUID2D1RenderTarget@@@Z ;	RefPtr<ID2D1RenderTarget>::AddRefTraitsReleaseHelper(ID2D1RenderTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 532Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10ShaderResourceView>::AddRefTraits<struct ID3D10ShaderResourceView>::Release(struct ID3D10ShaderResourceView *)
		public ?Release@?$AddRefTraits@UID3D10ShaderResourceView@@@?$RefPtr@UID3D10ShaderResourceView@@@@SAXPAUID3D10ShaderResourceView@@@Z
?Release@?$AddRefTraits@UID3D10ShaderResourceView@@@?$RefPtr@UID3D10ShaderResourceView@@@@SAXPAUID3D10ShaderResourceView@@@Z proc near
					; CODE XREF: RefPtr<ID3D10ShaderResourceView>::~RefPtr<ID3D10ShaderResourceView>(void)+1Cp
					; RefPtr<ID3D10ShaderResourceView>::assign_assuming_AddRef(ID3D10ShaderResourceView *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10ShaderResourceView@@@@CAXPAUID3D10ShaderResourceView@@@Z ; RefPtr<ID3D10ShaderResourceView>::AddRefTraitsReleaseHelper(ID3D10ShaderResourceView *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID3D10ShaderResourceView@@@?$RefPtr@UID3D10ShaderResourceView@@@@SAXPAUID3D10ShaderResourceView@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5344h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct ID3D10Texture2D>::AddRefTraits<struct ID3D10Texture2D>::Release(struct ID3D10Texture2D *)
		public ?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z
?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::~RefPtr<ID3D10Texture2D>(void)+1Cp
					; RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UID3D10Texture2D@@@@CAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraitsReleaseHelper(ID3D10Texture2D *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 535Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<struct IDXGISurface>::AddRefTraits<struct IDXGISurface>::Release(struct IDXGISurface *)
		public ?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z
?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z proc near
					; CODE XREF: RefPtr<IDXGISurface>::~RefPtr<IDXGISurface>(void)+1Cp
					; RefPtr<IDXGISurface>::assign_assuming_AddRef(IDXGISurface *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@UIDXGISurface@@@@CAXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::AddRefTraitsReleaseHelper(IDXGISurface *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5374h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraits<class mozilla::gfx::DataSourceSurfaceD2DTarget>::Release(class mozilla::gfx::DataSourceSurfaceD2DTarget *)
		public ?Release@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?Release@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::~RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>(void)+1Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z	; RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraitsReleaseHelper(mozilla::gfx::DataSourceSurfaceD2DTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 538Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl RefPtr<class mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraits<class mozilla::gfx::SourceSurfaceD2DTarget>::Release(class mozilla::gfx::SourceSurfaceD2DTarget *)
		public ?Release@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?Release@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc	near
					; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_assuming_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)+31p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRefTraitsReleaseHelper@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@CAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z	; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraitsReleaseHelper(mozilla::gfx::SourceSurfaceD2DTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?Release@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 53A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::Release(void)const
		public ?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ
?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::AddRefTraitsReleaseHelper(mozilla::gfx::DataSourceSurfaceD2DTarget *)+9p
					; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraitsReleaseHelper(mozilla::gfx::SourceSurfaceD2DTarget *)+9p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx

loc_53C5:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+23j
		xor	eax, eax
		jnz	short loc_53C5
		mov	ecx, [ebp+var_4]
		call	??F?$AtomicBaseIncDec@I$01@detail@mozilla@@QAEIXZ ; mozilla::detail::AtomicBaseIncDec<uint,2>::operator--(void)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_5427
		cmp	[ebp+var_4], 0
		jz	short loc_53EB
		mov	ecx, [ebp+var_4]
		sub	ecx, 4
		mov	[ebp+var_14], ecx
		jmp	short loc_53F2
; ---------------------------------------------------------------------------

loc_53EB:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+3Aj
		mov	[ebp+var_14], 0

loc_53F2:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+45j
		mov	edx, [ebp+var_14]
		mov	[ebp+var_10], edx
		mov	eax, [ebp+var_10]
		mov	[ebp+var_C], eax
		cmp	[ebp+var_C], 0
		jz	short loc_5420
		mov	esi, esp
		push	1
		mov	ecx, [ebp+var_C]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		jmp	short loc_5427
; ---------------------------------------------------------------------------

loc_5420:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+5Ej
		mov	[ebp+var_18], 0

loc_5427:				; CODE XREF: mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+34j
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::Release(void)+7Aj
		pop	esi
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Release@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5438h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D1_RENDER_TARGET_PROPERTIES __cdecl D2D1::RenderTargetProperties(enum  D2D1_RENDER_TARGET_TYPE, struct D2D1_PIXEL_FORMAT const &, float, float, enum	 D2D1_RENDER_TARGET_USAGE, enum	 D2D1_FEATURE_LEVEL)
		public ?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z
?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+52Dp

var_28		= byte ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		push	esi
		push	edi
		lea	edi, [ebp+var_28]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_24], eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		mov	eax, [ecx+4]
		mov	[ebp+var_20], edx
		mov	[ebp+var_1C], eax
		movss	xmm0, [ebp+arg_C]
		movss	[ebp+var_18], xmm0
		movss	xmm0, [ebp+arg_10]
		movss	[ebp+var_14], xmm0
		mov	ecx, [ebp+arg_14]
		mov	[ebp+var_10], ecx
		mov	edx, [ebp+arg_18]
		mov	[ebp+var_C], edx
		mov	ecx, 7
		lea	esi, [ebp+var_24]
		mov	edi, [ebp+arg_0]
		rep movsd
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
?RenderTargetProperties@D2D1@@YA?AUD2D1_RENDER_TARGET_PROPERTIES@@W4D2D1_RENDER_TARGET_TYPE@@ABUD2D1_PIXEL_FORMAT@@MMW4D2D1_RENDER_TARGET_USAGE@@W4D2D1_FEATURE_LEVEL@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_5		dd 1			; DATA XREF: D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE,D2D1_PIXEL_FORMAT const &,float,float,D2D1_RENDER_TARGET_USAGE,D2D1_FEATURE_LEVEL)+69o
		dd offset $LN4_5
$LN4_5		dd 0FFFFFFDCh, 1Ch	; DATA XREF: .text$mn:000054C4o
		dd offset $LN3_5	; "renderTargetProperties"
$LN3_5		db 'renderTargetProperties',0 ; DATA XREF: .text$mn:000054D0o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 54ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::gfx::BasicLogger::ShouldOutputMessage(int)
		public ?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z
?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Log<1,mozilla::gfx::CriticalLogger>(int,mozilla::gfx::LogReason)+5Dp
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Log<2,mozilla::gfx::BasicLogger>(int,mozilla::gfx::LogReason)+5Dp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA ;	int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		cmp	eax, [ebp+arg_0]
		jl	short loc_550C
		cmp	dword ptr ds:?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA, 4 ; int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		jge	short loc_5508
		cmp	[ebp+arg_0], 3
		jge	short loc_550C

loc_5508:				; CODE XREF: mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+14j
		mov	al, 1
		jmp	short loc_550E
; ---------------------------------------------------------------------------

loc_550C:				; CODE XREF: mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+Bj
					; mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+1Aj
		xor	al, al

loc_550E:				; CODE XREF: mozilla::gfx::BasicLogger::ShouldOutputMessage(int)+1Ej
		pop	ebp
		retn
?ShouldOutputMessage@BasicLogger@gfx@mozilla@@SA_NH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5510h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct D2D_SIZE_U __cdecl D2D1::SizeU(unsigned int, unsigned int)
		public ?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z
?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+2DDp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$Size@I@D2D1@@YA?AUD2D_SIZE_U@@II@Z ;	D2D1::Size<uint>(uint,uint)
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], edx
		mov	eax, [ebp+var_8]
		mov	edx, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?SizeU@D2D1@@YA?AUD2D_SIZE_U@@II@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5550h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1Bitmap * * __thiscall RefPtr<struct ID2D1Bitmap>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ
?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID2D1Bitmap>::operator	ID2D1Bitmap * *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	; RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID2D1Bitmap@@@@QAEPAPAUID2D1Bitmap@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 557Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1RenderTarget * * __thiscall RefPtr<struct	ID2D1RenderTarget>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ
?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID2D1RenderTarget>::operator ID2D1RenderTarget	* *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z ; RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID2D1RenderTarget@@@@QAEPAPAUID2D1RenderTarget@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 55A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10ShaderResourceView * * __thiscall RefPtr<struct ID3D10ShaderResourceView>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ
?StartAssignment@?$RefPtr@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID3D10ShaderResourceView>::operator ID3D10ShaderResourceView *	*(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID3D10ShaderResourceView@@@@AAEXPAUID3D10ShaderResourceView@@@Z ; RefPtr<ID3D10ShaderResourceView>::assign_assuming_AddRef(ID3D10ShaderResourceView *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID3D10ShaderResourceView@@@@QAEPAPAUID3D10ShaderResourceView@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 55D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Texture2D * * __thiscall	RefPtr<struct ID3D10Texture2D>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ
?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<ID3D10Texture2D>::operator ID3D10Texture2D * *(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	; RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UID3D10Texture2D@@@@QAEPAPAUID3D10Texture2D@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5600h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDXGISurface *	* __thiscall RefPtr<struct IDXGISurface>::StartAssignment(void)
		public ?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ
?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ proc near
					; CODE XREF: RefPtrGetterAddRefs<IDXGISurface>::operator IDXGISurface *	*(void)+13p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::assign_assuming_AddRef(IDXGISurface *)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?StartAssignment@?$RefPtr@UIDXGISurface@@@@QAEPAPAUIDXGISurface@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 562Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::DataSourceSurface::Unmap(mozilla::gfx::DataSourceSurface *__hidden this)
		public ?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ
?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ proc near ; DATA XREF: .rdata:00008E64o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_563A:				; CODE XREF: mozilla::gfx::DataSourceSurface::Unmap(void)+10j
		xor	eax, eax
		jnz	short loc_563A
		mov	ecx, [ebp+var_4]
		mov	byte ptr [ecx+10h], 0
		mov	esp, ebp
		pop	ebp
		retn
?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 564Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<1, struct mozilla::gfx::CriticalLogger>::ValidReason(void)const
		public ?ValidReason@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?ValidReason@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+10Ep
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+5Ap

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+0B4h], 0FFFFFFFFh
		jle	short loc_5684
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+0B4h], 65h ; 'e'
		jge	short loc_5684
		mov	[ebp+var_8], 1
		jmp	short loc_568B
; ---------------------------------------------------------------------------

loc_5684:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::ValidReason(void)+21j
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::ValidReason(void)+2Dj
		mov	[ebp+var_8], 0

loc_568B:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::ValidReason(void)+36j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?ValidReason@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5694h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::Log<2, struct mozilla::gfx::BasicLogger>::ValidReason(void)const
		public ?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ
?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+10Ep
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Ap

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+0B4h], 0FFFFFFFFh
		jle	short loc_56CC
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+0B4h], 65h ; 'e'
		jge	short loc_56CC
		mov	[ebp+var_8], 1
		jmp	short loc_56D3
; ---------------------------------------------------------------------------

loc_56CC:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)+21j
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)+2Dj
		mov	[ebp+var_8], 0

loc_56D3:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)+36j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 56DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall mozilla::gfx::Log<1,	struct mozilla::gfx::CriticalLogger>::WriteLog(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>	const &)
		public ?WriteLog@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
?WriteLog@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+77p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_5754
		mov	ecx, [ebp+var_4]
		call	?NoNewline@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::NoNewline(void)
		movzx	ecx, al
		push	ecx
		push	1
		mov	edx, [ebp+arg_0]
		push	edx
		call	?OutputMessage@CriticalLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ; mozilla::gfx::CriticalLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,bool)
		add	esp, 0Ch
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 4
		jz	short loc_5725

loc_5721:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+47j
		xor	edx, edx
		jnz	short loc_5721

loc_5725:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+43j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 8
		jz	short loc_5754
		mov	ecx, [ebp+var_4]
		call	?ValidReason@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::ValidReason(void)
		movzx	edx, al
		test	edx, edx
		jz	short loc_5754
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B4h]
		push	ecx
		call	?CrashAction@CriticalLogger@gfx@mozilla@@SAXW4LogReason@23@@Z ;	mozilla::gfx::CriticalLogger::CrashAction(mozilla::gfx::LogReason)
		add	esp, 4

loc_5754:				; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+1Bj
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+55j	...
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?WriteLog@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5764h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall mozilla::gfx::Log<2,	struct mozilla::gfx::BasicLogger>::WriteLog(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+77p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?LogIt@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ	; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::LogIt(void)
		movzx	eax, al
		test	eax, eax
		jz	short loc_57DC
		mov	ecx, [ebp+var_4]
		call	?NoNewline@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::NoNewline(void)
		movzx	ecx, al
		push	ecx
		push	2
		mov	edx, [ebp+arg_0]
		push	edx
		call	?OutputMessage@BasicLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>>	const &,int,bool)
		add	esp, 0Ch
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 4
		jz	short loc_57AD

loc_57A9:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+47j
		xor	edx, edx
		jnz	short loc_57A9

loc_57AD:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+43j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B0h]
		and	ecx, 8
		jz	short loc_57DC
		mov	ecx, [ebp+var_4]
		call	?ValidReason@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QBE_NXZ ;	mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::ValidReason(void)
		movzx	edx, al
		test	edx, edx
		jz	short loc_57DC
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+0B4h]
		push	ecx
		call	?CrashAction@BasicLogger@gfx@mozilla@@SAXW4LogReason@23@@Z ; mozilla::gfx::BasicLogger::CrashAction(mozilla::gfx::LogReason)
		add	esp, 4

loc_57DC:				; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+1Bj
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+55j ...
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?WriteLog@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 57ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	; std::allocator<std::_Container_proxy>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN5_0		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4_0
$LN4_0		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00005868o
		dd offset $LN3_0	; "_Alproxy"
$LN3_0		db '_Alproxy',0         ; DATA XREF: .text$mn:00005874o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5884h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Assign_rv(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &&)
		public ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z	proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+48p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 10h
		jnb	short loc_58C6
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		add	edx, 1
		push	edx		; Size
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		add	ecx, 4
		push	ecx		; Dst
		call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
		add	esp, 0Ch
		jmp	short loc_58F1
; ---------------------------------------------------------------------------

loc_58C6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+1Ej
		mov	edx, [ebp+arg_0]
		add	edx, 4
		push	edx		; int
		mov	eax, [ebp+var_4]
		add	eax, 4
		push	eax		; void *
		lea	ecx, [ebp+var_8+3]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char	*,char * &>(char * *,char * &)
		mov	edx, [ebp+arg_0]
		mov	dword ptr [edx+4], 0

loc_58F1:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+40j
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		mov	[eax+18h], edx
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+arg_0]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5928h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned long	__cdecl	std::_Atomic_fetch_add_4(unsigned long volatile	*, unsigned long, enum	std::memory_order)
		public ?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z
?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z proc near
					; CODE XREF: std::_Atomic_fetch_sub_4(ulong volatile *,ulong,std::memory_order)+11p
					; std::atomic_fetch_add_explicit(std::atomic_uint *,uint,std::memory_order)+Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 5	; switch 6 cases
		ja	short loc_599E	; jumptable 00005943 default case
		mov	ecx, [ebp+var_4]
		jmp	ds:$LN12[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	edx, [ebp+arg_4] ; jumptable 00005943 case 0
		push	edx		; unsigned __int32
		mov	eax, [ebp+arg_0]
		push	eax		; volatile unsigned __int32 *
		call	?_Fetch_add_relaxed_4@std@@YAKPCKK@Z ; std::_Fetch_add_relaxed_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A26
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	ecx, [ebp+arg_4] ; jumptable 00005943 cases 1,2
		push	ecx		; unsigned __int32
		mov	edx, [ebp+arg_0]
		push	edx		; volatile unsigned __int32 *
		call	?_Fetch_add_acquire_4@std@@YAKPCKK@Z ; std::_Fetch_add_acquire_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A26
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	eax, [ebp+arg_4] ; jumptable 00005943 case 3
		push	eax		; unsigned __int32
		mov	ecx, [ebp+arg_0]
		push	ecx		; volatile unsigned __int32 *
		call	?_Fetch_add_release_4@std@@YAKPCKK@Z ; std::_Fetch_add_release_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A26
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Bj
					; DATA XREF: .text$mn:$LN12o
		mov	edx, [ebp+arg_4] ; jumptable 00005943 cases 4,5
		push	edx		; unsigned __int32
		mov	eax, [ebp+arg_0]
		push	eax		; volatile unsigned __int32 *
		call	?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z ; std::_Fetch_add_seq_cst_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5A26
; ---------------------------------------------------------------------------

loc_599E:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+16j
		mov	esi, esp	; jumptable 00005943 default case
		push	698h		; unsigned int
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@ ; "Invalid memory_order"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
		test	ecx, ecx
		jz	short loc_59CC
		xor	edx, edx
		jnz	short loc_59FC

loc_59CC:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+9Ej
		mov	esi, esp
		push	offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	698h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_59FC
		int	3		; Trap to Debugger

loc_59FC:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+A2j
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+D1j
		mov	esi, esp
		push	0
		push	698h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1DC@FMPHIJPC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAf?$AAe?$AAt?$AAc?$AAh?$AA_?$AAa?$AAd?$AAd?$AA_?$AA4?$AA?$AA@ ;	"std::_Atomic_fetch_add_4"
		push	offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	eax, eax

loc_5A26:				; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+32j
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+47j ...
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd offset $LN5		; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+1Br
		dd offset $LN4		; jump table for switch	statement
		dd offset $LN4
		dd offset $LN3
		dd offset $LN2
		dd offset $LN2
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5A50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned long	__cdecl	std::_Atomic_fetch_sub_4(unsigned long volatile	*, unsigned long, enum	std::memory_order)
		public ?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z
?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_fetch_sub_explicit(std::atomic_uint *,uint,std::memory_order)+Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		xor	ecx, ecx
		sub	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z ; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5A74h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Atomic_store_4(unsigned long volatile *, unsigned long, enum  std::memory_order)
		public ?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z
?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_store_explicit(std::atomic_uint *,uint,std::memory_order)+Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jz	short loc_5A9A
		cmp	[ebp+var_4], 3
		jz	short loc_5AAF
		cmp	[ebp+var_4], 5
		jz	short loc_5AC4
		jmp	short loc_5AD9
; ---------------------------------------------------------------------------

loc_5A9A:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+16j
		mov	ecx, [ebp+arg_4]
		push	ecx		; unsigned __int32
		mov	edx, [ebp+arg_0]
		push	edx		; volatile unsigned __int32 *
		call	?_Store_relaxed_4@std@@YAXPCKK@Z ; std::_Store_relaxed_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5B5F
; ---------------------------------------------------------------------------

loc_5AAF:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+1Cj
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned __int32
		mov	ecx, [ebp+arg_0]
		push	ecx		; volatile unsigned __int32 *
		call	?_Store_release_4@std@@YAXPCKK@Z ; std::_Store_release_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5B5F
; ---------------------------------------------------------------------------

loc_5AC4:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+22j
		mov	edx, [ebp+arg_4]
		push	edx		; unsigned __int32
		mov	eax, [ebp+arg_0]
		push	eax		; volatile unsigned __int32 *
		call	?_Store_seq_cst_4@std@@YAXPCKK@Z ; std::_Store_seq_cst_4(ulong volatile	*,ulong)
		add	esp, 8
		jmp	loc_5B5F
; ---------------------------------------------------------------------------

loc_5AD9:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+24j
		mov	esi, esp
		push	577h		; unsigned int
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@ ; "Invalid memory_order"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
		test	ecx, ecx
		jz	short loc_5B07
		xor	edx, edx
		jnz	short loc_5B37

loc_5B07:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+8Dj
		mov	esi, esp
		push	offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
		push	offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
		push	0
		push	577h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	2
		call	dword ptr ds:__imp___CrtDbgReportW
		add	esp, 18h
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 1
		jnz	short loc_5B37
		int	3		; Trap to Debugger

loc_5B37:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+91j
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+C0j
		mov	esi, esp
		push	0
		push	577h
		push	offset ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		push	offset ??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@ ; "std::_Atomic_store_4"
		push	offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
		call	dword ptr ds:__imp___invalid_parameter
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5B5F:				; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+36j
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+4Bj ...
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
		public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Cp

var_38		= byte ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_25		= byte ptr -25h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 00005CB7 SIZE 00000009 BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 28h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_38]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		or	eax, 0Fh
		mov	[ebp+var_18], eax
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+var_18]
		jnb	short loc_5BCE
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_18], ecx
		jmp	short loc_5C20
; ---------------------------------------------------------------------------

loc_5BCE:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+54j
		mov	eax, [ebp+var_18]
		xor	edx, edx
		mov	ecx, 3
		div	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+18h]
		shr	ecx, 1
		cmp	ecx, eax
		ja	short loc_5BE8
		jmp	short loc_5C20
; ---------------------------------------------------------------------------

loc_5BE8:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+74j
		mov	edx, [ebp+var_14]
		mov	esi, [edx+18h]
		shr	esi, 1
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		sub	eax, esi
		mov	ecx, [ebp+var_14]
		cmp	[ecx+18h], eax
		ja	short loc_5C15
		mov	edx, [ebp+var_14]
		mov	eax, [edx+18h]
		shr	eax, 1
		mov	ecx, [ebp+var_14]
		add	eax, [ecx+18h]
		mov	[ebp+var_18], eax
		jmp	short loc_5C20
; ---------------------------------------------------------------------------

loc_5C15:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+90j
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		mov	[ebp+var_18], eax

loc_5C20:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5Cj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+76j ...
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_25]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_18]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_2C]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp+var_30], eax
		mov	ecx, [ebp+var_30]
		mov	[ebp+var_20], ecx
		jmp	short loc_5CB7
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp


; =============== S U B	R O U T	I N E =======================================


__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
					; DATA XREF: .xdata$x:000085F4o

; FUNCTION CHUNK AT 00005CA1 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00005CB1 SIZE 00000006 BYTES

		mov	[ebp-10h], esp
		mov	edx, [ebp+8]
		mov	[ebp-18h], edx
		mov	byte ptr [ebp-4], 2
		lea	eax, [ebp-26h]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp-34h], eax
		mov	ecx, [ebp-18h]
		add	ecx, 1
		push	ecx
		mov	ecx, [ebp-34h]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp-38h], eax
		mov	edx, [ebp-38h]
		mov	[ebp-20h], edx
		jmp	short loc_5CA1
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
					; DATA XREF: .xdata$x:00008604o
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN17
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_5CA1:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+34j
		mov	dword ptr [ebp-4], 1
		jmp	short loc_5CB1
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

; =============== S U B	R O U T	I N E =======================================


$LN17		proc near		; DATA XREF: .text$mn:00005C9Bo
		mov	dword ptr [ebp-4], 1
$LN17		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_5CB1:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+58j
		mov	eax, offset $LN19
		retn
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

loc_5CB7:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+DEj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_5CC7
; END OF FUNCTION CHUNK	FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

; =============== S U B	R O U T	I N E =======================================


$LN19		proc near		; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_5CB1o
		mov	dword ptr [ebp-4], 0FFFFFFFFh

loc_5CC7:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+14Ej
		cmp	dword ptr [ebp+0Ch], 0
		jbe	short loc_5CE6
		mov	eax, [ebp+0Ch]
		push	eax		; Size
		mov	ecx, [ebp-14h]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Src
		mov	ecx, [ebp-20h]
		push	ecx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_5CE6:				; CODE XREF: $LN19+Bj
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		lea	edx, [ebp-20h]
		push	edx		; int
		mov	eax, [ebp-14h]
		add	eax, 4
		push	eax		; void *
		lea	ecx, [ebp-27h]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char	*,char * &>(char * *,char * &)
		mov	edx, [ebp-14h]
		mov	eax, [ebp-18h]
		mov	[edx+18h], eax
		mov	ecx, [ebp+0Ch]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp-0Ch]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 38h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
$LN19		endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN23		dd 1			; DATA XREF: $LN19+69o
		dd offset $LN22
$LN22		dd 0FFFFFFE0h, 4	; DATA XREF: .text$mn:00005D58o
		dd offset $LN20		; "_Ptr"
$LN20		db '_Ptr',0             ; DATA XREF: .text$mn:00005D64o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5D70h
; COMDAT (pick associative to section at 5B70)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-3Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
		public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc	near
					; CODE XREF: $LN19+60p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+98p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	byte ptr [ebp+var_8+3],	0
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		lea	edx, [ebp+var_8+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		push	eax
		call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
		add	esp, 8
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DD8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_acquire_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_acquire_4@std@@YAKPCKK@Z
?_Fetch_add_acquire_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+3Fp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_acquire_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_relaxed_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_relaxed_4@std@@YAKPCKK@Z
?_Fetch_add_relaxed_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+2Ap

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_relaxed_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DF8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_release_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_release_4@std@@YAKPCKK@Z
?_Fetch_add_release_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+54p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_release_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E08h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned __int32 __cdecl std::_Fetch_add_seq_cst_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z
?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z proc near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+69p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lock xadd [ecx], eax
		pop	ebp
		retn
?_Fetch_add_seq_cst_4@std@@YAKPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_1		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+60o
		dd offset $LN4_1
$LN4_1		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:00005E98o
		dd offset $LN3_1	; "_Alproxy"
$LN3_1		db '_Alproxy',0         ; DATA XREF: .text$mn:00005EA4o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5EB4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
		public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+1Ep
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+57p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5EE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::_Getstate(int)
		public ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+62p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jnz	short loc_5F0F
		mov	ecx, [ebp+var_8]
		or	ecx, 4
		mov	[ebp+var_8], ecx

loc_5F0F:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+24j
		mov	edx, [ebp+arg_0]
		and	edx, 2
		jnz	short loc_5F20
		mov	eax, [ebp+var_8]
		or	eax, 2
		mov	[ebp+var_8], eax

loc_5F20:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+35j
		mov	ecx, [ebp+arg_0]
		and	ecx, 8
		jz	short loc_5F31
		mov	edx, [ebp+var_8]
		or	edx, 8
		mov	[ebp+var_8], edx

loc_5F31:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+46j
		mov	eax, [ebp+arg_0]
		and	eax, 4
		jz	short loc_5F42
		mov	ecx, [ebp+var_8]
		or	ecx, 10h
		mov	[ebp+var_8], ecx

loc_5F42:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Getstate(int)+57j
		mov	eax, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5F4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
		public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+78p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+66p

var_C		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_5F7F
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)

loc_5F7F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+29j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_5F9F
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
		jmp	short loc_5FE9
; ---------------------------------------------------------------------------

loc_5F9F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
		movzx	edx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_5FD9
		cmp	[ebp+arg_0], 10h
		jnb	short loc_5FD9
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+14h]
		jnb	short loc_5FC0
		mov	edx, [ebp+arg_0]
		mov	[ebp+Size], edx
		jmp	short loc_5FC9
; ---------------------------------------------------------------------------

loc_5FC0:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+6Aj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		mov	[ebp+Size], ecx

loc_5FC9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+72j
		mov	edx, [ebp+Size]
		push	edx		; Size
		push	1		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		jmp	short loc_5FE9
; ---------------------------------------------------------------------------

loc_5FD9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+59j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Fj
		cmp	[ebp+arg_0], 0
		jnz	short loc_5FE9
		push	0
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_5FE9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+51j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Bj ...
		cmp	[ebp+arg_0], 0
		jbe	short loc_5FF8
		mov	[ebp+var_C], 1
		jmp	short loc_5FFF
; ---------------------------------------------------------------------------

loc_5FF8:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+A1j
		mov	[ebp+var_C], 0

loc_5FFF:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+AAj
		mov	al, byte ptr [ebp+var_C]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6014h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(void *Src, size_t	Size, int)
		public ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+6Fp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+32p

var_C		= dword	ptr -0Ch
Dst		= dword	ptr -8
var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	esi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Dst], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+38h], 0
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+arg_8]
		mov	[ecx+3Ch], edx
		cmp	[ebp+Size], 0
		jz	loc_6149
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 6
		cmp	ecx, 6
		jz	loc_6149
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		mov	[ebp+Dst], eax
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		add	eax, [ebp+Size]
		mov	ecx, [ebp+var_4]
		mov	[ecx+38h], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx+3Ch]
		and	eax, 4
		jnz	short loc_60C0
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+Size]
		mov	esi, esp
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_60C0:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+89j
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+3Ch]
		and	edx, 2
		jnz	short loc_613A
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 18h
		jz	short loc_60E1
		mov	edx, [ebp+Dst]
		add	edx, [ebp+Size]
		mov	[ebp+var_C], edx
		jmp	short loc_60E7
; ---------------------------------------------------------------------------

loc_60E1:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+C0j
		mov	eax, [ebp+Dst]
		mov	[ebp+var_C], eax

loc_60E7:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+CBj
		mov	ecx, [ebp+Dst]
		add	ecx, [ebp+Size]
		mov	esi, esp
		push	ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_613A
		mov	esi, esp
		mov	ecx, [ebp+Dst]
		push	ecx
		push	0
		mov	edx, [ebp+Dst]
		push	edx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_613A:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+B5j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+108j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		or	ecx, 1
		mov	edx, [ebp+var_4]
		mov	[edx+3Ch], ecx

loc_6149:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+36j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+48j
		pop	esi
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 615Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
		public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+31p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_6190
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		cmp	[ebp+arg_0], eax
		jb	short loc_6190
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+var_4]
		add	eax, [ecx+14h]
		cmp	eax, [ebp+arg_0]
		ja	short loc_6196

loc_6190:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+12j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+1Fj
		xor	al, al
		jmp	short loc_6198
; ---------------------------------------------------------------------------
		jmp	short loc_6198
; ---------------------------------------------------------------------------

loc_6196:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+32j
		mov	al, 1

loc_6198:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+36j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+38j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
					; CODE XREF: $LN19+14p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+2Bp ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_61DC
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_61E5
; ---------------------------------------------------------------------------

loc_61DC:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_61E5:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 61F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+8Bp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_622C
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_6235
; ---------------------------------------------------------------------------

loc_622C:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_6235:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6248h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Store_relaxed_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Store_relaxed_4@std@@YAXPCKK@Z
?_Store_relaxed_4@std@@YAXPCKK@Z proc near
					; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+2Ep

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		pop	ebp
		retn
?_Store_relaxed_4@std@@YAXPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6258h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Store_release_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Store_release_4@std@@YAXPCKK@Z
?_Store_release_4@std@@YAXPCKK@Z proc near
					; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+43p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		pop	ebp
		retn
?_Store_release_4@std@@YAXPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6268h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::_Store_seq_cst_4(volatile unsigned __int32 *, unsigned __int32)
		public ?_Store_seq_cst_4@std@@YAXPCKK@Z
?_Store_seq_cst_4@std@@YAXPCKK@Z proc near
					; CODE XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+58p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		xchg	eax, [ecx]
		pop	ebp
		retn
?_Store_seq_cst_4@std@@YAXPCKK@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6278h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t	Size)
		public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+33p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+55p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_62A0
		jmp	short loc_6313
; ---------------------------------------------------------------------------

loc_62A0:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+24j
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+18h], 10h
		jb	short loc_6313
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		add	ecx, 4
		push	ecx
		lea	edx, [ebp+var_C+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
		cmp	[ebp+Size], 0
		jbe	short loc_62F2
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		push	ecx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		push	eax		; Src
		mov	edx, [ebp+var_4]
		add	edx, 4
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_62F2:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+58j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		add	ecx, 1
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; void *
		lea	eax, [ebp+var_C+2]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)

loc_6313:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+26j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+2Fj
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0Fh
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 633Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: void __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::_Tidy(void)
		public ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)+1Bp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 1
		jz	short loc_63D7
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_638C
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		jmp	short loc_63A1
; ---------------------------------------------------------------------------

loc_638C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+37j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax

loc_63A1:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+4Ej
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_8]
		sub	edx, eax
		push	edx		; int
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; void *
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)

loc_63D7:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+21j
		mov	esi, esp
		push	0
		push	0
		push	0
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	0
		push	0
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+38h], 0
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+3Ch]
		and	edx, 0FFFFFFFEh
		mov	eax, [ebp+var_4]
		mov	[eax+3Ch], edx
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6430h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
		public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+2Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6464h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
		public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+27p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+1Cp	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
		call	dword ptr ds:__imp_?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6498h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicAddSub<unsigned	int, 2>::add(struct std::atomic<unsigned int> &, unsigned int)
		public ?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z
?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicIncDec<uint,2>::inc(std::atomic<uint> &)+9p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z ; std::atomic_uint::fetch_add(uint,std::memory_order)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+D0p
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+26p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
		public ?allocate@?$allocator@D@std@@QAEPADI@Z
?allocate@?$allocator@D@std@@QAEPADI@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+58p
					; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+15p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@D@std@@YAPADIPAD@Z	; std::_Allocate<char>(uint,char *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@D@std@@QAEPADI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 650Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
		public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+2Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6538h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>> const &, unsigned int, unsigned int)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+56p

Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		cmp	eax, [ebp+arg_4]
		jnb	short loc_6564
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_6564:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+22j
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		sub	eax, [ebp+arg_4]
		mov	[ebp+Size], eax
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+Size]
		jnb	short loc_6580
		mov	ecx, [ebp+arg_8]
		mov	[ebp+Size], ecx

loc_6580:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
		mov	edx, [ebp+var_4]
		cmp	edx, [ebp+arg_0]
		jnz	short loc_65A7
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
		jmp	short loc_65E9
; ---------------------------------------------------------------------------

loc_65A7:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Ej
		push	0
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	eax, al
		test	eax, eax
		jz	short loc_65E9
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	ecx, [ebp+arg_0]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_4]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_65E9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+82j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 65FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+61p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	490h		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Str]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	?length@?$char_traits@D@std@@SAIPBD@Z ;	std::char_traits<char>::length(char const *)
		add	esp, 4
		push	eax		; Size
		mov	edx, [ebp+Str]
		push	edx		; Src
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char	const *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 664Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)+65p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+38p

var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+Size], 0
		jz	short loc_6676
		push	47Fh		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Src]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch

loc_6676:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12j
		mov	ecx, [ebp+Src]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
		movzx	edx, al
		test	edx, edx
		jz	short loc_66A9
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+Src]
		sub	ecx, eax
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
		jmp	short loc_66E6
; ---------------------------------------------------------------------------

loc_66A9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+3Bj
		push	0
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_66E3
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+Src]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Size]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_66E3:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+70j
		mov	eax, [ebp+var_4]

loc_66E6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Bj
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 66F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::char_traits<char>::assign(char &, char const	&)
		public ?assign@?$char_traits@D@std@@SAXAADABD@Z
?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+34p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx]
		mov	[eax], dl
		pop	ebp
		retn
?assign@?$char_traits@D@std@@SAXAADABD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6708h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1Bitmap>::assign_assuming_AddRef(struct ID2D1Bitmap *)
		public ?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z
?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::StartAssignment(void)+13p
					; RefPtr<ID2D1Bitmap>::assign_with_AddRef(ID2D1Bitmap *)+27p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6741
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z ;	RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::Release(ID2D1Bitmap *)
		add	esp, 4

loc_6741:				; CODE XREF: RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6754h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1RenderTarget>::assign_assuming_AddRef(struct ID2D1RenderTarget *)
		public ?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z
?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::StartAssignment(void)+13p
					; RefPtr<ID2D1RenderTarget>::assign_with_AddRef(ID2D1RenderTarget *)+27p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_678D
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z	; RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::Release(ID2D1RenderTarget	*)
		add	esp, 4

loc_678D:				; CODE XREF: RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 67A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID3D10ShaderResourceView>::assign_assuming_AddRef(struct ID3D10ShaderResourceView *)
		public ?assign_assuming_AddRef@?$RefPtr@UID3D10ShaderResourceView@@@@AAEXPAUID3D10ShaderResourceView@@@Z
?assign_assuming_AddRef@?$RefPtr@UID3D10ShaderResourceView@@@@AAEXPAUID3D10ShaderResourceView@@@Z proc near
					; CODE XREF: RefPtr<ID3D10ShaderResourceView>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_67D9
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID3D10ShaderResourceView@@@?$RefPtr@UID3D10ShaderResourceView@@@@SAXPAUID3D10ShaderResourceView@@@Z ; RefPtr<ID3D10ShaderResourceView>::AddRefTraits<ID3D10ShaderResourceView>::Release(ID3D10ShaderResourceView *)
		add	esp, 4

loc_67D9:				; CODE XREF: RefPtr<ID3D10ShaderResourceView>::assign_assuming_AddRef(ID3D10ShaderResourceView *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID3D10ShaderResourceView@@@@AAEXPAUID3D10ShaderResourceView@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 67ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID3D10Texture2D>::assign_assuming_AddRef(struct ID3D10Texture2D *)
		public ?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z
?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	proc near
					; CODE XREF: RefPtr<ID3D10Texture2D>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6825
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UID3D10Texture2D@@@?$RefPtr@UID3D10Texture2D@@@@SAXPAUID3D10Texture2D@@@Z ; RefPtr<ID3D10Texture2D>::AddRefTraits<ID3D10Texture2D>::Release(ID3D10Texture2D *)
		add	esp, 4

loc_6825:				; CODE XREF: RefPtr<ID3D10Texture2D>::assign_assuming_AddRef(ID3D10Texture2D *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UID3D10Texture2D@@@@AAEXPAUID3D10Texture2D@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6838h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct IDXGISurface>::assign_assuming_AddRef(struct IDXGISurface *)
		public ?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z
?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z proc near
					; CODE XREF: RefPtr<IDXGISurface>::StartAssignment(void)+13p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_6871
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@UIDXGISurface@@@?$RefPtr@UIDXGISurface@@@@SAXPAUIDXGISurface@@@Z ; RefPtr<IDXGISurface>::AddRefTraits<IDXGISurface>::Release(IDXGISurface *)
		add	esp, 4

loc_6871:				; CODE XREF: RefPtr<IDXGISurface>::assign_assuming_AddRef(IDXGISurface *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@UIDXGISurface@@@@AAEXPAUIDXGISurface@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6884h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<class	mozilla::gfx::SourceSurfaceD2DTarget>::assign_assuming_AddRef(class mozilla::gfx::SourceSurfaceD2DTarget *)
		public ?assign_assuming_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?assign_assuming_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_with_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)+27p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_0]
		mov	[edx], eax
		cmp	[ebp+var_8], 0
		jz	short loc_68BD
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?Release@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::SourceSurfaceD2DTarget>::Release(mozilla::gfx::SourceSurfaceD2DTarget *)
		add	esp, 4

loc_68BD:				; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_assuming_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)+2Bj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_assuming_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1Bitmap>::assign_with_AddRef(struct ID2D1Bitmap *)
		public ?assign_with_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z
?assign_with_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::operator=(ID2D1Bitmap	*)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_68F0
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRef@?$AddRefTraits@UID2D1Bitmap@@@?$RefPtr@UID2D1Bitmap@@@@SAXPAUID2D1Bitmap@@@Z ; RefPtr<ID2D1Bitmap>::AddRefTraits<ID2D1Bitmap>::AddRef(ID2D1Bitmap *)
		add	esp, 4

loc_68F0:				; CODE XREF: RefPtr<ID2D1Bitmap>::assign_with_AddRef(ID2D1Bitmap *)+12j
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z	; RefPtr<ID2D1Bitmap>::assign_assuming_AddRef(ID2D1Bitmap *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_with_AddRef@?$RefPtr@UID2D1Bitmap@@@@AAEXPAUID2D1Bitmap@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 690Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<struct ID2D1RenderTarget>::assign_with_AddRef(struct ID2D1RenderTarget *)
		public ?assign_with_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z
?assign_with_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z	proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::operator=(RefPtr<ID2D1RenderTarget> const &)+17p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_692C
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRef@?$AddRefTraits@UID2D1RenderTarget@@@?$RefPtr@UID2D1RenderTarget@@@@SAXPAUID2D1RenderTarget@@@Z ; RefPtr<ID2D1RenderTarget>::AddRefTraits<ID2D1RenderTarget>::AddRef(ID2D1RenderTarget *)
		add	esp, 4

loc_692C:				; CODE XREF: RefPtr<ID2D1RenderTarget>::assign_with_AddRef(ID2D1RenderTarget *)+12j
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z ; RefPtr<ID2D1RenderTarget>::assign_assuming_AddRef(ID2D1RenderTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_with_AddRef@?$RefPtr@UID2D1RenderTarget@@@@AAEXPAUID2D1RenderTarget@@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6948h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall RefPtr<class	mozilla::gfx::SourceSurfaceD2DTarget>::assign_with_AddRef(class	mozilla::gfx::SourceSurfaceD2DTarget *)
		public ?assign_with_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?assign_with_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::operator=(mozilla::gfx::SourceSurfaceD2DTarget *)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_6968
		mov	eax, [ebp+arg_0]
		push	eax
		call	?AddRef@?$AddRefTraits@VSourceSurfaceD2DTarget@gfx@mozilla@@@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@SAXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::AddRefTraits<mozilla::gfx::SourceSurfaceD2DTarget>::AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)
		add	esp, 4

loc_6968:				; CODE XREF: RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_with_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)+12j
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?assign_assuming_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z ;	RefPtr<mozilla::gfx::SourceSurfaceD2DTarget>::assign_assuming_AddRef(mozilla::gfx::SourceSurfaceD2DTarget *)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign_with_AddRef@?$RefPtr@VSourceSurfaceD2DTarget@gfx@mozilla@@@@AAEXPAVSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6984h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl std::atomic_fetch_add_explicit(struct std::atomic_uint *, unsigned int, enum  std::memory_order)
		public ?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z
?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_uint::fetch_add(uint,std::memory_order)+1Ap

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_fetch_add_4@std@@YAKPCKKW4memory_order@1@@Z ; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl std::atomic_fetch_sub_explicit(struct std::atomic_uint *, unsigned int, enum  std::memory_order)
		public ?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z
?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_uint::fetch_sub(uint,std::memory_order)+1Ap

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_fetch_sub_4@std@@YAKPCKKW4memory_order@1@@Z ; std::_Atomic_fetch_sub_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::atomic_store(struct	std::atomic_uint *, unsigned int)
		public ?atomic_store@std@@YAXPAUatomic_uint@1@I@Z
?atomic_store@std@@YAXPAUatomic_uint@1@I@Z proc	near
					; CODE XREF: std::atomic_uint::operator=(uint)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z ; std::atomic_store_explicit(std::atomic_uint *,uint,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_store@std@@YAXPAUatomic_uint@1@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 69E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::atomic_store_explicit(struct std::atomic_uint *, unsigned int, enum	 std::memory_order)
		public ?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z
?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z proc near
					; CODE XREF: std::atomic_store(std::atomic_uint	*,uint)+Dp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?_Atomic_store_4@std@@YAXPCKKW4memory_order@1@@Z ; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?atomic_store_explicit@std@@YAXPAUatomic_uint@1@IW4memory_order@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A04h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+46p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+29p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
		public ?category@error_code@std@@QBEABVerror_category@2@XZ
?category@error_code@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_code@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A40h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
		public ?category@error_condition@std@@QBEABVerror_category@2@XZ
?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Bp
					; std::error_condition::operator==(std::error_condition	const &)+24p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_condition@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A58h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::ToStorageTypeArgument<unsigned int>::convert(unsigned int)
		public ?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z
?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z proc near
					; CODE XREF: mozilla::detail::AtomicBase<uint,2>::AtomicBase<uint,2>(uint)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
?convert@?$ToStorageTypeArgument@I@detail@mozilla@@SAII@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::copy(void	*Dst, void *Src, size_t	Size)
		public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+6Cp ...

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_6A79
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_6A90
; ---------------------------------------------------------------------------

loc_6A79:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+Fj
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[ebp+var_4], eax

loc_6A90:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+17j
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::deallocate(void	*, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+96p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6AD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::deallocate(void *, int)
		public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+96p
					; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+19p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B00h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::deallocate(void *, int)
		public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+4Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B2Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicIncDec<unsigned	int, 2>::dec(struct std::atomic<unsigned int> &)
		public ?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z
?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z proc near
					; CODE XREF: mozilla::detail::AtomicBaseIncDec<uint,2>::operator--(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z ;	mozilla::detail::IntrinsicAddSub<uint,2>::sub(std::atomic<uint>	&,uint)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?dec@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B48h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::dec(struct	std::ios_base *)
		public ?dec@std@@YAAAVios_base@1@AAV21@@Z
?dec@std@@YAAAVios_base@1@AAV21@@Z proc	near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+32o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0E00h		; int
		push	200h		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setf@ios_base@std@@QAEHHH@Z	; std::ios_base::setf(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?dec@std@@YAAAVios_base@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::_System_error_category::default_error_condition(int)const
		public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00008C18o

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_6BBA
		call	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category(void)
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		jmp	short loc_6BCF
; ---------------------------------------------------------------------------
		jmp	short loc_6BCF
; ---------------------------------------------------------------------------

loc_6BBA:				; CODE XREF: std::_System_error_category::default_error_condition(int)+27j
		call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
		push	eax		; struct std::error_category *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]

loc_6BCF:				; CODE XREF: std::_System_error_category::default_error_condition(int)+3Ej
					; std::_System_error_category::default_error_condition(int)+40j
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6BE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::error_category::default_error_condition(int)const
		public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00008B88o
					; .rdata:00008BA4o ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::empty(void)const
		public ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+64p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+64p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_6C3D
		mov	[ebp+var_8], 1
		jmp	short loc_6C44
; ---------------------------------------------------------------------------

loc_6C3D:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)+1Ej
		mov	[ebp+var_8], 0

loc_6C44:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)+27j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl std::char_traits<char>::eof(void)
		public ?eof@?$char_traits@D@std@@SAHXZ
?eof@?$char_traits@D@std@@SAHXZ	proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1E2p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+30Dp	...
		push	ebp
		mov	ebp, esp
		or	eax, 0FFFFFFFFh
		pop	ebp
		retn
?eof@?$char_traits@D@std@@SAHXZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl std::char_traits<char>::eq(char const &, char const &)
		public ?eq@?$char_traits@D@std@@SA_NABD0@Z
?eq@?$char_traits@D@std@@SA_NABD0@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+B0p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax]
		mov	edx, [ebp+arg_4]
		movsx	eax, byte ptr [edx]
		cmp	ecx, eax
		jnz	short loc_6C78
		mov	[ebp+var_4], 1
		jmp	short loc_6C7F
; ---------------------------------------------------------------------------

loc_6C78:				; CODE XREF: std::char_traits<char>::eq(char const &,char const	&)+19j
		mov	[ebp+var_4], 0

loc_6C7F:				; CODE XREF: std::char_traits<char>::eq(char const &,char const	&)+22j
		mov	al, byte ptr [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
?eq@?$char_traits@D@std@@SA_NABD0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl std::char_traits<char>::eq_int_type(int const &, int const &)
		public ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1F2p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+31Dp	...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_6CA8
		mov	[ebp+var_4], 1
		jmp	short loc_6CAF
; ---------------------------------------------------------------------------

loc_6CA8:				; CODE XREF: std::char_traits<char>::eq_int_type(int const &,int const &)+15j
		mov	[ebp+var_4], 0

loc_6CAF:				; CODE XREF: std::char_traits<char>::eq_int_type(int const &,int const &)+1Ej
		mov	al, byte ptr [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CB8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
		public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
					; DATA XREF: .rdata:00008B8Co
					; .rdata:00008BA8o ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_6CFD
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_code@std@@QBEHXZ ;	std::error_code::value(void)
		cmp	eax, [ebp+arg_4]
		jnz	short loc_6CFD
		mov	[ebp+var_8], 1
		jmp	short loc_6D04
; ---------------------------------------------------------------------------

loc_6CFD:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+2Dj
					; std::error_category::equivalent(std::error_code const	&,int)+3Aj
		mov	[ebp+var_8], 0

loc_6D04:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+43j
		mov	al, byte ptr [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const	struct std::error_condition *)
		public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
					; DATA XREF: .rdata:00008B90o
					; .rdata:00008BACo ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	esi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; std::error_condition *
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+var_4]
		mov	edx, [eax]
		mov	ecx, [ebp+var_4]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	??8error_condition@std@@QBE_NABV01@@Z ;	std::error_condition::operator==(std::error_condition const &)
		pop	esi
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D74h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_6D95
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_6D95:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+17j
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6DB4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int,	unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+68p

var_C		= dword	ptr -0Ch
Dst		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Dst], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_6DE5
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_6DE5:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+27j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		ja	short loc_6E01
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		jmp	short loc_6E47
; ---------------------------------------------------------------------------

loc_6E01:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Dj
		cmp	[ebp+arg_4], 0
		jbe	short loc_6E47
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		mov	[ebp+Dst], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+var_C]
		sub	ecx, [ebp+arg_0]
		push	ecx		; Size
		mov	edx, [ebp+Dst]
		add	edx, [ebp+arg_4]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_6E47:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+4Bj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+51j
		mov	eax, [ebp+var_4]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E5Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::atomic_uint::fetch_add(unsigned int, enum  std::memory_order)
		public ?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z
?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicAddSub<uint,2>::add(std::atomic<uint> &,uint)+Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		call	?atomic_fetch_add_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z ; std::atomic_fetch_add_explicit(std::atomic_uint *,uint,std::memory_order)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?fetch_add@atomic_uint@std@@QAEIIW4memory_order@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::atomic_uint::fetch_sub(unsigned int, enum  std::memory_order)
		public ?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z
?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicAddSub<uint,2>::sub(std::atomic<uint> &,uint)+Cp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		call	?atomic_fetch_sub_explicit@std@@YAIPAUatomic_uint@1@IW4memory_order@1@@Z ; std::atomic_fetch_sub_explicit(std::atomic_uint *,uint,std::memory_order)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6EC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct already_AddRefed<class	mozilla::gfx::DataSourceSurfaceD2DTarget> __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::forget(void)
		public ?forget@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@XZ
?forget@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@XZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+2C3p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_14], 0
		mov	[ebp+var_C], 0
		lea	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?swap@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z ;	RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::swap(mozilla::gfx::DataSourceSurfaceD2DTarget	* &)
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE@PAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z ; already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>::already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget>(mozilla::gfx::DataSourceSurfaceD2DTarget *)
		mov	edx, [ebp+var_14]
		or	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?forget@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAE?AU?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@XZ endp

; ---------------------------------------------------------------------------
$LN7_2		dd 1			; DATA XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::forget(void)+53o
		dd offset $LN6
$LN6		dd 0FFFFFFF4h, 4	; DATA XREF: .text$mn:00006F38o
		dd offset $LN5_10	; "temp"
$LN5_10		db 'temp',0             ; DATA XREF: .text$mn:00006F44o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::generic_category()
		public ?generic_category@std@@YAABVerror_category@1@XZ
?generic_category@std@@YAABVerror_category@1@XZ	proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+29p
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
		pop	ebp
		retn
?generic_category@std@@YAABVerror_category@1@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F5Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1Bitmap * __thiscall RefPtr<struct	ID2D1Bitmap>::get(void)const
		public ?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ
?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ proc near
					; CODE XREF: RefPtr<ID2D1Bitmap>::operator ID2D1Bitmap *(void)+11p
					; RefPtr<ID2D1Bitmap>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID2D1Bitmap@@@@QBEPAUID2D1Bitmap@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F74h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID2D1RenderTarget * __thiscall	RefPtr<struct ID2D1RenderTarget>::get(void)const
		public ?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ
?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ	proc near
					; CODE XREF: RefPtr<ID2D1RenderTarget>::operator ID2D1RenderTarget *(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID2D1RenderTarget@@@@QBEPAUID2D1RenderTarget@@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F8Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10ShaderResourceView * __thiscall RefPtr<struct ID3D10ShaderResourceView>::get(void)const
		public ?get@?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ
?get@?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ proc near
					; CODE XREF: RefPtr<ID3D10ShaderResourceView>::operator	ID3D10ShaderResourceView *(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID3D10ShaderResourceView@@@@QBEPAUID3D10ShaderResourceView@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FA4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct ID3D10Texture2D * __thiscall RefPtr<struct ID3D10Texture2D>::get(void)const
		public ?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ
?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetNativeSurface(mozilla::gfx::NativeSurfaceType)+1Ap
					; RefPtr<ID3D10Texture2D>::operator ID3D10Texture2D *(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UID3D10Texture2D@@@@QBEPAUID3D10Texture2D@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FBCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct IDXGISurface *	__thiscall RefPtr<struct IDXGISurface>::get(void)const
		public ?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ
?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ proc near
					; CODE XREF: RefPtr<IDXGISurface>::operator IDXGISurface *(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@UIDXGISurface@@@@QBEPAUIDXGISurface@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::DataSourceSurfaceD2DTarget * __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::get(void)const
		public ?get@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ
?get@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::operator->(void)+15p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?get@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QBEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::hex(struct	std::ios_base *)
		public ?hex@std@@YAAAVios_base@1@AAV21@@Z
?hex@std@@YAAAVios_base@1@AAV21@@Z proc	near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+46o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0E00h		; int
		push	800h		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setf@ios_base@std@@QAEHHH@Z	; std::ios_base::setf(int,int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?hex@std@@YAAAVios_base@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 701Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicIncDec<unsigned	int, 2>::inc(struct std::atomic<unsigned int> &)
		public ?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z
?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z proc near
					; CODE XREF: mozilla::detail::AtomicBaseIncDec<uint,2>::operator++(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?add@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z ;	mozilla::detail::IntrinsicAddSub<uint,2>::add(std::atomic<uint>	&,uint)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?inc@?$IntrinsicIncDec@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7038h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::length(char *Str)
		public ?length@?$char_traits@D@std@@SAIPBD@Z
?length@?$char_traits@D@std@@SAIPBD@Z proc near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+49p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+28p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_7056
		mov	[ebp+var_4], 0
		jmp	short loc_7065
; ---------------------------------------------------------------------------

loc_7056:				; CODE XREF: std::char_traits<char>::length(char const *)+13j
		mov	edx, [ebp+Str]
		push	edx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_4], eax

loc_7065:				; CODE XREF: std::char_traits<char>::length(char const *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@?$char_traits@D@std@@SAIPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7078h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+28p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
		public ?max_size@?$allocator@D@std@@QBEIXZ
?max_size@?$allocator@D@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char>	const &)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		or	eax, 0FFFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@D@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70B8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class	std::allocator<char> const &)
		public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
		public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+83p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 1
		ja	short loc_710B
		mov	[ebp+var_10], 1
		jmp	short loc_7114
; ---------------------------------------------------------------------------

loc_710B:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+34j
		mov	ecx, [ebp+var_8]
		sub	ecx, 1
		mov	[ebp+var_10], ecx

loc_7114:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+3Dj
		mov	eax, [ebp+var_10]
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7128h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
		public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; CODE XREF: std::_Iostream_error_category::message(int)+4Cp
					; DATA XREF: .rdata:00008BA0o

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_7171
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_7178
; ---------------------------------------------------------------------------

loc_7171:				; CODE XREF: std::_Generic_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_7178:				; CODE XREF: std::_Generic_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 71A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
		public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc	near
					; DATA XREF: .rdata:00008BD4o

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		cmp	[ebp+arg_4], 1
		jnz	short loc_71E5
		push	offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		jmp	short loc_7201
; ---------------------------------------------------------------------------
		jmp	short loc_7201
; ---------------------------------------------------------------------------

loc_71E5:				; CODE XREF: std::_Iostream_error_category::message(int)+22j
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]

loc_7201:				; CODE XREF: std::_Iostream_error_category::message(int)+3Dj
					; std::_Iostream_error_category::message(int)+3Fj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7214h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
		public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; DATA XREF: .rdata:00008C14o

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Winerror_map@std@@YAPBDH@Z	; std::_Winerror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_725D
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_7264
; ---------------------------------------------------------------------------

loc_725D:				; CODE XREF: std::_System_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_7264:				; CODE XREF: std::_System_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7290h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::move(void	*Dst, void *Src, size_t	Size)
		public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+38p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+7Fp

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_72AA
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_72CB
; ---------------------------------------------------------------------------

loc_72AA:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
		mov	esi, esp
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], eax

loc_72CB:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+18j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
		public ?name@_Generic_error_category@std@@UBEPBDXZ
?name@_Generic_error_category@std@@UBEPBDXZ proc near ;	DATA XREF: .rdata:00008B9Co

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Generic_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
		public ?name@_Iostream_error_category@std@@UBEPBDXZ
?name@_Iostream_error_category@std@@UBEPBDXZ proc near ; DATA XREF: .rdata:00008BD0o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Iostream_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7310h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
		public ?name@_System_error_category@std@@UBEPBDXZ
?name@_System_error_category@std@@UBEPBDXZ proc	near ; DATA XREF: .rdata:00008C10o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
		mov	esp, ebp
		pop	ebp
		retn
?name@_System_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7328h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::noshowbase(struct std::ios_base *)
		public ?noshowbase@std@@YAAAVios_base@1@AAV21@@Z
?noshowbase@std@@YAAAVios_base@1@AAV21@@Z proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+39o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	8		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?unsetf@ios_base@std@@QAEXH@Z ; std::ios_base::unsetf(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?noshowbase@std@@YAAAVios_base@1@AAV21@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7350h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl std::char_traits<char>::not_eof(int const &)
		public ?not_eof@?$char_traits@D@std@@SAHABH@Z
?not_eof@?$char_traits@D@std@@SAHABH@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+66p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+12Cp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jz	short loc_737A
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	[ebp+var_4], eax
		jmp	short loc_7399
; ---------------------------------------------------------------------------

loc_737A:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+1Ej
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		test	eax, eax
		jnz	short loc_738C
		mov	[ebp+var_8], 1
		jmp	short loc_7393
; ---------------------------------------------------------------------------

loc_738C:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+31j
		mov	[ebp+var_8], 0

loc_7393:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+3Aj
		mov	ecx, [ebp+var_8]
		mov	[ebp+var_4], ecx

loc_7399:				; CODE XREF: std::char_traits<char>::not_eof(int const &)+28j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?not_eof@?$char_traits@D@std@@SAHABH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 73ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::overflow(int)
		public ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z proc near
					; DATA XREF: .rdata:00008E8Co

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
Src		= dword	ptr -18h
Dst		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 24h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_24], eax
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+Src], eax
		mov	[ebp+Dst], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+Size], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 2
		jz	short loc_73EF
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_778E
; ---------------------------------------------------------------------------
		jmp	short loc_741F
; ---------------------------------------------------------------------------

loc_73EF:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+35j
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_1C], eax
		lea	edx, [ebp+arg_0]
		push	edx
		lea	eax, [ebp+var_1C]
		push	eax
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_741F
		lea	edx, [ebp+arg_0]
		push	edx
		call	?not_eof@?$char_traits@D@std@@SAHABH@Z ; std::char_traits<char>::not_eof(int const &)
		add	esp, 4
		jmp	loc_778E
; ---------------------------------------------------------------------------

loc_741F:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+41j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+60j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 8
		jz	short loc_7499
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7499
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		cmp	eax, [edx+38h]
		jnb	short loc_7499
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+38h]
		push	ecx
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7499:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+7Cj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+92j ...
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7508
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jnb	short loc_7508
		lea	edx, [ebp+arg_0]
		push	edx
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	bl, al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Pninc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[eax], bl
		mov	eax, [ebp+arg_0]
		jmp	loc_778E
; ---------------------------------------------------------------------------
		jmp	loc_778E
; ---------------------------------------------------------------------------

loc_7508:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+101j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+12Bj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_7527
		mov	[ebp+var_20], 0
		jmp	short loc_7552
; ---------------------------------------------------------------------------

loc_7527:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+170j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	[ebp+var_20], esi

loc_7552:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+179j
		mov	eax, [ebp+var_20]
		mov	[ebp+Size], eax
		mov	ecx, [ebp+Size]
		mov	[ebp+var_C], ecx
		mov	edx, [ebp+var_C]
		shr	edx, 1
		cmp	edx, 20h ; ' '
		jnb	short loc_7571
		mov	[ebp+var_24], 20h ; ' '
		jmp	short loc_7579
; ---------------------------------------------------------------------------

loc_7571:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1BAj
		mov	eax, [ebp+var_C]
		shr	eax, 1
		mov	[ebp+var_24], eax

loc_7579:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1C3j
		mov	ecx, [ebp+var_24]
		mov	[ebp+var_10], ecx

loc_757F:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1EEj
		cmp	[ebp+var_10], 0
		jbe	short loc_759C
		mov	edx, 7FFFFFFFh
		sub	edx, [ebp+var_10]
		cmp	edx, [ebp+var_C]
		jnb	short loc_759C
		mov	eax, [ebp+var_10]
		shr	eax, 1
		mov	[ebp+var_10], eax
		jmp	short loc_757F
; ---------------------------------------------------------------------------

loc_759C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1D7j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1E4j
		cmp	[ebp+var_10], 0
		jnz	short loc_75AC
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_778E
; ---------------------------------------------------------------------------

loc_75AC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+1F4j
		mov	ecx, [ebp+var_C]
		add	ecx, [ebp+var_10]
		mov	[ebp+var_C], ecx
		mov	edx, [ebp+var_C]
		push	edx
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		mov	[ebp+Dst], eax
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Src], eax
		cmp	[ebp+Size], 0
		jbe	short loc_75F6
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_75F6:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+234j
		cmp	[ebp+Size], 0
		jnz	short loc_7671
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+Dst]
		mov	[eax+38h], ecx
		mov	edx, [ebp+Dst]
		add	edx, [ebp+var_C]
		mov	esi, esp
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+3Ch]
		and	edx, 4
		jz	short loc_764B
		mov	esi, esp
		mov	eax, [ebp+Dst]
		push	eax
		push	0
		mov	ecx, [ebp+Dst]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_766C
; ---------------------------------------------------------------------------

loc_764B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+27Fj
		mov	edx, [ebp+Dst]
		add	edx, 1
		mov	esi, esp
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+Dst]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_766C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+29Dj
		jmp	loc_773C
; ---------------------------------------------------------------------------

loc_7671:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+24Ej
		mov	edx, [ebp+var_4]
		mov	eax, [edx+38h]
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		mov	ecx, [ebp+var_4]
		mov	[ecx+38h], eax
		mov	edx, [ebp+Dst]
		add	edx, [ebp+var_C]
		mov	esi, esp
		push	edx
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 4
		jz	short loc_76F7
		mov	esi, esp
		mov	edx, [ebp+Dst]
		push	edx
		push	0
		mov	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_773C
; ---------------------------------------------------------------------------

loc_76F7:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+32Bj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	eax, [ebp+Src]
		add	eax, [ebp+Dst]
		push	eax
		mov	ecx, [ebp+Dst]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_773C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int):loc_766Cj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+349j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+3Ch]
		and	eax, 1
		jz	short loc_775A
		mov	ecx, [ebp+Size]
		push	ecx		; int
		mov	edx, [ebp+Src]
		push	edx		; void *
		mov	ecx, [ebp+var_4]
		add	ecx, 40h ; '@'
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)

loc_775A:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+399j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		or	ecx, 1
		mov	edx, [ebp+var_4]
		mov	[edx+3Ch], ecx
		lea	eax, [ebp+arg_0]
		push	eax
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	bl, al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Pninc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[eax], bl
		mov	eax, [ebp+arg_0]

loc_778E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+3Cj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+6Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 24h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 77A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::pbackfail(int)
		public ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z proc	near
					; DATA XREF: .rdata:00008E90o

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	ebx
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_786E
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jbe	short loc_786E
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_8], eax
		lea	eax, [ebp+arg_0]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	edx, al
		test	edx, edx
		jnz	short loc_7877
		lea	eax, [ebp+arg_0]
		push	eax
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	byte ptr [ebp+var_C+3],	al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, 1
		imul	edx, ecx, -1
		add	eax, edx
		push	eax
		lea	eax, [ebp+var_C+3]
		push	eax
		call	?eq@?$char_traits@D@std@@SA_NABD0@Z ; std::char_traits<char>::eq(char const &,char const &)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_7877
		mov	edx, [ebp+var_4]
		mov	eax, [edx+3Ch]
		and	eax, 2
		jz	short loc_7877

loc_786E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+31j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+5Fj
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	short loc_78D8
; ---------------------------------------------------------------------------
		jmp	short loc_78D8
; ---------------------------------------------------------------------------

loc_7877:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+7Ej
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+BDj ...
		mov	esi, esp
		push	0FFFFFFFFh
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		mov	[ebp+var_10], eax
		lea	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_10]
		push	edx
		call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
		add	esp, 8
		movzx	eax, al
		test	eax, eax
		jnz	short loc_78CC
		lea	ecx, [ebp+arg_0]
		push	ecx
		call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
		add	esp, 4
		mov	bl, al
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[eax], bl

loc_78CC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+104j
		lea	edx, [ebp+arg_0]
		push	edx
		call	?not_eof@?$char_traits@D@std@@SAHABH@Z ; std::char_traits<char>::not_eof(int const &)
		add	esp, 4

loc_78D8:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+CFj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+D1j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 78ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual class std::fpos<int> __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::seekoff(__int64, int, int)
		public ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z proc near
					; DATA XREF: .rdata:00008EA8o

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7953
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		cmp	[ecx+38h], eax
		jnb	short loc_7953
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+38h], eax

loc_7953:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+33j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+4Dj
		mov	eax, [ebp+arg_10]
		and	eax, 1
		jz	loc_7B1F
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7B1F
		cmp	[ebp+arg_C], 2
		jnz	short loc_79AA
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7A08
; ---------------------------------------------------------------------------

loc_79AA:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+91j
		cmp	[ebp+arg_C], 1
		jnz	short loc_79F1
		mov	eax, [ebp+arg_10]
		and	eax, 2
		jnz	short loc_79F1
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7A08
; ---------------------------------------------------------------------------

loc_79F1:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+C2j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+CAj
		cmp	[ebp+arg_C], 0
		jz	short loc_7A08
		mov	ecx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	edx, [ecx]
		mov	[ebp+arg_4], edx
		mov	eax, [ecx+4]
		mov	[ebp+arg_8], eax

loc_7A08:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+BCj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+103j ...
		cmp	[ebp+arg_8], 0
		jl	loc_7B0A
		jg	short loc_7A1E
		cmp	[ebp+arg_4], 0
		jb	loc_7B0A

loc_7A1E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+126j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_8]
		jg	loc_7B0A
		jl	short loc_7A5B
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_C]
		ja	loc_7B0A

loc_7A5B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+161j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+arg_10]
		and	edx, 2
		jz	short loc_7B08
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7B08
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7B08:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+1B9j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+1CFj
		jmp	short loc_7B1A
; ---------------------------------------------------------------------------

loc_7B0A:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+120j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+12Cj ...
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+4]
		mov	[ebp+arg_8], edx

loc_7B1A:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7B08j
		jmp	loc_7C83
; ---------------------------------------------------------------------------

loc_7B1F:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+6Dj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+87j
		mov	eax, [ebp+arg_10]
		and	eax, 2
		jz	loc_7C6B
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7C6B
		cmp	[ebp+arg_C], 2
		jnz	short loc_7B76
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7BCB
; ---------------------------------------------------------------------------

loc_7B76:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+25Dj
		cmp	[ebp+arg_C], 1
		jnz	short loc_7BB5
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_7BCB
; ---------------------------------------------------------------------------

loc_7BB5:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+28Ej
		cmp	[ebp+arg_C], 0
		jz	short loc_7BCB
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+4]
		mov	[ebp+arg_8], edx

loc_7BCB:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+288j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2C7j ...
		cmp	[ebp+arg_8], 0
		jl	loc_7C58
		jg	short loc_7BDD
		cmp	[ebp+arg_4], 0
		jb	short loc_7C58

loc_7BDD:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2E9j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_10]
		jg	short loc_7C58
		jl	short loc_7C12
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_14]
		ja	short loc_7C58

loc_7C12:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+31Cj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+arg_4]
		adc	edx, [ebp+arg_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::pbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7C69
; ---------------------------------------------------------------------------

loc_7C58:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2E3j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+2EFj ...
		mov	edx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	eax, [edx]
		mov	[ebp+arg_4], eax
		mov	ecx, [edx+4]
		mov	[ebp+arg_8], ecx

loc_7C69:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+36Aj
		jmp	short loc_7C83
; ---------------------------------------------------------------------------

loc_7C6B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+239j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+253j
		mov	edx, [ebp+arg_4]
		or	edx, [ebp+arg_8]
		jz	short loc_7C83
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+4]
		mov	[ebp+arg_8], edx

loc_7C83:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7B1Aj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7C69j ...
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$fpos@H@std@@QAE@_J@Z ; std::fpos<int>::fpos<int>(__int64)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7CA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual class std::fpos<int> __thiscall std::basic_stringbuf<char,	struct std::char_traits<char>, class std::allocator<char>>::seekpos(class std::fpos<int>, int)
		public ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z proc near
					; DATA XREF: .rdata:00008EACo

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 20h
		push	esi
		push	edi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+arg_4]
		call	??B?$fpos@H@std@@QBE_JXZ ; std::fpos<int>::operator __int64(void)
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], edx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7D26
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		cmp	[ecx+38h], eax
		jnb	short loc_7D26
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+38h], eax

loc_7D26:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+4Aj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+64j
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	[ebp+var_10], eax
		mov	ecx, [ebp+var_10]
		mov	edx, [ebp+var_C]
		cmp	edx, [ecx]
		jnz	short loc_7D48
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+4]
		jnz	short loc_7D48
		jmp	loc_7F5C
; ---------------------------------------------------------------------------

loc_7D48:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+8Ej
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+99j
		mov	edx, [ebp+arg_1C]
		and	edx, 1
		jz	loc_7E85
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7E85
		cmp	[ebp+var_8], 0
		jl	loc_7E70
		jg	short loc_7D84
		cmp	[ebp+var_C], 0
		jb	loc_7E70

loc_7D84:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+D0j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jg	loc_7E70
		jl	short loc_7DC1
		mov	ecx, [ebp+var_C]
		cmp	ecx, [ebp+var_18]
		ja	loc_7E70

loc_7DC1:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+10Bj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+var_C]
		adc	edx, [ebp+var_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::gbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+arg_1C]
		and	edx, 2
		jz	short loc_7E6E
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_7E6E
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::epptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setp(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7E6E:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+163j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+179j
		jmp	short loc_7E80
; ---------------------------------------------------------------------------

loc_7E70:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+CAj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+D6j ...
		mov	eax, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	ecx, [eax]
		mov	[ebp+var_C], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_8], edx

loc_7E80:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int):loc_7E6Ej
		jmp	loc_7F5C
; ---------------------------------------------------------------------------

loc_7E85:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+A6j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+C0j
		mov	eax, [ebp+arg_1C]
		and	eax, 2
		jz	loc_7F4B
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_7F4B
		cmp	[ebp+var_8], 0
		jl	loc_7F38
		jg	short loc_7EBD
		cmp	[ebp+var_C], 0
		jb	short loc_7F38

loc_7EBD:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+20Dj
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+38h]
		sub	edx, eax
		mov	eax, edx
		cdq
		mov	[ebp+var_20], eax
		mov	[ebp+var_1C], edx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_1C]
		jg	short loc_7F38
		jl	short loc_7EF2
		mov	ecx, [ebp+var_C]
		cmp	ecx, [ebp+var_20]
		ja	short loc_7F38

loc_7EF2:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+240j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, esi
		cdq
		add	eax, [ebp+var_C]
		adc	edx, [ebp+var_8]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char>>::pbump(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_7F49
; ---------------------------------------------------------------------------

loc_7F38:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+207j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+213j ...
		mov	edx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	eax, [edx]
		mov	[ebp+var_C], eax
		mov	ecx, [edx+4]
		mov	[ebp+var_8], ecx

loc_7F49:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+28Ej
		jmp	short loc_7F5C
; ---------------------------------------------------------------------------

loc_7F4B:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+1E3j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+1FDj
		mov	edx, dword ptr ds:__imp_?_BADOFF@std@@3_JB ; __int64 const std::_BADOFF
		mov	eax, [edx]
		mov	[ebp+var_C], eax
		mov	ecx, [edx+4]
		mov	[ebp+var_8], ecx

loc_7F5C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+9Bj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int):loc_7E80j ...
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+var_C]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$fpos@H@std@@QAE@_J@Z ; std::fpos<int>::fpos<int>(__int64)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		add	esp, 20h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	20h
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7F84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::ios_base *__cdecl	std::showbase(struct std::ios_base *)
		public ?showbase@std@@YAAAVios_base@1@AAV21@@Z
?showbase@std@@YAAAVios_base@1@AAV21@@Z	proc near
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+4Do

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	8		; int
		mov	ecx, [ebp+arg_0] ; this
		call	dword ptr ds:__imp_?setf@ios_base@std@@QAEHH@Z ; std::ios_base::setf(int)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?showbase@std@@YAAAVios_base@1@AAV21@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+1Ap
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+2Fp ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+14h]
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::str(class std::basic_string<char, struct std::char_traits<char>, class	std::allocator<char>> const &)
		public ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>>	const &)+18p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ;	std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		push	ecx		; int
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 800Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::basic_stringbuf<char, struct	std::char_traits<char>,	class std::allocator<char>>::str(void)const
		public ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ	proc near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(void)+28p

var_7C		= dword	ptr -7Ch
var_78		= dword	ptr -78h
var_70		= byte ptr -70h
var_4C		= byte ptr -4Ch
var_28		= byte ptr -28h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 7Ch
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_7C]
		mov	ecx, 1Fh
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_8], ecx
		mov	[ebp+var_78], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+3Ch]
		and	ecx, 2
		jnz	loc_80F9
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	loc_80F9
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_8]
		cmp	[edx+38h], eax
		jnb	short loc_8093
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_7C], eax
		jmp	short loc_809C
; ---------------------------------------------------------------------------

loc_8093:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+6Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+38h]
		mov	[ebp+var_7C], ecx

loc_809C:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+85j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_7C]
		sub	edx, eax
		push	edx		; Size
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pbase(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; Src
		lea	ecx, [ebp+var_28]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)
		lea	eax, [ebp+var_28]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	ecx, [ebp+var_78]
		or	ecx, 1
		mov	[ebp+var_78], ecx
		lea	ecx, [ebp+var_28]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		jmp	loc_81AA
; ---------------------------------------------------------------------------
		jmp	loc_81AA
; ---------------------------------------------------------------------------

loc_80F9:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+36j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+50j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+3Ch]
		and	eax, 4
		jnz	short loc_8182
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_8182
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		push	esi		; Size
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; Src
		lea	ecx, [ebp+var_4C]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *,uint)
		lea	ecx, [ebp+var_4C]
		push	ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	edx, [ebp+var_78]
		or	edx, 1
		mov	[ebp+var_78], edx
		lea	ecx, [ebp+var_4C]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		jmp	short loc_81AA
; ---------------------------------------------------------------------------
		jmp	short loc_81AA
; ---------------------------------------------------------------------------

loc_8182:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+F6j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+10Cj
		lea	ecx, [ebp+var_70]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		lea	eax, [ebp+var_70]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
		mov	ecx, [ebp+var_78]
		or	ecx, 1
		mov	[ebp+var_78], ecx
		lea	ecx, [ebp+var_70]
		call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]

loc_81AA:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+E3j
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+E8j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN18
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 7Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ	endp

; ---------------------------------------------------------------------------
		align 4
$LN18		dd 3			; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+1A2o
		dd offset $LN17_0
$LN17_0		dd 0FFFFFFD8h, 1Ch	; DATA XREF: .text$mn:000081DCo
		dd offset $LN14		; "_Str"
		dd 0FFFFFFB4h, 1Ch
		dd offset $LN15		; "_Str"
		db 90h
		db 3 dup(0FFh)
		dd 1Ch
		dd offset $LN16		; "_Nul"
$LN16		db '_Nul',0             ; DATA XREF: .text$mn:00008200o
$LN15		db '_Str',0             ; DATA XREF: .text$mn:000081F4o
$LN14		db '_Str',0             ; DATA XREF: .text$mn:000081E8o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8214h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::str(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z proc near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+94p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+94p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		add	ecx, 18h
		call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8244h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::str(void)const
		public ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ proc	near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void)+55p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void)+55p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		add	ecx, 18h
		call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ	; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)
		mov	ecx, [ebp+var_8]
		or	ecx, 1
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8290h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl mozilla::detail::IntrinsicAddSub<unsigned	int, 2>::sub(struct std::atomic<unsigned int> &, unsigned int)
		public ?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z
?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z proc near
					; CODE XREF: mozilla::detail::IntrinsicIncDec<uint,2>::dec(std::atomic<uint> &)+9p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	5
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?fetch_sub@atomic_uint@std@@QAEIIW4memory_order@2@@Z ; std::atomic_uint::fetch_sub(uint,std::memory_order)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?sub@?$IntrinsicAddSub@I$01@detail@mozilla@@SAIAAU?$atomic@I@std@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall RefPtr<class mozilla::gfx::DataSourceSurfaceD2DTarget>::swap(class mozilla::gfx::DataSourceSurfaceD2DTarget *	&)
		public ?swap@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z
?swap@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z proc near
					; CODE XREF: RefPtr<mozilla::gfx::DataSourceSurfaceD2DTarget>::forget(void)+32p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[edx], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+var_8]
		mov	[edx], eax
		mov	esp, ebp
		pop	ebp
		retn	4
?swap@?$RefPtr@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEXAAPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::system_category()
		public ?system_category@std@@YAABVerror_category@1@XZ
?system_category@std@@YAABVerror_category@1@XZ proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int):loc_6BBAp
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
		pop	ebp
		retn
?system_category@std@@YAABVerror_category@1@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	mozilla::gfx::DataSourceSurfaceD2DTarget * __thiscall already_AddRefed<class mozilla::gfx::DataSourceSurfaceD2DTarget>::take(void)
		public ?take@?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ
?take@?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ proc near
					; CODE XREF: already_AddRefed<mozilla::gfx::DataSourceSurface>::already_AddRefed<mozilla::gfx::DataSourceSurface>(already_AddRefed<mozilla::gfx::DataSourceSurfaceD2DTarget> &&)+11p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx], 0
		mov	eax, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
?take@?$already_AddRefed@VDataSourceSurfaceD2DTarget@gfx@mozilla@@@@QAEPAVDataSourceSurfaceD2DTarget@gfx@mozilla@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8320h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static char __cdecl std::char_traits<char>::to_char_type(int const &)
		public ?to_char_type@?$char_traits@D@std@@SADABH@Z
?to_char_type@?$char_traits@D@std@@SADABH@Z proc near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+131p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+3C1p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	al, [eax]
		pop	ebp
		retn
?to_char_type@?$char_traits@D@std@@SADABH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 832Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static int __cdecl std::char_traits<char>::to_int_type(char const &)
		public ?to_int_type@?$char_traits@D@std@@SAHABD@Z
?to_int_type@?$char_traits@D@std@@SAHABD@Z proc	near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+72p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+17Cp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		movzx	eax, byte ptr [eax]
		pop	ebp
		retn
?to_int_type@?$char_traits@D@std@@SAHABD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8338h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: virtual int __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::underflow(void)
		public ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ proc near
					; DATA XREF: .rdata:00008E98o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		push	edi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_836D
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_84BC
; ---------------------------------------------------------------------------
		jmp	loc_84BC
; ---------------------------------------------------------------------------

loc_836D:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+24j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::egptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		jnb	short loc_83BC
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
		add	esp, 4
		jmp	loc_84BC
; ---------------------------------------------------------------------------
		jmp	loc_84BC
; ---------------------------------------------------------------------------

loc_83BC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+5Dj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+3Ch]
		and	ecx, 4
		jnz	short loc_8421
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_8421
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		cmp	esi, eax
		ja	short loc_8430
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		cmp	[edx+38h], eax
		ja	short loc_8430

loc_8421:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+8Dj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+A3j
		call	?eof@?$char_traits@D@std@@SAHXZ	; std::char_traits<char>::eof(void)
		jmp	loc_84BC
; ---------------------------------------------------------------------------
		jmp	loc_84BC
; ---------------------------------------------------------------------------

loc_8430:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+CDj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+E7j
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		cmp	[ecx+38h], eax
		jnb	short loc_8462
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::pptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+38h], eax

loc_8462:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+110j
		mov	esi, esp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+38h]
		push	ecx
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::eback(void)
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char>>::setg(char *,char *,char *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	ecx, [ebp+var_4]
		call	dword ptr ds:__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
		add	esp, 4

loc_84BC:				; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+2Bj
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)+30j ...
		pop	edi
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 84CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_code::value(std::error_code	*__hidden this)
		public ?value@error_code@std@@QBEHXZ
?value@error_code@std@@QBEHXZ proc near	; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+32p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_code@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 84E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
		public ?value@error_condition@std@@QBEHXZ
?value@error_condition@std@@QBEHXZ proc	near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+3Ap
					; std::error_condition::operator==(std::error_condition	const &)+44p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_condition@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 84FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _hypot
_hypot		proc near

var_14		= qword	ptr -14h
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		sub	esp, 8
		movsd	xmm0, [ebp+arg_8]
		movsd	[esp+0Ch+var_C], xmm0
		sub	esp, 8
		movsd	xmm0, [ebp+arg_0]
		movsd	[esp+14h+var_14], xmm0
		call	dword ptr ds:__imp___hypot
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
_hypot		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8538h
; COMDAT (pick associative to section at 2C88)
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008548o
		dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
		dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8564h
; COMDAT (pick associative to section at 2FEC)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00008574o
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8590h
; COMDAT (pick associative to section at 2F38)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000085A0o
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 85BCh
; COMDAT (pick associative to section at 2E88)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000085CCo
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 85E8h
; COMDAT (pick associative to section at 5B70)
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 dd offset $SG161963+4
					; DATA XREF: .xdata$x:00008670o
					; "ed in CreateBitmap. Code: "
		dd 2 dup(0)
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 dd offset $SG161963+4
					; DATA XREF: .xdata$x:0000865Co
					; "ed in CreateBitmap. Code: "
		dd 2 dup(0)
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:00008630o
		dd 0FFFFFFFFh, 0
		dd 1, 0
		dd 1, 0
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 19930522h,	4
					; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
		dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 2
		dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 3 dup(0)
		dd 1
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd	2 dup(2), 3, 1
					; DATA XREF: .xdata$x:00008638o
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
		dd 2 dup(0)
		dd 3, 1
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8674h
; COMDAT (pick associative to section at 3B0C)
__unwindtable$??1SourceSurface@gfx@mozilla@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008684o
		dd offset __unwindfunclet$??1SourceSurface@gfx@mozilla@@UAE@XZ$0
__ehfuncinfo$??1SourceSurface@gfx@mozilla@@UAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??1SourceSurface@gfx@mozilla@@UAE@XZ+11o
		dd offset __unwindtable$??1SourceSurface@gfx@mozilla@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 86A0h
; COMDAT (pick associative to section at 3344)
__unwindtable$??0SourceSurface@gfx@mozilla@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000086B0o
		dd offset __unwindfunclet$??0SourceSurface@gfx@mozilla@@QAE@XZ$0
__ehfuncinfo$??0SourceSurface@gfx@mozilla@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??0SourceSurface@gfx@mozilla@@QAE@XZ+11o
		dd offset __unwindtable$??0SourceSurface@gfx@mozilla@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 86CCh
; COMDAT (pick associative to section at 315C)
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000086E4o
		dd offset __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
		align 8
		dd offset __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z+11o
		dd offset __unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8700h
; COMDAT (pick associative to section at 3090)
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008710o
		dd offset __unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z+11o
		dd offset __unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 872Ch
; COMDAT (pick associative to section at 28D8)
__unwindtable$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000873Co
		dd offset __unwindfunclet$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0
__ehfuncinfo$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z+11o
		dd offset __unwindtable$??0?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8758h
; COMDAT (pick associative to section at 3704)
__unwindtable$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008768o
		dd offset __unwindfunclet$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0
__ehfuncinfo$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ+11o
		dd offset __unwindtable$??1?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8784h
; COMDAT (pick associative to section at 4B08)
__unwindtable$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000879Co
		dd offset __unwindfunclet$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0
		align 10h
		dd offset __unwindfunclet$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1
__ehfuncinfo$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ+1Bo
		dd offset __unwindtable$?Flush@?$Log@$00UCriticalLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 87B8h
; COMDAT (pick associative to section at 2998)
__unwindtable$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000087C8o
		dd offset __unwindfunclet$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z$0
__ehfuncinfo$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z+11o
		dd offset __unwindtable$??0?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@HW4LogReason@12@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 87E4h
; COMDAT (pick associative to section at 378C)
__unwindtable$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000087F4o
		dd offset __unwindfunclet$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ$0
__ehfuncinfo$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ	dd 19930522h, 1
					; DATA XREF: __ehhandler$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ+11o
		dd offset __unwindtable$??1?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8810h
; COMDAT (pick associative to section at 4C44)
__unwindtable$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00008828o
		dd offset __unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$0
		dd 0
		dd offset __unwindfunclet$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ$1
__ehfuncinfo$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ+1Bo
		dd offset __unwindtable$?Flush@?$Log@$01UBasicLogger@gfx@mozilla@@@gfx@mozilla@@QAEXXZ
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8844h
__unwindtable$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000088C4o
		dd offset __unwindfunclet$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ$0
__unwindtable$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000088E8o
		dd offset __unwindfunclet$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z$0
__unwindtable$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008930o
		dd offset __unwindfunclet$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z$0
__unwindtable$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008954o
		dd offset __unwindfunclet$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ$0
__unwindtable$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000890Co
		dd offset __unwindfunclet$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$0
		align 10h
		dd offset __unwindfunclet$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$1
__unwindtable$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008978o
		dd offset __unwindfunclet$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ$1
__unwindtable$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008A08o
		dd offset __unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$0
		align 10h
		dd offset __unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$1
		dd 1
		dd offset __unwindfunclet$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z$2
__unwindtable$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000089E4o
		dd offset __unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$0
		align 8
		dd offset __unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$1
		dd 1
		dd offset __unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$2
		dd 2
		dd offset __unwindfunclet$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ$3
__ehfuncinfo$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ dd 19930522h,	1
					; DATA XREF: __ehhandler$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ+14o
		dd offset __unwindtable$?EnsureMapped@DataSourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z+14o
		dd offset __unwindtable$?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z
		align 20h
		dd 1
__ehfuncinfo$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ+11o
		dd offset __unwindtable$??1DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z+11o
		dd offset __unwindtable$??0DataSourceSurfaceD2DTarget@gfx@mozilla@@QAE@W4SurfaceFormat@12@@Z
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ+1Bo
		dd offset __unwindtable$?DrawTargetWillChange@SourceSurfaceD2DTarget@gfx@mozilla@@AAEXXZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ+14o
		dd offset __unwindtable$?GetSRView@SourceSurfaceD2DTarget@gfx@mozilla@@AAEPAUID3D10ShaderResourceView@@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z	dd 19930522h, 7
					; DATA XREF: __ehhandler$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z+1Eo
		dd offset __unwindtable$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z
		dd 5 dup(0)
		dd 1
__ehfuncinfo$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ dd 19930522h, 6
					; DATA XREF: __ehhandler$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ+1Eo
		dd offset __unwindtable$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ dd 19930522h, 4
					; DATA XREF: __ehhandler$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ+11o
		dd offset __unwindtable$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ
		dd 5 dup(0)
		dd 1
__ehfuncinfo$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z+11o
		dd offset __unwindtable$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z
		align 20h
		dd 1
__unwindtable$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000089C0o
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$3
		align 10h
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0
		align 8
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$1
		dd 2
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$2
		dd 2
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$4
		dd 2
		dd offset __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$5
__unwindtable$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000899Co
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$0
		align 10h
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$1
		align 8
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$2
		align 10h
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$3
		dd 3
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$4
		dd 4
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$5
		dd 4
		dd offset __unwindfunclet$?GetBitmap@SourceSurfaceD2DTarget@gfx@mozilla@@QAEPAUID2D1Bitmap@@PAUID2D1RenderTarget@@@Z$6
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8A8Ch
; COMDAT (pick associative to section at 1EA8)
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 dd offset $SG161963+4
					; DATA XREF: .xdata$x:00008AACo
					; "ed in CreateBitmap. Code: "
		dd 2 dup(0)
		dd offset __catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z dd 2 dup(1), 2, 1
					; DATA XREF: .xdata$x:00008AD8o
		dd offset __catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008AD0o
		dd offset __unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
		dd 4 dup(0)
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z dd 19930522h, 3
					; DATA XREF: __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z+14o
		dd offset __unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		dd 1
		dd offset __tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
		dd 3 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8AECh
; COMDAT (pick associative to section at 35A4)
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008AFCo
		dd offset __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z+11o
		dd offset __unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8B18h
; COMDAT (pick associative to section at 2598)
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00008B28o
		dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
		dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8B44h
; COMDAT (pick associative to section at 24A0)
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008B54o
		dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
		dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 8B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_allocator_arg	db ?
_piecewise_construct db	?
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 8B74h
; COMDAT (pick any)
		public ??_C@_00CNPNBAHC@?$AA@
; char `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Flush(void):loc_4B84o
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Flush(void):loc_4CC0o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B78h
; COMDAT (pick largest)
		dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
		public ??_7error_category@std@@6B@
; const	std::error_category::`vftable'
??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
					; DATA XREF: std::error_category::error_category(void)+11o
					; std::error_category::~error_category(void)+11o
					; std::error_category::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8B94h
; COMDAT (pick largest)
		dd offset ??_R4_Generic_error_category@std@@6B@	; const	std::_Generic_error_category::`RTTI Complete Object Locator'
		public ??_7_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`vftable'
??_7_Generic_error_category@std@@6B@ dd	offset ??_E_Generic_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+19o
					; std::_Generic_error_category::`vector	deleting destructor'(uint)
		dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ;	std::_Generic_error_category::name(void)
		dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BB0h
; COMDAT (pick any)
		public ??_C@_07DCLBNMLN@generic?$AA@
; `string'
??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
					; DATA XREF: std::_Generic_error_category::name(void)+Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BB8h
; COMDAT (pick any)
		public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
; `string'
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
					; DATA XREF: std::_Generic_error_category::message(int):loc_7171o
					; std::_System_error_category::message(int):loc_725Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BC8h
; COMDAT (pick largest)
		dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
		public ??_7_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`vftable'
??_7_Iostream_error_category@std@@6B@ dd offset	??_E_Iostream_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+19o
					; std::_Iostream_error_category::`vector deleting destructor'(uint)
		dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
		dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BE4h
; COMDAT (pick any)
		public ??_C@_08LLGCOLLL@iostream?$AA@
; `string'
??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
					; DATA XREF: std::_Iostream_error_category::name(void)+Eo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8BF0h
; COMDAT (pick any)
		public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; char `string'[]
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	db 'iostream stream error',0
					; DATA XREF: std::_Iostream_error_category::message(int)+24o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8C08h
; COMDAT (pick largest)
		dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
		public ??_7_System_error_category@std@@6B@
; const	std::_System_error_category::`vftable'
??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_System_error_category::_System_error_category(void)+19o
					; std::_System_error_category::`vector deleting	destructor'(uint)
		dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
		dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
		dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8C24h
; COMDAT (pick any)
		public ??_C@_06FHFOAHML@system?$AA@
; `string'
??_C@_06FHFOAHML@system?$AA@ db	'system',0
					; DATA XREF: std::_System_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8C2Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8C30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; std::_Iostream_error_category	std::_Error_objects<int>::_Iostream_object
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8C34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; std::_System_error_category std::_Error_objects<int>::_System_object
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A dd	?
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8C38h
; COMDAT (pick any)
		public ??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1JC@LCKPGPAG@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+7Do
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+B7o ...
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xatomic.h>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8CCCh
; COMDAT (pick any)
		public ??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@
; wchar_t `string'
??_C@_1CK@BEGEBJJG@?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+82o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+71o
		unicode	0, <Invalid memory_order>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8CF8h
; COMDAT (pick any)
		public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
; `string'
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+97o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+86o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8D20h
; COMDAT (pick any)
		public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
; `string'
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+A6o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+95o
		unicode	0, <"Standard C++ Libraries Invalid Argument" && 0>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D80h
; COMDAT (pick any)
		public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
; `string'
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+ABo
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+9Ao
		unicode	0, <%s>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8D88h
; COMDAT (pick any)
		public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
; `string'
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+E7o
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+D6o
		unicode	0, <"invalid argument">,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8DB0h
; COMDAT (pick any)
		public ??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@
; `string'
??_C@_1CK@BEBCCGEN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAs?$AAt?$AAo?$AAr?$AAe?$AA_?$AA4?$AA?$AA@:
					; DATA XREF: std::_Atomic_store_4(ulong	volatile *,ulong,std::memory_order)+D1o
		unicode	0, <std::_Atomic_store_4>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8DDCh
; COMDAT (pick any)
		public ??_C@_1DC@FMPHIJPC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAf?$AAe?$AAt?$AAc?$AAh?$AA_?$AAa?$AAd?$AAd?$AA_?$AA4?$AA?$AA@
; `string'
??_C@_1DC@FMPHIJPC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAt?$AAo?$AAm?$AAi?$AAc?$AA_?$AAf?$AAe?$AAt?$AAc?$AAh?$AA_?$AAa?$AAd?$AAd?$AA_?$AA4?$AA?$AA@:
					; DATA XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+E2o
		unicode	0, <std::_Atomic_fetch_add_4>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E10h
; COMDAT (pick largest)
		dd offset ??_R4SourceSurface@gfx@mozilla@@6B@ ;	const mozilla::gfx::SourceSurface::`RTTI Complete Object Locator'
		public ??_7SourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurface::`vftable'
??_7SourceSurface@gfx@mozilla@@6B@ dd offset ??_ESourceSurface@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::SourceSurface::SourceSurface(void)+42o
					; mozilla::gfx::SourceSurface::~SourceSurface(void)+30o
					; mozilla::gfx::SourceSurface::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset __purecall
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E34h
; COMDAT (pick largest)
		dd offset ??_R4DataSourceSurface@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurface::`RTTI Complete Object Locator'
		public ??_7DataSourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurface::`vftable'
??_7DataSourceSurface@gfx@mozilla@@6B@ dd offset ??_EDataSourceSurface@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::DataSourceSurface::DataSourceSurface(void)+19o
					; mozilla::gfx::DataSourceSurface::`vector deleting destructor'(uint)
		dd offset ?GetType@DataSourceSurface@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ ; mozilla::gfx::DataSourceSurface::GetType(void)
		dd offset __purecall
		dd offset __purecall
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset ?GetDataSurface@DataSourceSurface@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ ; mozilla::gfx::DataSourceSurface::GetDataSurface(void)
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
		dd offset __purecall
		dd offset __purecall
		dd offset ?Map@DataSourceSurface@gfx@mozilla@@UAE_NW4MapType@123@PAUMappedSurface@123@@Z ; mozilla::gfx::DataSourceSurface::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface	*)
		dd offset ?Unmap@DataSourceSurface@gfx@mozilla@@UAEXXZ ; mozilla::gfx::DataSourceSurface::Unmap(void)
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8E68h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8E6Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E70h
; COMDAT (pick any)
		public ??_C@_01EEMJAFIK@?6?$AA@
; `string'
??_C@_01EEMJAFIK@?6?$AA@ db 0Ah, 0	; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool):loc_5262o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E74h
; COMDAT (pick any)
		public ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
; char `string'[]
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ db '%s%s',0
					; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+4Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E7Ch
; COMDAT (pick largest)
		dd offset ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; const std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Complete Object Locator'
		public ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>>::`vftable'
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@	dd offset ??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+4Ao
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)+12o
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vector deleting destructor'(uint)
		dd offset ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Lock(void)
		dd offset ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Unlock(void)
		dd offset ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)
		dd offset ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)
		dd offset ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char>>::showmanyc(void)
		dd offset ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(void)
		dd offset ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::uflow(void)
		dd offset ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::xsgetn(char *,__int64)
		dd offset ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ;	std::basic_streambuf<char,std::char_traits<char>>::xsputn(char const *,__int64)
		dd offset ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)
		dd offset ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)
		dd offset ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char>>::setbuf(char *,__int64)
		dd offset ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ;	std::basic_streambuf<char,std::char_traits<char>>::sync(void)
		dd offset ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char>>::imbue(std::locale const	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8EBCh
; COMDAT (pick largest)
		dd offset ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ;	const std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Complete	Object Locator'
		public ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vftable'
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ dd offset ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+A9o
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)+1Bo
_rdata		ends			; [thunk]:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vector deleting destructor'`vtordisp{4294967292,0}' (uint)

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8EC4h
; COMDAT (pick any)
		public ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vbtable'{for `std::basic_istream<char, struct std::char_traits<char>>'}
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ dd	0
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+47o
		dd offset $SG161981+0Ch	; " texture to surface."
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8ECCh
; COMDAT (pick any)
		public ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vbtable'{for `std::basic_ostream<char, struct std::char_traits<char>>'}
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ dd	0
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+50o
		dd offset $SG161963+1Ch	; ": "
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8ED4h
; COMDAT (pick largest)
		dd offset ??_R4SourceSurfaceD2DTarget@gfx@mozilla@@6B@ ; const mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Complete Object Locator'
		public ??_7SourceSurfaceD2DTarget@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurfaceD2DTarget::`vftable'
??_7SourceSurfaceD2DTarget@gfx@mozilla@@6B@ dd offset ??_ESourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+3Fo
					; mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+40o
					; mozilla::gfx::SourceSurfaceD2DTarget::`vector	deleting destructor'(uint)
		dd offset ?GetType@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ	; mozilla::gfx::SourceSurfaceD2DTarget::GetType(void)
		dd offset ?GetSize@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ ;	mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)
		dd offset ?GetFormat@SourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ ; mozilla::gfx::SourceSurfaceD2DTarget::GetFormat(void)
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset ?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ ; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)
		dd offset ?GetNativeSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z	; mozilla::gfx::SourceSurfaceD2DTarget::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8EF8h
; COMDAT (pick largest)
		dd offset ??_R4DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@ ; const mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Complete Object Locator'
		public ??_7DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurfaceD2DTarget::`vftable'
??_7DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@	dd offset ??_EDataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z
					; DATA XREF: mozilla::gfx::DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(mozilla::gfx::SurfaceFormat)+3Fo
					; mozilla::gfx::DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget(void)+3Ao
					; mozilla::gfx::DataSourceSurfaceD2DTarget::`vector deleting destructor'(uint)
		dd offset ?GetType@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceType@23@XZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::GetType(void)
		dd offset ?GetSize@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@XZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::GetSize(void)
		dd offset ?GetFormat@DataSourceSurfaceD2DTarget@gfx@mozilla@@UBE?AW4SurfaceFormat@23@XZ	; mozilla::gfx::DataSourceSurfaceD2DTarget::GetFormat(void)
		dd offset ?IsValid@SourceSurface@gfx@mozilla@@UBE_NXZ ;	mozilla::gfx::SourceSurface::IsValid(void)
		dd offset ?GetDataSurface@DataSourceSurface@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ ; mozilla::gfx::DataSourceSurface::GetDataSurface(void)
		dd offset ?GetNativeSurface@SourceSurface@gfx@mozilla@@UAEPAXW4NativeSurfaceType@23@@Z ; mozilla::gfx::SourceSurface::GetNativeSurface(mozilla::gfx::NativeSurfaceType)
		dd offset ?GuaranteePersistance@SourceSurface@gfx@mozilla@@MAEXXZ ; mozilla::gfx::SourceSurface::GuaranteePersistance(void)
		dd offset ?GetData@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAEXZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::GetData(void)
		dd offset ?Stride@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEHXZ ; mozilla::gfx::DataSourceSurfaceD2DTarget::Stride(void)
		dd offset ?Map@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAE_NW4MapType@DataSourceSurface@23@PAUMappedSurface@523@@Z ; mozilla::gfx::DataSourceSurfaceD2DTarget::Map(mozilla::gfx::DataSourceSurface::MapType,mozilla::gfx::DataSourceSurface::MappedSurface *)
		dd offset ?Unmap@DataSourceSurfaceD2DTarget@gfx@mozilla@@UAEXXZ	; mozilla::gfx::DataSourceSurfaceD2DTarget::Unmap(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8F2Ch
; COMDAT (pick any)
		public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+13o
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+19o
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xstring>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FBCh
; COMDAT (pick any)
		public ??_C@_04HGKILAJC@?$FLGFX?$AA@
; char `string'[]
??_C@_04HGKILAJC@?$FLGFX?$AA@ db '[GFX',0
					; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+91o
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+D4o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FC4h
; COMDAT (pick any)
		public ??_C@_01JOAMLHOP@?9?$AA@
; char `string'[]
??_C@_01JOAMLHOP@?9?$AA@ db 2Dh, 0	; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason):loc_4EB3o
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason):loc_504Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FC8h
; COMDAT (pick any)
		public ??_C@_01CLKCMJKC@?5?$AA@
; char `string'[]
??_C@_01CLKCMJKC@?5?$AA@ db 20h, 0	; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+13Eo
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason)+13Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FCCh
; COMDAT (pick any)
		public ??_C@_03FLKELDHI@?$FN?3?5?$AA@
; char `string'[]
??_C@_03FLKELDHI@?$FN?3?5?$AA@ dd 203A5Dh
					; DATA XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason):loc_4F5Eo
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::Init(int,bool,mozilla::gfx::LogReason):loc_50F6o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FD0h
; COMDAT (pick any)
		public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
; char `string'[]
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FE0h
; COMDAT (pick any)
		public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
; char `string'[]
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8FF8h
; COMDAT (pick any)
		public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; wchar_t `string'
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+14o
		unicode	0, <invalid null pointer>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9024h
; COMDAT (pick any)
		public __GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
__GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec dd 0CAFCB56Ch, 48896AC3h, 239E47BFh, 0EC60D2BBh
					; DATA XREF: IUnknown::QueryInterface<IDXGISurface>(IDXGISurface * *)+Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9034h
; COMDAT (pick any)
		public ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>>::`RTTI Complete Object Locator'
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ dd 3 dup(0)
					; DATA XREF: .rdata:00008E7Co
		dd offset ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd offset ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 9048h
; COMDAT (pick any)
		public ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
; class	std::basic_stringbuf<char, struct std::char_traits<char>, class	std::allocator<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009040o
					; .rdata$r:std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Basic_str	db '.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@st'
		db 'd@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9098h
; COMDAT (pick any)
		public ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00009044o
					; .rdata$r:000090CCo
		dd 2
		dd offset ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 90A8h
; COMDAT (pick any)
		public ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Array'
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
					; DATA XREF: .rdata$r:000090A4o
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 90B4h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8	dd offset ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
					; DATA XREF: .rdata$r:std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'o
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 90D0h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; std::basic_streambuf<char, struct std::char_traits<char>>::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 dd offset ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:000090ACo
					; .rdata$r:std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base Class Array'o
					; std::basic_streambuf<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8	; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 90ECh
; COMDAT (pick any)
		public ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_streambuf<char, struct std::char_traits<char>> `RTTI	Type Descriptor'
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_s_0	db '.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9128h
; COMDAT (pick any)
		public ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; std::basic_streambuf<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:000090E8o
		dd 1
		dd offset ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8	; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9138h
; COMDAT (pick any)
		public ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
; std::basic_streambuf<char, struct std::char_traits<char>>::`RTTI Base	Class Array'
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 dd offset	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:00009134o
					; std::basic_streambuf<char,std::char_traits<char>>::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9140h
; COMDAT (pick any)
		public ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
; const	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`RTTI	Complete Object	Locator'
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ dd 0
					; DATA XREF: .rdata:00008EBCo
		dd offset $SG161981+0Ch	; " texture to surface."
		dd 4
		dd offset ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8	; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd offset ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 9154h
; COMDAT (pick any)
		public ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
; class	std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000914Co
					; .rdata$r:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_s_1	db '.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@'
		db '@std@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 91A4h
; COMDAT (pick any)
		public ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`RTTI Class	Hierarchy Descriptor'
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd 0
					; DATA XREF: .rdata$r:00009150o
					; .rdata$r:000091F8o
		dd 3, 0Ah
		dd offset ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 91B4h
; COMDAT (pick any)
		public ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Array'
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
					; DATA XREF: .rdata$r:000091B0o
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8	; std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char>>::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		dd offset ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8	; std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (16,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 91E0h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
; std::basic_stringstream<char,	struct std::char_traits<char>, class std::allocator<char>>::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 dd offset ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
					; DATA XREF: .rdata$r:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Base Class Array'o
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'
		dd 9, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 91FCh
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
; std::basic_iostream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 dd offset	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:000091B8o
					; .rdata$r:std::basic_iostream<char,std::char_traits<char>>::`RTTI Base	Class Array'o
					; std::basic_iostream<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 8, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9218h
; COMDAT (pick any)
		public ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_iostream<char, struct std::char_traits<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Basic_ios	db '.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9254h
; COMDAT (pick any)
		public ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
; std::basic_iostream<char, struct std::char_traits<char>>::`RTTI Class	Hierarchy Descriptor'
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 dd	0 ; DATA XREF: .rdata$r:00009214o
		dd 3, 9
		dd offset ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9264h
; COMDAT (pick any)
		public ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
; std::basic_iostream<char, struct std::char_traits<char>>::`RTTI Base Class Array'
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 dd	offset ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:00009260o
					; std::basic_iostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char>>::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		dd offset ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8	; std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (16,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 928Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
; std::basic_istream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 dd	offset ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:000091BCo
					; .rdata$r:00009268o ...
					; std::basic_istream<char,std::char_traits<char>> `RTTI	Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_istream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 92A8h
; COMDAT (pick any)
		public ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_istream<char, struct	std::char_traits<char>>	`RTTI Type Descriptor'
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_istream<char,std::char_traits<char>>::`RTTI Base Class	Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Basic_ist	db '.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 92E4h
; COMDAT (pick any)
		public ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
; std::basic_istream<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:000092A4o
		dd 4
		dd offset ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_istream<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 92F4h
; COMDAT (pick any)
		public ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
; std::basic_istream<char, struct std::char_traits<char>>::`RTTI Base Class Array'
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:000092F0o
					; std::basic_istream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9308h
; COMDAT (pick any)
		public ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Base Class	Descriptor at (0, 0, 4,	80)'
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8	dd offset ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:000091C0o
					; .rdata$r:000091D0o ...
					; std::basic_ios<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 2, 2	dup(0)
		dd 4, 50h
		dd offset ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9324h
; COMDAT (pick any)
		public ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_ios<char, struct std::char_traits<char>> `RTTI Type Descriptor'
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,0,4,80)'o
					; .rdata$r:std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_i_0	db '.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 935Ch
; COMDAT (pick any)
		public ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	dd 2 dup(0) ; DATA XREF: .rdata$r:00009320o
					; .rdata$r:00009394o
		dd 3
		dd offset ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 936Ch
; COMDAT (pick any)
		public ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Base Class	Array'
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	dd offset ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:00009368o
					; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@ios_base@std@@8	; std::ios_base::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R17?0A@EA@?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 937Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
; std::basic_ios<char, struct std::char_traits<char>>::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 dd offset ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Array'o
					; std::basic_ios<char,std::char_traits<char>> `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9398h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@ios_base@std@@8
; std::ios_base::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@ios_base@std@@8 dd offset	??_R0?AVios_base@std@@@8
					; DATA XREF: .rdata$r:00009370o
					; .rdata$r:std::ios_base::`RTTI	Base Class Array'o
					; std::ios_base	`RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3ios_base@std@@8 ; std::ios_base::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 93B4h
; COMDAT (pick any)
		public ??_R0?AVios_base@std@@@8
; class	std::ios_base `RTTI Type Descriptor'
??_R0?AVios_base@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::ios_base::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; .rdata$r:std::ios_base::`RTTI	Base Class Descriptor at (0,0,4,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avios_base@s	db '.?AVios_base@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 93D0h
; COMDAT (pick any)
		public ??_R3ios_base@std@@8
; std::ios_base::`RTTI Class Hierarchy Descriptor'
??_R3ios_base@std@@8 dd	2 dup(0)	; DATA XREF: .rdata$r:000093B0o
					; .rdata$r:00009470o
		dd 2
		dd offset ??_R2ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 93E0h
; COMDAT (pick any)
		public ??_R2ios_base@std@@8
; std::ios_base::`RTTI Base Class Array'
??_R2ios_base@std@@8 dd	offset ??_R1A@?0A@EA@ios_base@std@@8 ; DATA XREF: .rdata$r:000093DCo
					; std::ios_base::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R17?0A@EA@?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 93ECh
; COMDAT (pick any)
		public ??_R17?0A@EA@?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Descriptor at (8, -1, 0, 64)'
??_R17?0A@EA@?$_Iosb@H@std@@8 dd offset	??_R0?AV?$_Iosb@H@std@@@8
					; DATA XREF: .rdata$r:00009374o
					; .rdata$r:000093E4o
					; std::_Iosb<int> `RTTI	Type Descriptor'
		dd 0
		dd 8, 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9408h
; COMDAT (pick any)
		public ??_R0?AV?$_Iosb@H@std@@@8
; class	std::_Iosb<int>	`RTTI Type Descriptor'
??_R0?AV?$_Iosb@H@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::_Iosb<int>::`RTTI Base Class	Descriptor at (8,-1,0,64)'o
					; .rdata$r:std::_Iosb<int>::`RTTI Base Class Descriptor	at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 10h
a_?av?_iosb@h@s	db '.?AV?$_Iosb@H@std@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9424h
; COMDAT (pick any)
		public ??_R3?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
??_R3?$_Iosb@H@std@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00009404o
					; .rdata$r:00009454o ...
		dd 1
		dd offset ??_R2?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9434h
; COMDAT (pick any)
		public ??_R2?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Array'
??_R2?$_Iosb@H@std@@8 dd offset	??_R1A@?0A@EA@?$_Iosb@H@std@@8
					; DATA XREF: .rdata$r:00009430o
					; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 943Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$_Iosb@H@std@@8 dd offset ??_R0?AV?$_Iosb@H@std@@@8
					; DATA XREF: .rdata$r:std::_Iosb<int>::`RTTI Base Class	Array'o
					; std::_Iosb<int> `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9458h
; COMDAT (pick any)
		public ??_R1A@A@3EA@ios_base@std@@8
; std::ios_base::`RTTI Base Class Descriptor at	(0, 0, 4, 64)'
??_R1A@A@3EA@ios_base@std@@8 dd	offset ??_R0?AVios_base@std@@@8
					; DATA XREF: .rdata$r:000091C4o
					; .rdata$r:000091D4o ...
					; std::ios_base	`RTTI Type Descriptor'
		dd 1, 2	dup(0)
		dd 4, 40h
		dd offset ??_R3ios_base@std@@8 ; std::ios_base::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9474h
; COMDAT (pick any)
		public ??_R17A@3EA@?$_Iosb@H@std@@8
; std::_Iosb<int>::`RTTI Base Class Descriptor at (8, 0, 4, 64)'
??_R17A@3EA@?$_Iosb@H@std@@8 dd	offset ??_R0?AV?$_Iosb@H@std@@@8
					; DATA XREF: .rdata$r:000091C8o
					; .rdata$r:000091D8o ...
					; std::_Iosb<int> `RTTI	Type Descriptor'
		dd 0
		dd 8, 0
		dd 4, 40h
		dd offset ??_R3?$_Iosb@H@std@@8	; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9490h
; COMDAT (pick any)
		public ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor at (16, -1, 0, 64)'
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd offset	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:000091CCo
					; .rdata$r:00009278o
					; std::basic_ostream<char,std::char_traits<char>> `RTTI	Type Descriptor'
		dd 3, 10h, 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_ostream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 94ACh
; COMDAT (pick any)
		public ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
; class	std::basic_ostream<char, struct	std::char_traits<char>>	`RTTI Type Descriptor'
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class	Descriptor at (16,-1,0,64)'o
					; .rdata$r:std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Basic_ost	db '.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94E8h
; COMDAT (pick any)
		public ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:000094A8o
					; .rdata$r:00009524o
		dd 4
		dd offset ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 94F8h
; COMDAT (pick any)
		public ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Base Class Array'
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd offset ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
					; DATA XREF: .rdata$r:000094F4o
					; std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char>>::`RTTI Base Class Descriptor at	(0,0,4,80)'
		dd offset ??_R1A@A@3EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
		dd offset ??_R17A@3EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI	Base Class Descriptor at (8,0,4,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 950Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
; std::basic_ostream<char, struct std::char_traits<char>>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 dd	offset ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
					; DATA XREF: .rdata$r:std::basic_ostream<char,std::char_traits<char>>::`RTTI Base Class	Array'o
					; std::basic_ostream<char,std::char_traits<char>> `RTTI	Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ;	std::basic_ostream<char,std::char_traits<char>>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9528h
; COMDAT (pick any)
		public ??_R4error_category@std@@6B@
; const	std::error_category::`RTTI Complete Object Locator'
??_R4error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00008B78o
		dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 953Ch
; COMDAT (pick any)
		public ??_R0?AVerror_category@std@@@8
; class	std::error_category `RTTI Type Descriptor'
??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00009534o
					; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?averror_cate	db '.?AVerror_category@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9560h
; COMDAT (pick any)
		public ??_R3error_category@std@@8
; std::error_category::`RTTI Class Hierarchy Descriptor'
??_R3error_category@std@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00009538o
					; .rdata$r:00009590o
		dd 1
		dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9570h
; COMDAT (pick any)
		public ??_R2error_category@std@@8
; std::error_category::`RTTI Base Class	Array'
??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
					; DATA XREF: .rdata$r:0000956Co
					; std::error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9578h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@error_category@std@@8
; std::error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
					; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
					; .rdata$r:000095E8o ...
					; std::error_category `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9594h
; COMDAT (pick any)
		public ??_R4_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`RTTI Complete Object Locator'
??_R4_Generic_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00008B94o
		dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 95A8h
; COMDAT (pick any)
		public ??_R0?AV_Generic_error_category@std@@@8
; class	std::_Generic_error_category `RTTI Type	Descriptor'
??_R0?AV_Generic_error_category@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000095A0o
					; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av_generic_e	db '.?AV_Generic_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 95D4h
; COMDAT (pick any)
		public ??_R3_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Generic_error_category@std@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000095A4o
					; .rdata$r:00009608o
		dd 2
		dd offset ??_R2_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 95E4h
; COMDAT (pick any)
		public ??_R2_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Array'
??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
					; DATA XREF: .rdata$r:000095E0o
					; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 95F0h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_Generic_error_category@std@@8 dd	offset ??_R0?AV_Generic_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
					; .rdata$r:00009660o ...
					; std::_Generic_error_category `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 960Ch
; COMDAT (pick any)
		public ??_R4_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`RTTI Complete Object Locator'
??_R4_Iostream_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00008BC8o
		dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9620h
; COMDAT (pick any)
		public ??_R0?AV_Iostream_error_category@std@@@8
; class	std::_Iostream_error_category `RTTI Type Descriptor'
??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009618o
					; .rdata$r:std::_Iostream_error_category::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?av_iostream_	db '.?AV_Iostream_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 964Ch
; COMDAT (pick any)
		public ??_R3_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Iostream_error_category@std@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:0000961Co
					; .rdata$r:00009684o
		dd 3
		dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 965Ch
; COMDAT (pick any)
		public ??_R2_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Array'
??_R2_Iostream_error_category@std@@8 dd	offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
					; DATA XREF: .rdata$r:00009658o
					; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 966Ch
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset	??_R0?AV_Iostream_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base	Class Array'o
					; std::_Iostream_error_category	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9688h
; COMDAT (pick any)
		public ??_R4_System_error_category@std@@6B@
; const	std::_System_error_category::`RTTI Complete Object Locator'
??_R4_System_error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00008C08o
		dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 969Ch
; COMDAT (pick any)
		public ??_R0?AV_System_error_category@std@@@8
; class	std::_System_error_category `RTTI Type Descriptor'
??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009694o
					; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av_system_er	db '.?AV_System_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96C8h
; COMDAT (pick any)
		public ??_R3_System_error_category@std@@8
; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_System_error_category@std@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00009698o
					; .rdata$r:00009700o
		dd 3
		dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96D8h
; COMDAT (pick any)
		public ??_R2_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Array'
??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
					; DATA XREF: .rdata$r:000096D4o
					; std::_System_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 96E8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
					; std::_System_error_category `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9704h
; COMDAT (pick any)
		public ??_R4SourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurface::`RTTI Complete Object Locator'
??_R4SourceSurface@gfx@mozilla@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00008E10o
		dd offset ??_R0?AVSourceSurface@gfx@mozilla@@@8	; mozilla::gfx::SourceSurface `RTTI Type Descriptor'
		dd offset ??_R3SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9718h
; COMDAT (pick any)
		public ??_R0?AVSourceSurface@gfx@mozilla@@@8
; class	mozilla::gfx::SourceSurface `RTTI Type Descriptor'
??_R0?AVSourceSurface@gfx@mozilla@@@8 dd offset	??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009710o
					; .rdata$r:mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avsourcesurf	db '.?AVSourceSurface@gfx@mozilla@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9740h
; COMDAT (pick any)
		public ??_R3SourceSurface@gfx@mozilla@@8
; mozilla::gfx::SourceSurface::`RTTI Class Hierarchy Descriptor'
??_R3SourceSurface@gfx@mozilla@@8 dd 2 dup(0) ;	DATA XREF: .rdata$r:00009714o
					; .rdata$r:00009778o
		dd 3
		dd offset ??_R2SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9750h
; COMDAT (pick any)
		public ??_R2SourceSurface@gfx@mozilla@@8
; mozilla::gfx::SourceSurface::`RTTI Base Class	Array'
??_R2SourceSurface@gfx@mozilla@@8 dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8
					; DATA XREF: .rdata$r:0000974Co
					; mozilla::gfx::SourceSurface::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9760h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8
; mozilla::gfx::SourceSurface::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 dd offset ??_R0?AVSourceSurface@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::SourceSurface::`RTTI Base Class Array'o
					; .rdata$r:00009910o ...
					; mozilla::gfx::SourceSurface `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 977Ch
; COMDAT (pick any)
		public ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd offset ??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8
					; DATA XREF: .rdata$r:00009754o
					; .rdata$r:00009914o ...
					; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface> `RTTI Type Descriptor'
		dd 1, 4, 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 9798h
; COMDAT (pick any)
		public ??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8
; class	mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface> `RTTI Type Descriptor'
??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class Descriptor at (4,-1,0,64)'o
					; .rdata$r:mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av?Atomicref	db '.?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozi'
		db 'lla@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 97E8h
; COMDAT (pick any)
		public ??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Class Hierarchy	Descriptor'
??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd 2 dup(0)
					; DATA XREF: .rdata$r:00009794o
					; .rdata$r:0000981Co
		dd 2
		dd offset ??_R2?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 97F8h
; COMDAT (pick any)
		public ??_R2?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Base Class Array'
??_R2?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd offset ??_R1A@?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
					; DATA XREF: .rdata$r:000097F4o
					; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8	; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9804h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8
; mozilla::external::AtomicRefCounted<class mozilla::gfx::SourceSurface>::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 dd offset ??_R0?AV?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class Array'o
					; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface> `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9820h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd offset	??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8
					; DATA XREF: .rdata$r:000097FCo
					; .rdata$r:mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class	Array'o
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0> `RTTI Type	Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data$r		segment	para public 'DATA' use32
		assume cs:_data$r
		;org 983Ch
; COMDAT (pick any)
		public ??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8
; class	mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0> `RTTI	Type Descriptor'
??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; .rdata$r:mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av?Refcounte	db '.?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@'
		db '@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9888h
; COMDAT (pick any)
		public ??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Class Hierarchy Descriptor'
??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd	2 dup(0)
					; DATA XREF: .rdata$r:00009838o
					; .rdata$r:000098B8o
		dd 1
		dd offset ??_R2?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9898h
; COMDAT (pick any)
		public ??_R2?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Base	Class Array'
??_R2?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd	offset ??_R1A@?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
					; DATA XREF: .rdata$r:00009894o
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98A0h
; COMDAT (pick any)
		public ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8
; mozilla::detail::RefCounted<class mozilla::gfx::SourceSurface, 0>::`RTTI Base	Class Descriptor at (4,	-1, 0, 64)'
??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 dd	offset ??_R0?AV?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@@8
					; DATA XREF: .rdata$r:00009758o
					; .rdata$r:00009918o ...
					; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0> `RTTI Type	Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98BCh
; COMDAT (pick any)
		public ??_R4DataSourceSurface@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurface::`RTTI Complete	Object Locator'
??_R4DataSourceSurface@gfx@mozilla@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00008E34o
		dd offset ??_R0?AVDataSourceSurface@gfx@mozilla@@@8 ; mozilla::gfx::DataSourceSurface `RTTI Type Descriptor'
		dd offset ??_R3DataSourceSurface@gfx@mozilla@@8	; mozilla::gfx::DataSourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 98D0h
; COMDAT (pick any)
		public ??_R0?AVDataSourceSurface@gfx@mozilla@@@8
; class	mozilla::gfx::DataSourceSurface	`RTTI Type Descriptor'
??_R0?AVDataSourceSurface@gfx@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000098C8o
					; .rdata$r:mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avdatasource	db '.?AVDataSourceSurface@gfx@mozilla@@',0
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 98FCh
; COMDAT (pick any)
		public ??_R3DataSourceSurface@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurface::`RTTI Class Hierarchy Descriptor'
??_R3DataSourceSurface@gfx@mozilla@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:000098CCo
					; .rdata$r:00009938o
		dd 4
		dd offset ??_R2DataSourceSurface@gfx@mozilla@@8	; mozilla::gfx::DataSourceSurface::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 990Ch
; COMDAT (pick any)
		public ??_R2DataSourceSurface@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurface::`RTTI Base Class Array'
??_R2DataSourceSurface@gfx@mozilla@@8 dd offset	??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8
					; DATA XREF: .rdata$r:00009908o
					; mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9920h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8 dd offset ??_R0?AVDataSourceSurface@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::DataSourceSurface::`RTTI Base Class	Array'o
					; .rdata$r:00009A24o
					; mozilla::gfx::DataSourceSurface `RTTI	Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3DataSourceSurface@gfx@mozilla@@8	; mozilla::gfx::DataSourceSurface::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 993Ch
; COMDAT (pick any)
		public ??_R4SourceSurfaceD2DTarget@gfx@mozilla@@6B@
; const	mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Complete Object Locator'
??_R4SourceSurfaceD2DTarget@gfx@mozilla@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00008ED4o
		dd offset ??_R0?AVSourceSurfaceD2DTarget@gfx@mozilla@@@8 ; mozilla::gfx::SourceSurfaceD2DTarget	`RTTI Type Descriptor'
		dd offset ??_R3SourceSurfaceD2DTarget@gfx@mozilla@@8 ; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 9950h
; COMDAT (pick any)
		public ??_R0?AVSourceSurfaceD2DTarget@gfx@mozilla@@@8
; class	mozilla::gfx::SourceSurfaceD2DTarget `RTTI Type	Descriptor'
??_R0?AVSourceSurfaceD2DTarget@gfx@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00009948o
					; .rdata$r:mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avsourcesu_0	db '.?AVSourceSurfaceD2DTarget@gfx@mozilla@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9984h
; COMDAT (pick any)
		public ??_R3SourceSurfaceD2DTarget@gfx@mozilla@@8
; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Class Hierarchy Descriptor'
??_R3SourceSurfaceD2DTarget@gfx@mozilla@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:0000994Co
					; .rdata$r:000099C0o
		dd 4
		dd offset ??_R2SourceSurfaceD2DTarget@gfx@mozilla@@8 ; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9994h
; COMDAT (pick any)
		public ??_R2SourceSurfaceD2DTarget@gfx@mozilla@@8
; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Base Class Array'
??_R2SourceSurfaceD2DTarget@gfx@mozilla@@8 dd offset ??_R1A@?0A@EA@SourceSurfaceD2DTarget@gfx@mozilla@@8
					; DATA XREF: .rdata$r:00009990o
					; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 99A8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@SourceSurfaceD2DTarget@gfx@mozilla@@8
; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SourceSurfaceD2DTarget@gfx@mozilla@@8 dd offset ??_R0?AVSourceSurfaceD2DTarget@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Base Class Array'o
					; mozilla::gfx::SourceSurfaceD2DTarget `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3SourceSurfaceD2DTarget@gfx@mozilla@@8 ; mozilla::gfx::SourceSurfaceD2DTarget::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 99C4h
; COMDAT (pick any)
		public ??_R4DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@
; const	mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI	Complete Object	Locator'
??_R4DataSourceSurfaceD2DTarget@gfx@mozilla@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00008EF8o
		dd offset ??_R0?AVDataSourceSurfaceD2DTarget@gfx@mozilla@@@8 ; mozilla::gfx::DataSourceSurfaceD2DTarget	`RTTI Type Descriptor'
		dd offset ??_R3DataSourceSurfaceD2DTarget@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 99D8h
; COMDAT (pick any)
		public ??_R0?AVDataSourceSurfaceD2DTarget@gfx@mozilla@@@8
; class	mozilla::gfx::DataSourceSurfaceD2DTarget `RTTI Type Descriptor'
??_R0?AVDataSourceSurfaceD2DTarget@gfx@mozilla@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:000099D0o
					; .rdata$r:mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avdatasour_0	db '.?AVDataSourceSurfaceD2DTarget@gfx@mozilla@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9A10h
; COMDAT (pick any)
		public ??_R3DataSourceSurfaceD2DTarget@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Class	Hierarchy Descriptor'
??_R3DataSourceSurfaceD2DTarget@gfx@mozilla@@8 dd 2 dup(0) ; DATA XREF:	.rdata$r:000099D4o
					; .rdata$r:00009A50o
		dd 5
		dd offset ??_R2DataSourceSurfaceD2DTarget@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Base	Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9A20h
; COMDAT (pick any)
		public ??_R2DataSourceSurfaceD2DTarget@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Base Class Array'
??_R2DataSourceSurfaceD2DTarget@gfx@mozilla@@8 dd offset ??_R1A@?0A@EA@DataSourceSurfaceD2DTarget@gfx@mozilla@@8
					; DATA XREF: .rdata$r:00009A1Co
					; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@DataSourceSurface@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@SourceSurface@gfx@mozilla@@8 ; mozilla::gfx::SourceSurface::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@?$AtomicRefCounted@VSourceSurface@gfx@mozilla@@@external@mozilla@@8 ; mozilla::external::AtomicRefCounted<mozilla::gfx::SourceSurface>::`RTTI Base Class	Descriptor at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@?$RefCounted@VSourceSurface@gfx@mozilla@@$0A@@detail@mozilla@@8 ; mozilla::detail::RefCounted<mozilla::gfx::SourceSurface,0>::`RTTI Base	Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9A38h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@DataSourceSurfaceD2DTarget@gfx@mozilla@@8
; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@DataSourceSurfaceD2DTarget@gfx@mozilla@@8	dd offset ??_R0?AVDataSourceSurfaceD2DTarget@gfx@mozilla@@@8
					; DATA XREF: .rdata$r:mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Base Class Array'o
					; mozilla::gfx::DataSourceSurfaceD2DTarget `RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset $SG161963+4	; "ed in CreateBitmap. Code: "
		dd offset ??_R3DataSourceSurfaceD2DTarget@gfx@mozilla@@8 ; mozilla::gfx::DataSourceSurfaceD2DTarget::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 9A54h
; COMDAT (pick any)
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 9A58h
; COMDAT (pick any)
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9A5Ch
; COMDAT (pick any)
		public __real@00000000
__real@00000000	dd 0			; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+502r
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+510r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9A60h
; COMDAT (pick any)
		public __real@42c00000
__real@42c00000	dd 42C00000h		; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+198r
					; mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+1A6r ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A64h
_piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ	; std::`dynamic	initializer for	'piecewise_construct''(void)
_allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer	for 'allocator_arg''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A6Ch
; COMDAT (pick associative to section at 8C2C)
; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A70h
; COMDAT (pick associative to section at 8C30)
; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA	dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A74h
; COMDAT (pick associative to section at 8C34)
; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset	??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer	for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A78h
; COMDAT (pick associative to section at 8E68)
; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 9A7Ch
; COMDAT (pick associative to section at 8E6C)
; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __purecall:near	; DATA XREF: .rdata:00008B80o
					; .rdata:00008B84o ...
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+50p
					; std::_Allocate<char>(uint,char *)+25p ...
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: __unwindfunclet$?GetDataSurface@SourceSurfaceD2DTarget@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ$0+4p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`scalar deleting destructor'(uint)+22p ...
; int __cdecl atexit(void (__cdecl *)())
		extrn _atexit:near	; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
					; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
		extrn __imp___invalid_parameter:near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+ECp
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+DBp
					; DATA XREF: ...
; int _printf(const char *Format, ...)
		extrn __imp__printf:near
					; CODE XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+51p
					; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+51r
; void __cdecl _free(void *Memory)
		extrn __imp__free:near	; CODE XREF: mozilla::gfx::UserData::Destroy(void)+7Bp
					; DATA XREF: mozilla::gfx::UserData::Destroy(void)+7Br
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+28p
					; DATA XREF: std::char_traits<char>::move(char *,char const *,uint)+28r
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+25p
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: std::char_traits<char>::length(char const *)+22p
		extrn __imp___hypot:near ; CODE	XREF: _hypot+20p
					; DATA XREF: _hypot+20r
; bool __cdecl std::uncaught_exception()
		extrn __imp_?uncaught_exception@std@@YA_NXZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+11p
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+11r
		extrn __imp___CrtDbgReportW:near
					; CODE XREF: std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+BEp
					; std::_Atomic_store_4(ulong volatile *,ulong,std::memory_order)+ADp
					; DATA XREF: ...
; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
		extrn __imp_?_Debug_message@std@@YAXPB_W0I@Z:near
					; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+19p
					; std::_Atomic_fetch_add_4(ulong volatile *,ulong,std::memory_order)+87p ...
; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
		extrn __imp_??0_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14p
					; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14r
; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden	this)
		extrn __imp_??1_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14p
					; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14r
; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
		extrn __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28p
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28r
; void __cdecl std::_Xbad_alloc()
		extrn __imp_?_Xbad_alloc@std@@YAXXZ:near
					; CODE XREF: std::_Allocate<char>(uint,char *)+38p
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Ep
					; DATA XREF: ...
; void __cdecl std::_Xlength_error(const char *)
		extrn __imp_?_Xlength_error@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16r
; void __cdecl std::_Xout_of_range(const char *)
		extrn __imp_?_Xout_of_range@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16r
; _DWORD __thiscall std::locale::id::id(std::locale::id	*__hidden this,	unsigned int)
		extrn __imp_??0id@locale@std@@QAE@I@Z:near
					; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Dp
					; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Dp
					; DATA XREF: ...
; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
		extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::error_category::`vftable'o
; const	char *__cdecl std::_Syserror_map(int)
		extrn __imp_?_Syserror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+15p
					; std::_Generic_error_category::message(int)+28p
					; DATA XREF: ...
; const	char *__cdecl std::_Winerror_map(int)
		extrn __imp_?_Winerror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::message(int)+28p
					; DATA XREF: std::_System_error_category::message(int)+28r
; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ;	weak
					; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
; bool __thiscall std::ios_base::good(std::ios_base *__hidden this)
		extrn __imp_?good@ios_base@std@@QBE_NXZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+4Ep
					; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+DDp
					; DATA XREF: ...
; int __thiscall std::ios_base::flags(std::ios_base *__hidden this)
		extrn __imp_?flags@ios_base@std@@QBEHXZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+139p
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+139r
; int __thiscall std::ios_base::setf(std::ios_base *__hidden this, int)
		extrn __imp_?setf@ios_base@std@@QAEHH@Z:near
					; CODE XREF: std::showbase(std::ios_base &)+Bp
					; DATA XREF: std::showbase(std::ios_base &)+Br
; int __thiscall std::ios_base::setf(std::ios_base *__hidden this, int,	int)
		extrn __imp_?setf@ios_base@std@@QAEHHH@Z:near
					; CODE XREF: std::dec(std::ios_base &)+13p
					; std::hex(std::ios_base &)+13p
					; DATA XREF: ...
; void __thiscall std::ios_base::unsetf(std::ios_base *__hidden	this, int)
		extrn __imp_?unsetf@ios_base@std@@QAEXH@Z:near
					; CODE XREF: std::noshowbase(std::ios_base &)+Bp
					; DATA XREF: std::noshowbase(std::ios_base &)+Br
; __int64 __thiscall std::ios_base::width(std::ios_base	*__hidden this)
		extrn __imp_?width@ios_base@std@@QBE_JXZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+66p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+94p ...
; __int64 __thiscall std::ios_base::width(std::ios_base	*__hidden this,	__int64)
		extrn __imp_?width@ios_base@std@@QAE_J_J@Z:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+34Fp
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+34Fr
; __declspec(dllimport)	protected: __thiscall std::basic_streambuf<char, struct	std::char_traits<char>>::basic_streambuf<char, struct std::char_traits<char>>(void)
		extrn __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+33p
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(int)+33r
; __declspec(dllimport)	public:	virtual	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::~basic_streambuf<char, struct std::char_traits<char>>(void)
		extrn __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0+5p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>(void)+25p
					; DATA XREF: ...
; __declspec(dllimport)	public:	int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sputc(char)
		extrn __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1CCp
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+2F1p
					; DATA XREF: ...
; __declspec(dllimport)	public:	__int64	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sputn(char const *, __int64)
		extrn __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+247p
					; DATA XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+247r
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::eback(void)const
		extrn __imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+6Ap
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+82p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::gptr(void)const
		extrn __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+F9p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+368p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::pbase(void)const
		extrn __imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+CFp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+2FEp ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::pptr(void)const
		extrn __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+28p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+83p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::egptr(void)const
		extrn __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+55p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::str(void)+113p ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::gbump(int)
		extrn __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(int)+DAp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+1A6p ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setg(char	*, char	*, char	*)
		extrn __imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+9Fp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char const *,uint,int)+119p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::epptr(void)const
		extrn __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+3Ep
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+B3p ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::pbump(int)
		extrn __imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+35Dp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos(std::fpos<int>,int)+281p
					; DATA XREF: ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setp(char	*, char	*)
		extrn __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Tidy(void)+BCp
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+269p
					; DATA XREF: ...
; __declspec(dllimport)	protected: void	__thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setp(char	*, char	*, char	*)
		extrn __imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::_Init(char	const *,uint,int)+E7p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+E0p ...
; __declspec(dllimport)	protected: char	* __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::_Pninc(void)
		extrn __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:near
					; CODE XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+140p
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(int)+3D0p
					; DATA XREF: ...
; __declspec(dllimport)	public:	virtual	__thiscall std::basic_ios<char,	struct std::char_traits<char>>::~basic_ios<char, struct	std::char_traits<char>>(void)
		extrn __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0+18p
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vbase destructor(void)+22p
					; DATA XREF: ...
; __declspec(dllimport)	public:	void __thiscall	std::basic_ios<char, struct std::char_traits<char>>::setstate(int, bool)
		extrn __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:near
					; CODE XREF: __catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0+13p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+3A7p
					; DATA XREF: ...
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> *	__thiscall std::basic_ios<char,	struct std::char_traits<char>>::tie(void)const
		extrn __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+6Fp
					; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+8Fp ...
; __declspec(dllimport)	public:	class std::basic_streambuf<char, struct	std::char_traits<char>>	* __thiscall std::basic_ios<char, struct std::char_traits<char>>::rdbuf(void)const
		extrn __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+1B2p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+226p	...
; __declspec(dllimport)	public:	char __thiscall	std::basic_ios<char, struct std::char_traits<char>>::fill(void)const
		extrn __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:near
					; CODE XREF: std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+193p
					; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)+2B4p
					; DATA XREF: ...
; __declspec(dllimport)	protected: __thiscall std::basic_ios<char, struct std::char_traits<char>>::basic_ios<char, struct std::char_traits<char>>(void)
		extrn __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+5Fp
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+5Fr
; __declspec(dllimport)	public:	void __thiscall	std::basic_ostream<char, struct	std::char_traits<char>>::_Osfx(void)
		extrn __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+2Cp
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+2Cr
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(class std::ios_base & (__cdecl *)(class std::ios_base &))
		extrn __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z:near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+60p
					; mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+72p ...
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(int)
		extrn __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+A4p
					; mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::Init(int,bool,mozilla::gfx::LogReason)+E7p ...
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::operator<<(long)
		extrn __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z:near
					; CODE XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+84p
					; DATA XREF: mozilla::gfx::Log<2,mozilla::gfx::BasicLogger>::operator<<<long>(mozilla::gfx::Hexa<long>)+84r
; __declspec(dllimport)	public:	class std::basic_ostream<char, struct std::char_traits<char>> &	__thiscall std::basic_ostream<char, struct std::char_traits<char>>::flush(void)
		extrn __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:near
					; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+C1p
					; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+C1r
; public: virtual void * __thiscall mozilla::gfx::SourceSurface::`vector deleting destructor'(unsigned int)
		extrn ??_ESourceSurface@gfx@mozilla@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const mozilla::gfx::SourceSurface::`vftable'o
; public: virtual struct already_AddRefed<class	mozilla::gfx::DataSourceSurface> __thiscall mozilla::gfx::DataSourceSurface::GetDataSurface(void)
		extrn ?GetDataSurface@DataSourceSurface@gfx@mozilla@@UAE?AU?$already_AddRefed@VDataSourceSurface@gfx@mozilla@@@@XZ:near
					; DATA XREF: .rdata:00008E4Co
					; .rdata:00008F10o
; public: virtual void * __thiscall mozilla::gfx::DataSourceSurface::`vector deleting destructor'(unsigned int)
		extrn ??_EDataSourceSurface@gfx@mozilla@@UAEPAXI@Z:near	; weak
					; DATA XREF: .rdata:const mozilla::gfx::DataSourceSurface::`vftable'o
; struct ID3D10Device1 *__cdecl	static mozilla::gfx::Factory::GetDirect3D10Device()
		extrn ?GetDirect3D10Device@Factory@gfx@mozilla@@SAPAUID3D10Device1@@XZ:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+F8p
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void):loc_75Bp ...
; __declspec(dllimport)	public:	__thiscall std::basic_iostream<char, struct std::char_traits<char>>::basic_iostream<char, struct std::char_traits<char>>(class std::basic_streambuf<char, struct std::char_traits<char>> *)
		extrn __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:near
					; CODE XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+8Ap
					; DATA XREF: std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(int)+8Ar
; __declspec(dllimport)	public:	virtual	__thiscall std::basic_iostream<char, struct std::char_traits<char>>::~basic_iostream<char, struct std::char_traits<char>>(void)
		extrn __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ:near
					; CODE XREF: __unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1+8p
					; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream<char,std::char_traits<char>,std::allocator<char>>(void)+52p
					; DATA XREF: ...
; public: static void __cdecl mozilla::gfx::CriticalLogger::OutputMessage(class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> const &, int, bool)
		extrn ?OutputMessage@CriticalLogger@gfx@mozilla@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z:near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+2Fp
; void __cdecl __high static mozilla::gfx::CriticalLogger::CrashAction(enum mozilla::gfx::LogReason)
		extrn ?CrashAction@CriticalLogger@gfx@mozilla@@SAXW4LogReason@23@@Z:near
					; CODE XREF: mozilla::gfx::Log<1,mozilla::gfx::CriticalLogger>::WriteLog(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+70p
; public: virtual void * __thiscall std::basic_stringbuf<char, struct std::char_traits<char>, class std::allocator<char>>::`vector deleting destructor'(unsigned int)
		extrn ??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::`vftable'o
; public: virtual void * __thiscall std::basic_stringstream<char, struct std::char_traits<char>, class std::allocator<char>>::`vector deleting destructor'(unsigned int)
		extrn ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:near ; weak
					; CODE XREF: [thunk]:std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::`vector	deleting destructor'`vtordisp{4294967292,0}' (uint)+3j
; public: virtual void * __thiscall mozilla::gfx::SourceSurfaceD2DTarget::`vector deleting destructor'(unsigned int)
		extrn ??_ESourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const mozilla::gfx::SourceSurfaceD2DTarget::`vftable'o
; public: virtual void * __thiscall mozilla::gfx::DataSourceSurfaceD2DTarget::`vector deleting destructor'(unsigned int)
		extrn ??_EDataSourceSurfaceD2DTarget@gfx@mozilla@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const mozilla::gfx::DataSourceSurfaceD2DTarget::`vftable'o
; struct ID2D1Factory *__cdecl static mozilla::gfx::DrawTargetD2D::factory()
		extrn ?factory@DrawTargetD2D@gfx@mozilla@@SAPAUID2D1Factory@@XZ:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+588p
; public: virtual void __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Lock(void)
		extrn ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:near
					; DATA XREF: .rdata:00008E84o
; public: virtual void __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Unlock(void)
		extrn ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:near
					; DATA XREF: .rdata:00008E88o
; protected: virtual void __thiscall std::basic_streambuf<char,	struct std::char_traits<char>>::imbue(class std::locale	const &)
		extrn ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:near
					; DATA XREF: .rdata:00008EB8o
; protected: virtual class std::basic_streambuf<char, struct std::char_traits<char>> * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::setbuf(char *, __int64)
		extrn ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:near
					; DATA XREF: .rdata:00008EB0o
; protected: virtual __int64 __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::showmanyc(void)
		extrn ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:near
					; DATA XREF: .rdata:00008E94o
; protected: virtual int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sync(void)
		extrn ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:near
					; DATA XREF: .rdata:00008EB4o
; protected: virtual int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::uflow(void)
		extrn ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:near
					; DATA XREF: .rdata:00008E9Co
; protected: virtual __int64 __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::xsgetn(char *, __int64)
		extrn ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:near
					; DATA XREF: .rdata:00008EA0o
; protected: virtual __int64 __thiscall	std::basic_streambuf<char, struct std::char_traits<char>>::xsputn(char const *,	__int64)
		extrn ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:near
					; DATA XREF: .rdata:00008EA4o
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+DFp
					; mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)+6Cp ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetSize(void)+7Ap
					; mozilla::gfx::SourceSurfaceD2DTarget::GetDataSurface(void)+33Dp ...
; __stdcall _CxxThrowException(x, x)
		extrn __CxxThrowException@8:near
					; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
		extrn __RTC_CheckEsp:near
					; CODE XREF: mozilla::gfx::D2DPixelFormat(mozilla::gfx::SurfaceFormat)+49p
					; mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D *,mozilla::gfx::SurfaceFormat)+A5p ...
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0SourceSurfaceD2DTarget@gfx@mozilla@@QAE@PAVDrawTargetD2D@12@PAUID3D10Texture2D@@W4SurfaceFormat@12@@Z+16j
					; __ehhandler$??1SourceSurfaceD2DTarget@gfx@mozilla@@UAE@XZ+16j ...
; __declspec(dllimport)	__int64	const std::_BADOFF
		extrn __imp_?_BADOFF@std@@3_JB:near
					; DATA XREF: std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int)+10Br
					; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff(__int64,int,int):loc_7B0Ar ...
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data$r:std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char>> `RTTI Type Descriptor'o
					; .data$r:std::basic_streambuf<char,std::char_traits<char>> `RTTI Type Descriptor'o ...
; const	IID IID_IDXGISurface
		extrn _IID_IDXGISurface:near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *)+23Do
; public: static int mozilla::gfx::LoggingPrefs::sGfxLogLevel
		extrn ?sGfxLogLevel@LoggingPrefs@gfx@mozilla@@2HA:near
					; DATA XREF: mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,int,bool)+Cr
					; mozilla::gfx::BasicLogger::OutputMessage(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,bool)+16r ...
; public: static unsigned __int64 mozilla::gfx::DrawTargetD2D::mVRAMUsageSS
		extrn ?mVRAMUsageSS@DrawTargetD2D@gfx@mozilla@@2_KA:near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+7Fr
					; mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+87r ...
		extrn ___security_cookie:near
					; DATA XREF: mozilla::gfx::SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(mozilla::gfx::DrawTargetD2D *,ID3D10Texture2D	*,mozilla::gfx::SurfaceFormat)+19r
					; mozilla::gfx::SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget(void)+29r ...
		extrn __fltused:near


		end
