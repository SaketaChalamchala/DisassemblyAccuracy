;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4976F360CE647525BB3DBD7BDC5F40C3
; Input	CRC32 :	B4FFBD03

; File Name   :	D:\compspace\objfiles\firefox\gfx2d\SourceSurfaceRawData.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; must resolve:	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; must resolve:	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; must resolve:	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; must resolve:	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; must resolve:	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
$SG4890		db 'Assertion failure: %s, at %s:%d',0Ah,0
		align 4
$SG4896		db 'Hit MOZ_CRASH(%s) at %s:%d',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mozilla::gfx::BytesPerPixel(enum	mozilla::gfx::SurfaceFormat)
?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+2Cp
					; DATA XREF: .xdata$x:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5o ...

var_4		= dword	ptr -4
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	al, [ebp+arg_0]
		mov	byte ptr [ebp+var_4], al
		cmp	byte ptr [ebp+var_4], 6
		jz	short loc_66
		cmp	byte ptr [ebp+var_4], 7
		jz	short loc_5F
		jmp	short loc_6D
; ---------------------------------------------------------------------------

loc_5F:					; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+1Bj
		mov	eax, 1
		jmp	short loc_72
; ---------------------------------------------------------------------------

loc_66:					; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+15j
		mov	eax, 2
		jmp	short loc_72
; ---------------------------------------------------------------------------

loc_6D:					; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+1Dj
		mov	eax, 4

loc_72:					; CODE XREF: mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+24j
					; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)+2Bj
		mov	esp, ebp
		pop	ebp
		retn
?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::SourceSurfaceRawData::InitWrappingData(unsigned	char *,	struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> const &, int, enum	 mozilla::gfx::SurfaceFormat, bool)
		public ?InitWrappingData@SourceSurfaceRawData@gfx@mozilla@@QAEXPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@_N@Z
?InitWrappingData@SourceSurfaceRawData@gfx@mozilla@@QAEXPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@_N@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		mov	ecx, [edx+4]
		mov	edx, [ebp+var_4]
		mov	[edx+20h], eax
		mov	[edx+24h], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_8]
		mov	[eax+18h], ecx
		mov	edx, [ebp+var_4]
		mov	al, [ebp+arg_C]
		mov	[edx+1Ch], al
		mov	ecx, [ebp+var_4]
		mov	dl, [ebp+arg_10]
		mov	[ecx+2Ch], dl
		mov	esp, ebp
		pop	ebp
		retn	14h
?InitWrappingData@SourceSurfaceRawData@gfx@mozilla@@QAEXPAEABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@HW4SurfaceFormat@23@_N@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall mozilla::gfx::SourceSurfaceRawData::GuaranteePersistance(mozilla::gfx::SourceSurfaceRawData *__hidden	this)
		public ?GuaranteePersistance@SourceSurfaceRawData@gfx@mozilla@@UAEXXZ
?GuaranteePersistance@SourceSurfaceRawData@gfx@mozilla@@UAEXXZ proc near

var_C		= dword	ptr -0Ch
Src		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Src], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		movzx	ecx, byte ptr [eax+2Ch]
		test	ecx, ecx
		jz	short loc_FB
		jmp	short loc_14E
; ---------------------------------------------------------------------------

loc_FB:					; CODE XREF: mozilla::gfx::SourceSurfaceRawData::GuaranteePersistance(void)+27j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		mov	[ebp+Src], eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+var_4]
		mov	eax, [ecx+18h]
		imul	eax, [edx+24h]
		push	eax		; unsigned int
		call	??_U@YAPAXI@Z	; operator new[](uint)
		add	esp, 4
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+var_C]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+var_4]
		mov	edx, [eax+18h]
		imul	edx, [ecx+24h]
		push	edx		; Size
		mov	eax, [ebp+Src]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+14h]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_4]
		mov	byte ptr [eax+2Ch], 1

loc_14E:				; CODE XREF: mozilla::gfx::SourceSurfaceRawData::GuaranteePersistance(void)+29j
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?GuaranteePersistance@SourceSurfaceRawData@gfx@mozilla@@UAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::SourceSurfaceAlignedRawData::Init(struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> const &,	enum  mozilla::gfx::SurfaceFormat, bool)
		public ?Init@SourceSurfaceAlignedRawData@gfx@mozilla@@QAE_NABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@W4SurfaceFormat@23@_N@Z
?Init@SourceSurfaceAlignedRawData@gfx@mozilla@@QAE_NABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@W4SurfaceFormat@23@_N@Z proc near

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	cl, [ebp+arg_4]
		mov	[eax+24h], cl
		movzx	edx, [ebp+arg_4]
		push	edx
		call	?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		imul	eax, [ecx]
		push	eax
		call	??$GetAlignedStride@$0BA@@gfx@mozilla@@YAHH@Z ;	mozilla::gfx::GetAlignedStride<16>(int)
		add	esp, 4
		mov	edx, [ebp+var_4]
		mov	[edx+20h], eax
		push	0		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx+20h]
		push	eax		; this
		call	?BufferSizeFromStrideAndHeight@gfx@mozilla@@YAIHHH@Z ; mozilla::gfx::BufferSizeFromStrideAndHeight(int,int,int)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jbe	short loc_1F1
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	?Realloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXI_N@Z ;	mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_4]
		mov	[eax+28h], ecx
		mov	[eax+2Ch], edx
		jmp	short loc_20B
; ---------------------------------------------------------------------------

loc_1F1:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+68j
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	?Dealloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXXZ ; mozilla::gfx::AlignedArray<uchar,16>::Dealloc(void)
		push	0
		push	0
		mov	ecx, [ebp+var_4]
		add	ecx, 28h ; '('
		call	?SizeTo@?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAEXHH@Z ; mozilla::gfx::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>::SizeTo(int,int)

loc_20B:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+8Fj
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	??B?$AlignedArray@E$0BA@@gfx@mozilla@@QAEPAEXZ ; mozilla::gfx::AlignedArray<uchar,16>::operator	uchar *(void)
		test	eax, eax
		jz	short loc_223
		mov	[ebp+var_C], 1
		jmp	short loc_22A
; ---------------------------------------------------------------------------

loc_223:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+B8j
		mov	[ebp+var_C], 0

loc_22A:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+C1j
		mov	al, byte ptr [ebp+var_C]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?Init@SourceSurfaceAlignedRawData@gfx@mozilla@@QAE_NABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@W4SurfaceFormat@23@_N@Z endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits> const &, enum	mozilla::gfx::SurfaceFormat, int, bool)
		public ?InitWithStride@SourceSurfaceAlignedRawData@gfx@mozilla@@QAE_NABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@W4SurfaceFormat@23@H_N@Z
?InitWithStride@SourceSurfaceAlignedRawData@gfx@mozilla@@QAE_NABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@W4SurfaceFormat@23@H_N@Z	proc near

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	cl, [ebp+arg_4]
		mov	[eax+24h], cl
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_8]
		mov	[edx+20h], eax
		push	0		; int
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+20h]
		push	ecx		; this
		call	?BufferSizeFromStrideAndHeight@gfx@mozilla@@YAIHHH@Z ; mozilla::gfx::BufferSizeFromStrideAndHeight(int,int,int)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jbe	short loc_2B8
		movzx	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	?Realloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXI_N@Z ;	mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	eax, [ecx+4]
		mov	ecx, [ebp+var_4]
		mov	[ecx+28h], edx
		mov	[ecx+2Ch], eax
		jmp	short loc_2D2
; ---------------------------------------------------------------------------

loc_2B8:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+4Fj
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	?Dealloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXXZ ; mozilla::gfx::AlignedArray<uchar,16>::Dealloc(void)
		push	0
		push	0
		mov	ecx, [ebp+var_4]
		add	ecx, 28h ; '('
		call	?SizeTo@?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAEXHH@Z ; mozilla::gfx::BaseSize<int,mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits>>::SizeTo(int,int)

loc_2D2:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+76j
		mov	ecx, [ebp+var_4]
		add	ecx, 14h
		call	??B?$AlignedArray@E$0BA@@gfx@mozilla@@QAEPAEXZ ; mozilla::gfx::AlignedArray<uchar,16>::operator	uchar *(void)
		test	eax, eax
		jz	short loc_2EA
		mov	[ebp+var_C], 1
		jmp	short loc_2F1
; ---------------------------------------------------------------------------

loc_2EA:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+9Fj
		mov	[ebp+var_C], 0

loc_2F1:				; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+A8j
		mov	al, byte ptr [ebp+var_C]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?InitWithStride@SourceSurfaceAlignedRawData@gfx@mozilla@@QAE_NABU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@23@W4SurfaceFormat@23@H_N@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 304h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	mozilla::CheckedInt<int>::CheckedInt<int>(int, bool)
		public ??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z
??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z proc near
					; CODE XREF: mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+2Dp
					; mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+6Bp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	al, [ebp+arg_4]
		mov	[edx+4], al
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 32Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::CheckedInt<int>::CheckedInt<int>(int)
		public ??$?0H@?$CheckedInt@H@mozilla@@QAE@H@Z
??$?0H@?$CheckedInt@H@mozilla@@QAE@H@Z proc near
					; CODE XREF: mozilla::detail::CastToCheckedIntImpl<int,int>::run(int)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	??$IsInRange@HH@detail@mozilla@@YA_NH@Z	; mozilla::detail::IsInRange<int,int>(int)
		add	esp, 4
		mov	ecx, [ebp+var_4]
		mov	[ecx+4], al
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?0H@?$CheckedInt@H@mozilla@@QAE@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 368h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::CheckedInt<int>::CheckedInt<int>(unsigned	int)
		public ??$?0I@?$CheckedInt@H@mozilla@@QAE@I@Z
??$?0I@?$CheckedInt@H@mozilla@@QAE@I@Z proc near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+40p
					; mozilla::detail::CastToCheckedIntImpl<int,uint>::run(uint)+Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	??$IsInRange@HI@detail@mozilla@@YA_NI@Z	; mozilla::detail::IsInRange<int,uint>(uint)
		add	esp, 4
		mov	ecx, [ebp+var_4]
		mov	[ecx+4], al
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$?0I@?$CheckedInt@H@mozilla@@QAE@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	mozilla::CheckedInt<int> __cdecl mozilla::operator*<int>(class mozilla::CheckedInt<int>	const &, class mozilla::CheckedInt<int>	const &)
		public ??$?DH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z
??$?DH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z	proc near
					; CODE XREF: mozilla::operator*<int,uint>(mozilla::CheckedInt<int> const &,uint)+2Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		push	eax
		call	??$IsMulValid@H@detail@mozilla@@YA_NHH@Z ; mozilla::detail::IsMulValid<int>(int,int)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_3DB
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		call	??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(int,bool)
		mov	eax, [ebp+arg_0]
		jmp	short loc_417
; ---------------------------------------------------------------------------

loc_3DB:				; CODE XREF: mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+24j
		mov	edx, [ebp+arg_4]
		movzx	eax, byte ptr [edx+4]
		test	eax, eax
		jz	short loc_3F7
		mov	ecx, [ebp+arg_8]
		movzx	edx, byte ptr [ecx+4]
		test	edx, edx
		jz	short loc_3F7
		mov	byte ptr [ebp+var_4+3],	1
		jmp	short loc_3FB
; ---------------------------------------------------------------------------

loc_3F7:				; CODE XREF: mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+40j
					; mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+4Bj
		mov	byte ptr [ebp+var_4+3],	0

loc_3FB:				; CODE XREF: mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+51j
		movzx	eax, byte ptr [ebp+var_4+3]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		mov	eax, [ecx]
		imul	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(int,bool)
		mov	eax, [ebp+arg_0]

loc_417:				; CODE XREF: mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+35j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$?DH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 428h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	mozilla::CheckedInt<int> __cdecl mozilla::operator*<int, unsigned int>(class mozilla::CheckedInt<int> const &, unsigned	int)
		public ??$?DHI@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@I@Z
??$?DHI@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@I@Z proc near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+4Ap

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		call	??$castToCheckedInt@HI@mozilla@@YA?AV?$CheckedInt@H@0@I@Z ; mozilla::castToCheckedInt<int,uint>(uint)
		add	esp, 8
		push	eax
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$?DH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z	; mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$?DHI@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 470h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	mozilla::CheckedInt<int> __cdecl mozilla::operator+<int>(class mozilla::CheckedInt<int>	const &, class mozilla::CheckedInt<int>	const &)
		public ??$?HH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z
??$?HH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z	proc near
					; CODE XREF: mozilla::operator+<int,int>(mozilla::CheckedInt<int> const	&,int)+2Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		push	eax
		call	??$IsAddValid@H@detail@mozilla@@YA_NHH@Z ; mozilla::detail::IsAddValid<int>(int,int)
		add	esp, 8
		movzx	ecx, al
		test	ecx, ecx
		jnz	short loc_4A7
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		call	??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(int,bool)
		mov	eax, [ebp+arg_0]
		jmp	short loc_4E2
; ---------------------------------------------------------------------------

loc_4A7:				; CODE XREF: mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+24j
		mov	edx, [ebp+arg_4]
		movzx	eax, byte ptr [edx+4]
		test	eax, eax
		jz	short loc_4C3
		mov	ecx, [ebp+arg_8]
		movzx	edx, byte ptr [ecx+4]
		test	edx, edx
		jz	short loc_4C3
		mov	byte ptr [ebp+var_4+3],	1
		jmp	short loc_4C7
; ---------------------------------------------------------------------------

loc_4C3:				; CODE XREF: mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+40j
					; mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+4Bj
		mov	byte ptr [ebp+var_4+3],	0

loc_4C7:				; CODE XREF: mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+51j
		movzx	eax, byte ptr [ebp+var_4+3]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_8]
		add	edx, [eax]
		push	edx
		mov	ecx, [ebp+arg_0]
		call	??$?0H@?$CheckedInt@H@mozilla@@IAE@H_N@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(int,bool)
		mov	eax, [ebp+arg_0]

loc_4E2:				; CODE XREF: mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+35j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$?HH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4F0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	mozilla::CheckedInt<int> __cdecl mozilla::operator+<int, int>(class mozilla::CheckedInt<int> const &, int)
		public ??$?HHH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@H@Z
??$?HHH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@H@Z proc near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+57p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_8]
		push	eax
		lea	ecx, [ebp+var_8]
		push	ecx
		call	??$castToCheckedInt@HH@mozilla@@YA?AV?$CheckedInt@H@0@H@Z ; mozilla::castToCheckedInt<int,int>(int)
		add	esp, 8
		push	eax
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$?HH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@0@Z	; mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$?HHH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 538h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mozilla::detail::BinaryComplement<int>(int)
		public ??$BinaryComplement@H@detail@mozilla@@YAHH@Z
??$BinaryComplement@H@detail@mozilla@@YAHH@Z proc near
					; CODE XREF: mozilla::detail::IsAddValid<int>(int,int)+47p
					; mozilla::detail::IsAddValid<int>(int,int)+64p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		not	eax
		pop	ebp
		retn
??$BinaryComplement@H@detail@mozilla@@YAHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 544h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mozilla::gfx::GetAlignedStride<16>(int)
		public ??$GetAlignedStride@$0BA@@gfx@mozilla@@YAHH@Z
??$GetAlignedStride@$0BA@@gfx@mozilla@@YAHH@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+3Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0Fh
		mov	eax, [ebp+arg_0]
		add	eax, 0Fh
		and	eax, 0FFFFFFF0h
		mov	esp, ebp
		pop	ebp
		retn
??$GetAlignedStride@$0BA@@gfx@mozilla@@YAHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 564h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::detail::HasSignBit<int>(int)
		public ??$HasSignBit@H@detail@mozilla@@YA_NH@Z
??$HasSignBit@H@detail@mozilla@@YA_NH@Z	proc near
					; CODE XREF: mozilla::detail::IsAddValid<int>(int,int)+50p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		shr	eax, 1Fh
		test	eax, eax
		jz	short loc_57F
		mov	byte ptr [ebp+var_4+3],	1
		jmp	short loc_583
; ---------------------------------------------------------------------------

loc_57F:				; CODE XREF: mozilla::detail::HasSignBit<int>(int)+13j
		mov	byte ptr [ebp+var_4+3],	0

loc_583:				; CODE XREF: mozilla::detail::HasSignBit<int>(int)+19j
		mov	al, byte ptr [ebp+var_4+3]
		mov	esp, ebp
		pop	ebp
		retn
??$HasSignBit@H@detail@mozilla@@YA_NH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 58Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::detail::IsAddValid<int>(int, int)
		public ??$IsAddValid@H@detail@mozilla@@YA_NHH@Z
??$IsAddValid@H@detail@mozilla@@YA_NHH@Z proc near
					; CODE XREF: mozilla::operator+<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+17p

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_4], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_4]
		add	edx, [ebp+var_8]
		mov	[ebp+var_C], edx
		mov	eax, 1
		test	eax, eax
		jz	short loc_5EC
		mov	ecx, [ebp+var_C]
		xor	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_C]
		xor	edx, [ebp+arg_4]
		and	ecx, edx
		push	ecx
		call	??$BinaryComplement@H@detail@mozilla@@YAHH@Z ; mozilla::detail::BinaryComplement<int>(int)
		add	esp, 4
		push	eax
		call	??$HasSignBit@H@detail@mozilla@@YA_NH@Z	; mozilla::detail::HasSignBit<int>(int)
		add	esp, 4
		movzx	eax, al
		mov	[ebp+var_10], eax
		jmp	short loc_613
; ---------------------------------------------------------------------------

loc_5EC:				; CODE XREF: mozilla::detail::IsAddValid<int>(int,int)+36j
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	??$BinaryComplement@H@detail@mozilla@@YAHH@Z ; mozilla::detail::BinaryComplement<int>(int)
		add	esp, 4
		cmp	eax, [ebp+arg_4]
		jl	short loc_606
		mov	[ebp+var_14], 1
		jmp	short loc_60D
; ---------------------------------------------------------------------------

loc_606:				; CODE XREF: mozilla::detail::IsAddValid<int>(int,int)+6Fj
		mov	[ebp+var_14], 0

loc_60D:				; CODE XREF: mozilla::detail::IsAddValid<int>(int,int)+78j
		mov	edx, [ebp+var_14]
		mov	[ebp+var_10], edx

loc_613:				; CODE XREF: mozilla::detail::IsAddValid<int>(int,int)+5Ej
		mov	al, byte ptr [ebp+var_10]
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$IsAddValid@H@detail@mozilla@@YA_NHH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 624h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::detail::IsInRange<int, int>(int)
		public ??$IsInRange@HH@detail@mozilla@@YA_NH@Z
??$IsInRange@HH@detail@mozilla@@YA_NH@Z	proc near
					; CODE XREF: mozilla::CheckedInt<int>::CheckedInt<int>(int)+1Ap

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?run@?$IsInRangeImpl@HH$00$00$00@detail@mozilla@@SA_NH@Z ; mozilla::detail::IsInRangeImpl<int,int,1,1,1>::run(int)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$IsInRange@HH@detail@mozilla@@YA_NH@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 63Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::detail::IsInRange<int, unsigned	int>(unsigned int)
		public ??$IsInRange@HI@detail@mozilla@@YA_NI@Z
??$IsInRange@HI@detail@mozilla@@YA_NI@Z	proc near
					; CODE XREF: mozilla::CheckedInt<int>::CheckedInt<int>(uint)+1Ap

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	eax
		call	?run@?$IsInRangeImpl@HI$00$0A@$0A@@detail@mozilla@@SA_NI@Z ; mozilla::detail::IsInRangeImpl<int,uint,1,0,0>::run(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$IsInRange@HI@detail@mozilla@@YA_NI@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 654h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::detail::IsInRange<int, __int64>(__int64)
		public ??$IsInRange@H_J@detail@mozilla@@YA_N_J@Z
??$IsInRange@H_J@detail@mozilla@@YA_N_J@Z proc near
					; CODE XREF: mozilla::detail::IsMulValidImpl<int,1,1>::run(int,int)+38p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?run@?$IsInRangeImpl@H_J$00$00$0A@@detail@mozilla@@SA_N_J@Z ; mozilla::detail::IsInRangeImpl<int,__int64,1,1,0>::run(__int64)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$IsInRange@H_J@detail@mozilla@@YA_N_J@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 670h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __cdecl mozilla::detail::IsMulValid<int>(int, int)
		public ??$IsMulValid@H@detail@mozilla@@YA_NHH@Z
??$IsMulValid@H@detail@mozilla@@YA_NHH@Z proc near
					; CODE XREF: mozilla::operator*<int>(mozilla::CheckedInt<int> const &,mozilla::CheckedInt<int> const &)+17p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?run@?$IsMulValidImpl@H$00$00@detail@mozilla@@SA_NHH@Z ; mozilla::detail::IsMulValidImpl<int,1,1>::run(int,int)
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$IsMulValid@H@detail@mozilla@@YA_NHH@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::_Allocate<char>(unsigned int, char *)
		public ??$_Allocate@D@std@@YAPADIPAD@Z
??$_Allocate@D@std@@YAPADIPAD@Z	proc near
					; CODE XREF: std::allocator<char>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_6A7
		jmp	short loc_6D1
; ---------------------------------------------------------------------------

loc_6A7:				; CODE XREF: std::_Allocate<char>(uint,char *)+17j
		cmp	[ebp+arg_0], 0FFFFFFFFh
		ja	short loc_6C2
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_6D1

loc_6C2:				; CODE XREF: std::_Allocate<char>(uint,char *)+1Fj
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6D1:				; CODE XREF: std::_Allocate<char>(uint,char *)+19j
					; std::_Allocate<char>(uint,char *)+34j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@D@std@@YAPADIPAD@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
		public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
					; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], 0
		cmp	[ebp+arg_0], 0
		jnz	short loc_6FF
		jmp	short loc_72F
; ---------------------------------------------------------------------------

loc_6FF:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+17j
		cmp	[ebp+arg_0], 1FFFFFFFh
		ja	short loc_720
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax		; unsigned int
		call	??2@YAPAXI@Z	; operator new(uint)
		add	esp, 4
		mov	[ebp+var_4], eax
		cmp	[ebp+var_4], 0
		jnz	short loc_72F

loc_720:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+22j
		mov	esi, esp
		call	dword ptr ds:__imp_?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_72F:				; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+19j
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Aj
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 744h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::_Debug_pointer<char>(int, wchar_t *,	unsigned int)
		public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+1Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+22p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		cmp	[ebp+arg_0], 0
		jnz	short loc_76D
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
		call	dword ptr ds:__imp_?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const	*,wchar_t const	*,uint)
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_76D:				; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+8j
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 778h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * __cdecl std::addressof<char>(char &)
		public ??$addressof@D@std@@YAPADAAD@Z
??$addressof@D@std@@YAPADAAD@Z proc near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p
					; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+27p	...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$addressof@D@std@@YAPADAAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 780h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	mozilla::CheckedInt<int> __cdecl mozilla::castToCheckedInt<int,	int>(int)
		public ??$castToCheckedInt@HH@mozilla@@YA?AV?$CheckedInt@H@0@H@Z
??$castToCheckedInt@HH@mozilla@@YA?AV?$CheckedInt@H@0@H@Z proc near
					; CODE XREF: mozilla::operator+<int,int>(mozilla::CheckedInt<int> const	&,int)+1Cp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?run@?$CastToCheckedIntImpl@HH@detail@mozilla@@SA?AV?$CheckedInt@H@3@H@Z ; mozilla::detail::CastToCheckedIntImpl<int,int>::run(int)
		add	esp, 8
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$castToCheckedInt@HH@mozilla@@YA?AV?$CheckedInt@H@0@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	mozilla::CheckedInt<int> __cdecl mozilla::castToCheckedInt<int,	unsigned int>(unsigned int)
		public ??$castToCheckedInt@HI@mozilla@@YA?AV?$CheckedInt@H@0@I@Z
??$castToCheckedInt@HI@mozilla@@YA?AV?$CheckedInt@H@0@I@Z proc near
					; CODE XREF: mozilla::operator*<int,uint>(mozilla::CheckedInt<int> const &,uint)+1Cp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?run@?$CastToCheckedIntImpl@HI@detail@mozilla@@SA?AV?$CheckedInt@H@3@I@Z ; mozilla::detail::CastToCheckedIntImpl<int,uint>::run(uint)
		add	esp, 8
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$castToCheckedInt@HI@mozilla@@YA?AV?$CheckedInt@H@0@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7C0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::construct<char *,char *	&>(void	*, int)
		public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: $LN19+4Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	edx, [ebp+var_4]
		push	edx		; int
		call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ;	std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
		add	esp, 0Ch
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::construct<char *,char * &>(void *, int)
		public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char	* &>(std::allocator<char> &,char * *,char * &)+17p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	4		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_86E
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		mov	edx, [ebp+var_18]
		mov	eax, [eax]
		mov	[edx], eax
		mov	ecx, [ebp+var_18]
		mov	[ebp+var_1C], ecx
		jmp	short loc_875
; ---------------------------------------------------------------------------

loc_86E:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+55j
		mov	[ebp+var_1C], 0

loc_875:				; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+70j
		mov	edx, [ebp+var_1C]
		mov	[ebp+var_14], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8A0h
; COMDAT (pick associative to section at 7FC)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
					; DATA XREF: .xdata$x:00002548o
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
					; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void	*, int)
		public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+23p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_8]
		push	eax
		call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; void *
		mov	ecx, [ebp+arg_0]
		call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char	* &>(char * *,char * &)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
		public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+49p

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		push	8		; unsigned int
		call	??2@YAPAXIPAX@Z	; operator new(uint,void *)
		add	esp, 8
		mov	[ebp+var_18], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_18], 0
		jz	short loc_96C
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
		add	esp, 4
		mov	edx, [eax]
		mov	eax, [eax+4]
		mov	ecx, [ebp+var_18]
		mov	[ecx], edx
		mov	[ecx+4], eax
		mov	edx, [ebp+var_18]
		mov	[ebp+var_1C], edx
		jmp	short loc_973
; ---------------------------------------------------------------------------

loc_96C:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+55j
		mov	[ebp+var_1C], 0

loc_973:				; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+76j
		mov	eax, [ebp+var_1C]
		mov	[ebp+var_14], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 1Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 99Ch
; COMDAT (pick associative to section at 8F4)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
					; DATA XREF: .xdata$x:0000251Co
		mov	eax, [ebp+8]
		push	eax
		mov	eax, [ebp-18h]
		push	eax		; void *
		call	??3@YAXPAX0@Z	; operator delete(void *,void *)
		add	esp, 8
		retn
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc	near
					; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-14h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+4Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		push	ecx
		call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
		public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char *	*)+Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
		public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+16p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ;	std::allocator<char>::destroy<char *>(char * *)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::allocator<struct	std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
		public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+3Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esp, ebp
		pop	ebp
		retn	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char * & __cdecl std::forward<char * &>(char * &)
		public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char *	&)+12p
					; std::allocator<char>::construct<char *,char *	&>(char	* *,char * &)+5Bp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A40h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
		public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc	near
					; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5Bp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		retn
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A48h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
		public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+42p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		mov	ecx, [ebp+var_10]
		call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_10]
		call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0AB4h
; COMDAT (pick associative to section at A48)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
					; DATA XREF: .xdata$x:00002438o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-8]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AD8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
		public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+30p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+14h], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
		public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B48h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<char>::allocator<char>(void)
		public ??0?$allocator@D@std@@QAE@XZ
??0?$allocator@D@std@@QAE@XZ proc near	; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+11p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+39p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@D@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
		public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+1Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
		public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; CODE XREF: std::_Generic_error_category::message(int)+57p
					; std::_Iostream_error_category::message(int)+2Cp ...

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	[ebp+var_14], 0CCCCCCCCh
		mov	[ebp+var_10], 0CCCCCCCCh
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], ecx
		lea	ecx, [ebp+var_14+3]
		call	??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
		push	eax
		mov	ecx, [ebp+var_10]
		call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z	; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
		mov	[ebp+var_4], 0
		push	0		; Size
		push	0		; char
		mov	ecx, [ebp+var_10]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		mov	eax, [ebp+Str]
		push	eax		; Str
		mov	ecx, [ebp+var_10]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_10]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		add	esp, 14h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C04h
; COMDAT (pick associative to section at B78)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
					; DATA XREF: .xdata$x:00002464o
		mov	ecx, [ebp-10h]
		jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
		public ??0_Container_proxy@std@@QAE@XZ
??0_Container_proxy@std@@QAE@XZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+3Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0_Container_proxy@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
		public ??0_Generic_error_category@std@@QAE@XZ
??0_Generic_error_category@std@@QAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+11p
					; std::_System_error_category::_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0error_category@std@@QAE@XZ ;	std::error_category::error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Generic_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C80h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??0_Iostream_error_category@std@@QAE@XZ
??0_Iostream_error_category@std@@QAE@XZ	proc near
					; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_Iostream_error_category@std@@6B@ ;	const std::_Iostream_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_Iostream_error_category@std@@QAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CB0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
		public ??0_System_error_category@std@@QAE@XZ
??0_System_error_category@std@@QAE@XZ proc near
					; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0_System_error_category@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
		public ??0error_category@std@@QAE@XZ
??0error_category@std@@QAE@XZ proc near	; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
??0error_category@std@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D00h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct	std::error_category *)
		public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+36p
					; std::_System_error_category::default_error_condition(int)+4Fp ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	eax, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char,	class std::allocator<char>>>::~_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>(void)
		public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
		mov	ecx, [ebp+var_4]
		call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ;	std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
		public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
					; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+19p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category	*__hidden this)
		public ??1_Generic_error_category@std@@UAE@XZ
??1_Generic_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+11p
					; std::_System_error_category::~_System_error_category(void)+11p ...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Generic_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
		public ??1_Iostream_error_category@std@@UAE@XZ
??1_Iostream_error_category@std@@UAE@XZ	proc near
					; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_Iostream_error_category@std@@UAE@XZ	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DCCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
		public ??1_System_error_category@std@@UAE@XZ
??1_System_error_category@std@@UAE@XZ proc near
					; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+11p
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1_System_error_category@std@@UAE@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DF0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
		public ??1error_category@std@@UAE@XZ
??1error_category@std@@UAE@XZ proc near	; CODE XREF: std::_Generic_error_category::~_Generic_error_category(void)+11p
					; std::error_category::`scalar deleting	destructor'(uint)+11p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], offset	??_7error_category@std@@6B@ ; const std::error_category::`vftable'
		mov	esp, ebp
		pop	ebp
		retn
??1error_category@std@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int, void	*)
		public ??2@YAPAXIPAX@Z
??2@YAPAXIPAX@Z	proc near		; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+3Fp
					; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+3Fp

arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		pop	ebp
		retn
??2@YAPAXIPAX@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E14h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX0@Z
??3@YAXPAX0@Z	proc near		; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
					; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
??3@YAXPAX0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E1Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::error_category::operator==(class	std::error_category const &)const
		public ??8error_category@std@@QBE_NABV01@@Z
??8error_category@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Bp
					; std::error_category::equivalent(std::error_code const	&,int)+23p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_E44
		mov	[ebp+var_8], 1
		jmp	short loc_E4B
; ---------------------------------------------------------------------------

loc_E44:				; CODE XREF: std::error_category::operator==(std::error_category const &)+1Dj
		mov	[ebp+var_8], 0

loc_E4B:				; CODE XREF: std::error_category::operator==(std::error_category const &)+26j
		mov	al, byte ptr [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_category@std@@QBE_NABV01@@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::error_condition::operator==(std::error_condition *)
		public ??8error_condition@std@@QBE_NABV01@@Z
??8error_condition@std@@QBE_NABV01@@Z proc near
					; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+43p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		push	eax
		mov	ecx, [ebp+var_4] ; this
		call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
		mov	ecx, eax
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_EAA
		mov	ecx, [ebp+var_4] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
		cmp	esi, eax
		jnz	short loc_EAA
		mov	[ebp+var_8], 1
		jmp	short loc_EB1
; ---------------------------------------------------------------------------

loc_EAA:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+35j
					; std::error_condition::operator==(std::error_condition	const &)+4Bj
		mov	[ebp+var_8], 0

loc_EB1:				; CODE XREF: std::error_condition::operator==(std::error_condition const &)+54j
		mov	al, byte ptr [ebp+var_8]
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8error_condition@std@@QBE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall mozilla::gfx::AlignedArray<unsigned char, 16>::operator unsigned char *(void)
		public ??B?$AlignedArray@E$0BA@@gfx@mozilla@@QAEPAEXZ
??B?$AlignedArray@E$0BA@@gfx@mozilla@@QAEPAEXZ proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+B1p
					; mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+98p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
??B?$AlignedArray@E$0BA@@gfx@mozilla@@QAEPAEXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Generic_error_category@std@@UAEPAXI@Z
??_G_Generic_error_category@std@@UAEPAXI@Z proc	near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F0A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F0A:				; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Generic_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F20h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_Iostream_error_category@std@@UAEPAXI@Z
??_G_Iostream_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F4A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F4A:				; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_Iostream_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F60h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
		public ??_G_System_error_category@std@@UAEPAXI@Z
??_G_System_error_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F8A
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F8A:				; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_G_System_error_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FA0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
		public ??_Gerror_category@std@@UAEPAXI@Z
??_Gerror_category@std@@UAEPAXI@Z proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4] ; this
		call	??1error_category@std@@UAE@XZ ;	std::error_category::~error_category(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_FCA
		mov	ecx, [ebp+var_4]
		push	ecx		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_FCA:				; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_Gerror_category@std@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FE0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new[](unsigned	int, void *)
		public ??_U@YAPAXIPAX@Z
??_U@YAPAXIPAX@Z proc near		; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+14Fp

arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		pop	ebp
		retn
??_U@YAPAXIPAX@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 0FE8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
		push	offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 100Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category(void)
		push	offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 1030h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??0_System_error_category@std@@QAE@XZ ;	std::_System_error_category::_System_error_category(void)
		push	offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ	; void (__cdecl	*)()
		call	_atexit
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 1054h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc	near
					; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 1078h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	initializer for	'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		push	0		; unsigned int
		mov	ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
		call	dword ptr ds:__imp_??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 109Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
??__Eallocator_arg@std@@YAXXZ proc near	; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Eallocator_arg@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$di	segment	para public 'CODE' use32
		assume cs:_text$di
		;org 10B0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
??__Epiecewise_construct@std@@YAXXZ proc near
					; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		mov	byte ptr [ebp+var_4+3],	al
		mov	esp, ebp
		pop	ebp
		retn
??__Epiecewise_construct@std@@YAXXZ endp

_text$di	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 10C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc	near
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
		call	??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 10DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
		call	??1_Iostream_error_category@std@@UAE@XZ	; std::_Iostream_error_category::~_Iostream_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$yd	segment	para public 'CODE' use32
		assume cs:_text$yd
		;org 10F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl `dynamic	atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
		push	ebp
		mov	ebp, esp
		mov	ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
		call	??1_System_error_category@std@@UAE@XZ ;	std::_System_error_category::~_System_error_category(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$yd	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 110Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::AlignedArray<unsigned char, 16>::Dealloc(void)
		public ?Dealloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXXZ
?Dealloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXXZ proc	near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+97p
					; mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+7Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		push	ecx		; Memory
		call	dword ptr ds:__imp__free
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+4], 0
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax], 0
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?Dealloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1158h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::AlignedArray<unsigned char, 16>::Realloc(unsigned int, bool)
		public ?Realloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXI_N@Z
?Realloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXI_N@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+79p
					; mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+60p

var_28		= dword	ptr -28h
var_24		= byte ptr -24h
var_1C		= byte ptr -1Ch
var_10		= byte ptr -10h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_28]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+4]
		push	ecx		; Memory
		call	dword ptr ds:__imp__free
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	0Fh
		mov	edx, [ebp+arg_0]
		push	edx
		push	1
		lea	ecx, [ebp+var_1C]
		call	??$?0I@?$CheckedInt@H@mozilla@@QAE@I@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(uint)
		push	eax
		lea	eax, [ebp+var_24]
		push	eax
		call	??$?DHI@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@I@Z ; mozilla::operator*<int,uint>(mozilla::CheckedInt<int> const &,uint)
		add	esp, 0Ch
		push	eax
		lea	ecx, [ebp+var_10]
		push	ecx
		call	??$?HHH@mozilla@@YA?AV?$CheckedInt@H@0@ABV10@H@Z ; mozilla::operator+<int,int>(mozilla::CheckedInt<int>	const &,int)
		add	esp, 0Ch
		lea	ecx, [ebp+var_10]
		call	?isValid@?$CheckedInt@H@mozilla@@QBE_NXZ ; mozilla::CheckedInt<int>::isValid(void)
		movzx	edx, al
		test	edx, edx
		jnz	short loc_11E8
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx+8], 0
		jmp	loc_12C3
; ---------------------------------------------------------------------------

loc_11E8:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+6Cj
		movzx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1215
		lea	ecx, [ebp+var_10]
		call	?value@?$CheckedInt@H@mozilla@@QBEHXZ ;	mozilla::CheckedInt<int>::value(void)
		mov	esi, esp
		push	eax		; SizeOfElements
		push	1		; NumOfElements
		call	dword ptr ds:__imp__calloc
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_4]
		mov	[ecx+4], eax
		jmp	short loc_1236
; ---------------------------------------------------------------------------

loc_1215:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+96j
		lea	ecx, [ebp+var_10]
		call	?value@?$CheckedInt@H@mozilla@@QBEHXZ ;	mozilla::CheckedInt<int>::value(void)
		mov	esi, esp
		push	eax		; Size
		call	dword ptr ds:__imp__malloc
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	edx, [ebp+var_4]
		mov	[edx+4], eax

loc_1236:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+BBj
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_125E
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+4], 0
		mov	edx, [ebp+var_4]
		mov	dword ptr [edx], 0
		mov	eax, [ebp+var_4]
		mov	dword ptr [eax+8], 0
		jmp	short loc_12C3
; ---------------------------------------------------------------------------

loc_125E:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+E5j
		mov	ecx, [ebp+var_4]
		mov	eax, [ecx+4]
		xor	edx, edx
		mov	ecx, 10h
		div	ecx
		test	edx, edx
		jz	short loc_1292
		mov	edx, [ebp+var_4]
		mov	ecx, [edx+4]
		add	ecx, 10h
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		xor	edx, edx
		mov	esi, 10h
		div	esi
		sub	ecx, edx
		mov	eax, [ebp+var_4]
		mov	[eax], ecx
		jmp	short loc_129D
; ---------------------------------------------------------------------------

loc_1292:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+117j
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	[ecx], eax

loc_129D:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+138j
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		push	edx		; void *
		mov	eax, [ebp+arg_0]
		push	eax		; unsigned int
		call	??_U@YAPAXIPAX@Z ; operator new[](uint,void *)
		add	esp, 8
		mov	[ebp+var_28], eax
		mov	ecx, [ebp+var_4]
		mov	edx, [ebp+var_28]
		mov	[ecx], edx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_12C3:				; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+8Bj
					; mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+104j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		add	esp, 28h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?Realloc@?$AlignedArray@E$0BA@@gfx@mozilla@@QAEXI_N@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN11		dd 1			; DATA XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+16Fo
		dd offset $LN10
$LN10		dd 0FFFFFFF0h, 8	; DATA XREF: .text$mn:000012ECo
		dd offset $LN9		; "storageByteCount"
$LN9		db 'storageByteCount',0 ; DATA XREF: .text$mn:000012F8o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1310h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall mozilla::gfx::BaseSize<int, struct mozilla::gfx::IntSizeTyped<struct mozilla::gfx::UnknownUnits>>::SizeTo(int, int)
		public ?SizeTo@?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAEXHH@Z
?SizeTo@?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAEXHH@Z proc near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+A6p
					; mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+8Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	edx, [ebp+var_4]
		mov	eax, [ebp+arg_4]
		mov	[edx+4], eax
		mov	esp, ebp
		pop	ebp
		retn	8
?SizeTo@?$BaseSize@HU?$IntSizeTyped@UUnknownUnits@gfx@mozilla@@@gfx@mozilla@@@gfx@mozilla@@QAEXHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1338h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
		public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char>	const &)+3Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], eax
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		push	1
		lea	ecx, [ebp+var_C+3]
		call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	; std::allocator<std::_Container_proxy>::allocate(uint)
		mov	ecx, [ebp+var_4]
		mov	[ecx], eax
		lea	ecx, [ebp+var_18] ; this
		call	??0_Container_proxy@std@@QAE@XZ	; std::_Container_proxy::_Container_proxy(void)
		push	eax		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx]
		mov	eax, [ebp+var_4]
		mov	[edx], eax
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		add	esp, 18h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 10h
$LN5		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+5Co
		dd offset $LN4
$LN4		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000013B4o
		dd offset $LN3		; "_Alproxy"
$LN3		db '_Alproxy',0         ; DATA XREF: .text$mn:000013C0o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 13D0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
		public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Cp

var_38		= byte ptr -38h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_25		= byte ptr -25h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

; FUNCTION CHUNK AT 00001517 SIZE 00000009 BYTES

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		mov	eax, large fs:0
		push	eax
		push	ecx
		sub	esp, 28h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_38]
		mov	ecx, 0Ah
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_10], esp
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		or	eax, 0Fh
		mov	[ebp+var_18], eax
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+var_18]
		jnb	short loc_142E
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_18], ecx
		jmp	short loc_1480
; ---------------------------------------------------------------------------

loc_142E:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+54j
		mov	eax, [ebp+var_18]
		xor	edx, edx
		mov	ecx, 3
		div	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+18h]
		shr	ecx, 1
		cmp	ecx, eax
		ja	short loc_1448
		jmp	short loc_1480
; ---------------------------------------------------------------------------

loc_1448:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+74j
		mov	edx, [ebp+var_14]
		mov	esi, [edx+18h]
		shr	esi, 1
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		sub	eax, esi
		mov	ecx, [ebp+var_14]
		cmp	[ecx+18h], eax
		ja	short loc_1475
		mov	edx, [ebp+var_14]
		mov	eax, [edx+18h]
		shr	eax, 1
		mov	ecx, [ebp+var_14]
		add	eax, [ecx+18h]
		mov	[ebp+var_18], eax
		jmp	short loc_1480
; ---------------------------------------------------------------------------

loc_1475:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+90j
		mov	ecx, [ebp+var_14]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		mov	[ebp+var_18], eax

loc_1480:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5Cj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+76j ...
		mov	[ebp+var_4], 0
		lea	edx, [ebp+var_25]
		push	edx
		mov	ecx, [ebp+var_14]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_18]
		add	eax, 1
		push	eax
		mov	ecx, [ebp+var_2C]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp+var_30], eax
		mov	ecx, [ebp+var_30]
		mov	[ebp+var_20], ecx
		jmp	short loc_1517
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp


; =============== S U B	R O U T	I N E =======================================


__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
					; DATA XREF: .xdata$x:00002498o

; FUNCTION CHUNK AT 00001501 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 00001511 SIZE 00000006 BYTES

		mov	[ebp-10h], esp
		mov	edx, [ebp+8]
		mov	[ebp-18h], edx
		mov	byte ptr [ebp-4], 2
		lea	eax, [ebp-26h]
		push	eax
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	[ebp-34h], eax
		mov	ecx, [ebp-18h]
		add	ecx, 1
		push	ecx
		mov	ecx, [ebp-34h]
		call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
		mov	[ebp-38h], eax
		mov	edx, [ebp-38h]
		mov	[ebp-20h], edx
		jmp	short loc_1501
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
					; DATA XREF: .xdata$x:000024A8o
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		push	0
		push	0
		call	__CxxThrowException@8 ;	_CxxThrowException(x,x)
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp

; ---------------------------------------------------------------------------
		mov	eax, offset $LN17
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_1501:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+34j
		mov	dword ptr [ebp-4], 1
		jmp	short loc_1511
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

; =============== S U B	R O U T	I N E =======================================


$LN17		proc near		; DATA XREF: .text$mn:000014FBo
		mov	dword ptr [ebp-4], 1
$LN17		endp ; sp-analysis failed

; START	OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0

loc_1511:				; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+58j
		mov	eax, offset $LN19
		retn
; END OF FUNCTION CHUNK	FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

loc_1517:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+DEj
		mov	[ebp+var_4], 0FFFFFFFFh
		jmp	short loc_1527
; END OF FUNCTION CHUNK	FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z

; =============== S U B	R O U T	I N E =======================================


$LN19		proc near		; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1511o
		mov	dword ptr [ebp-4], 0FFFFFFFFh

loc_1527:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+14Ej
		cmp	dword ptr [ebp+0Ch], 0
		jbe	short loc_1546
		mov	eax, [ebp+0Ch]
		push	eax		; Size
		mov	ecx, [ebp-14h]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Src
		mov	ecx, [ebp-20h]
		push	ecx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_1546:				; CODE XREF: $LN19+Bj
		push	0		; Size
		push	1		; char
		mov	ecx, [ebp-14h]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		lea	edx, [ebp-20h]
		push	edx		; int
		mov	eax, [ebp-14h]
		add	eax, 4
		push	eax		; void *
		lea	ecx, [ebp-27h]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char	*,char * &>(char * *,char * &)
		mov	edx, [ebp-14h]
		mov	eax, [ebp-18h]
		mov	[edx+18h], eax
		mov	ecx, [ebp+0Ch]
		push	ecx
		mov	ecx, [ebp-14h]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp-0Ch]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 38h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
$LN19		endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN23		dd 1			; DATA XREF: $LN19+69o
		dd offset $LN22
$LN22		dd 0FFFFFFE0h, 4	; DATA XREF: .text$mn:000015B8o
		dd offset $LN20		; "_Ptr"
$LN20		db '_Ptr',0             ; DATA XREF: .text$mn:000015C4o
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 15D0h
; COMDAT (pick associative to section at 13D0)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-3Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 15ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
		public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc	near
					; CODE XREF: $LN19+60p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+98p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	byte ptr [ebp+var_8+3],	0
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		lea	edx, [ebp+var_8+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		push	eax
		call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
		add	esp, 8
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1638h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::_String_alloc<0,	struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
		public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+11p

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	ecx, [ebp+var_C+3]
		call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
		mov	esi, esp
		mov	ecx, [ebp+var_4] ; this
		call	dword ptr ds:__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ ;	std::_Container_base12::_Orphan_all(void)
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_4]
		mov	ecx, [eax]
		push	ecx
		lea	ecx, [ebp+var_C+3]
		call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
		push	1		; int
		mov	edx, [ebp+var_4]
		mov	eax, [edx]
		push	eax		; void *
		lea	ecx, [ebp+var_C+3]
		call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx], 0
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp

; ---------------------------------------------------------------------------
$LN5_0		dd 1			; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+60o
		dd offset $LN4_0
$LN4_0		dd 0FFFFFFF7h, 1	; DATA XREF: .text$mn:000016B8o
		dd offset $LN3_0	; "_Alproxy"
$LN3_0		db '_Alproxy',0         ; DATA XREF: .text$mn:000016C4o
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Wrap_alloc<class	std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
		public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BEp
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+14p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1700h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
		public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+78p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+66p

var_C		= dword	ptr -0Ch
Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+var_4]
		call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
		cmp	eax, [ebp+arg_0]
		jnb	short loc_1733
		mov	ecx, [ebp+var_4]
		call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)

loc_1733:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+29j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_1753
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
		jmp	short loc_179D
; ---------------------------------------------------------------------------

loc_1753:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
		movzx	edx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_178D
		cmp	[ebp+arg_0], 10h
		jnb	short loc_178D
		mov	eax, [ebp+var_4]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+14h]
		jnb	short loc_1774
		mov	edx, [ebp+arg_0]
		mov	[ebp+Size], edx
		jmp	short loc_177D
; ---------------------------------------------------------------------------

loc_1774:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+6Aj
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		mov	[ebp+Size], ecx

loc_177D:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+72j
		mov	edx, [ebp+Size]
		push	edx		; Size
		push	1		; char
		mov	ecx, [ebp+var_4]
		call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
		jmp	short loc_179D
; ---------------------------------------------------------------------------

loc_178D:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+59j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Fj
		cmp	[ebp+arg_0], 0
		jnz	short loc_179D
		push	0
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_179D:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+51j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Bj ...
		cmp	[ebp+arg_0], 0
		jbe	short loc_17AC
		mov	[ebp+var_C], 1
		jmp	short loc_17B3
; ---------------------------------------------------------------------------

loc_17AC:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+A1j
		mov	[ebp+var_C], 0

loc_17B3:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+AAj
		mov	al, byte ptr [ebp+var_C]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
		public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+31p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_17FC
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		cmp	[ebp+arg_0], eax
		jb	short loc_17FC
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+var_4]
		add	eax, [ecx+14h]
		cmp	eax, [ebp+arg_0]
		ja	short loc_1802

loc_17FC:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+12j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+1Fj
		xor	al, al
		jmp	short loc_1804
; ---------------------------------------------------------------------------
		jmp	short loc_1804
; ---------------------------------------------------------------------------

loc_1802:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+32j
		mov	al, 1

loc_1804:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+36j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+38j
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1814h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
					; CODE XREF: $LN19+14p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+2Bp ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_1848
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_1851
; ---------------------------------------------------------------------------

loc_1848:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_1851:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1864h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
		public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+8Bp

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_1898
		mov	ecx, [ebp+var_4]
		mov	edx, [ecx+4]
		push	edx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		mov	[ebp+var_8], eax
		jmp	short loc_18A1
; ---------------------------------------------------------------------------

loc_1898:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+1Ej
		mov	eax, [ebp+var_4]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_18A1:				; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+32j
		mov	eax, [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 18B4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t	Size)
		public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+55p
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+7p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		movzx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_18DC
		jmp	short loc_194F
; ---------------------------------------------------------------------------

loc_18DC:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+24j
		mov	ecx, [ebp+var_4]
		cmp	dword ptr [ecx+18h], 10h
		jb	short loc_194F
		mov	edx, [ebp+var_4]
		mov	eax, [edx+4]
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_4]
		add	ecx, 4
		push	ecx
		lea	edx, [ebp+var_C+3]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
		cmp	[ebp+Size], 0
		jbe	short loc_192E
		mov	eax, [ebp+Size]
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		push	ecx
		call	??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
		add	esp, 4
		push	eax		; Src
		mov	edx, [ebp+var_4]
		add	edx, 4
		push	edx		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch

loc_192E:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+58j
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+18h]
		add	ecx, 1
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; void *
		lea	eax, [ebp+var_C+2]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)

loc_194F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+26j
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+2Fj
		mov	ecx, [ebp+var_4]
		mov	dword ptr [ecx+18h], 0Fh
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1978h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
		public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+2Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
		call	dword ptr ds:__imp_?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 19ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
		public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc	near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+27p
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+1Cp	...

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		push	offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
		call	dword ptr ds:__imp_?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 19E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
		public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+D0p
					; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+26p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A0Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
		public ?allocate@?$allocator@D@std@@QAEPADI@Z
?allocate@?$allocator@D@std@@QAEPADI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+15p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@D@std@@YAPADIPAD@Z	; std::_Allocate<char>(uint,char *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@D@std@@QAEPADI@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A38h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
		public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	proc near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+2Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
		add	esp, 8
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A64h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>> const &, unsigned int, unsigned int)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+56p

Size		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+Size], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		cmp	eax, [ebp+arg_4]
		jnb	short loc_1A90
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_1A90:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+22j
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		sub	eax, [ebp+arg_4]
		mov	[ebp+Size], eax
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+Size]
		jnb	short loc_1AAC
		mov	ecx, [ebp+arg_8]
		mov	[ebp+Size], ecx

loc_1AAC:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
		mov	edx, [ebp+var_4]
		cmp	edx, [ebp+arg_0]
		jnz	short loc_1AD3
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		mov	ecx, [ebp+var_4]
		call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
		jmp	short loc_1B15
; ---------------------------------------------------------------------------

loc_1AD3:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Ej
		push	0
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	eax, al
		test	eax, eax
		jz	short loc_1B15
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	ecx, [ebp+arg_0]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_4]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	edx, [ebp+Size]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_1B15:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+82j
		mov	eax, [ebp+var_4]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B28h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+61p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		push	490h		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Str]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	?length@?$char_traits@D@std@@SAIPBD@Z ;	std::char_traits<char>::length(char const *)
		add	esp, 4
		push	eax		; Size
		mov	edx, [ebp+Str]
		push	edx		; Src
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char	const *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B78h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
		public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+38p

var_4		= dword	ptr -4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		cmp	[ebp+Size], 0
		jz	short loc_1BA2
		push	47Fh		; unsigned int
		push	offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
		mov	eax, [ebp+Src]
		push	eax		; int
		call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char	const *,wchar_t	const *,uint)
		add	esp, 0Ch

loc_1BA2:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12j
		mov	ecx, [ebp+Src]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
		movzx	edx, al
		test	edx, edx
		jz	short loc_1BD5
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		mov	ecx, [ebp+Src]
		sub	ecx, eax
		push	ecx
		mov	edx, [ebp+var_4]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
		jmp	short loc_1C12
; ---------------------------------------------------------------------------

loc_1BD5:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+3Bj
		push	0
		mov	eax, [ebp+Size]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
		movzx	ecx, al
		test	ecx, ecx
		jz	short loc_1C0F
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+Src]
		push	eax		; Src
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		push	eax		; Dst
		call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+Size]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_1C0F:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+70j
		mov	eax, [ebp+var_4]

loc_1C12:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Bj
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static void __cdecl std::char_traits<char>::assign(char &, char const	&)
		public ?assign@?$char_traits@D@std@@SAXAADABD@Z
?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+34p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	dl, [ecx]
		mov	[eax], dl
		pop	ebp
		retn
?assign@?$char_traits@D@std@@SAXAADABD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C34h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
		public ?category@error_code@std@@QBEABVerror_category@2@XZ
?category@error_code@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Ap

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_code@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
		public ?category@error_condition@std@@QBEABVerror_category@2@XZ
?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Bp
					; std::error_condition::operator==(std::error_condition	const &)+24p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?category@error_condition@std@@QBEABVerror_category@2@XZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C64h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::copy(void	*Dst, void *Src, size_t	Size)
		public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+72p ...

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_1C7D
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_1C94
; ---------------------------------------------------------------------------

loc_1C7D:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+Fj
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[ebp+var_4], eax

loc_1C94:				; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+17j
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1CA8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::_Wrap_alloc<std::allocator<char>>::deallocate(void	*, int)
		public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+96p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_4]
		call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1CD8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<char>::deallocate(void *, int)
		public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+19p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D04h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	std::allocator<std::_Container_proxy>::deallocate(void *, int)
		public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc	near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+4Ep

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::_System_error_category::default_error_condition(int)const
		public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00002614o

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jz	short loc_1D72
		call	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category(void)
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		jmp	short loc_1D87
; ---------------------------------------------------------------------------
		jmp	short loc_1D87
; ---------------------------------------------------------------------------

loc_1D72:				; CODE XREF: std::_System_error_category::default_error_condition(int)+27j
		call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
		push	eax		; struct std::error_category *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]

loc_1D87:				; CODE XREF: std::_System_error_category::default_error_condition(int)+3Ej
					; std::_System_error_category::default_error_condition(int)+40j
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::error_condition __thiscall	std::error_category::default_error_condition(int)const
		public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
					; DATA XREF: .rdata:00002584o
					; .rdata:000025A0o ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax		; struct std::error_category *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
		mov	eax, [ebp+arg_0]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DCCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
		public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
					; DATA XREF: .rdata:00002588o
					; .rdata:000025A4o ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
		push	eax
		mov	ecx, [ebp+var_4]
		call	??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
		movzx	eax, al
		test	eax, eax
		jz	short loc_1E11
		mov	ecx, [ebp+arg_0] ; this
		call	?value@error_code@std@@QBEHXZ ;	std::error_code::value(void)
		cmp	eax, [ebp+arg_4]
		jnz	short loc_1E11
		mov	[ebp+var_8], 1
		jmp	short loc_1E18
; ---------------------------------------------------------------------------

loc_1E11:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+2Dj
					; std::error_category::equivalent(std::error_code const	&,int)+3Aj
		mov	[ebp+var_8], 0

loc_1E18:				; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+43j
		mov	al, byte ptr [ebp+var_8]
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E2Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const	struct std::error_condition *)
		public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
					; DATA XREF: .rdata:0000258Co
					; .rdata:000025A8o ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		push	esi
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; std::error_condition *
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		push	ecx
		lea	edx, [ebp+var_C]
		push	edx
		mov	eax, [ebp+var_4]
		mov	edx, [eax]
		mov	ecx, [ebp+var_4]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, eax
		call	??8error_condition@std@@QBE_NABV01@@Z ;	std::error_condition::operator==(std::error_condition const &)
		pop	esi
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E88h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_1EA9
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_1EA9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+17j
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EC8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> & __thiscall	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int,	unsigned int)
		public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+68p

var_C		= dword	ptr -0Ch
Dst		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	[ebp+var_C], 0CCCCCCCCh
		mov	[ebp+Dst], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	ecx, [eax+14h]
		cmp	ecx, [ebp+arg_0]
		jnb	short loc_1EF9
		mov	ecx, [ebp+var_4]
		call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)

loc_1EF9:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+27j
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		ja	short loc_1F15
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
		jmp	short loc_1F5B
; ---------------------------------------------------------------------------

loc_1F15:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Dj
		cmp	[ebp+arg_4], 0
		jbe	short loc_1F5B
		mov	ecx, [ebp+var_4]
		call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
		add	eax, [ebp+arg_0]
		mov	[ebp+Dst], eax
		mov	edx, [ebp+var_4]
		mov	eax, [edx+14h]
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_C], eax
		mov	ecx, [ebp+var_C]
		sub	ecx, [ebp+arg_0]
		push	ecx		; Size
		mov	edx, [ebp+Dst]
		add	edx, [ebp+arg_4]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
		add	esp, 0Ch
		mov	ecx, [ebp+var_C]
		push	ecx
		mov	ecx, [ebp+var_4]
		call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)

loc_1F5B:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+4Bj
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+51j
		mov	eax, [ebp+var_4]
		add	esp, 0Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::generic_category()
		public ?generic_category@std@@YAABVerror_category@1@XZ
?generic_category@std@@YAABVerror_category@1@XZ	proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+29p
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
		pop	ebp
		retn
?generic_category@std@@YAABVerror_category@1@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F7Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: bool __thiscall mozilla::CheckedInt<int>::isValid(void)const
		public ?isValid@?$CheckedInt@H@mozilla@@QBE_NXZ
?isValid@?$CheckedInt@H@mozilla@@QBE_NXZ proc near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+62p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	al, [eax+4]
		mov	esp, ebp
		pop	ebp
		retn
?isValid@?$CheckedInt@H@mozilla@@QBE_NXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F94h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::length(char *Str)
		public ?length@?$char_traits@D@std@@SAIPBD@Z
?length@?$char_traits@D@std@@SAIPBD@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+28p

var_4		= dword	ptr -4
Str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+Str]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jnz	short loc_1FB2
		mov	[ebp+var_4], 0
		jmp	short loc_1FC1
; ---------------------------------------------------------------------------

loc_1FB2:				; CODE XREF: std::char_traits<char>::length(char const *)+13j
		mov	edx, [ebp+Str]
		push	edx		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+var_4], eax

loc_1FC1:				; CODE XREF: std::char_traits<char>::length(char const *)+1Cj
		mov	eax, [ebp+var_4]
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@?$char_traits@D@std@@SAIPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1FD4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
		public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+28p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		push	eax
		call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
		add	esp, 4
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1FFCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
		public ?max_size@?$allocator@D@std@@QBEIXZ
?max_size@?$allocator@D@std@@QBEIXZ proc near
					; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char>	const &)+6p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		or	eax, 0FFFFFFFFh
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$allocator@D@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2014h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class	std::allocator<char> const &)
		public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	proc near
					; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+12p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+arg_0]
		call	?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2028h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
		public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Cp
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+83p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, 0CCCCCCCCh
		mov	[ebp+var_10], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		lea	eax, [ebp+var_C+3]
		push	eax
		mov	ecx, [ebp+var_4]
		call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
		mov	ecx, eax
		call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 1
		ja	short loc_2067
		mov	[ebp+var_10], 1
		jmp	short loc_2070
; ---------------------------------------------------------------------------

loc_2067:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+34j
		mov	ecx, [ebp+var_8]
		sub	ecx, 1
		mov	[ebp+var_10], ecx

loc_2070:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+3Dj
		mov	eax, [ebp+var_10]
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2084h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
		public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; CODE XREF: std::_Iostream_error_category::message(int)+4Cp
					; DATA XREF: .rdata:0000259Co

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Syserror_map@std@@YAPBDH@Z	; std::_Syserror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_20CD
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_20D4
; ---------------------------------------------------------------------------

loc_20CD:				; CODE XREF: std::_Generic_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_20D4:				; CODE XREF: std::_Generic_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2100h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
		public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc	near
					; DATA XREF: .rdata:000025D0o

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	[ebp+var_8], 0
		cmp	[ebp+arg_4], 1
		jnz	short loc_2141
		push	offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		jmp	short loc_215D
; ---------------------------------------------------------------------------
		jmp	short loc_215D
; ---------------------------------------------------------------------------

loc_2141:				; CODE XREF: std::_Iostream_error_category::message(int)+22j
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_4]
		call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		mov	eax, [ebp+var_8]
		or	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]

loc_215D:				; CODE XREF: std::_Iostream_error_category::message(int)+3Dj
					; std::_Iostream_error_category::message(int)+3Fj
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2170h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual class	std::basic_string<char,	struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
		public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
					; DATA XREF: .rdata:00002610o

Str		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	esi
		mov	eax, 0CCCCCCCCh
		mov	[ebp+Str], eax
		mov	[ebp+var_C], eax
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], eax
		mov	[ebp+var_4], ecx
		mov	[ebp+var_C], 0
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	dword ptr ds:__imp_?_Winerror_map@std@@YAPBDH@Z	; std::_Winerror_map(int)
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jz	short loc_21B9
		mov	ecx, [ebp+var_8]
		mov	[ebp+Str], ecx
		jmp	short loc_21C0
; ---------------------------------------------------------------------------

loc_21B9:				; CODE XREF: std::_System_error_category::message(int)+3Fj
		mov	[ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@	; "unknown error"

loc_21C0:				; CODE XREF: std::_System_error_category::message(int)+47j
		mov	edx, [ebp+Str]
		push	edx		; Str
		mov	ecx, [ebp+arg_0]
		call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
		mov	eax, [ebp+var_C]
		or	eax, 1
		mov	[ebp+var_C], eax
		mov	eax, [ebp+arg_0]
		pop	esi
		add	esp, 10h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl std::char_traits<char>::move(void	*Dst, void *Src, size_t	Size)
		public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+7Fp

var_4		= dword	ptr -4
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ecx
		push	esi
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+Size], 0
		jnz	short loc_2206
		mov	eax, [ebp+Dst]
		mov	[ebp+var_4], eax
		jmp	short loc_2227
; ---------------------------------------------------------------------------

loc_2206:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
		mov	esi, esp
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_4], eax

loc_2227:				; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+18j
		mov	eax, [ebp+var_4]
		pop	esi
		add	esp, 4
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 223Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
		public ?name@_Generic_error_category@std@@UBEPBDXZ
?name@_Generic_error_category@std@@UBEPBDXZ proc near ;	DATA XREF: .rdata:00002598o

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Generic_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2254h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
		public ?name@_Iostream_error_category@std@@UBEPBDXZ
?name@_Iostream_error_category@std@@UBEPBDXZ proc near ; DATA XREF: .rdata:000025CCo

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
		mov	esp, ebp
		pop	ebp
		retn
?name@_Iostream_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 226Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
		public ?name@_System_error_category@std@@UBEPBDXZ
?name@_System_error_category@std@@UBEPBDXZ proc	near ; DATA XREF: .rdata:0000260Co

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
		mov	esp, ebp
		pop	ebp
		retn
?name@_System_error_category@std@@UBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2284h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class mozilla::CheckedInt<int>	__cdecl	mozilla::detail::CastToCheckedIntImpl<int, int>::run(int)
		public ?run@?$CastToCheckedIntImpl@HH@detail@mozilla@@SA?AV?$CheckedInt@H@3@H@Z
?run@?$CastToCheckedIntImpl@HH@detail@mozilla@@SA?AV?$CheckedInt@H@3@H@Z proc near
					; CODE XREF: mozilla::castToCheckedInt<int,int>(int)+Bp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$?0H@?$CheckedInt@H@mozilla@@QAE@H@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(int)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?run@?$CastToCheckedIntImpl@HH@detail@mozilla@@SA?AV?$CheckedInt@H@3@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static class mozilla::CheckedInt<int>	__cdecl	mozilla::detail::CastToCheckedIntImpl<int, unsigned int>::run(unsigned int)
		public ?run@?$CastToCheckedIntImpl@HI@detail@mozilla@@SA?AV?$CheckedInt@H@3@I@Z
?run@?$CastToCheckedIntImpl@HI@detail@mozilla@@SA?AV?$CheckedInt@H@3@I@Z proc near
					; CODE XREF: mozilla::castToCheckedInt<int,uint>(uint)+Bp

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??$?0I@?$CheckedInt@H@mozilla@@QAE@I@Z ; mozilla::CheckedInt<int>::CheckedInt<int>(uint)
		mov	eax, [ebp+arg_0]
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
?run@?$CastToCheckedIntImpl@HI@detail@mozilla@@SA?AV?$CheckedInt@H@3@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22BCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl mozilla::detail::IsInRangeImpl<int, int, 1, 1, 1>::run(int)
		public ?run@?$IsInRangeImpl@HH$00$00$00@detail@mozilla@@SA_NH@Z
?run@?$IsInRangeImpl@HH$00$00$00@detail@mozilla@@SA_NH@Z proc near
					; CODE XREF: mozilla::detail::IsInRange<int,int>(int)+7p
		push	ebp
		mov	ebp, esp
		mov	al, 1
		pop	ebp
		retn
?run@?$IsInRangeImpl@HH$00$00$00@detail@mozilla@@SA_NH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl mozilla::detail::IsInRangeImpl<int, unsigned int,	1, 0, 0>::run(unsigned int)
		public ?run@?$IsInRangeImpl@HI$00$0A@$0A@@detail@mozilla@@SA_NI@Z
?run@?$IsInRangeImpl@HI$00$0A@$0A@@detail@mozilla@@SA_NI@Z proc	near
					; CODE XREF: mozilla::detail::IsInRange<int,uint>(uint)+7p

var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		xor	eax, eax
		jnz	short loc_22E5
		cmp	[ebp+arg_0], 7FFFFFFFh
		jbe	short loc_22E5
		mov	[ebp+var_4], 0
		jmp	short loc_22EC
; ---------------------------------------------------------------------------

loc_22E5:				; CODE XREF: mozilla::detail::IsInRangeImpl<int,uint,1,0,0>::run(uint)+Dj
					; mozilla::detail::IsInRangeImpl<int,uint,1,0,0>::run(uint)+16j
		mov	[ebp+var_4], 1

loc_22EC:				; CODE XREF: mozilla::detail::IsInRangeImpl<int,uint,1,0,0>::run(uint)+1Fj
		mov	al, byte ptr [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
?run@?$IsInRangeImpl@HI$00$0A@$0A@@detail@mozilla@@SA_NI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl mozilla::detail::IsInRangeImpl<int, __int64, 1, 1, 0>::run(__int64)
		public ?run@?$IsInRangeImpl@H_J$00$00$0A@@detail@mozilla@@SA_N_J@Z
?run@?$IsInRangeImpl@H_J$00$00$0A@@detail@mozilla@@SA_N_J@Z proc near
					; CODE XREF: mozilla::detail::IsInRange<int,__int64>(__int64)+Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		cmp	[ebp+arg_4], 0
		jg	short loc_232A
		jl	short loc_2310
		cmp	[ebp+arg_0], 7FFFFFFFh
		ja	short loc_232A

loc_2310:				; CODE XREF: mozilla::detail::IsInRangeImpl<int,__int64,1,1,0>::run(__int64)+11j
		cmp	[ebp+arg_4], 0FFFFFFFFh
		jl	short loc_232A
		jg	short loc_2321
		cmp	[ebp+arg_0], 80000000h
		jb	short loc_232A

loc_2321:				; CODE XREF: mozilla::detail::IsInRangeImpl<int,__int64,1,1,0>::run(__int64)+22j
		mov	[ebp+var_4], 1
		jmp	short loc_2331
; ---------------------------------------------------------------------------

loc_232A:				; CODE XREF: mozilla::detail::IsInRangeImpl<int,__int64,1,1,0>::run(__int64)+Fj
					; mozilla::detail::IsInRangeImpl<int,__int64,1,1,0>::run(__int64)+1Aj ...
		mov	[ebp+var_4], 0

loc_2331:				; CODE XREF: mozilla::detail::IsInRangeImpl<int,__int64,1,1,0>::run(__int64)+34j
		mov	al, byte ptr [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
?run@?$IsInRangeImpl@H_J$00$00$0A@@detail@mozilla@@SA_N_J@Z endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2338h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static bool __cdecl mozilla::detail::IsMulValidImpl<int, 1, 1>::run(int, int)
		public ?run@?$IsMulValidImpl@H$00$00@detail@mozilla@@SA_NHH@Z
?run@?$IsMulValidImpl@H$00$00@detail@mozilla@@SA_NHH@Z proc near
					; CODE XREF: mozilla::detail::IsMulValid<int>(int,int)+Bp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	esi
		mov	[ebp+var_8], 0CCCCCCCCh
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	eax, [ebp+arg_0]
		cdq
		mov	ecx, eax
		mov	esi, edx
		mov	eax, [ebp+arg_4]
		cdq
		push	edx
		push	eax
		push	esi
		push	ecx
		call	__allmul
		mov	[ebp+var_8], eax
		mov	[ebp+var_4], edx
		mov	edx, [ebp+var_4]
		push	edx
		mov	eax, [ebp+var_8]
		push	eax
		call	??$IsInRange@H_J@detail@mozilla@@YA_N_J@Z ; mozilla::detail::IsInRange<int,__int64>(__int64)
		add	esp, 8
		pop	esi
		add	esp, 8
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?run@?$IsMulValidImpl@H$00$00@detail@mozilla@@SA_NHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2388h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+1Ap
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&,uint,uint)+2Fp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax+14h]
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct std::error_category *__cdecl std::system_category()
		public ?system_category@std@@YAABVerror_category@1@XZ
?system_category@std@@YAABVerror_category@1@XZ proc near
					; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1D72p
		push	ebp
		mov	ebp, esp
		mov	eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
		pop	ebp
		retn
?system_category@std@@YAABVerror_category@1@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23ACh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall mozilla::CheckedInt<int>::value(void)const
		public ?value@?$CheckedInt@H@mozilla@@QBEHXZ
?value@?$CheckedInt@H@mozilla@@QBEHXZ proc near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+9Bp
					; mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+C0p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx

loc_23BA:				; CODE XREF: mozilla::CheckedInt<int>::value(void)+10j
		xor	eax, eax
		jnz	short loc_23BA
		mov	ecx, [ebp+var_4]
		mov	eax, [ecx]
		mov	esp, ebp
		pop	ebp
		retn
?value@?$CheckedInt@H@mozilla@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_code::value(std::error_code	*__hidden this)
		public ?value@error_code@std@@QBEHXZ
?value@error_code@std@@QBEHXZ proc near	; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+32p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_code@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
		public ?value@error_condition@std@@QBEHXZ
?value@error_condition@std@@QBEHXZ proc	near
					; CODE XREF: std::error_condition::operator==(std::error_condition const &)+3Ap
					; std::error_condition::operator==(std::error_condition	const &)+44p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ecx
		mov	[ebp+var_4], 0CCCCCCCCh
		mov	[ebp+var_4], ecx
		mov	eax, [ebp+var_4]
		mov	eax, [eax]
		mov	esp, ebp
		pop	ebp
		retn
?value@error_condition@std@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23F8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _hypot
_hypot		proc near

var_14		= qword	ptr -14h
var_C		= qword	ptr -0Ch
arg_0		= qword	ptr  8
arg_8		= qword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, esp
		sub	esp, 8
		movsd	xmm0, [ebp+arg_8]
		movsd	[esp+0Ch+var_C], xmm0
		sub	esp, 8
		movsd	xmm0, [ebp+arg_0]
		movsd	[esp+14h+var_14], xmm0
		call	dword ptr ds:__imp___hypot
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	esi
		cmp	ebp, esp
		call	__RTC_CheckEsp
		pop	ebp
		retn
_hypot		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2434h
; COMDAT (pick associative to section at A48)
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002444o
		dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
		dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2460h
; COMDAT (pick associative to section at B78)
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002470o
		dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
		dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 248Ch
; COMDAT (pick associative to section at 13D0)
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 dd offset ?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z
					; DATA XREF: .xdata$x:00002514o
					; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		dd 2 dup(0)
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 dd offset ?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z
					; DATA XREF: .xdata$x:00002500o
					; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		dd 2 dup(0)
		dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 0FFFFFFFFh, 0
					; DATA XREF: .xdata$x:000024D4o
		dd 0FFFFFFFFh, 0
		dd 1, 0
		dd 1, 0
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd 19930522h,	4
					; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
		dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 2
		dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
		dd 3 dup(0)
		dd 1
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z dd	2 dup(2), 3, 1
					; DATA XREF: .xdata$x:000024DCo
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
		dd 2 dup(0)
		dd 3, 1
		dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2518h
; COMDAT (pick associative to section at 8F4)
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00002528o
		dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
		dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 2544h
; COMDAT (pick associative to section at 7FC)
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00002554o
		dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
		dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 2570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_allocator_arg	db ?
_piecewise_construct db	?
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2574h
; COMDAT (pick largest)
		dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
		public ??_7error_category@std@@6B@
; const	std::error_category::`vftable'
??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
					; DATA XREF: std::error_category::error_category(void)+11o
					; std::error_category::~error_category(void)+11o
					; std::error_category::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2590h
; COMDAT (pick largest)
		dd offset ??_R4_Generic_error_category@std@@6B@	; const	std::_Generic_error_category::`RTTI Complete Object Locator'
		public ??_7_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`vftable'
??_7_Generic_error_category@std@@6B@ dd	offset ??_E_Generic_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+19o
					; std::_Generic_error_category::`vector	deleting destructor'(uint)
		dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ;	std::_Generic_error_category::name(void)
		dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 25ACh
; COMDAT (pick any)
		public ??_C@_07DCLBNMLN@generic?$AA@
; `string'
??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
					; DATA XREF: std::_Generic_error_category::name(void)+Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 25B4h
; COMDAT (pick any)
		public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
; `string'
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
					; DATA XREF: std::_Generic_error_category::message(int):loc_20CDo
					; std::_System_error_category::message(int):loc_21B9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 25C4h
; COMDAT (pick largest)
		dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
		public ??_7_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`vftable'
??_7_Iostream_error_category@std@@6B@ dd offset	??_E_Iostream_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+19o
					; std::_Iostream_error_category::`vector deleting destructor'(uint)
		dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
		dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
		dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 25E0h
; COMDAT (pick any)
		public ??_C@_08LLGCOLLL@iostream?$AA@
; `string'
??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
					; DATA XREF: std::_Iostream_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 25ECh
; COMDAT (pick any)
		public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; char `string'[]
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	db 'iostream stream error',0
					; DATA XREF: std::_Iostream_error_category::message(int)+24o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2604h
; COMDAT (pick largest)
		dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
		public ??_7_System_error_category@std@@6B@
; const	std::_System_error_category::`vftable'
??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
					; DATA XREF: std::_System_error_category::_System_error_category(void)+19o
					; std::_System_error_category::`vector deleting	destructor'(uint)
		dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
		dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
		dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
		dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
		dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z	; std::error_category::equivalent(int,std::error_condition const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2620h
; COMDAT (pick any)
		public ??_C@_06FHFOAHML@system?$AA@
; `string'
??_C@_06FHFOAHML@system?$AA@ db	'system',0
					; DATA XREF: std::_System_error_category::name(void)+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 2628h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 262Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
; std::_Iostream_error_category	std::_Error_objects<int>::_Iostream_object
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
					; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 2630h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
; std::_System_error_category std::_Error_objects<int>::_System_object
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A dd	?
					; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
					; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 2634h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 2638h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A dd ?
					; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+8o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 263Ch
; COMDAT (pick any)
		public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
; wchar_t `string'
??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+13o
					; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+19o
		unicode	0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
		unicode	0, <clude\xstring>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26CCh
; COMDAT (pick any)
		public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
; char `string'[]
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26DCh
; COMDAT (pick any)
		public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
; char `string'[]
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+11o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26F4h
; COMDAT (pick any)
		public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; wchar_t `string'
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+14o
		unicode	0, <invalid null pointer>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2720h
; COMDAT (pick any)
		public ??_R4error_category@std@@6B@
; const	std::error_category::`RTTI Complete Object Locator'
??_R4error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00002574o
		dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 2734h
; COMDAT (pick any)
		public ??_R0?AVerror_category@std@@@8
; class	std::error_category `RTTI Type Descriptor'
??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:0000272Co
					; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?averror_cate	db '.?AVerror_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2758h
; COMDAT (pick any)
		public ??_R3error_category@std@@8
; std::error_category::`RTTI Class Hierarchy Descriptor'
??_R3error_category@std@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00002730o
					; .rdata$r:00002788o
		dd 1
		dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2768h
; COMDAT (pick any)
		public ??_R2error_category@std@@8
; std::error_category::`RTTI Base Class	Array'
??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
					; DATA XREF: .rdata$r:00002764o
					; std::error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2770h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@error_category@std@@8
; std::error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
					; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
					; .rdata$r:000027E0o ...
					; std::error_category `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 278Ch
; COMDAT (pick any)
		public ??_R4_Generic_error_category@std@@6B@
; const	std::_Generic_error_category::`RTTI Complete Object Locator'
??_R4_Generic_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF: .rdata:00002590o
		dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 27A0h
; COMDAT (pick any)
		public ??_R0?AV_Generic_error_category@std@@@8
; class	std::_Generic_error_category `RTTI Type	Descriptor'
??_R0?AV_Generic_error_category@std@@@8	dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00002798o
					; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?av_generic_e	db '.?AV_Generic_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 27CCh
; COMDAT (pick any)
		public ??_R3_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Generic_error_category@std@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000279Co
					; .rdata$r:00002800o
		dd 2
		dd offset ??_R2_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 27DCh
; COMDAT (pick any)
		public ??_R2_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Array'
??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
					; DATA XREF: .rdata$r:000027D8o
					; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 27E8h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Generic_error_category@std@@8
; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_Generic_error_category@std@@8 dd	offset ??_R0?AV_Generic_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
					; .rdata$r:00002858o ...
					; std::_Generic_error_category `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		dd offset ??_R3_Generic_error_category@std@@8 ;	std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2804h
; COMDAT (pick any)
		public ??_R4_Iostream_error_category@std@@6B@
; const	std::_Iostream_error_category::`RTTI Complete Object Locator'
??_R4_Iostream_error_category@std@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000025C4o
		dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 2818h
; COMDAT (pick any)
		public ??_R0?AV_Iostream_error_category@std@@@8
; class	std::_Iostream_error_category `RTTI Type Descriptor'
??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00002810o
					; .rdata$r:std::_Iostream_error_category::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?av_iostream_	db '.?AV_Iostream_error_category@std@@',0
		align 4
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2844h
; COMDAT (pick any)
		public ??_R3_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_Iostream_error_category@std@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00002814o
					; .rdata$r:0000287Co
		dd 3
		dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2854h
; COMDAT (pick any)
		public ??_R2_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Array'
??_R2_Iostream_error_category@std@@8 dd	offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
					; DATA XREF: .rdata$r:00002850o
					; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2864h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
; std::_Iostream_error_category::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset	??_R0?AV_Iostream_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base	Class Array'o
					; std::_Iostream_error_category	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2880h
; COMDAT (pick any)
		public ??_R4_System_error_category@std@@6B@
; const	std::_System_error_category::`RTTI Complete Object Locator'
??_R4_System_error_category@std@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00002604o
		dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data$r		segment	dword public 'DATA' use32
		assume cs:_data$r
		;org 2894h
; COMDAT (pick any)
		public ??_R0?AV_System_error_category@std@@@8
; class	std::_System_error_category `RTTI Type Descriptor'
??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000288Co
					; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?av_system_er	db '.?AV_System_error_category@std@@',0
		align 10h
_data$r		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 28C0h
; COMDAT (pick any)
		public ??_R3_System_error_category@std@@8
; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
??_R3_System_error_category@std@@8 dd 2	dup(0) ; DATA XREF: .rdata$r:00002890o
					; .rdata$r:000028F8o
		dd 3
		dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 28D0h
; COMDAT (pick any)
		public ??_R2_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Array'
??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
					; DATA XREF: .rdata$r:000028CCo
					; std::_System_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@error_category@std@@8 ;	std::error_category::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 28E0h
; COMDAT (pick any)
		public ??_R1A@?0A@EA@_System_error_category@std@@8
; std::_System_error_category::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
					; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
					; std::_System_error_category `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?BytesPerPixel@gfx@mozilla@@YAHW4SurfaceFormat@12@@Z ; mozilla::gfx::BytesPerPixel(mozilla::gfx::SurfaceFormat)
		dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 28FCh
; COMDAT (pick any)
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 2900h
; COMDAT (pick any)
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 2904h
_piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ	; std::`dynamic	initializer for	'piecewise_construct''(void)
_allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer	for 'allocator_arg''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 290Ch
; COMDAT (pick associative to section at 2628)
; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 2910h
; COMDAT (pick associative to section at 262C)
; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA	dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 2914h
; COMDAT (pick associative to section at 2630)
; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset	??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer	for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 2918h
; COMDAT (pick associative to section at 2634)
; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct	std::char_traits<char>,	class std::allocator<char>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 291Ch
; COMDAT (pick associative to section at 2638)
; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __purecall:near	; DATA XREF: .rdata:0000257Co
					; .rdata:00002580o
; void *__cdecl	operator new(unsigned int)
		extrn ??2@YAPAXI@Z:near	; CODE XREF: std::_Allocate<char>(uint,char *)+25p
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+2Bp
; void __cdecl operator	delete(void *)
		extrn ??3@YAXPAX@Z:near	; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+22p
					; std::_Iostream_error_category::`scalar deleting destructor'(uint)+22p ...
; int __cdecl atexit(void (__cdecl *)())
		extrn _atexit:near	; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
					; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
; void *__cdecl	_calloc(size_t NumOfElements, size_t SizeOfElements)
		extrn __imp__calloc:near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+A5p
					; DATA XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+A5r
; void __cdecl _free(void *Memory)
		extrn __imp__free:near	; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Dealloc(void)+18p
					; mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+25p
					; DATA XREF: ...
; void *__cdecl	_malloc(size_t Size)
		extrn __imp__malloc:near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+C8p
					; DATA XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+C8r
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+28p
					; DATA XREF: std::char_traits<char>::move(char *,char const *,uint)+28r
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: mozilla::gfx::SourceSurfaceRawData::GuaranteePersistance(void)+6Fp
					; std::char_traits<char>::copy(char *,char const *,uint)+25p
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: std::char_traits<char>::length(char const *)+22p
		extrn __imp___hypot:near ; CODE	XREF: _hypot+20p
					; DATA XREF: _hypot+20r
; void *__cdecl	operator new[](unsigned	int)
		extrn ??_U@YAPAXI@Z:near
					; CODE XREF: mozilla::gfx::SourceSurfaceRawData::GuaranteePersistance(void)+42p
; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
		extrn __imp_?_Debug_message@std@@YAXPB_W0I@Z:near
					; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+19p
					; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+19r
; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
		extrn __imp_??0_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14p
					; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+14r
; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden	this)
		extrn __imp_??1_Container_base12@std@@QAE@XZ:near
					; CODE XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14p
					; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+14r
; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
		extrn __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:near
					; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28p
					; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+28r
; void __cdecl std::_Xbad_alloc()
		extrn __imp_?_Xbad_alloc@std@@YAXXZ:near
					; CODE XREF: std::_Allocate<char>(uint,char *)+38p
					; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+3Ep
					; DATA XREF: ...
; void __cdecl std::_Xlength_error(const char *)
		extrn __imp_?_Xlength_error@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+16r
; void __cdecl std::_Xout_of_range(const char *)
		extrn __imp_?_Xout_of_range@std@@YAXPBD@Z:near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16p
					; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+16r
; _DWORD __thiscall std::locale::id::id(std::locale::id	*__hidden this,	unsigned int)
		extrn __imp_??0id@locale@std@@QAE@I@Z:near
					; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Dp
					; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Dp
					; DATA XREF: ...
; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
		extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::error_category::`vftable'o
; const	char *__cdecl std::_Syserror_map(int)
		extrn __imp_?_Syserror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::default_error_condition(int)+15p
					; std::_Generic_error_category::message(int)+28p
					; DATA XREF: ...
; const	char *__cdecl std::_Winerror_map(int)
		extrn __imp_?_Winerror_map@std@@YAPBDH@Z:near
					; CODE XREF: std::_System_error_category::message(int)+28p
					; DATA XREF: std::_System_error_category::message(int)+28r
; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ;	weak
					; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
		extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
					; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
; unsigned int __cdecl mozilla::gfx::BufferSizeFromStrideAndHeight(mozilla::gfx	*__hidden this,	int, int, int)
		extrn ?BufferSizeFromStrideAndHeight@gfx@mozilla@@YAIHHH@Z:near
					; CODE XREF: mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+59p
					; mozilla::gfx::SourceSurfaceAlignedRawData::InitWithStride(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,int,bool)+40p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: mozilla::gfx::AlignedArray<uchar,16>::Realloc(uint,bool)+175p
					; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+62p ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
					; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
; __stdcall _CxxThrowException(x, x)
		extrn __CxxThrowException@8:near
					; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
		extrn __RTC_CheckEsp:near
					; CODE XREF: mozilla::gfx::SourceSurfaceRawData::GuaranteePersistance(void)+83p
					; mozilla::gfx::SourceSurfaceAlignedRawData::Init(mozilla::gfx::IntSizeTyped<mozilla::gfx::UnknownUnits> const &,mozilla::gfx::SurfaceFormat,bool)+D2p	...
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
					; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
		extrn __allmul:near	; CODE XREF: mozilla::detail::IsMulValidImpl<int,1,1>::run(int,int)+25p
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
					; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
		extrn ___security_cookie:near
					; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+25r
					; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+25r ...
		extrn __fltused:near


		end
