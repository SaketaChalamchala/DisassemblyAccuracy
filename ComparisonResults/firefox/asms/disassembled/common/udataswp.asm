;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	9A492EE63ADE988F80C143CE9ACDB0E5
; Input	CRC32 :	494BE916

; File Name   :	D:\compspace\objfiles\firefox\common\udataswp.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"
;
; Exported entry
;

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_readInt16_56
_udata_readInt16_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		movzx	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_readInt16_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 4Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 50h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_readInt32_56
_udata_readInt32_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_readInt32_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_swapInvStringBlock_56
_udata_swapInvStringBlock_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_CC
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_D3

loc_CC:					; CODE XREF: _udata_swapInvStringBlock_56+22j
		xor	eax, eax
		jmp	loc_1A3
; ---------------------------------------------------------------------------

loc_D3:					; CODE XREF: _udata_swapInvStringBlock_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_F1
		cmp	[ebp+arg_4], 0
		jz	short loc_F1
		cmp	[ebp+arg_8], 0
		jl	short loc_F1
		cmp	[ebp+arg_8], 0
		jle	short loc_101
		cmp	[ebp+arg_C], 0
		jnz	short loc_101

loc_F1:					; CODE XREF: _udata_swapInvStringBlock_56+37j
					; _udata_swapInvStringBlock_56+3Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_1A3
; ---------------------------------------------------------------------------

loc_101:				; CODE XREF: _udata_swapInvStringBlock_56+49j
					; _udata_swapInvStringBlock_56+4Fj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_14], eax

loc_10D:				; CODE XREF: _udata_swapInvStringBlock_56+8Aj
		cmp	[ebp+var_14], 0
		jle	short loc_12C
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax-1]
		test	ecx, ecx
		jz	short loc_12C
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_10D
; ---------------------------------------------------------------------------

loc_12C:				; CODE XREF: _udata_swapInvStringBlock_56+71j
					; _udata_swapInvStringBlock_56+7Fj
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+24h]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_C]
		jz	short loc_192
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_14]
		jle	short loc_192
		push	1
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+arg_8]
		sub	ecx, [ebp+var_14]
		push	ecx		; Size
		mov	edx, [ebp+var_8]
		add	edx, [ebp+var_14]
		push	edx		; Src
		mov	eax, [ebp+arg_C]
		add	eax, [ebp+var_14]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_192:				; CODE XREF: _udata_swapInvStringBlock_56+BAj
					; _udata_swapInvStringBlock_56+C2j
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jg	short loc_1A1
		mov	eax, [ebp+arg_8]
		jmp	short loc_1A3
; ---------------------------------------------------------------------------
		jmp	short loc_1A3
; ---------------------------------------------------------------------------

loc_1A1:				; CODE XREF: _udata_swapInvStringBlock_56+F8j
		xor	eax, eax

loc_1A3:				; CODE XREF: _udata_swapInvStringBlock_56+2Ej
					; _udata_swapInvStringBlock_56+5Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_swapInvStringBlock_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_printError_56
_udata_printError_56 proc near		; CODE XREF: _udata_swapDataHeader_56+A3p
					; _udata_swapDataHeader_56+141p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_20F
		lea	eax, [ebp+arg_8]
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+2Ch]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], 0

loc_20F:				; CODE XREF: _udata_printError_56+25j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_printError_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 224h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl udata_swapDataHeader_56(int, void	*Src, int, void	*Dst, int)
		public _udata_swapDataHeader_56
_udata_swapDataHeader_56 proc near

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= word ptr -20h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_250
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_257

loc_250:				; CODE XREF: _udata_swapDataHeader_56+22j
		xor	eax, eax
		jmp	loc_49D
; ---------------------------------------------------------------------------

loc_257:				; CODE XREF: _udata_swapDataHeader_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_275
		cmp	[ebp+Src], 0
		jz	short loc_275
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_275
		cmp	[ebp+arg_8], 0
		jle	short loc_285
		cmp	[ebp+Dst], 0
		jnz	short loc_285

loc_275:				; CODE XREF: _udata_swapDataHeader_56+37j
					; _udata_swapDataHeader_56+3Dj	...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_49D
; ---------------------------------------------------------------------------

loc_285:				; CODE XREF: _udata_swapDataHeader_56+49j
					; _udata_swapDataHeader_56+4Fj
		mov	eax, [ebp+Src]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_8], 0
		jl	short loc_297
		cmp	[ebp+arg_8], 18h
		jb	short loc_2BE

loc_297:				; CODE XREF: _udata_swapDataHeader_56+6Bj
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+2]
		cmp	ecx, 0DAh ; 'Ú'
		jnz	short loc_2BE
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+3]
		cmp	ecx, 27h ; '''
		jnz	short loc_2BE
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Ah]
		cmp	ecx, 2
		jz	short loc_2DF

loc_2BE:				; CODE XREF: _udata_swapDataHeader_56+71j
					; _udata_swapDataHeader_56+80j	...
		push	offset ??_C@_0EB@GINDMELE@udata_swapDataHeader?$CI?$CJ?3?5initial?5@ ; "udata_swapDataHeader():	initial	bytes d"...
		mov	eax, [ebp+arg_0]
		push	eax
		call	_udata_printError_56
		add	esp, 8
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_49D
; ---------------------------------------------------------------------------

loc_2DF:				; CODE XREF: _udata_swapDataHeader_56+98j
		mov	esi, esp
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], ax
		mov	esi, esp
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax+4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 18h
		jb	short loc_34E
		movzx	eax, [ebp+var_20]
		cmp	eax, 14h
		jb	short loc_34E
		movzx	eax, [ebp+var_14]
		movzx	ecx, [ebp+var_20]
		add	ecx, 4
		cmp	eax, ecx
		jb	short loc_34E
		cmp	[ebp+arg_8], 0
		jl	short loc_37D
		movzx	eax, [ebp+var_14]
		cmp	[ebp+arg_8], eax
		jge	short loc_37D

loc_34E:				; CODE XREF: _udata_swapDataHeader_56+101j
					; _udata_swapDataHeader_56+10Aj ...
		mov	eax, [ebp+arg_8]
		push	eax
		movzx	ecx, [ebp+var_20]
		push	ecx
		movzx	edx, [ebp+var_14]
		push	edx
		push	offset ??_C@_0FE@LPPODGNH@udata_swapDataHeader?$CI?$CJ?3?5header?5s@ ; "udata_swapDataHeader():	header size mis"...
		mov	eax, [ebp+arg_0]
		push	eax
		call	_udata_printError_56
		add	esp, 14h
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_49D
; ---------------------------------------------------------------------------

loc_37D:				; CODE XREF: _udata_swapDataHeader_56+11Fj
					; _udata_swapDataHeader_56+128j
		cmp	[ebp+arg_8], 0
		jle	loc_499
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+Dst]
		jz	short loc_3B2
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		movzx	ecx, [ebp+var_14]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_3B2:				; CODE XREF: _udata_swapDataHeader_56+169j
		mov	eax, [ebp+Dst]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+2]
		mov	[eax+8], dl
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+3]
		mov	[eax+9], dl
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		push	2
		mov	edx, [ebp+var_8]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_2C]
		add	ecx, 4
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		add	edx, 4
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	eax, [ebp+var_20]
		add	eax, 4
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_20]
		add	eax, [ebp+Src]
		mov	[ebp+var_38], eax
		movzx	eax, [ebp+var_14]
		movzx	ecx, [ebp+var_20]
		sub	eax, ecx
		mov	[ebp+var_44], eax
		mov	[ebp+arg_8], 0
		jmp	short loc_456
; ---------------------------------------------------------------------------

loc_44D:				; CODE XREF: _udata_swapDataHeader_56+247j
		mov	eax, [ebp+arg_8]
		add	eax, 1
		mov	[ebp+arg_8], eax

loc_456:				; CODE XREF: _udata_swapDataHeader_56+227j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_44]
		jge	short loc_46D
		mov	eax, [ebp+var_38]
		add	eax, [ebp+arg_8]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_46D
		jmp	short loc_44D
; ---------------------------------------------------------------------------

loc_46D:				; CODE XREF: _udata_swapDataHeader_56+238j
					; _udata_swapDataHeader_56+245j
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		movzx	ecx, [ebp+var_20]
		add	ecx, [ebp+Dst]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+24h]
		call	eax
		add	esp, 14h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_499:				; CODE XREF: _udata_swapDataHeader_56+15Dj
		movzx	eax, [ebp+var_14]

loc_49D:				; CODE XREF: _udata_swapDataHeader_56+2Ej
					; _udata_swapDataHeader_56+5Cj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_swapDataHeader_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4B4h
		public ??_C@_0FE@LPPODGNH@udata_swapDataHeader?$CI?$CJ?3?5header?5s@
; `string'
??_C@_0FE@LPPODGNH@udata_swapDataHeader?$CI?$CJ?3?5header?5s@ db 'udata_swapDataHeader(): header size mismatch - headerSize %d info'
					; DATA XREF: _udata_swapDataHeader_56+138o
		db 'Size %d length %d',0Ah,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 508h
		public ??_C@_0EB@GINDMELE@udata_swapDataHeader?$CI?$CJ?3?5initial?5@
; `string'
??_C@_0EB@GINDMELE@udata_swapDataHeader?$CI?$CJ?3?5initial?5@ db 'udata_swapDataHeader(): initial bytes do not look like ICU data',0Ah
					; DATA XREF: _udata_swapDataHeader_56:loc_2BEo
		db 0
		align 4
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_openSwapper_56
_udata_openSwapper_56 proc near		; CODE XREF: _udata_openSwapperForInputData_56+154p

var_D0		= dword	ptr -0D0h
Dst		= dword	ptr -8
arg_0		= byte ptr  8
arg_4		= byte ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_578
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_57F

loc_578:				; CODE XREF: _udata_openSwapper_56+22j
		xor	eax, eax
		jmp	loc_775
; ---------------------------------------------------------------------------

loc_57F:				; CODE XREF: _udata_openSwapper_56+2Aj
		movzx	eax, [ebp+arg_4]
		cmp	eax, 1
		jg	short loc_591
		movzx	eax, [ebp+arg_C]
		cmp	eax, 1
		jle	short loc_5A1

loc_591:				; CODE XREF: _udata_openSwapper_56+3Aj
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_775
; ---------------------------------------------------------------------------

loc_5A1:				; CODE XREF: _udata_openSwapper_56+43j
		push	30h ; '0'
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_5C4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_775
; ---------------------------------------------------------------------------

loc_5C4:				; CODE XREF: _udata_openSwapper_56+66j
		push	30h ; '0'       ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	cl, [ebp+arg_0]
		mov	[eax], cl
		mov	eax, [ebp+Dst]
		mov	cl, [ebp+arg_4]
		mov	[eax+1], cl
		mov	eax, [ebp+Dst]
		mov	cl, [ebp+arg_8]
		mov	[eax+2], cl
		mov	eax, [ebp+Dst]
		mov	cl, [ebp+arg_C]
		mov	[eax+3], cl
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_60B
		mov	[ebp+var_D0], offset _uprv_readDirectUInt16
		jmp	short loc_615
; ---------------------------------------------------------------------------

loc_60B:				; CODE XREF: _udata_openSwapper_56+B1j
		mov	[ebp+var_D0], offset _uprv_readSwapUInt16

loc_615:				; CODE XREF: _udata_openSwapper_56+BDj
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+4], edx
		movsx	eax, [ebp+arg_0]
		test	eax, eax
		jnz	short loc_635
		mov	[ebp+var_D0], offset _uprv_readDirectUInt32
		jmp	short loc_63F
; ---------------------------------------------------------------------------

loc_635:				; CODE XREF: _udata_openSwapper_56+DBj
		mov	[ebp+var_D0], offset _uprv_readSwapUInt32

loc_63F:				; CODE XREF: _udata_openSwapper_56+E7j
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+8], edx
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jnz	short loc_65F
		mov	[ebp+var_D0], offset _uprv_writeDirectUInt16
		jmp	short loc_669
; ---------------------------------------------------------------------------

loc_65F:				; CODE XREF: _udata_openSwapper_56+105j
		mov	[ebp+var_D0], offset _uprv_writeSwapUInt16

loc_669:				; CODE XREF: _udata_openSwapper_56+111j
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+10h], edx
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jnz	short loc_689
		mov	[ebp+var_D0], offset _uprv_writeDirectUInt32
		jmp	short loc_693
; ---------------------------------------------------------------------------

loc_689:				; CODE XREF: _udata_openSwapper_56+12Fj
		mov	[ebp+var_D0], offset _uprv_writeSwapUInt32

loc_693:				; CODE XREF: _udata_openSwapper_56+13Bj
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+14h], edx
		movzx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_6B3
		mov	[ebp+var_D0], offset _uprv_compareInvAscii_56
		jmp	short loc_6BD
; ---------------------------------------------------------------------------

loc_6B3:				; CODE XREF: _udata_openSwapper_56+159j
		mov	[ebp+var_D0], offset _uprv_compareInvEbcdic_56

loc_6BD:				; CODE XREF: _udata_openSwapper_56+165j
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+0Ch], edx
		movsx	eax, [ebp+arg_0]
		movsx	ecx, [ebp+arg_8]
		cmp	eax, ecx
		jnz	short loc_6F5
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+18h], offset _uprv_copyArray16
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+1Ch], offset _uprv_copyArray32
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+20h], offset _uprv_copyArray64
		jmp	short loc_713
; ---------------------------------------------------------------------------

loc_6F5:				; CODE XREF: _udata_openSwapper_56+187j
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+18h], offset _uprv_swapArray16
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+1Ch], offset _uprv_swapArray32
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+20h], offset _uprv_swapArray64

loc_713:				; CODE XREF: _udata_openSwapper_56+1A7j
		movzx	eax, [ebp+arg_4]
		test	eax, eax
		jnz	short loc_747
		movzx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_72F
		mov	[ebp+var_D0], offset _uprv_copyAscii_56
		jmp	short loc_739
; ---------------------------------------------------------------------------

loc_72F:				; CODE XREF: _udata_openSwapper_56+1D5j
		mov	[ebp+var_D0], offset _uprv_ebcdicFromAscii_56

loc_739:				; CODE XREF: _udata_openSwapper_56+1E1j
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+24h], edx
		jmp	short loc_772
; ---------------------------------------------------------------------------

loc_747:				; CODE XREF: _udata_openSwapper_56+1CDj
		movzx	eax, [ebp+arg_C]
		cmp	eax, 1
		jnz	short loc_75C
		mov	[ebp+var_D0], offset _uprv_copyEbcdic_56
		jmp	short loc_766
; ---------------------------------------------------------------------------

loc_75C:				; CODE XREF: _udata_openSwapper_56+202j
		mov	[ebp+var_D0], offset _uprv_asciiFromEbcdic_56

loc_766:				; CODE XREF: _udata_openSwapper_56+20Ej
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_D0]
		mov	[ecx+24h], edx

loc_772:				; CODE XREF: _udata_openSwapper_56+1F9j
		mov	eax, [ebp+Dst]

loc_775:				; CODE XREF: _udata_openSwapper_56+2Ej
					; _udata_openSwapper_56+50j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_openSwapper_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_swapArray16 proc near		; DATA XREF: _udata_openSwapper_56+1ACo

var_F0		= byte ptr -0F0h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_7B8
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_7BF

loc_7B8:				; CODE XREF: _uprv_swapArray16+22j
		xor	eax, eax
		jmp	loc_849
; ---------------------------------------------------------------------------

loc_7BF:				; CODE XREF: _uprv_swapArray16+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_7DF
		cmp	[ebp+arg_4], 0
		jz	short loc_7DF
		cmp	[ebp+arg_8], 0
		jl	short loc_7DF
		mov	eax, [ebp+arg_8]
		and	eax, 1
		jnz	short loc_7DF
		cmp	[ebp+arg_C], 0
		jnz	short loc_7EC

loc_7DF:				; CODE XREF: _uprv_swapArray16+37j
					; _uprv_swapArray16+3Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_849
; ---------------------------------------------------------------------------

loc_7EC:				; CODE XREF: _uprv_swapArray16+51j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_20], eax

loc_803:				; CODE XREF: _uprv_swapArray16+B8j
		cmp	[ebp+var_20], 0
		jle	short loc_846
		mov	eax, [ebp+var_8]
		mov	cx, [eax]
		mov	[ebp+var_2C], cx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		movzx	eax, [ebp+var_2C]
		shl	eax, 8
		movzx	ecx, [ebp+var_2C]
		sar	ecx, 8
		or	eax, ecx
		mov	edx, [ebp+var_14]
		mov	[edx], ax
		mov	eax, [ebp+var_14]
		add	eax, 2
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_803
; ---------------------------------------------------------------------------

loc_846:				; CODE XREF: _uprv_swapArray16+7Bj
		mov	eax, [ebp+arg_8]

loc_849:				; CODE XREF: _uprv_swapArray16+2Ej
					; _uprv_swapArray16+5Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_swapArray16 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 850h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_copyArray16(int, void *Src, size_t Size, void *Dst, int)
_uprv_copyArray16 proc near		; DATA XREF: _udata_openSwapper_56+18Co

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_87C
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_880

loc_87C:				; CODE XREF: _uprv_copyArray16+22j
		xor	eax, eax
		jmp	short loc_8E0
; ---------------------------------------------------------------------------

loc_880:				; CODE XREF: _uprv_copyArray16+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_8A0
		cmp	[ebp+Src], 0
		jz	short loc_8A0
		cmp	[ebp+Size], 0
		jl	short loc_8A0
		mov	eax, [ebp+Size]
		and	eax, 1
		jnz	short loc_8A0
		cmp	[ebp+Dst], 0
		jnz	short loc_8AD

loc_8A0:				; CODE XREF: _uprv_copyArray16+34j
					; _uprv_copyArray16+3Aj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_8E0
; ---------------------------------------------------------------------------

loc_8AD:				; CODE XREF: _uprv_copyArray16+4Ej
		cmp	[ebp+Size], 0
		jle	short loc_8DD
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+Dst]
		jz	short loc_8DD
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8DD:				; CODE XREF: _uprv_copyArray16+61j
					; _uprv_copyArray16+69j
		mov	eax, [ebp+Size]

loc_8E0:				; CODE XREF: _uprv_copyArray16+2Ej
					; _uprv_copyArray16+5Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_copyArray16 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_swapArray32 proc near		; DATA XREF: _udata_openSwapper_56+1B6o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_920
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_927

loc_920:				; CODE XREF: _uprv_swapArray32+22j
		xor	eax, eax
		jmp	loc_9CC
; ---------------------------------------------------------------------------

loc_927:				; CODE XREF: _uprv_swapArray32+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_947
		cmp	[ebp+arg_4], 0
		jz	short loc_947
		cmp	[ebp+arg_8], 0
		jl	short loc_947
		mov	eax, [ebp+arg_8]
		and	eax, 3
		jnz	short loc_947
		cmp	[ebp+arg_C], 0
		jnz	short loc_954

loc_947:				; CODE XREF: _uprv_swapArray32+37j
					; _uprv_swapArray32+3Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_9CC
; ---------------------------------------------------------------------------

loc_954:				; CODE XREF: _uprv_swapArray32+51j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		cdq
		and	edx, 3
		add	eax, edx
		sar	eax, 2
		mov	[ebp+var_20], eax

loc_96F:				; CODE XREF: _uprv_swapArray32+D3j
		cmp	[ebp+var_20], 0
		jle	short loc_9C9
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_2C], ecx
		mov	edx, [ebp+var_8]
		add	edx, 4
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_2C]
		shl	eax, 18h
		mov	ecx, [ebp+var_2C]
		shl	ecx, 8
		and	ecx, 0FF0000h
		or	eax, ecx
		mov	edx, [ebp+var_2C]
		shr	edx, 8
		and	edx, 0FF00h
		or	eax, edx
		mov	ecx, [ebp+var_2C]
		shr	ecx, 18h
		or	eax, ecx
		mov	edx, [ebp+var_14]
		mov	[edx], eax
		mov	eax, [ebp+var_14]
		add	eax, 4
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_96F
; ---------------------------------------------------------------------------

loc_9C9:				; CODE XREF: _uprv_swapArray32+7Fj
		mov	eax, [ebp+arg_8]

loc_9CC:				; CODE XREF: _uprv_swapArray32+2Ej
					; _uprv_swapArray32+5Ej
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_swapArray32 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_copyArray32(int, void *Src, size_t Size, void *Dst, int)
_uprv_copyArray32 proc near		; DATA XREF: _udata_openSwapper_56+196o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_A00
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_A04

loc_A00:				; CODE XREF: _uprv_copyArray32+22j
		xor	eax, eax
		jmp	short loc_A64
; ---------------------------------------------------------------------------

loc_A04:				; CODE XREF: _uprv_copyArray32+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_A24
		cmp	[ebp+Src], 0
		jz	short loc_A24
		cmp	[ebp+Size], 0
		jl	short loc_A24
		mov	eax, [ebp+Size]
		and	eax, 3
		jnz	short loc_A24
		cmp	[ebp+Dst], 0
		jnz	short loc_A31

loc_A24:				; CODE XREF: _uprv_copyArray32+34j
					; _uprv_copyArray32+3Aj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_A64
; ---------------------------------------------------------------------------

loc_A31:				; CODE XREF: _uprv_copyArray32+4Ej
		cmp	[ebp+Size], 0
		jle	short loc_A61
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+Dst]
		jz	short loc_A61
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_A61:				; CODE XREF: _uprv_copyArray32+61j
					; _uprv_copyArray32+69j
		mov	eax, [ebp+Size]

loc_A64:				; CODE XREF: _uprv_copyArray32+2Ej
					; _uprv_copyArray32+5Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_copyArray32 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A78h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_swapArray64 proc near		; DATA XREF: _udata_openSwapper_56+1C0o

var_F4		= byte ptr -0F4h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_AA4
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_AAB

loc_AA4:				; CODE XREF: _uprv_swapArray64+22j
		xor	eax, eax
		jmp	loc_BFD
; ---------------------------------------------------------------------------

loc_AAB:				; CODE XREF: _uprv_swapArray64+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_ACB
		cmp	[ebp+arg_4], 0
		jz	short loc_ACB
		cmp	[ebp+arg_8], 0
		jl	short loc_ACB
		mov	eax, [ebp+arg_8]
		and	eax, 7
		jnz	short loc_ACB
		cmp	[ebp+arg_C], 0
		jnz	short loc_ADB

loc_ACB:				; CODE XREF: _uprv_swapArray64+37j
					; _uprv_swapArray64+3Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_BFD
; ---------------------------------------------------------------------------

loc_ADB:				; CODE XREF: _uprv_swapArray64+51j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		mov	[ebp+var_20], eax

loc_AF6:				; CODE XREF: _uprv_swapArray64+17Dj
		cmp	[ebp+var_20], 0
		jle	loc_BFA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+var_30], ecx
		mov	edx, [eax+4]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_8]
		add	eax, 8
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_30]
		mov	edx, [ebp+var_2C]
		mov	cl, 38h	; '8'
		call	__allshl
		mov	esi, eax
		mov	edi, edx
		mov	eax, [ebp+var_30]
		and	eax, 0FF00h
		mov	edx, [ebp+var_2C]
		and	edx, 0
		mov	cl, 28h	; '('
		call	__allshl
		or	esi, eax
		or	edi, edx
		mov	eax, [ebp+var_30]
		and	eax, 0FF0000h
		mov	edx, [ebp+var_2C]
		and	edx, 0
		mov	cl, 18h
		call	__allshl
		or	esi, eax
		or	edi, edx
		mov	eax, [ebp+var_30]
		and	eax, 0FF000000h
		mov	edx, [ebp+var_2C]
		and	edx, 0
		mov	cl, 8
		call	__allshl
		or	esi, eax
		or	edi, edx
		mov	eax, [ebp+var_30]
		mov	edx, [ebp+var_2C]
		mov	cl, 8
		call	__aullshr
		and	eax, 0FF000000h
		and	edx, 0
		or	esi, eax
		or	edi, edx
		mov	eax, [ebp+var_30]
		mov	edx, [ebp+var_2C]
		mov	cl, 18h
		call	__aullshr
		and	eax, 0FF0000h
		and	edx, 0
		or	esi, eax
		or	edi, edx
		mov	eax, [ebp+var_30]
		mov	edx, [ebp+var_2C]
		mov	cl, 28h	; '('
		call	__aullshr
		and	eax, 0FF00h
		and	edx, 0
		or	esi, eax
		or	edi, edx
		mov	eax, [ebp+var_30]
		mov	edx, [ebp+var_2C]
		mov	cl, 38h	; '8'
		call	__aullshr
		or	esi, eax
		or	edi, edx
		mov	[ebp+var_30], esi
		mov	[ebp+var_2C], edi
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_30]
		mov	[eax], ecx
		mov	edx, [ebp+var_2C]
		mov	[eax+4], edx
		mov	eax, [ebp+var_14]
		add	eax, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	loc_AF6
; ---------------------------------------------------------------------------

loc_BFA:				; CODE XREF: _uprv_swapArray64+82j
		mov	eax, [ebp+arg_8]

loc_BFD:				; CODE XREF: _uprv_swapArray64+2Ej
					; _uprv_swapArray64+5Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_swapArray64 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C14h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_copyArray64(int, void *Src, size_t Size, void *Dst, int)
_uprv_copyArray64 proc near		; DATA XREF: _udata_openSwapper_56+1A0o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_C40
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_C44

loc_C40:				; CODE XREF: _uprv_copyArray64+22j
		xor	eax, eax
		jmp	short loc_CA4
; ---------------------------------------------------------------------------

loc_C44:				; CODE XREF: _uprv_copyArray64+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_C64
		cmp	[ebp+Src], 0
		jz	short loc_C64
		cmp	[ebp+Size], 0
		jl	short loc_C64
		mov	eax, [ebp+Size]
		and	eax, 7
		jnz	short loc_C64
		cmp	[ebp+Dst], 0
		jnz	short loc_C71

loc_C64:				; CODE XREF: _uprv_copyArray64+34j
					; _uprv_copyArray64+3Aj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_CA4
; ---------------------------------------------------------------------------

loc_C71:				; CODE XREF: _uprv_copyArray64+4Ej
		cmp	[ebp+Size], 0
		jle	short loc_CA1
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+Dst]
		jz	short loc_CA1
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_CA1:				; CODE XREF: _uprv_copyArray64+61j
					; _uprv_copyArray64+69j
		mov	eax, [ebp+Size]

loc_CA4:				; CODE XREF: _uprv_copyArray64+2Ej
					; _uprv_copyArray64+5Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_copyArray64 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_readSwapUInt16 proc near		; CODE XREF: _udata_openSwapperForInputData_56+DFp
					; _udata_openSwapperForInputData_56+F3p
					; DATA XREF: ...

var_C0		= byte ptr -0C0h
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		shl	eax, 8
		movzx	ecx, [ebp+arg_0]
		sar	ecx, 8
		or	eax, ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_readSwapUInt16 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_readDirectUInt16 proc near	; DATA XREF: _udata_openSwapper_56+B3o

var_C0		= byte ptr -0C0h
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_readDirectUInt16 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D1Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_readSwapUInt32 proc near		; DATA XREF: _udata_openSwapper_56:loc_635o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		shl	eax, 18h
		mov	ecx, [ebp+arg_0]
		shl	ecx, 8
		and	ecx, 0FF0000h
		or	eax, ecx
		mov	edx, [ebp+arg_0]
		shr	edx, 8
		and	edx, 0FF00h
		or	eax, edx
		mov	ecx, [ebp+arg_0]
		shr	ecx, 18h
		or	eax, ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_readSwapUInt32 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D6Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_readDirectUInt32 proc near	; DATA XREF: _udata_openSwapper_56+DDo

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_readDirectUInt32 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D94h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_writeSwapUInt16 proc near		; DATA XREF: _udata_openSwapper_56:loc_65Fo

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_4]
		shl	eax, 8
		movzx	ecx, [ebp+arg_4]
		sar	ecx, 8
		or	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	[edx], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_writeSwapUInt16 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DD0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_writeDirectUInt16	proc near	; DATA XREF: _udata_openSwapper_56+107o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	cx, [ebp+arg_4]
		mov	[eax], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_writeDirectUInt16	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E00h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_writeSwapUInt32 proc near		; DATA XREF: _udata_openSwapper_56:loc_689o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		shl	eax, 18h
		mov	ecx, [ebp+arg_4]
		shl	ecx, 8
		and	ecx, 0FF0000h
		or	eax, ecx
		mov	edx, [ebp+arg_4]
		shr	edx, 8
		and	edx, 0FF00h
		or	eax, edx
		mov	ecx, [ebp+arg_4]
		shr	ecx, 18h
		or	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	[edx], eax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_writeSwapUInt32 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E54h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_uprv_writeDirectUInt32	proc near	; DATA XREF: _udata_openSwapper_56+131o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_writeDirectUInt32	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E84h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_openSwapperForInputData_56
_udata_openSwapperForInputData_56 proc near

var_FC		= byte ptr -0FCh
var_35		= byte ptr -35h
var_29		= byte ptr -29h
var_20		= word ptr -20h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_EB0
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_EB7

loc_EB0:				; CODE XREF: _udata_openSwapperForInputData_56+22j
		xor	eax, eax
		jmp	loc_FE0
; ---------------------------------------------------------------------------

loc_EB7:				; CODE XREF: _udata_openSwapperForInputData_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_ED2
		cmp	[ebp+arg_4], 0
		jl	short loc_EC9
		cmp	[ebp+arg_4], 18h
		jb	short loc_ED2

loc_EC9:				; CODE XREF: _udata_openSwapperForInputData_56+3Dj
		movzx	eax, [ebp+arg_C]
		cmp	eax, 1
		jle	short loc_EE2

loc_ED2:				; CODE XREF: _udata_openSwapperForInputData_56+37j
					; _udata_openSwapperForInputData_56+43j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_FE0
; ---------------------------------------------------------------------------

loc_EE2:				; CODE XREF: _udata_openSwapperForInputData_56+4Cj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_4], 0
		jl	short loc_EF4
		cmp	[ebp+arg_4], 18h
		jb	short loc_F1B

loc_EF4:				; CODE XREF: _udata_openSwapperForInputData_56+68j
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+2]
		cmp	ecx, 0DAh ; 'Ú'
		jnz	short loc_F1B
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+3]
		cmp	ecx, 27h ; '''
		jnz	short loc_F1B
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+0Ah]
		cmp	ecx, 2
		jz	short loc_F2B

loc_F1B:				; CODE XREF: _udata_openSwapperForInputData_56+6Ej
					; _udata_openSwapperForInputData_56+7Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_FE0
; ---------------------------------------------------------------------------

loc_F2B:				; CODE XREF: _udata_openSwapperForInputData_56+95j
		mov	eax, [ebp+var_8]
		mov	cl, [eax+8]
		mov	[ebp+var_29], cl
		mov	eax, [ebp+var_8]
		mov	cl, [eax+9]
		mov	[ebp+var_35], cl
		movsx	eax, [ebp+var_29]
		test	eax, eax
		jnz	short loc_F5C
		mov	eax, [ebp+var_8]
		mov	cx, [eax]
		mov	[ebp+var_14], cx
		mov	eax, [ebp+var_8]
		mov	cx, [eax+4]
		mov	[ebp+var_20], cx
		jmp	short loc_F83
; ---------------------------------------------------------------------------

loc_F5C:				; CODE XREF: _udata_openSwapperForInputData_56+BFj
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		push	ecx
		call	_uprv_readSwapUInt16
		add	esp, 4
		mov	[ebp+var_14], ax
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax+4]
		push	ecx
		call	_uprv_readSwapUInt16
		add	esp, 4
		mov	[ebp+var_20], ax

loc_F83:				; CODE XREF: _udata_openSwapperForInputData_56+D6j
		movzx	eax, [ebp+var_14]
		cmp	eax, 18h
		jb	short loc_FB3
		movzx	eax, [ebp+var_20]
		cmp	eax, 14h
		jb	short loc_FB3
		movzx	eax, [ebp+var_14]
		movzx	ecx, [ebp+var_20]
		add	ecx, 4
		cmp	eax, ecx
		jb	short loc_FB3
		cmp	[ebp+arg_4], 0
		jl	short loc_FC0
		movzx	eax, [ebp+var_14]
		cmp	[ebp+arg_4], eax
		jge	short loc_FC0

loc_FB3:				; CODE XREF: _udata_openSwapperForInputData_56+106j
					; _udata_openSwapperForInputData_56+10Fj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	short loc_FE0
; ---------------------------------------------------------------------------

loc_FC0:				; CODE XREF: _udata_openSwapperForInputData_56+124j
					; _udata_openSwapperForInputData_56+12Dj
		mov	eax, [ebp+arg_10]
		push	eax
		movzx	ecx, [ebp+arg_C]
		push	ecx
		movzx	edx, [ebp+arg_8]
		push	edx
		movzx	eax, [ebp+var_35]
		push	eax
		movzx	ecx, [ebp+var_29]
		push	ecx
		call	_udata_openSwapper_56
		add	esp, 14h

loc_FE0:				; CODE XREF: _udata_openSwapperForInputData_56+2Ej
					; _udata_openSwapperForInputData_56+59j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_openSwapperForInputData_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FF4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _udata_closeSwapper_56
_udata_closeSwapper_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_udata_closeSwapper_56 endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_CheckEsp:near ; CODE XREF: _udata_readInt16_56+32p
					; _udata_readInt16_56+42p ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _udata_swapInvStringBlock_56+EAp
					; _udata_swapDataHeader_56+186p ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: _udata_swapInvStringBlock_56+CDp
					; _udata_swapDataHeader_56+171p ...
		extrn _uprv_asciiFromEbcdic_56:near
					; DATA XREF: _udata_openSwapper_56:loc_75Co
		extrn _uprv_copyEbcdic_56:near ; DATA XREF: _udata_openSwapper_56+204o
		extrn _uprv_ebcdicFromAscii_56:near
					; DATA XREF: _udata_openSwapper_56:loc_72Fo
		extrn _uprv_copyAscii_56:near ;	DATA XREF: _udata_openSwapper_56+1D7o
		extrn _uprv_compareInvEbcdic_56:near
					; DATA XREF: _udata_openSwapper_56:loc_6B3o
		extrn _uprv_compareInvAscii_56:near ; DATA XREF: _udata_openSwapper_56+15Bo
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _udata_openSwapper_56+80p
		extrn _uprv_malloc_56:near ; CODE XREF:	_udata_openSwapper_56+57p
		extrn __aullshr:near	; CODE XREF: _uprv_swapArray64+103p
					; _uprv_swapArray64+11Cp ...
		extrn __allshl:near	; CODE XREF: _uprv_swapArray64+A7p
					; _uprv_swapArray64+C0p ...
		extrn _uprv_free_56:near ; CODE	XREF: _udata_closeSwapper_56+22p


		end
