;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	02660DF17EE35248724418D678F42C48
; Input	CRC32 :	D7D26EF6

; File Name   :	D:\compspace\objfiles\firefox\common\uniset.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset off_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	??4UMemory@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UMemory::operator=(icu_56::UMemory const	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset aAtcher@icu_56@ ;	"atcher@icu_56@@"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; char `public:	static void * __cdecl icu_56::UnicodeSet::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@UnicodeSet@icu_56@@SAPAXXZ@4DA db	?
					; DATA XREF: icu_56::UnicodeSet::getStaticClassID(void)+1Eo
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp

loc_FF:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 134h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 138h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near		; CODE XREF: icu_56::SymbolTable::`scalar deleting destructor'(uint)+37p
					; icu_56::SymbolTable::`vector deleting	destructor'(uint)+75p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 198h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::ParsePosition::ParsePosition(void)+26p
					; icu_56::ParsePosition::ParsePosition(int)+26p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_1FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 228h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 234h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000228o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 248h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000240o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 268h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000244o
					; .rdata$r:0000029Co
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 278h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000274o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 284h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000540o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2A0h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:0000027Co
					; .rdata$r:00000544o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2BCh
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2DCh
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000002B8o
					; .rdata$r:0000030Co
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2ECh
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000002E8o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2F4h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 310h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition	const &)+2Ap
					; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor	const &)+2Ap ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_347
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_351
; ---------------------------------------------------------------------------

loc_347:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_351:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 368h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFunctor::operator=(icu_56::UnicodeFunctor const &)+2Ap
					; icu_56::Replaceable::operator=(icu_56::Replaceable const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3D7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_3D7:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_3FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_451
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_449
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_449:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_470
; ---------------------------------------------------------------------------

loc_451:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_46D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_46D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_470:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 488h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition *__hidden this)
		public ??0ParsePosition@icu_56@@QAE@XZ
??0ParsePosition@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ParsePosition@icu_56@@6B@ ;	const icu_56::ParsePosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0ParsePosition@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E8h
		dd offset ??_R4ParsePosition@icu_56@@6B@ ; const icu_56::ParsePosition::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ParsePosition@icu_56@@6B@
; const	icu_56::ParsePosition::`vftable'
??_7ParsePosition@icu_56@@6B@ dd offset	??_EParsePosition@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ParsePosition::ParsePosition(void)+2Eo
					; icu_56::ParsePosition::ParsePosition(int)+2Eo ...
					; icu_56::ParsePosition::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@ParsePosition@icu_56@@UBEPAXXZ ; icu_56::ParsePosition::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4F4h
		public ??_R4ParsePosition@icu_56@@6B@
; const	icu_56::ParsePosition::`RTTI Complete Object Locator'
??_R4ParsePosition@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000004E8o
		dd offset ??_R0?AVParsePosition@icu_56@@@8 ; icu_56::ParsePosition `RTTI Type Descriptor'
		dd offset ??_R3ParsePosition@icu_56@@8 ; icu_56::ParsePosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 508h
		public ??_R0?AVParsePosition@icu_56@@@8
; class	icu_56::ParsePosition `RTTI Type Descriptor'
??_R0?AVParsePosition@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000500o
					; .rdata$r:icu_56::ParsePosition::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avparseposit	db '.?AVParsePosition@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 52Ch
		public ??_R3ParsePosition@icu_56@@8
; icu_56::ParsePosition::`RTTI Class Hierarchy Descriptor'
??_R3ParsePosition@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00000504o
					; .rdata$r:00000564o
		dd 3
		dd offset ??_R2ParsePosition@icu_56@@8 ; icu_56::ParsePosition::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 53Ch
		public ??_R2ParsePosition@icu_56@@8
; icu_56::ParsePosition::`RTTI Base Class Array'
??_R2ParsePosition@icu_56@@8 dd	offset ??_R1A@?0A@EA@ParsePosition@icu_56@@8
					; DATA XREF: .rdata$r:00000538o
					; icu_56::ParsePosition::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 54Ch
		public ??_R1A@?0A@EA@ParsePosition@icu_56@@8
; icu_56::ParsePosition::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@ParsePosition@icu_56@@8 dd offset	??_R0?AVParsePosition@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ParsePosition::`RTTI Base	Class Array'o
					; icu_56::ParsePosition	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ParsePosition@icu_56@@8 ; icu_56::ParsePosition::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition *this, int)
		public ??0ParsePosition@icu_56@@QAE@H@Z
??0ParsePosition@icu_56@@QAE@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ParsePosition@icu_56@@6B@ ;	const icu_56::ParsePosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0ParsePosition@icu_56@@QAE@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ParsePosition::ParsePosition(icu_56::ParsePosition *this, const struct icu_56::ParsePosition *)
		public ??0ParsePosition@icu_56@@QAE@ABV01@@Z
??0ParsePosition@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ParsePosition@icu_56@@6B@ ;	const icu_56::ParsePosition::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0ParsePosition@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 634h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ParsePosition::`scalar deleting destructor'(unsigned int)
		public ??_GParsePosition@icu_56@@UAEPAXI@Z
??_GParsePosition@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ParsePosition@icu_56@@UAE@XZ	; icu_56::ParsePosition::~ParsePosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_673
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_673:				; CODE XREF: icu_56::ParsePosition::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GParsePosition@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 68Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ParsePosition::`vector deleting destructor'(unsigned int)
		public ??_EParsePosition@icu_56@@UAEPAXI@Z
??_EParsePosition@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ParsePosition::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_6ED
		push	offset ??1ParsePosition@icu_56@@UAE@XZ ; icu_56::ParsePosition::~ParsePosition(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	0Ch
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6E5
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_6E5:				; CODE XREF: icu_56::ParsePosition::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_70C
; ---------------------------------------------------------------------------

loc_6ED:				; CODE XREF: icu_56::ParsePosition::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ParsePosition@icu_56@@UAE@XZ	; icu_56::ParsePosition::~ParsePosition(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_709
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_709:				; CODE XREF: icu_56::ParsePosition::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_70C:				; CODE XREF: icu_56::ParsePosition::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EParsePosition@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 724h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::ParsePosition &	__thiscall icu_56::ParsePosition::operator=(class icu_56::ParsePosition	const &)
		public ??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z
??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4ParsePosition@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 76Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::ParsePosition::operator==(class icu_56::ParsePosition const &)const
		public ??8ParsePosition@icu_56@@QBECABV01@@Z
??8ParsePosition@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::ParsePosition::operator!=(icu_56::ParsePosition const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_7AB
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jz	short loc_7B1

loc_7AB:				; CODE XREF: icu_56::ParsePosition::operator==(icu_56::ParsePosition const &)+2Fj
		xor	al, al
		jmp	short loc_7B3
; ---------------------------------------------------------------------------
		jmp	short loc_7B3
; ---------------------------------------------------------------------------

loc_7B1:				; CODE XREF: icu_56::ParsePosition::operator==(icu_56::ParsePosition const &)+3Dj
		mov	al, 1

loc_7B3:				; CODE XREF: icu_56::ParsePosition::operator==(icu_56::ParsePosition const &)+41j
					; icu_56::ParsePosition::operator==(icu_56::ParsePosition const	&)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8ParsePosition@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::ParsePosition::operator!=(class icu_56::ParsePosition const &)const
		public ??9ParsePosition@icu_56@@QBECABV01@@Z
??9ParsePosition@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8ParsePosition@icu_56@@QBECABV01@@Z ;	icu_56::ParsePosition::operator==(icu_56::ParsePosition	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp

loc_7FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9ParsePosition@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 80Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::ParsePosition::getIndex(icu_56::ParsePosition *__hidden this)
		public ?getIndex@ParsePosition@icu_56@@QBEHXZ
?getIndex@ParsePosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIndex@ParsePosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::ParsePosition::setIndex(icu_56::ParsePosition	*this, int)
		public ?setIndex@ParsePosition@icu_56@@QAEXH@Z
?setIndex@ParsePosition@icu_56@@QAEXH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setIndex@ParsePosition@icu_56@@QAEXH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 874h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::ParsePosition::getErrorIndex(icu_56::ParsePosition *__hidden this)
		public ?getErrorIndex@ParsePosition@icu_56@@QBEHXZ
?getErrorIndex@ParsePosition@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getErrorIndex@ParsePosition@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::ParsePosition::setErrorIndex(icu_56::ParsePosition *this, int)
		public ?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z
?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setErrorIndex@ParsePosition@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SymbolTable::SymbolTable(icu_56::SymbolTable *__hidden this)
		public ??0SymbolTable@icu_56@@QAE@XZ
??0SymbolTable@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0SymbolTable@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 914h
		dd offset ??_R4SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SymbolTable@icu_56@@6B@
; const	icu_56::SymbolTable::`vftable'
??_7SymbolTable@icu_56@@6B@ dd offset ??_ESymbolTable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SymbolTable::SymbolTable(void)+26o
					; icu_56::SymbolTable::SymbolTable(icu_56::SymbolTable const &)+26o ...
					; icu_56::SymbolTable::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 928h
		public ??_R4SymbolTable@icu_56@@6B@
; const	icu_56::SymbolTable::`RTTI Complete Object Locator'
??_R4SymbolTable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000914o
		dd offset ??_R0?AVSymbolTable@icu_56@@@8 ; icu_56::SymbolTable `RTTI Type Descriptor'
		dd offset ??_R3SymbolTable@icu_56@@8 ; icu_56::SymbolTable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 93Ch
		public ??_R0?AVSymbolTable@icu_56@@@8
; class	icu_56::SymbolTable `RTTI Type Descriptor'
??_R0?AVSymbolTable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000934o
					; .rdata$r:icu_56::SymbolTable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avsymboltabl	db '.?AVSymbolTable@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 960h
		public ??_R3SymbolTable@icu_56@@8
; icu_56::SymbolTable::`RTTI Class Hierarchy Descriptor'
??_R3SymbolTable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00000938o
					; .rdata$r:00000990o
		dd 1
		dd offset ??_R2SymbolTable@icu_56@@8 ; icu_56::SymbolTable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 970h
		public ??_R2SymbolTable@icu_56@@8
; icu_56::SymbolTable::`RTTI Base Class	Array'
??_R2SymbolTable@icu_56@@8 dd offset ??_R1A@?0A@EA@SymbolTable@icu_56@@8
					; DATA XREF: .rdata$r:0000096Co
					; icu_56::SymbolTable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 978h
		public ??_R1A@?0A@EA@SymbolTable@icu_56@@8
; icu_56::SymbolTable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SymbolTable@icu_56@@8 dd offset ??_R0?AVSymbolTable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SymbolTable::`RTTI Base Class Array'o
					; icu_56::SymbolTable `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SymbolTable@icu_56@@8 ; icu_56::SymbolTable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 994h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SymbolTable::SymbolTable(icu_56::SymbolTable *this,	const struct icu_56::SymbolTable *)
		public ??0SymbolTable@icu_56@@QAE@ABV01@@Z
??0SymbolTable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0SymbolTable@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::SymbolTable & __thiscall icu_56::SymbolTable::operator=(class icu_56::SymbolTable const	&)
		public ??4SymbolTable@icu_56@@QAEAAV01@ABV01@@Z
??4SymbolTable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4SymbolTable@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SymbolTable::`scalar deleting destructor'(unsigned int)
		public ??_GSymbolTable@icu_56@@UAEPAXI@Z
??_GSymbolTable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SymbolTable@icu_56@@UAE@XZ ;	icu_56::SymbolTable::~SymbolTable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_A3B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_A3B:				; CODE XREF: icu_56::SymbolTable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSymbolTable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SymbolTable::`vector deleting destructor'(unsigned int)
		public ??_ESymbolTable@icu_56@@UAEPAXI@Z
??_ESymbolTable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::SymbolTable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_AB5
		push	offset ??1SymbolTable@icu_56@@UAE@XZ ; icu_56::SymbolTable::~SymbolTable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_AAD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_AAD:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_AD4
; ---------------------------------------------------------------------------

loc_AB5:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SymbolTable@icu_56@@UAE@XZ ;	icu_56::SymbolTable::~SymbolTable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_AD1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_AD1:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_AD4:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESymbolTable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete[](void *)
		public ??_V@YAXPAX@Z
??_V@YAXPAX@Z	proc near		; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+51p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+51p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??_V@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		public ??0UnicodeFunctor@icu_56@@QAE@XZ
??0UnicodeFunctor@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFunctor@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B6Ch
		dd offset ??_R4UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`vftable'
??_7UnicodeFunctor@icu_56@@6B@ dd offset ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFunctor::UnicodeFunctor(void)+2Eo
					; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor	const &)+32o
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ ;	icu_56::UnicodeFunctor::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B88h
		public ??_R4UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`RTTI Complete Object Locator'
??_R4UnicodeFunctor@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00000B6Co
		dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8 ; icu_56::UnicodeFunctor `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B9Ch
		public ??_R0?AVUnicodeFunctor@icu_56@@@8
; class	icu_56::UnicodeFunctor `RTTI Type Descriptor'
??_R0?AVUnicodeFunctor@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000B94o
					; .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodefun	db '.?AVUnicodeFunctor@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC0h
		public ??_R3UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeFunctor@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00000B98o
					; .rdata$r:00000BF8o
		dd 3
		dd offset ??_R2UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BD0h
		public ??_R2UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
??_R2UnicodeFunctor@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
					; DATA XREF: .rdata$r:00000BCCo
					; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BE0h
		public ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Array'o
					; .rdata$r:00001080o ...
					; icu_56::UnicodeFunctor `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *this, const struct icu_56::UnicodeFunctor *)
		public ??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFunctor & __thiscall icu_56::UnicodeFunctor::operator=(class icu_56::UnicodeFunctor const &)
		public ??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFunctor@icu_56@@UAEPAXI@Z
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_CD7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_CD7:				; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFunctor::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_D51
		push	offset ??1UnicodeFunctor@icu_56@@UAE@XZ	; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D49
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_D49:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_D70
; ---------------------------------------------------------------------------

loc_D51:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D6D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_D6D:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_D70:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		public ??0UnicodeMatcher@icu_56@@QAE@XZ
??0UnicodeMatcher@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+31p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeMatcher@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DC0h
		dd offset ??_R4UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`vftable'
??_7UnicodeMatcher@icu_56@@6B@ dd offset ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeMatcher::UnicodeMatcher(void)+26o
					; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher	const &)+26o
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DD8h
		public ??_R4UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`RTTI Complete Object Locator'
??_R4UnicodeMatcher@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00000DC0o
		dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8 ; icu_56::UnicodeMatcher `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0DECh
		public ??_R0?AVUnicodeMatcher@icu_56@@@8
; class	icu_56::UnicodeMatcher `RTTI Type Descriptor'
??_R0?AVUnicodeMatcher@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00000DE4o
					; .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		dd 0
		dd 56413F2Eh, 63696E55h, 4D65646Fh
aAtcher@icu_56@	db 'atcher@icu_56@@',0  ; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E10h
		public ??_R3UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeMatcher@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00000DE8o
					; .rdata$r:00000E40o ...
		dd 1
		dd offset ??_R2UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E20h
		public ??_R2UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
??_R2UnicodeMatcher@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
					; DATA XREF: .rdata$r:00000E1Co
					; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0E28h
		public ??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8 dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Array'o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *this, const struct icu_56::UnicodeMatcher *)
		public ??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeMatcher & __thiscall icu_56::UnicodeMatcher::operator=(class icu_56::UnicodeMatcher const &)
		public ??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeMatcher@icu_56@@UAEPAXI@Z
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EEB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_EEB:				; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeMatcher::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_F65
		push	offset ??1UnicodeMatcher@icu_56@@UAE@XZ	; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F5D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_F5D:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F84
; ---------------------------------------------------------------------------

loc_F65:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F81
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_F81:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F84:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *__hidden this)
		public ??0UnicodeFilter@icu_56@@QAE@XZ
??0UnicodeFilter@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+45p
					; icu_56::UnicodeSet::UnicodeSet(int,int)+45p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@XZ ; icu_56::UnicodeFunctor::UnicodeFunctor(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@XZ ; icu_56::UnicodeMatcher::UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFilter@icu_56@@QAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FFCh
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeMatcher'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
					; icu_56::UnicodeFilter::UnicodeFilter(void)+42o ...
					; [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z	; icu_56::UnicodeFilter::matches(icu_56::Replaceable const &,int &,int,signed char)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1014h
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeFunctor'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+39o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+62o
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1034h
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@	dd 3 dup(0) ; DATA XREF: .rdata:00001014o
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1048h
		public ??_R0?AVUnicodeFilter@icu_56@@@8
; class	icu_56::UnicodeFilter `RTTI Type Descriptor'
??_R0?AVUnicodeFilter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001040o
					; .rdata$r:icu_56::UnicodeFilter::`RTTI	Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		align 10h
a_?avunicodefil	db '.?AVUnicodeFilter@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 106Ch
		public ??_R3UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeFilter@icu_56@@8 dd	0	; DATA XREF: .rdata$r:00001044o
					; .rdata$r:000010ACo ...
		dd 1, 5
		dd offset ??_R2UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 107Ch
		public ??_R2UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Array'
??_R2UnicodeFilter@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
					; DATA XREF: .rdata$r:00001078o
					; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1094h
		public ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeFilter@icu_56@@8 dd offset	??_R0?AVUnicodeFilter@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFilter::`RTTI Base	Class Array'o
					; .rdata$r:00005F08o
					; icu_56::UnicodeFilter	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 10B0h
		public ??_R13?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UnicodeMatcher@icu_56@@8 dd offset	??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:0000108Co
					; .rdata$r:00005F18o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 10CCh
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@	dd 0 ; DATA XREF: .rdata:00000FFCo
		dd 4, 0
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *this, const struct icu_56::UnicodeFilter *)
		public ??0UnicodeFilter@icu_56@@QAE@ABV01@@Z
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+49p
					; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+4Cp

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeFunctor	*
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_1123
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_112D
; ---------------------------------------------------------------------------

loc_1123:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+33j
		mov	[ebp+var_D0], 0

loc_112D:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx		; struct icu_56::UnicodeMatcher	*
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 116Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFilter &	__thiscall icu_56::UnicodeFilter::operator=(class icu_56::UnicodeFilter	const &)
		public ??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeFunctor::operator=(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_11AF
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_11B9
; ---------------------------------------------------------------------------

loc_11AF:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+33j
		mov	[ebp+var_D0], 0

loc_11B9:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeMatcher::operator=(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFilter@icu_56@@UAEPAXI@Z
??_GUnicodeFilter@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1223
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1223:				; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFilter@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 123Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
??_EUnicodeFilter@icu_56@@UAEPAXI@Z proc near
					; CODE XREF: [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_129D
		push	offset ??1UnicodeFilter@icu_56@@UAE@XZ ; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1295
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_1295:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_12BC
; ---------------------------------------------------------------------------

loc_129D:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_12B9
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_12B9:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_12BC:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFilter@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1328h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1354h
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00001328o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1368h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00001360o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 138Ch
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00001364o
					; .rdata$r:000013C4o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 139Ch
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00001398o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13ACh
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:00001FDCo
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1410h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_144F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_144F:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1468h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_14C9
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_14C1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_14C1:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_14E8
; ---------------------------------------------------------------------------

loc_14C9:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_14E5
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_14E5:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_14E8:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1500h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 154Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 159Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+9Bp
					; icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const	&)+6Cp	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near
					; CODE XREF: icu_56::CharString::toStringPiece(void)+36p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 171Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near
					; CODE XREF: icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 174Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 177Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1820h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1860h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_18B9
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_189D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_189D:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_18B9:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_1913
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_1909
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_1913
; ---------------------------------------------------------------------------

loc_1909:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_1913:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 191Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 196Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 19E4h
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 19F8h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000019E4o
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1A0Ch
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00001A04o
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A2Ch
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00001A08o
					; .rdata$r:00001A60o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A3Ch
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00001A38o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A48h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1AA3
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1AA3:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1B1D
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1B15
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_1B15:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1B3C
; ---------------------------------------------------------------------------

loc_1B1D:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1B39
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1B39:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1B3C:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1CAB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1CAB:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1D25
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1D1D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_1D1D:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_1D44
; ---------------------------------------------------------------------------

loc_1D25:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_1D41
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_1D41:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_1D44:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1D92
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1DAE
; ---------------------------------------------------------------------------

loc_1D92:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_1DAE
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_1DAE:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1E05
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1E17
; ---------------------------------------------------------------------------

loc_1E05:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_1E17
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_1E17:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_1E2A
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_1E46
; ---------------------------------------------------------------------------

loc_1E2A:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_1E46
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_1E46:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1E99
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1EA5
; ---------------------------------------------------------------------------

loc_1E99:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1EA5:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1EF1
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1EFD
; ---------------------------------------------------------------------------

loc_1EF1:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1EFD:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F64h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1F90h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00001F64o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1FA4h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001F9Co
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1FC8h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001FA0o
					; .rdata$r:00002004o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1FD8h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:00001FD4o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1FECh
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
off_2000	dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
					; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2008h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2040h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2074h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_20B6
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_20C2
; ---------------------------------------------------------------------------

loc_20B6:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_20C2:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_2117
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_2123
; ---------------------------------------------------------------------------

loc_2117:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_2123:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2130h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2170h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_222D
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_2224
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_222D

loc_2224:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_2234
; ---------------------------------------------------------------------------

loc_222D:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_2234:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+59p
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+56p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_2285
		xor	eax, eax
		jmp	short loc_22A1
; ---------------------------------------------------------------------------
		jmp	short loc_22A1
; ---------------------------------------------------------------------------

loc_2285:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_229B
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_22A1
; ---------------------------------------------------------------------------
		jmp	short loc_22A1
; ---------------------------------------------------------------------------

loc_229B:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_22A1:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_22EE
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_231F
; ---------------------------------------------------------------------------
		jmp	short loc_231F
; ---------------------------------------------------------------------------

loc_22EE:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_231F:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2338h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2376
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_23D0
; ---------------------------------------------------------------------------
		jmp	short loc_23D0
; ---------------------------------------------------------------------------

loc_2376:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_23C3
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_23C3
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_23C3
		mov	[ebp+var_E5], 1
		jmp	short loc_23CA
; ---------------------------------------------------------------------------

loc_23C3:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_23CA:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_23D0:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2438h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 249Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2500h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2564h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::compareUnicodeString(UElement,UElement)+31p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 267Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 272Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2834h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_287A
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_28AB
; ---------------------------------------------------------------------------
		jmp	short loc_28AB
; ---------------------------------------------------------------------------

loc_287A:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_28AB:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2920h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2978h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_2B76
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_2BAB
; ---------------------------------------------------------------------------
		jmp	short loc_2BAB
; ---------------------------------------------------------------------------

loc_2B76:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_2BAB:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2EB7
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_2EB7
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2EBA
; ---------------------------------------------------------------------------

loc_2EB7:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2EBA:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2ED0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_2FFD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3058h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 314Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3254h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 330Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3374h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_33DF
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_33DF
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_33E2
; ---------------------------------------------------------------------------

loc_33DF:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_33E2:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3518h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 360Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 365Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3724h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3788h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_381C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_381C:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3854h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_388C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_388C:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 393Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_39EC
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_39EC:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_3A6A
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_3A6A:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::setPattern(icu_56::UnicodeString const	&)+73p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax

loc_3FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_405B
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_4060
; ---------------------------------------------------------------------------
		jmp	short loc_4060
; ---------------------------------------------------------------------------

loc_405B:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_4060:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4078h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+112p
					; icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const	&)+7Bp	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4108h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4144h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_4202
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_421F
; ---------------------------------------------------------------------------

loc_4202:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_421F:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4238h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 431Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 436Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4440h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4488h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4544h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 459Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 463Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 468Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near
					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+8Cp
					; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+ABp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4724h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4770h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4808h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 485Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4908h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 495Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_4A34
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_4A3C
; ---------------------------------------------------------------------------

loc_4A34:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_4A3C:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_4A90
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_4A90
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_4AA6
; ---------------------------------------------------------------------------

loc_4A90:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_4AA6:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap
					; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed	char)+FEp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_4BB2
		cmp	[ebp+arg_0], 0
		jnz	short loc_4BB2
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_4BD3
; ---------------------------------------------------------------------------
		jmp	short loc_4BD3
; ---------------------------------------------------------------------------

loc_4BB2:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_4BD1
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_4BD3
; ---------------------------------------------------------------------------
		jmp	short loc_4BD3
; ---------------------------------------------------------------------------

loc_4BD1:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_4BD3:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4BECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeSet::`scalar	deleting destructor'(unsigned int)
		public ??_GUnicodeSet@icu_56@@UAEPAXI@Z
??_GUnicodeSet@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4CC3
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4CC3:				; CODE XREF: icu_56::UnicodeSet::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeSet@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeSet::`vector	deleting destructor'(unsigned int)
		public ??_EUnicodeSet@icu_56@@UAEPAXI@Z
??_EUnicodeSet@icu_56@@UAEPAXI@Z proc near
					; CODE XREF: [thunk]:icu_56::UnicodeSet::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4D3D
		push	offset ??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	34h ; '4'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4D35
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4D35:				; CODE XREF: icu_56::UnicodeSet::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4D5C
; ---------------------------------------------------------------------------

loc_4D3D:				; CODE XREF: icu_56::UnicodeSet::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4D59
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4D59:				; CODE XREF: icu_56::UnicodeSet::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4D5C:				; CODE XREF: icu_56::UnicodeSet::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeSet@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UnicodeSet::operator!=(class icu_56::UnicodeSet const &)const
		public ??9UnicodeSet@icu_56@@QBECABV01@@Z
??9UnicodeSet@icu_56@@QBECABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeSet@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4DD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isFrozen(icu_56::UnicodeSet *__hidden this)
		public ?isFrozen@UnicodeSet@icu_56@@QBECXZ
?isFrozen@UnicodeSet@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+75p
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+58p ...

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_4E0E
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+2Ch], 0
		jnz	short loc_4E0E
		mov	[ebp+var_CD], 0
		jmp	short loc_4E15
; ---------------------------------------------------------------------------

loc_4E0E:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+2Aj
					; icu_56::UnicodeSet::isFrozen(void)+33j
		mov	[ebp+var_CD], 1

loc_4E15:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isFrozen@UnicodeSet@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, int, int)
		public ?containsSome@UnicodeSet@icu_56@@QBECHH@Z
?containsSome@UnicodeSet@icu_56@@QBECHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECHH@Z ; icu_56::UnicodeSet::containsNone(int,int)
		movsx	edx, al
		test	edx, edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?containsSome@UnicodeSet@icu_56@@QBECHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z ;	icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4EC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::UnicodeSet::containsNone(icu_56::UnicodeString const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isBogus(icu_56::UnicodeSet *__hidden this)
		public ?isBogus@UnicodeSet@icu_56@@QBECXZ
?isBogus@UnicodeSet@icu_56@@QBECXZ proc	near
					; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+6Fp
					; icu_56::UnicodeSet::add(int)+55p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movzx	eax, byte ptr [eax+30h]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeSet@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(const struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct USet *__thiscall icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet	*__hidden this)
		public ?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4FCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct USet *__thiscall	icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet *__hidden	this)
		public ?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4FFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::span(class	icu_56::UnicodeString const &, int, enum  USetSpanCondition)const
		public ?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_5039
		mov	[ebp+arg_4], 0
		jmp	short loc_5047
; ---------------------------------------------------------------------------

loc_5039:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_5047
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_5047:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_14]
		sub	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	edx, [ebp+arg_4]
		lea	eax, [eax+edx*2]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		add	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanBack(class icu_56::UnicodeString const	&, int,	enum  USetSpanCondition)const
		public ?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_50C1
		mov	[ebp+arg_4], 0
		jmp	short loc_50CF
; ---------------------------------------------------------------------------

loc_50C1:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_50CF
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_50CF:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		mov	ecx, [ebp+var_8]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PatternProps & __thiscall icu_56::PatternProps::operator=(class	icu_56::PatternProps const &)
		public ??4PatternProps@icu_56@@QAEAAV01@ABV01@@Z
??4PatternProps@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4PatternProps@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5130h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::ICU_Utility & __thiscall icu_56::ICU_Utility::operator=(class icu_56::ICU_Utility const	&)
		public ??4ICU_Utility@icu_56@@QAEAAV01@ABV01@@Z
??4ICU_Utility@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4ICU_Utility@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5160h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		public ?size@UVector@icu_56@@QBEHXZ
?size@UVector@icu_56@@QBEHXZ proc near	; CODE XREF: icu_56::UnicodeSet::size(void)+A7p
					; icu_56::UnicodeSet::isEmpty(void)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@UVector@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5190h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::isEmpty(icu_56::UVector *__hidden this)
		public ?isEmpty@UVector@icu_56@@QBECXZ
?isEmpty@UVector@icu_56@@QBECXZ	proc near ; CODE XREF: icu_56::UStack::empty(void)+26p
					; icu_56::UnicodeSet::freeze(void)+F1p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UVector@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, void *)
		public ?contains@UVector@icu_56@@QBECPAX@Z
?contains@UVector@icu_56@@QBECPAX@Z proc near
					; CODE XREF: icu_56::UnicodeSet::contains(icu_56::UnicodeString	const &)+52p
					; icu_56::UnicodeSet::add(icu_56::UnicodeString	const &)+71p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHPAXH@Z ; icu_56::UVector::indexOf(void *,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, int)
		public ?contains@UVector@icu_56@@QBECH@Z
?contains@UVector@icu_56@@QBECH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHHH@Z ; icu_56::UVector::indexOf(int,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 525Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::firstElement(icu_56::UVector *__hidden this)
		public ?firstElement@UVector@icu_56@@QBEPAXXZ
?firstElement@UVector@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?firstElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::lastElement(icu_56::UVector	*__hidden this)
		public ?lastElement@UVector@icu_56@@QBEPAXXZ
?lastElement@UVector@icu_56@@QBEPAXXZ proc near	; CODE XREF: icu_56::UStack::peek(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::lastElementi(icu_56::UVector *__hidden this)
		public ?lastElementi@UVector@icu_56@@QBEHXZ
?lastElementi@UVector@icu_56@@QBEHXZ proc near ; CODE XREF: icu_56::UStack::peeki(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElementi@UVector@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5338h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::UVector::operator[](int)const
		public ??AUVector@icu_56@@QBEPAXH@Z
??AUVector@icu_56@@QBEPAXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUVector@icu_56@@QBEPAXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5380h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector::operator!=(class icu_56::UVector const &)
		public ??9UVector@icu_56@@QAECABV01@@Z
??9UVector@icu_56@@QAECABV01@@Z	proc near
					; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+7Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8UVector@icu_56@@QAECABV01@@Z	; icu_56::UVector::operator==(icu_56::UVector const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UVector@icu_56@@QAECABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UStack::empty(icu_56::UStack	*__hidden this)
		public ?empty@UStack@icu_56@@QBECXZ
?empty@UStack@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?empty@UStack@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5410h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::peek(icu_56::UStack *__hidden this)
		public ?peek@UStack@icu_56@@QBEPAXXZ
?peek@UStack@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElement@UVector@icu_56@@QBEPAXXZ ;	icu_56::UVector::lastElement(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peek@UStack@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5450h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::peeki(icu_56::UStack *__hidden	this)
		public ?peeki@UStack@icu_56@@QBEHXZ
?peeki@UStack@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElementi@UVector@icu_56@@QBEHXZ ; icu_56::UVector::lastElementi(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peeki@UStack@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5490h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::push(icu_56::UStack *this, void *, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::UVector::addElement(void *,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::push(icu_56::UStack *this, int, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5528h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *__hidden	this)
		public ??0CharString@icu_56@@QAE@XZ
??0CharString@icu_56@@QAE@XZ proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0CharString@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 55BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@XZ$0 proc near ; DATA	XREF: .xdata$x:000055E8o
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::CharString::CharString(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 55E4h
__unwindtable$??0CharString@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA	XREF: .xdata$x:000055F4o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@XZ$0
__ehfuncinfo$??0CharString@icu_56@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *this, const struct icu_56::StringPiece *, enum UErrorCode *)
		public ??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+var_14] ; this
		call	?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 56B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:000056E0o
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::CharString::CharString(icu_56::StringPiece	const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 56DCh
__unwindtable$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000056ECo
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5708h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *this, const struct icu_56::CharString *,	enum UErrorCode	*)
		public ??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::CharString *
		mov	ecx, [ebp+var_14] ; this
		call	?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z ; icu_56::CharString::append(icu_56::CharString const &,UErrorCode	&)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 57ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000057D8o
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::CharString::CharString(icu_56::CharString const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 57D4h
__unwindtable$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000057E4o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@ABV01@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5800h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::CharString(icu_56::CharString *this, const char	*, int,	enum UErrorCode	*)
		public ??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14]
		call	??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::MaybeStackArray<char,40>(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_14]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; char *
		mov	ecx, [ebp+var_14] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 58A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:000058D4o
		mov	ecx, [ebp-14h]
		jmp	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
__unwindfunclet$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::CharString::CharString(char const *,int,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 58D0h
__unwindtable$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000058E0o
		dd offset __unwindfunclet$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0CharString@icu_56@@QAE@PBDHAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 58FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::CharString::~CharString(icu_56::CharString *__hidden this)
		public ??1CharString@icu_56@@QAE@XZ
??1CharString@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1CharString@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 593Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CharString::isEmpty(icu_56::CharString *__hidden this)
		public ?isEmpty@CharString@icu_56@@QBECXZ
?isEmpty@CharString@icu_56@@QBECXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+34h], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@CharString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5970h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharString::length(icu_56::CharString *__hidden this)
		public ?length@CharString@icu_56@@QBEHXZ
?length@CharString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::CharString::append(icu_56::CharString const &,UErrorCode &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+34h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@CharString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char __thiscall icu_56::CharString::operator[](int)const
		public ??ACharString@icu_56@@QBEDH@Z
??ACharString@icu_56@@QBEDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	al, [eax]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??ACharString@icu_56@@QBEDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::CharString::toStringPiece(void)const
		public ?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ
?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+34h]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		push	eax		; char *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@PBDH@Z ; icu_56::StringPiece::StringPiece(char const	*,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?toStringPiece@CharString@icu_56@@QBE?AVStringPiece@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::CharString::data(icu_56::CharString *__hidden this)
		public ?data@CharString@icu_56@@QBEPBDXZ
?data@CharString@icu_56@@QBEPBDXZ proc near
					; CODE XREF: icu_56::CharString::append(icu_56::CharString const &,UErrorCode &)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@CharString@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__thiscall icu_56::CharString::data(icu_56::CharString *__hidden this)
		public ?data@CharString@icu_56@@QAEPADXZ
?data@CharString@icu_56@@QAEPADXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@CharString@icu_56@@QAEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharString *__thiscall	icu_56::CharString::clear(icu_56::CharString *__hidden this)
		public ?clear@CharString@icu_56@@QAEAAV12@XZ
?clear@CharString@icu_56@@QAEAAV12@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+34h], 0
		push	0
		mov	ecx, [ebp+var_8]
		call	??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z ;	icu_56::MaybeStackArray<char,40>::operator[](int)
		mov	byte ptr [eax],	0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@CharString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *this, const struct icu_56::StringPiece *, enum UErrorCode *)
		public ?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z
?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::CharString::CharString(icu_56::StringPiece	const &,UErrorCode &)+73p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@StringPiece@icu_56@@QBEHXZ ; icu_56::StringPiece::length(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?data@StringPiece@icu_56@@QBEPBDXZ ; icu_56::StringPiece::data(void)
		push	eax		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@CharString@icu_56@@QAEAAV12@ABVStringPiece@2@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *this, const struct icu_56::CharString *,	enum UErrorCode	*)
		public ?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z
?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::CharString::CharString(icu_56::CharString const &,UErrorCode &)+73p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@CharString@icu_56@@QBEHXZ ; icu_56::CharString::length(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?data@CharString@icu_56@@QBEPBDXZ ; icu_56::CharString::data(void)
		push	eax		; char *
		mov	ecx, [ebp+var_8] ; this
		call	?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z ; icu_56::CharString::append(char const *,int,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@CharString@icu_56@@QAEAAV12@ABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5BC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SymbolTable::~SymbolTable(icu_56::SymbolTable *__hidden this)
		public ??1SymbolTable@icu_56@@UAE@XZ
??1SymbolTable@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::SymbolTable::`scalar deleting destructor'(uint)+26p
					; icu_56::SymbolTable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`vftable'
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??1SymbolTable@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5BF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UnicodeSet::getStaticClassID()
		public ?getStaticClassID@UnicodeSet@icu_56@@SAPAXXZ
?getStaticClassID@UnicodeSet@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::UnicodeSet::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@UnicodeSet@icu_56@@SAPAXXZ@4DA ; char	`icu_56::UnicodeSet::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@UnicodeSet@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UnicodeSet::getDynamicClassID(icu_56::UnicodeSet *__hidden this)
		public ?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ
?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ proc near ; DATA	XREF: .rdata:00005E28o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@UnicodeSet@icu_56@@SAPAXXZ ; icu_56::UnicodeSet::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *__hidden	this)
		public ??0UnicodeSet@icu_56@@QAE@XZ
??0UnicodeSet@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeString const &)+45p
					; icu_56::UnicodeSet::complementAll(icu_56::UnicodeString const	&)+45p	...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSet@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UnicodeFilter@icu_56@@QAE@XZ	; icu_56::UnicodeFilter::UnicodeFilter(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], offset ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 11h
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+30h], 0
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::allocateStrings(UErrorCode &)
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_5D53
		jmp	short loc_5D8A
; ---------------------------------------------------------------------------

loc_5D53:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+F3j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+10h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_5D82
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	dword ptr [ecx], 110000h
		jmp	short loc_5D8A
; ---------------------------------------------------------------------------

loc_5D82:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+116j
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)

loc_5D8A:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+F5j
					; icu_56::UnicodeSet::UnicodeSet(void)+124j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeSet@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
$LN10		dd 1			; DATA XREF: icu_56::UnicodeSet::UnicodeSet(void)+13Co
		dd offset $LN9
$LN9		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00005DC8o
		dd offset $LN7		; "status"
$LN7		db 'status',0           ; DATA XREF: .text:00005DD4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5DE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSet@icu_56@@QAE@XZ$0 proc near ; DATA	XREF: .xdata$x:00005E98o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
__unwindfunclet$??0UnicodeSet@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSet@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSet@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSet@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E08h
		dd offset ??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
;
; Exported entry
;
		public ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeSet@icu_56@@W3AEPAXI@Z
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(void)+5Do
					; icu_56::UnicodeSet::UnicodeSet(int,int)+5Do ...
					; [thunk]:icu_56::UnicodeSet::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z ; icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed	char)
		dd offset ?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z	; icu_56::UnicodeSet::toPattern(icu_56::UnicodeString &,signed char)
		dd offset ?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z	; icu_56::UnicodeSet::matchesIndexValue(uchar)
		dd offset ?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z ; icu_56::UnicodeSet::addMatchSetTo(icu_56::UnicodeSet	&)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5E20h
		dd offset ??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
;
; Exported entry
;
		public ??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeSet@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(void)+54o
					; icu_56::UnicodeSet::UnicodeSet(int,int)+54o ...
					; icu_56::UnicodeSet::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeSet@icu_56@@UBEPAXXZ ; icu_56::UnicodeSet::getDynamicClassID(void)
		dd offset ?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ ;	icu_56::UnicodeSet::clone(void)
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset ?contains@UnicodeSet@icu_56@@UBECH@Z ; icu_56::UnicodeSet::contains(int)
		dd offset ??8UnicodeSet@icu_56@@UBECABV01@@Z ; icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)
		dd offset ?hashCode@UnicodeSet@icu_56@@UBEHXZ ;	icu_56::UnicodeSet::hashCode(void)
		dd offset ?size@UnicodeSet@icu_56@@UBEHXZ ; icu_56::UnicodeSet::size(void)
		dd offset ?isEmpty@UnicodeSet@icu_56@@UBECXZ ; icu_56::UnicodeSet::isEmpty(void)
		dd offset ?contains@UnicodeSet@icu_56@@UBECHH@Z	; icu_56::UnicodeSet::contains(int,int)
		dd offset ?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z ; icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet const &)
		dd offset ?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z	; icu_56::UnicodeSet::add(int,int)
		dd offset ?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)
		dd offset ?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)
		dd offset ?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ;	icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const &)
		dd offset ?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z ; icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)
		dd offset ?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::retain(int,int)
		dd offset ?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::remove(int,int)
		dd offset ?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::complement(int,int)
		dd offset ?complement@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::complement(void)
		dd offset ?clear@UnicodeSet@icu_56@@UAEAAV12@XZ	; icu_56::UnicodeSet::clear(void)
		dd offset ?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::removeAllStrings(void)
		dd offset ?getRangeCount@UnicodeSet@icu_56@@UBEHXZ ; icu_56::UnicodeSet::getRangeCount(void)
		dd offset ?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z ; icu_56::UnicodeSet::getRangeStart(int)
		dd offset ?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z ; icu_56::UnicodeSet::getRangeEnd(int)
		dd offset ?compact@UnicodeSet@icu_56@@UAEAAV12@XZ ; icu_56::UnicodeSet::compact(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5E94h
__unwindtable$??0UnicodeSet@icu_56@@QAE@XZ dd 0FFFFFFFFh ; DATA	XREF: .xdata$x:00005EA4o
		dd offset __unwindfunclet$??0UnicodeSet@icu_56@@QAE@XZ$0
__ehfuncinfo$??0UnicodeSet@icu_56@@QAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??0UnicodeSet@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0UnicodeSet@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5EC0h
		public ??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ dd	3 dup(0) ; DATA	XREF: .rdata:00005E20o
		dd offset ??_R0?AVUnicodeSet@icu_56@@@8	; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5ED4h
		public ??_R0?AVUnicodeSet@icu_56@@@8
; class	icu_56::UnicodeSet `RTTI Type Descriptor'
??_R0?AVUnicodeSet@icu_56@@@8 dd offset	??_7type_info@@6B@ ; DATA XREF:	.rdata$r:00005ECCo
					; .rdata$r:icu_56::UnicodeSet::`RTTI Base Class	Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		dd 0
a_?avunicodeset	db '.?AVUnicodeSet@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5EF4h
		public ??_R3UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeSet@icu_56@@8 dd 0		; DATA XREF: .rdata$r:00005ED0o
					; .rdata$r:00005F38o ...
		dd 1, 6
		dd offset ??_R2UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5F04h
		public ??_R2UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Base Class Array'
??_R2UnicodeSet@icu_56@@8 dd offset ??_R1A@?0A@EA@UnicodeSet@icu_56@@8
					; DATA XREF: .rdata$r:00005F00o
					; icu_56::UnicodeSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8	; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5F20h
		public ??_R1A@?0A@EA@UnicodeSet@icu_56@@8
; icu_56::UnicodeSet::`RTTI Base Class Descriptor at (0, -1, 0,	64)'
??_R1A@?0A@EA@UnicodeSet@icu_56@@8 dd offset ??_R0?AVUnicodeSet@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeSet::`RTTI	Base Class Array'o
					; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd 5, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5F3Ch
		public ??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeSet::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ dd	0 ; DATA XREF: .rdata:00005E08o
		dd 4, 0
		dd offset ??_R0?AVUnicodeSet@icu_56@@@8	; icu_56::UnicodeSet `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeSet@icu_56@@8 ; icu_56::UnicodeSet::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+E6p
					; icu_56::UnicodeSet::UnicodeSet(int,int)+E6p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5F7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *this, int, int)
		public ??0UnicodeSet@icu_56@@QAE@HH@Z
??0UnicodeSet@icu_56@@QAE@HH@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSet@icu_56@@QAE@HH@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UnicodeFilter@icu_56@@QAE@XZ	; icu_56::UnicodeFilter::UnicodeFilter(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], offset ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 11h
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+30h], 0
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::allocateStrings(UErrorCode &)
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6073
		jmp	short loc_60BA
; ---------------------------------------------------------------------------

loc_6073:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(int,int)+F3j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+10h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_60B2
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	dword ptr [ecx], 110000h
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_14] ; this
		call	?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z ; icu_56::UnicodeSet::complement(int,int)
		jmp	short loc_60BA
; ---------------------------------------------------------------------------

loc_60B2:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(int,int)+116j
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)

loc_60BA:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(int,int)+F5j
					; icu_56::UnicodeSet::UnicodeSet(int,int)+134j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN10_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UnicodeSet@icu_56@@QAE@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN10_0		dd 1			; DATA XREF: icu_56::UnicodeSet::UnicodeSet(int,int)+14Co
		dd offset $LN9_0
$LN9_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:000060FCo
		dd offset $LN7_0	; "status"
$LN7_0		db 'status',0           ; DATA XREF: .text:00006108o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6114h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSet@icu_56@@QAE@HH@Z$0 proc near ; DATA XREF:	.xdata$x:00006140o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
__unwindfunclet$??0UnicodeSet@icu_56@@QAE@HH@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSet@icu_56@@QAE@HH@Z proc	near
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(int,int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSet@icu_56@@QAE@HH@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSet@icu_56@@QAE@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 613Ch
__unwindtable$??0UnicodeSet@icu_56@@QAE@HH@Z dd	0FFFFFFFFh ; DATA XREF:	.xdata$x:0000614Co
		dd offset __unwindfunclet$??0UnicodeSet@icu_56@@QAE@HH@Z$0
__ehfuncinfo$??0UnicodeSet@icu_56@@QAE@HH@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UnicodeSet@icu_56@@QAE@HH@Z+14o
		dd offset __unwindtable$??0UnicodeSet@icu_56@@QAE@HH@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6168h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ??0UnicodeSet@icu_56@@QAE@ABV01@@Z
??0UnicodeSet@icu_56@@QAE@ABV01@@Z proc	near
					; CODE XREF: icu_56::UnicodeSet::clone(void)+6Cp

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSet@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeFilter *
		mov	ecx, [ebp+var_14] ; this
		call	??0UnicodeFilter@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], offset ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+arg_0] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_61F7
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[ebp+var_E8], edx
		jmp	short loc_6206
; ---------------------------------------------------------------------------

loc_61F7:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+7Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		add	ecx, 10h
		mov	[ebp+var_E8], ecx

loc_6206:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+8Dj
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_E8]
		mov	[edx+0Ch], eax
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+30h], 0
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::allocateStrings(UErrorCode &)
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6291
		jmp	short loc_62C8
; ---------------------------------------------------------------------------

loc_6291:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+125j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+10h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_62C0
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeSet *
		mov	ecx, [ebp+var_14]
		call	??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z	; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)
		jmp	short loc_62C8
; ---------------------------------------------------------------------------

loc_62C0:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+148j
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)

loc_62C8:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+127j
					; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+156j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN12
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeSet@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
$LN12		dd 1			; DATA XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+16Eo
		dd offset $LN11
$LN11		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00006308o
		dd offset $LN9_1	; "status"
$LN9_1		db 'status',0           ; DATA XREF: .text:00006314o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSet@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000634Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
__unwindfunclet$??0UnicodeSet@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSet@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0ECh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSet@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSet@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6348h
__unwindtable$??0UnicodeSet@icu_56@@QAE@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006358o
		dd offset __unwindfunclet$??0UnicodeSet@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0UnicodeSet@icu_56@@QAE@ABV01@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UnicodeSet@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0UnicodeSet@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6374h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *,	signed __int8)
		public ??0UnicodeSet@icu_56@@AAE@ABV01@C@Z
??0UnicodeSet@icu_56@@AAE@ABV01@C@Z proc near
					; CODE XREF: icu_56::UnicodeSet::cloneAsThawed(void)+6Ep

var_138		= dword	ptr -138h
var_134		= dword	ptr -134h
var_12C		= byte ptr -12Ch
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_138]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeFilter *
		mov	ecx, [ebp+var_18] ; this
		call	??0UnicodeFilter@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax], offset	??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+4], offset ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		add	ecx, 10h
		mov	edx, [ebp+var_18]
		mov	[edx+0Ch], ecx
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_18]
		mov	byte ptr [eax+30h], 0
		mov	[ebp+var_24], 0
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_18] ; this
		call	?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::allocateStrings(UErrorCode &)
		mov	eax, [ebp+var_24]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_647A
		jmp	loc_6575
; ---------------------------------------------------------------------------

loc_647A:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+FFj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_18]
		mov	[edx+10h], eax
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+10h], 0
		jz	loc_656D
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_18]
		mov	eax, [edx+8]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		push	edx		; Src
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+10h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_650B
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_650B
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		push	offset ?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z ; void (__cdecl *)(union	UElement *, union UElement *)
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		push	edx		; struct icu_56::UVector *
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]	; this
		call	?assign@UVector@icu_56@@QAEXABV12@P6AXPATUElement@@1@ZAAW4UErrorCode@@@Z ; icu_56::UVector::assign(icu_56::UVector const &,void	(*)(UElement *,UElement	*),UErrorCode &)
		jmp	short loc_6515
; ---------------------------------------------------------------------------

loc_650B:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+16Fj
					; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+178j
		mov	ecx, [ebp+var_18] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	short loc_6575
; ---------------------------------------------------------------------------

loc_6515:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+195j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+24h], 0
		jz	short loc_656B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+24h]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_12C] ; this
		call	??0UnicodeString@icu_56@@QAE@PB_WH@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *,int)
		mov	[ebp+var_134], eax
		mov	ecx, [ebp+var_134]
		mov	[ebp+var_138], ecx
		mov	byte ptr [ebp+var_4], 1
		mov	edx, [ebp+var_138]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?setPattern@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z ; icu_56::UnicodeSet::setPattern(icu_56::UnicodeString	const &)
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_12C] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_656B:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+1A8j
		jmp	short loc_6575
; ---------------------------------------------------------------------------

loc_656D:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+125j
		mov	ecx, [ebp+var_18] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)

loc_6575:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+101j
					; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+19Fj ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_18]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UnicodeSet@icu_56@@AAE@ABV01@C@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN14		dd 1			; DATA XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+20Fo
		dd offset $LN13
$LN13		dd 0FFFFFFDCh, 4	; DATA XREF: .text:000065C0o
		dd offset $LN11_0	; "status"
$LN11_0		db 'status',0           ; DATA XREF: .text:000065CCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 65D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z$0 proc near
					; DATA XREF: .xdata$x:00006618o
		mov	ecx, [ebp-18h]	; this
		jmp	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
__unwindfunclet$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z$1 proc near
					; DATA XREF: .xdata$x:00006620o
		lea	ecx, [ebp-12Ch]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z	proc near
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-13Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6614h
__unwindtable$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000662Co
		dd offset __unwindfunclet$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z$0
		align 10h
		dd offset __unwindfunclet$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z$1
__ehfuncinfo$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z+1Eo
		dd offset __unwindtable$??0UnicodeSet@icu_56@@AAE@ABV01@C@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6648h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::cloneUnicodeString(union UElement	*, union UElement *)
?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z	proc near
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+17Eo
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1B8o

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		push	40h ; '@'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_D4], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_D4], 0
		jz	short loc_66BE
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_D4] ; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	[ebp+var_E8], eax
		jmp	short loc_66C8
; ---------------------------------------------------------------------------

loc_66BE:				; CODE XREF: icu_56::cloneUnicodeString(UElement *,UElement *)+5Bj
		mov	[ebp+var_E8], 0

loc_66C8:				; CODE XREF: icu_56::cloneUnicodeString(UElement *,UElement *)+74j
		mov	edx, [ebp+var_E8]
		mov	[ebp+var_E0], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_E0]
		mov	[eax], ecx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6708h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z$0 proc near
					; DATA XREF: .xdata$x:00006738o
		mov	eax, [ebp-0D4h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z proc near
					; DATA XREF: icu_56::cloneUnicodeString(UElement *,UElement *)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0ECh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z
		jmp	___CxxFrameHandler3
__ehhandler$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6734h
__unwindtable$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006744o
		dd offset __unwindfunclet$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z$0
__ehfuncinfo$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z+14o
		dd offset __unwindtable$?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6760h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeSet::~UnicodeSet(icu_56::UnicodeSet *__hidden this)
		public ??1UnicodeSet@icu_56@@UAE@XZ
??1UnicodeSet@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::UnicodeSet::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeSet::`vector deleting destructor'(uint)+64p ...

var_124		= dword	ptr -124h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1UnicodeSet@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], offset ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14h]
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_110]
		mov	[ebp+var_11C], edx
		cmp	[ebp+var_11C], 0
		jz	short loc_6811
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_11C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_11C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_124], eax
		jmp	short loc_681B
; ---------------------------------------------------------------------------

loc_6811:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+8Aj
		mov	[ebp+var_124], 0

loc_681B:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+AFj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_6833
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_6833:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+C2j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_6879
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_124], eax
		jmp	short loc_6883
; ---------------------------------------------------------------------------

loc_6879:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+F2j
		mov	[ebp+var_124], 0

loc_6883:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+117j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2Ch]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_68B9
		push	1
		mov	ecx, [ebp+var_EC]
		call	??_GUnicodeSetStringSpan@icu_56@@QAEPAXI@Z ; icu_56::UnicodeSetStringSpan::`scalar deleting destructor'(uint)
		mov	[ebp+var_124], eax
		jmp	short loc_68C3
; ---------------------------------------------------------------------------

loc_68B9:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+142j
		mov	[ebp+var_124], 0

loc_68C3:				; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+157j
		mov	ecx, [ebp+var_14] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UnicodeSet@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 68FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1UnicodeSet@icu_56@@UAE@XZ$0 proc near ; DATA	XREF: .xdata$x:00006928o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
__unwindfunclet$??1UnicodeSet@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1UnicodeSet@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::UnicodeSet::~UnicodeSet(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-128h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1UnicodeSet@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1UnicodeSet@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6924h
__unwindtable$??1UnicodeSet@icu_56@@UAE@XZ dd 0FFFFFFFFh ; DATA	XREF: .xdata$x:00006934o
		dd offset __unwindfunclet$??1UnicodeSet@icu_56@@UAE@XZ$0
__ehfuncinfo$??1UnicodeSet@icu_56@@UAE@XZ dd 19930522h,	1
					; DATA XREF: __ehhandler$??1UnicodeSet@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1UnicodeSet@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6950h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::UnicodeSetStringSpan::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeSetStringSpan@icu_56@@QAEPAXI@Z
??_GUnicodeSetStringSpan@icu_56@@QAEPAXI@Z proc	near
					; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+14Cp
					; icu_56::UnicodeSet::freeze(void)+1B1p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_698F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_698F:				; CODE XREF: icu_56::UnicodeSetStringSpan::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeSetStringSpan@icu_56@@QAEPAXI@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 69A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeSet::operator=(icu_56::UnicodeSet *)
		public ??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z	proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)+151p

var_168		= dword	ptr -168h
var_164		= dword	ptr -164h
var_15C		= byte ptr -15Ch
var_114		= dword	ptr -114h
var_108		= dword	ptr -108h
var_FC		= dword	ptr -0FCh
var_F0		= dword	ptr -0F0h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 15Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_168]
		mov	ecx, 57h ; 'W'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	eax, [ebp+var_18]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_69FD
		mov	eax, [ebp+var_18]
		jmp	loc_6C8B
; ---------------------------------------------------------------------------

loc_69FD:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+4Bj
		mov	ecx, [ebp+var_18] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6A14
		mov	eax, [ebp+var_18]
		jmp	loc_6C8B
; ---------------------------------------------------------------------------

loc_6A14:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+62j
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6A33
		mov	ecx, [ebp+var_18] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		mov	eax, [ebp+var_18]
		jmp	loc_6C8B
; ---------------------------------------------------------------------------

loc_6A33:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+79j
		mov	[ebp+var_24], 0
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		push	edx		; int
		mov	ecx, [ebp+var_18] ; this
		call	?ensureCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_24]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6A68
		mov	eax, [ebp+var_18]
		jmp	loc_6C8B
; ---------------------------------------------------------------------------

loc_6A68:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+B6j
		mov	eax, [ebp+var_18]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_18]
		mov	eax, [edx+8]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		push	edx		; Src
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+10h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_6ABD
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+14h], 0
		jmp	loc_6B4A
; ---------------------------------------------------------------------------

loc_6ABD:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+104j
		push	314h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_108], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_108], 0
		jz	short loc_6B08
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+var_18]
		mov	eax, [edx+10h]
		push	eax		; int *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+14h]
		push	edx		; struct icu_56::BMPSet	*
		mov	ecx, [ebp+var_108] ; this
		call	??0BMPSet@icu_56@@QAE@ABV01@PBHH@Z ; icu_56::BMPSet::BMPSet(icu_56::BMPSet const &,int const *,int)
		mov	[ebp+var_164], eax
		jmp	short loc_6B12
; ---------------------------------------------------------------------------

loc_6B08:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+136j
		mov	[ebp+var_164], 0

loc_6B12:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+15Ej
		mov	eax, [ebp+var_164]
		mov	[ebp+var_114], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_18]
		mov	edx, [ebp+var_114]
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_6B4A
		mov	ecx, [ebp+var_18] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		mov	eax, [ebp+var_18]
		jmp	loc_6C8B
; ---------------------------------------------------------------------------

loc_6B4A:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+110j
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+190j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_6B79
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_6B79
		lea	eax, [ebp+var_24]
		push	eax		; enum UErrorCode *
		push	offset ?cloneUnicodeString@icu_56@@YAXPATUElement@@0@Z ; void (__cdecl *)(union	UElement *, union UElement *)
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		push	edx		; struct icu_56::UVector *
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]	; this
		call	?assign@UVector@icu_56@@QAEXABV12@P6AXPATUElement@@1@ZAAW4UErrorCode@@@Z ; icu_56::UVector::assign(icu_56::UVector const &,void	(*)(UElement *,UElement	*),UErrorCode &)
		jmp	short loc_6B89
; ---------------------------------------------------------------------------

loc_6B79:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1A9j
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1B2j
		mov	ecx, [ebp+var_18] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		mov	eax, [ebp+var_18]
		jmp	loc_6C8B
; ---------------------------------------------------------------------------

loc_6B89:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1CFj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+2Ch], 0
		jnz	short loc_6BA1
		mov	eax, [ebp+var_18]
		mov	dword ptr [eax+2Ch], 0
		jmp	loc_6C24
; ---------------------------------------------------------------------------

loc_6BA1:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1E8j
		push	0D8h ; ''      ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_F0], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_F0], 0
		jz	short loc_6BE5
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]
		push	ecx		; struct icu_56::UVector *
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+2Ch]
		push	eax		; struct icu_56::UnicodeSetStringSpan *
		mov	ecx, [ebp+var_F0] ; this
		call	??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z ; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan const &,icu_56::UVector const &)
		mov	[ebp+var_164], eax
		jmp	short loc_6BEF
; ---------------------------------------------------------------------------

loc_6BE5:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+21Aj
		mov	[ebp+var_164], 0

loc_6BEF:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+23Bj
		mov	ecx, [ebp+var_164]
		mov	[ebp+var_FC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_18]
		mov	eax, [ebp+var_FC]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+2Ch], 0
		jnz	short loc_6C24
		mov	ecx, [ebp+var_18] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		mov	eax, [ebp+var_18]
		jmp	short loc_6C8B
; ---------------------------------------------------------------------------

loc_6C24:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1F4j
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+26Dj
		mov	ecx, [ebp+var_18] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+24h], 0
		jz	short loc_6C88
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+24h]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_15C] ; this
		call	??0UnicodeString@icu_56@@QAE@PB_WH@Z ; icu_56::UnicodeString::UnicodeString(wchar_t const *,int)
		mov	[ebp+var_164], eax
		mov	ecx, [ebp+var_164]
		mov	[ebp+var_168], ecx
		mov	[ebp+var_4], 2
		mov	edx, [ebp+var_168]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_18] ; this
		call	?setPattern@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z ; icu_56::UnicodeSet::setPattern(icu_56::UnicodeString	const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_15C] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)

loc_6C88:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+28Bj
		mov	eax, [ebp+var_18]

loc_6C8B:				; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+50j
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+67j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN26
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 168h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
$LN26		dd 1			; DATA XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+2E7o
		dd offset $LN25
$LN25		dd 0FFFFFFDCh, 4	; DATA XREF: .text:00006CCCo
		dd offset $LN23
$LN23		db 65h,	63h, 0		; DATA XREF: .text:00006CD8o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6CE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00006D34o
		mov	eax, [ebp-108h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00006D3Co
		mov	eax, [ebp-0F0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$2 proc near
					; DATA XREF: .xdata$x:00006D44o
		lea	ecx, [ebp-15Ch]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$2 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-16Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6D30h
__unwindtable$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006D50o
		dd offset __unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$1
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z$2
__ehfuncinfo$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z dd	19930522h, 3
					; DATA XREF: __ehhandler$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z+1Eo
		dd offset __unwindtable$??4UnicodeSet@icu_56@@QAEAAV01@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6D6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::clone(icu_56::UnicodeSet *__hidden this)
		public ?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ
?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ proc near ;	DATA XREF: .rdata:00005E2Co

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		push	34h ; '4'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_6DE5
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_E0] ; this
		call	??0UnicodeSet@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_6DEF
; ---------------------------------------------------------------------------

loc_6DE5:				; CODE XREF: icu_56::UnicodeSet::clone(void)+60j
		mov	[ebp+var_F4], 0

loc_6DEF:				; CODE XREF: icu_56::UnicodeSet::clone(void)+77j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6E28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ$0 proc near
					; DATA XREF: .xdata$x:00006E58o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ	proc near
					; DATA XREF: icu_56::UnicodeSet::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6E54h
__unwindtable$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006E64o
		dd offset __unwindfunclet$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ$0
__ehfuncinfo$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ+14o
		dd offset __unwindtable$?clone@UnicodeSet@icu_56@@UBEPAVUnicodeFunctor@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6E80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::cloneAsThawed(icu_56::UnicodeSet *__hidden this)
		public ?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ
?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		push	34h ; '4'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_6EFB
		push	1		; signed __int8
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_E0] ; this
		call	??0UnicodeSet@icu_56@@AAE@ABV01@C@Z ; icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet	const &,signed char)
		mov	[ebp+var_F4], eax
		jmp	short loc_6F05
; ---------------------------------------------------------------------------

loc_6EFB:				; CODE XREF: icu_56::UnicodeSet::cloneAsThawed(void)+60j
		mov	[ebp+var_F4], 0

loc_6F05:				; CODE XREF: icu_56::UnicodeSet::cloneAsThawed(void)+79j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6F40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ$0 proc near
					; DATA XREF: .xdata$x:00006F70o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ	proc near
					; DATA XREF: icu_56::UnicodeSet::cloneAsThawed(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6F6Ch
__unwindtable$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006F7Co
		dd offset __unwindfunclet$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ$0
__ehfuncinfo$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ+14o
		dd offset __unwindtable$?cloneAsThawed@UnicodeSet@icu_56@@QBEPAVUnicodeFunctor@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::UnicodeSet::operator==(class icu_56::UnicodeSet const &)const
		public ??8UnicodeSet@icu_56@@UBECABV01@@Z
??8UnicodeSet@icu_56@@UBECABV01@@Z proc	near ; DATA XREF: .rdata:00005E40o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+8]
		cmp	edx, [ecx+8]
		jz	short loc_6FCD
		xor	al, al
		jmp	short loc_7029
; ---------------------------------------------------------------------------

loc_6FCD:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+2Fj
		mov	[ebp+var_14], 0
		jmp	short loc_6FDF
; ---------------------------------------------------------------------------

loc_6FD6:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &):loc_7008j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_6FDF:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+8]
		jge	short loc_700A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+edx*4]
		cmp	ecx, [eax+esi*4]
		jz	short loc_7008
		xor	al, al
		jmp	short loc_7029
; ---------------------------------------------------------------------------

loc_7008:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+6Aj
		jmp	short loc_6FD6
; ---------------------------------------------------------------------------

loc_700A:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+50j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+28h]
		call	??9UVector@icu_56@@QAECABV01@@Z	; icu_56::UVector::operator!=(icu_56::UVector const &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7027
		xor	al, al
		jmp	short loc_7029
; ---------------------------------------------------------------------------

loc_7027:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+89j
		mov	al, 1

loc_7029:				; CODE XREF: icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+33j
					; icu_56::UnicodeSet::operator==(icu_56::UnicodeSet const &)+6Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeSet@icu_56@@UBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7040h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::hashCode(icu_56::UnicodeSet *__hidden this)
		public ?hashCode@UnicodeSet@icu_56@@UBEHXZ
?hashCode@UnicodeSet@icu_56@@UBEHXZ proc near ;	DATA XREF: .rdata:00005E44o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		jmp	short loc_707E
; ---------------------------------------------------------------------------

loc_7075:				; CODE XREF: icu_56::UnicodeSet::hashCode(void)+67j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_707E:				; CODE XREF: icu_56::UnicodeSet::hashCode(void)+33j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+8]
		jge	short loc_70A9
		mov	eax, [ebp+var_14]
		imul	eax, 0F4243h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ebp+var_14]
		add	eax, [ecx+edx*4]
		mov	[ebp+var_14], eax
		jmp	short loc_7075
; ---------------------------------------------------------------------------

loc_70A9:				; CODE XREF: icu_56::UnicodeSet::hashCode(void)+47j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeSet@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 70B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::size(icu_56::UnicodeSet *__hidden this)
		public ?size@UnicodeSet@icu_56@@UBEHXZ
?size@UnicodeSet@icu_56@@UBEHXZ	proc near ; DATA XREF: .rdata:00005E48o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	[ebp+var_2C], 0
		jmp	short loc_7109
; ---------------------------------------------------------------------------

loc_7100:				; CODE XREF: icu_56::UnicodeSet::size(void)+9Fj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_7109:				; CODE XREF: icu_56::UnicodeSet::size(void)+4Aj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	short loc_7155
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, eax
		mov	edi, esp
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+64h]
		call	edx
		cmp	edi, esp
		call	__RTC_CheckEsp
		sub	esi, eax
		mov	eax, [ebp+var_14]
		lea	ecx, [eax+esi+1]
		mov	[ebp+var_14], ecx
		jmp	short loc_7100
; ---------------------------------------------------------------------------

loc_7155:				; CODE XREF: icu_56::UnicodeSet::size(void)+5Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		add	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?size@UnicodeSet@icu_56@@UBEHXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7178h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isEmpty(icu_56::UnicodeSet *__hidden this)
		public ?isEmpty@UnicodeSet@icu_56@@UBECXZ
?isEmpty@UnicodeSet@icu_56@@UBECXZ proc	near ; DATA XREF: .rdata:00005E4Co

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 1
		jnz	short loc_71BC
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		test	eax, eax
		jnz	short loc_71BC
		mov	[ebp+var_CD], 1
		jmp	short loc_71C3
; ---------------------------------------------------------------------------

loc_71BC:				; CODE XREF: icu_56::UnicodeSet::isEmpty(void)+2Aj
					; icu_56::UnicodeSet::isEmpty(void)+39j
		mov	[ebp+var_CD], 0

loc_71C3:				; CODE XREF: icu_56::UnicodeSet::isEmpty(void)+42j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeSet@icu_56@@UBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::contains(icu_56::UnicodeSet *this, int)
		public ?contains@UnicodeSet@icu_56@@UBECH@Z
?contains@UnicodeSet@icu_56@@UBECH@Z proc near ; DATA XREF: .rdata:00005E3Co

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_722E
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [edx]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_726A
; ---------------------------------------------------------------------------

loc_722E:				; CODE XREF: icu_56::UnicodeSet::contains(int)+2Aj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_7248
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+2Ch]	; this
		call	?contains@UnicodeSetStringSpan@icu_56@@QBECH@Z ; icu_56::UnicodeSetStringSpan::contains(int)
		jmp	short loc_726A
; ---------------------------------------------------------------------------

loc_7248:				; CODE XREF: icu_56::UnicodeSet::contains(int)+55j
		cmp	[ebp+arg_0], 110000h
		jl	short loc_7255
		xor	al, al
		jmp	short loc_726A
; ---------------------------------------------------------------------------

loc_7255:				; CODE XREF: icu_56::UnicodeSet::contains(int)+6Fj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z ; icu_56::UnicodeSet::findCodePoint(int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 1

loc_726A:				; CODE XREF: icu_56::UnicodeSet::contains(int)+4Cj
					; icu_56::UnicodeSet::contains(int)+66j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UnicodeSet@icu_56@@UBECH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7280h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSetStringSpan::contains(icu_56::UnicodeSetStringSpan *this, int)
		public ?contains@UnicodeSetStringSpan@icu_56@@QBECH@Z
?contains@UnicodeSetStringSpan@icu_56@@QBECH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::contains(int)+61p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UnicodeSetStringSpan@icu_56@@QBECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::findCodePoint(icu_56::UnicodeSet *this, int)
		public ?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z
?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::contains(int)+7Cp
					; icu_56::UnicodeSet::contains(int,int)+2Ap ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [ecx]
		jge	short loc_7308
		xor	eax, eax
		jmp	short loc_7375
; ---------------------------------------------------------------------------

loc_7308:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+2Ej
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jge	short loc_7335
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4-4]
		jl	short loc_733A

loc_7335:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+4Dj
		mov	eax, [ebp+var_20]
		jmp	short loc_7375
; ---------------------------------------------------------------------------

loc_733A:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+5Fj
					; icu_56::UnicodeSet::findCodePoint(int):loc_7370j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]
		sar	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_14]
		jnz	short loc_7351
		jmp	short loc_7372
; ---------------------------------------------------------------------------
		jmp	short loc_7370
; ---------------------------------------------------------------------------

loc_7351:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+77j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4]
		jge	short loc_736A
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		jmp	short loc_7370
; ---------------------------------------------------------------------------

loc_736A:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+8Cj
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_14], eax

loc_7370:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+7Bj
					; icu_56::UnicodeSet::findCodePoint(int)+94j
		jmp	short loc_733A
; ---------------------------------------------------------------------------

loc_7372:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+79j
		mov	eax, [ebp+var_20]

loc_7375:				; CODE XREF: icu_56::UnicodeSet::findCodePoint(int)+32j
					; icu_56::UnicodeSet::findCodePoint(int)+64j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7380h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::contains(icu_56::UnicodeSet *this, int, int)
		public ?contains@UnicodeSet@icu_56@@UBECHH@Z
?contains@UnicodeSet@icu_56@@UBECHH@Z proc near	; DATA XREF: .rdata:00005E50o

var_DC		= byte ptr -0DCh
var_D9		= byte ptr -0D9h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z ; icu_56::UnicodeSet::findCodePoint(int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 1
		jz	short loc_73D4
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [edx+eax*4]
		jge	short loc_73D4
		mov	[ebp+var_D9], 1
		jmp	short loc_73DB
; ---------------------------------------------------------------------------

loc_73D4:				; CODE XREF: icu_56::UnicodeSet::contains(int,int)+38j
					; icu_56::UnicodeSet::contains(int,int)+49j
		mov	[ebp+var_D9], 0

loc_73DB:				; CODE XREF: icu_56::UnicodeSet::contains(int,int)+52j
		mov	al, [ebp+var_D9]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?contains@UnicodeSet@icu_56@@UBECHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::contains(icu_56::UnicodeSet *this, const	struct icu_56::UnicodeString *)
		public ?contains@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?contains@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		test	eax, eax
		jnz	short loc_742B
		xor	al, al
		jmp	short loc_746D
; ---------------------------------------------------------------------------

loc_742B:				; CODE XREF: icu_56::UnicodeSet::contains(icu_56::UnicodeString	const &)+2Dj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z ; icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_7453
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?contains@UVector@icu_56@@QBECPAX@Z ; icu_56::UVector::contains(void *)
		jmp	short loc_746D
; ---------------------------------------------------------------------------
		jmp	short loc_746D
; ---------------------------------------------------------------------------

loc_7453:				; CODE XREF: icu_56::UnicodeSet::contains(icu_56::UnicodeString	const &)+46j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_746D:				; CODE XREF: icu_56::UnicodeSet::contains(icu_56::UnicodeString	const &)+31j
					; icu_56::UnicodeSet::contains(icu_56::UnicodeString const &)+57j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7484h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z
?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z proc near ; DATA XREF: .rdata:00005E54o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		jmp	short loc_74D2
; ---------------------------------------------------------------------------

loc_74C9:				; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &):loc_7531j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_74D2:				; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &)+43j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_7533
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		push	eax
		mov	edi, esp
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+64h]
		call	edx
		cmp	edi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_7531
		xor	al, al
		jmp	short loc_7552
; ---------------------------------------------------------------------------

loc_7531:				; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &)+A7j
		jmp	short loc_74C9
; ---------------------------------------------------------------------------

loc_7533:				; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &)+54j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		push	ecx		; struct icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+28h]	; this
		call	?containsAll@UVector@icu_56@@QBECABV12@@Z ; icu_56::UVector::containsAll(icu_56::UVector const &)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_7550
		xor	al, al
		jmp	short loc_7552
; ---------------------------------------------------------------------------

loc_7550:				; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &)+C6j
		mov	al, 1

loc_7552:				; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &)+ABj
					; icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet const &)+CAj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsAll@UnicodeSet@icu_56@@UBECABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7568h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString	*)
		public ?containsAll@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?containsAll@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		mov	ecx, [ebp+var_8]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	esi, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsAll@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 75CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *this, int, int)
		public ?containsNone@UnicodeSet@icu_56@@QBECHH@Z
?containsNone@UnicodeSet@icu_56@@QBECHH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::containsSome(int,int)+2Ep
					; icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+8Fp

var_DC		= byte ptr -0DCh
var_D9		= byte ptr -0D9h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z ; icu_56::UnicodeSet::findCodePoint(int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 1
		jnz	short loc_7620
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [edx+eax*4]
		jge	short loc_7620
		mov	[ebp+var_D9], 1
		jmp	short loc_7627
; ---------------------------------------------------------------------------

loc_7620:				; CODE XREF: icu_56::UnicodeSet::containsNone(int,int)+38j
					; icu_56::UnicodeSet::containsNone(int,int)+49j
		mov	[ebp+var_D9], 0

loc_7627:				; CODE XREF: icu_56::UnicodeSet::containsNone(int,int)+52j
		mov	al, [ebp+var_D9]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?containsNone@UnicodeSet@icu_56@@QBECHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z
?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet const &)+2Ap

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		jmp	short loc_7692
; ---------------------------------------------------------------------------

loc_7689:				; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &):loc_76E3j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_7692:				; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+43j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_76E5
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax
		mov	esi, esp
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+64h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECHH@Z ; icu_56::UnicodeSet::containsNone(int,int)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_76E3
		xor	al, al
		jmp	short loc_7704
; ---------------------------------------------------------------------------

loc_76E3:				; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+99j
		jmp	short loc_7689
; ---------------------------------------------------------------------------

loc_76E5:				; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+54j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		push	ecx		; struct icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+28h]	; this
		call	?containsNone@UVector@icu_56@@QBECABV12@@Z ; icu_56::UVector::containsNone(icu_56::UVector const &)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_7702
		xor	al, al
		jmp	short loc_7704
; ---------------------------------------------------------------------------

loc_7702:				; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+B8j
		mov	al, 1

loc_7704:				; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+9Dj
					; icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+BCj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 771Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc	near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeString const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		mov	ecx, [ebp+var_8]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	esi, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::matchesIndexValue(icu_56::UnicodeSet *this, unsigned __int8)
		public ?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z
?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z proc near	; DATA XREF: .rdata:00005E18o

var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		sub	ecx, 4
		mov	eax, [ebp+var_8]
		mov	edx, [eax-4]
		mov	esi, esp
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	[ebp+var_14], 0
		jmp	short loc_77D2
; ---------------------------------------------------------------------------

loc_77C9:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar):loc_7884j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_77D2:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+47j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jge	loc_7889
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		sub	ecx, 4
		mov	edx, [ebp+var_8]
		mov	eax, [edx-4]
		mov	edx, [eax+64h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		sub	ecx, 4
		mov	edx, [ebp+var_8]
		mov	eax, [edx-4]
		mov	edx, [eax+68h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFFF00h
		mov	ecx, [ebp+var_38]
		and	ecx, 0FFFFFF00h
		cmp	eax, ecx
		jnz	short loc_785F
		mov	eax, [ebp+var_2C]
		and	eax, 0FFh
		movzx	ecx, [ebp+arg_0]
		cmp	eax, ecx
		jg	short loc_785D
		movzx	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		and	ecx, 0FFh
		cmp	eax, ecx
		jg	short loc_785D
		mov	al, 1
		jmp	loc_78F1
; ---------------------------------------------------------------------------

loc_785D:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+C3j
					; icu_56::UnicodeSet::matchesIndexValue(uchar)+D4j
		jmp	short loc_7884
; ---------------------------------------------------------------------------

loc_785F:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+B3j
		mov	eax, [ebp+var_2C]
		and	eax, 0FFh
		movzx	ecx, [ebp+arg_0]
		cmp	eax, ecx
		jle	short loc_7880
		movzx	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		and	ecx, 0FFh
		cmp	eax, ecx
		jg	short loc_7884

loc_7880:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+EDj
		mov	al, 1
		jmp	short loc_78F1
; ---------------------------------------------------------------------------

loc_7884:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar):loc_785Dj
					; icu_56::UnicodeSet::matchesIndexValue(uchar)+FEj
		jmp	loc_77C9
; ---------------------------------------------------------------------------

loc_7889:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+58j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		test	eax, eax
		jz	short loc_78EF
		mov	[ebp+var_14], 0
		jmp	short loc_78AA
; ---------------------------------------------------------------------------

loc_78A1:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar):loc_78EDj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_78AA:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+11Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_78EF
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+24h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_44], eax
		push	0		; int
		mov	ecx, [ebp+var_44] ; this
		call	?char32At@UnicodeString@icu_56@@QBEHH@Z	; icu_56::UnicodeString::char32At(int)
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_50]
		and	eax, 0FFh
		movzx	ecx, [ebp+arg_0]
		cmp	eax, ecx
		jnz	short loc_78ED
		mov	al, 1
		jmp	short loc_78F1
; ---------------------------------------------------------------------------

loc_78ED:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+167j
		jmp	short loc_78A1
; ---------------------------------------------------------------------------

loc_78EF:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+116j
					; icu_56::UnicodeSet::matchesIndexValue(uchar)+138j
		xor	al, al

loc_78F1:				; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+D8j
					; icu_56::UnicodeSet::matchesIndexValue(uchar)+102j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?matchesIndexValue@UnicodeSet@icu_56@@EBECE@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7908h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual enum	icu_56::UMatchDegree __thiscall	icu_56::UnicodeSet::matches(class icu_56::Replaceable const &, int &, int, signed char)
		public ?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z
?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z proc	near
					; DATA XREF: .rdata:00005E10o

var_130		= dword	ptr -130h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= word ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= word ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_130]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_8]
		jnz	short loc_7979
		mov	esi, esp
		push	0FFFFh
		mov	ecx, [ebp+var_8]
		sub	ecx, 4
		mov	eax, [ebp+var_8]
		mov	edx, [eax-4]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_796D
		movsx	eax, [ebp+arg_C]
		neg	eax
		sbb	eax, eax
		add	eax, 2
		jmp	loc_7B3E
; ---------------------------------------------------------------------------
		jmp	short loc_7974
; ---------------------------------------------------------------------------

loc_796D:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+51j
		xor	eax, eax
		jmp	loc_7B3E
; ---------------------------------------------------------------------------

loc_7974:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+63j
		jmp	loc_7B3E
; ---------------------------------------------------------------------------

loc_7979:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+2Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		test	eax, eax
		jz	loc_7B25
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_8]
		setl	dl
		mov	[ebp+var_1D], dl
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		mov	[ebp+var_2C], ax
		mov	[ebp+var_38], 0
		mov	[ebp+var_14], 0
		jmp	short loc_79C5
; ---------------------------------------------------------------------------

loc_79BC:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+140j
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char):loc_7AE0j ...
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_79C5:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+B2j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_14], eax
		jge	loc_7AEA
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+24h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_44], eax
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_79FF
		mov	[ebp+var_130], 0
		jmp	short loc_7A10
; ---------------------------------------------------------------------------

loc_79FF:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+E9j
		mov	ecx, [ebp+var_44] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, 1
		mov	[ebp+var_130], eax

loc_7A10:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+F5j
		mov	ecx, [ebp+var_130]
		push	ecx		; int
		mov	ecx, [ebp+var_44] ; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_50], ax
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_7A3C
		movzx	eax, [ebp+var_50]
		movzx	ecx, [ebp+var_2C]
		cmp	eax, ecx
		jle	short loc_7A3C
		jmp	loc_7AEA
; ---------------------------------------------------------------------------

loc_7A3C:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+121j
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char)+12Dj
		movzx	eax, [ebp+var_50]
		movzx	ecx, [ebp+var_2C]
		cmp	eax, ecx
		jz	short loc_7A4D
		jmp	loc_79BC
; ---------------------------------------------------------------------------

loc_7A4D:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+13Ej
		mov	eax, [ebp+var_44]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::Replaceable *
		call	?matchRest@UnicodeSet@icu_56@@CAHABVReplaceable@2@HHABVUnicodeString@2@@Z ; icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)
		add	esp, 10h
		mov	[ebp+var_5C], eax
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_7AB3
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_7A8A
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		sub	edx, [ecx]
		mov	[ebp+var_130], edx
		jmp	short loc_7A98
; ---------------------------------------------------------------------------

loc_7A8A:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+170j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		sub	ecx, [ebp+arg_8]
		mov	[ebp+var_130], ecx

loc_7A98:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+180j
		mov	edx, [ebp+var_130]
		mov	[ebp+var_68], edx
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_68]
		jnz	short loc_7AB3
		mov	eax, 1
		jmp	loc_7B3E
; ---------------------------------------------------------------------------

loc_7AB3:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+168j
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char)+19Fj
		mov	ecx, [ebp+var_44] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+var_5C], eax
		jnz	short loc_7AE5
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_38]
		jle	short loc_7ACE
		mov	eax, [ebp+var_5C]
		mov	[ebp+var_38], eax

loc_7ACE:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+1BEj
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_7AE0
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_38]
		jge	short loc_7AE0
		jmp	short loc_7AEA
; ---------------------------------------------------------------------------

loc_7AE0:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+1CCj
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char)+1D4j
		jmp	loc_79BC
; ---------------------------------------------------------------------------

loc_7AE5:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+1B6j
		jmp	loc_79BC
; ---------------------------------------------------------------------------

loc_7AEA:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+CBj
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char)+12Fj ...
		cmp	[ebp+var_38], 0
		jz	short loc_7B25
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_7B03
		mov	ecx, [ebp+var_38]
		mov	[ebp+var_130], ecx
		jmp	short loc_7B0E
; ---------------------------------------------------------------------------

loc_7B03:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+1EEj
		mov	edx, [ebp+var_38]
		neg	edx
		mov	[ebp+var_130], edx

loc_7B0E:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+1F9j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		add	ecx, [ebp+var_130]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx
		mov	eax, 2
		jmp	short loc_7B3E
; ---------------------------------------------------------------------------

loc_7B25:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+7Ej
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char)+1E6j
		movzx	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z ;	icu_56::UnicodeFilter::matches(icu_56::Replaceable const &,int &,int,signed char)

loc_7B3E:				; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+5Ej
					; icu_56::UnicodeSet::matches(icu_56::Replaceable const	&,int &,int,signed char)+67j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?matches@UnicodeSet@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z endp	; sp-analysis failed

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::UnicodeSet::matchRest(const struct icu_56::Replaceable *,	int, int, const	struct icu_56::UnicodeString *)
		public ?matchRest@UnicodeSet@icu_56@@CAHABVReplaceable@2@HHABVUnicodeString@2@@Z
?matchRest@UnicodeSet@icu_56@@CAHABVReplaceable@2@HHABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+157p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jge	short loc_7BE3
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jle	short loc_7B9C
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax

loc_7B9C:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+40j
		mov	[ebp+var_8], 1
		jmp	short loc_7BAE
; ---------------------------------------------------------------------------

loc_7BA5:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &):loc_7BDFj
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_7BAE:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+4Fj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jge	short loc_7BE1
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	esi, ax
		mov	ecx, [ebp+var_8]
		push	ecx		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	edx, ax
		cmp	esi, edx
		jz	short loc_7BDF
		xor	eax, eax
		jmp	short loc_7C4E
; ---------------------------------------------------------------------------

loc_7BDF:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+85j
		jmp	short loc_7BA5
; ---------------------------------------------------------------------------

loc_7BE1:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+60j
		jmp	short loc_7C4B
; ---------------------------------------------------------------------------

loc_7BE3:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+2Fj
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_8]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jle	short loc_7BFA
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax

loc_7BFA:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+9Ej
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		mov	[ebp+var_8], 1
		jmp	short loc_7C15
; ---------------------------------------------------------------------------

loc_7C0C:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &):loc_7C49j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_7C15:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+B6j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jge	short loc_7C4B
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	esi, ax
		mov	ecx, [ebp+var_20]
		sub	ecx, [ebp+var_8]
		push	ecx		; int
		mov	ecx, [ebp+arg_C] ; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	edx, ax
		cmp	esi, edx
		jz	short loc_7C49
		xor	eax, eax
		jmp	short loc_7C4E
; ---------------------------------------------------------------------------

loc_7C49:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+EFj
		jmp	short loc_7C0C
; ---------------------------------------------------------------------------

loc_7C4B:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &):loc_7BE1j
					; icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const	&)+C7j
		mov	eax, [ebp+var_14]

loc_7C4E:				; CODE XREF: icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const &)+89j
					; icu_56::UnicodeSet::matchRest(icu_56::Replaceable const &,int,int,icu_56::UnicodeString const	&)+F3j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?matchRest@UnicodeSet@icu_56@@CAHABVReplaceable@2@HHABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::addMatchSetTo(icu_56::UnicodeSet *this, struct icu_56::UnicodeSet	*)
		public ?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z
?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z proc near ; DATA	XREF: .rdata:00005E1Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		mov	ecx, [ebp+arg_0]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?addMatchSetTo@UnicodeSet@icu_56@@UBEXAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7CBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::indexOf(icu_56::UnicodeSet	*this, int)
		public ?indexOf@UnicodeSet@icu_56@@QBEHH@Z
?indexOf@UnicodeSet@icu_56@@QBEHH@Z proc near

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_7CEE
		cmp	[ebp+arg_0], 10FFFFh
		jle	short loc_7CF3

loc_7CEE:				; CODE XREF: icu_56::UnicodeSet::indexOf(int)+27j
		or	eax, 0FFFFFFFFh
		jmp	short loc_7D5F
; ---------------------------------------------------------------------------

loc_7CF3:				; CODE XREF: icu_56::UnicodeSet::indexOf(int)+30j
		mov	[ebp+var_14], 0
		mov	[ebp+var_20], 0

loc_7D01:				; CODE XREF: icu_56::UnicodeSet::indexOf(int)+A1j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_2C]
		jge	short loc_7D26
		or	eax, 0FFFFFFFFh
		jmp	short loc_7D5F
; ---------------------------------------------------------------------------

loc_7D26:				; CODE XREF: icu_56::UnicodeSet::indexOf(int)+63j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_38]
		jge	short loc_7D51
		mov	eax, [ebp+var_20]
		add	eax, [ebp+arg_0]
		sub	eax, [ebp+var_2C]
		jmp	short loc_7D5F
; ---------------------------------------------------------------------------

loc_7D51:				; CODE XREF: icu_56::UnicodeSet::indexOf(int)+88j
		mov	eax, [ebp+var_38]
		sub	eax, [ebp+var_2C]
		add	eax, [ebp+var_20]
		mov	[ebp+var_20], eax
		jmp	short loc_7D01
; ---------------------------------------------------------------------------

loc_7D5F:				; CODE XREF: icu_56::UnicodeSet::indexOf(int)+35j
					; icu_56::UnicodeSet::indexOf(int)+68j	...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeSet@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::charAt(icu_56::UnicodeSet *this, int)
		public ?charAt@UnicodeSet@icu_56@@QBEHH@Z
?charAt@UnicodeSet@icu_56@@QBEHH@Z proc	near

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_7DFA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFEh
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0

loc_7DA4:				; CODE XREF: icu_56::UnicodeSet::charAt(int)+90j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_7DFA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		sub	eax, [ebp+var_2C]
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_38]
		jge	short loc_7DEF
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+arg_0]
		jmp	short loc_7DFD
; ---------------------------------------------------------------------------

loc_7DEF:				; CODE XREF: icu_56::UnicodeSet::charAt(int)+7Dj
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_38]
		mov	[ebp+arg_0], eax
		jmp	short loc_7DA4
; ---------------------------------------------------------------------------

loc_7DFA:				; CODE XREF: icu_56::UnicodeSet::charAt(int)+27j
					; icu_56::UnicodeSet::charAt(int)+42j
		or	eax, 0FFFFFFFFh

loc_7DFD:				; CODE XREF: icu_56::UnicodeSet::charAt(int)+85j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeSet@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::set(icu_56::UnicodeSet *this, int, int)
		public ?set@UnicodeSet@icu_56@@QAEAAV12@HH@Z
?set@UnicodeSet@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+50h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?set@UnicodeSet@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::add(icu_56::UnicodeSet *this, int, int)
		public ?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z
?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z proc near	; DATA XREF: .rdata:00005E58o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+arg_0]
		push	eax
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+arg_4]
		push	ecx
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		cmp	esi, eax
		jge	short loc_7EEB
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], 110000h
		push	0		; signed __int8
		push	2		; int
		lea	eax, [ebp+var_20]
		push	eax		; int *
		mov	ecx, [ebp+var_C] ; this
		call	?add@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::add(int const	*,int,signed char)
		jmp	short loc_7EFF
; ---------------------------------------------------------------------------

loc_7EEB:				; CODE XREF: icu_56::UnicodeSet::add(int,int)+49j
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_7EFF
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?add@UnicodeSet@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeSet::add(int)

loc_7EFF:				; CODE XREF: icu_56::UnicodeSet::add(int,int)+71j
					; icu_56::UnicodeSet::add(int,int)+79j
		mov	eax, [ebp+var_C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?add@UnicodeSet@icu_56@@UAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN8		dd 1			; DATA XREF: icu_56::UnicodeSet::add(int,int)+8Eo
		dd offset $LN7_1
$LN7_1		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:00007F38o
		dd offset $LN6		; "range"
$LN6		db 'range',0            ; DATA XREF: .text:00007F44o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::pinCodePoint(int &)
?pinCodePoint@icu_56@@YAHAAH@Z proc near ; CODE	XREF: icu_56::UnicodeSet::add(int,int)+31p
					; icu_56::UnicodeSet::add(int,int)+3Fp	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_7F81
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_7F95
; ---------------------------------------------------------------------------

loc_7F81:				; CODE XREF: icu_56::pinCodePoint(int &)+24j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 10FFFFh
		jle	short loc_7F95
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 10FFFFh

loc_7F95:				; CODE XREF: icu_56::pinCodePoint(int &)+2Fj
					; icu_56::pinCodePoint(int &)+3Aj
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?pinCodePoint@icu_56@@YAHAAH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7FA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::add(icu_56::UnicodeSet *this, int)
		public ?add@UnicodeSet@icu_56@@QAEAAV12@H@Z
?add@UnicodeSet@icu_56@@QAEAAV12@H@Z proc near
					; CODE XREF: icu_56::UnicodeSet::add(int,int)+82p
					; icu_56::UnicodeSet::add(icu_56::UnicodeString	const &)+9Ap ...

var_138		= byte ptr -138h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findCodePoint@UnicodeSet@icu_56@@ABEHH@Z ; icu_56::UnicodeSet::findCodePoint(int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 1
		jnz	short loc_8005
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_8005
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)

loc_7FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		movsx	eax, al
		test	eax, eax
		jz	short loc_800D

loc_8005:				; CODE XREF: icu_56::UnicodeSet::add(int)+41j
					; icu_56::UnicodeSet::add(int)+50j
		mov	eax, [ebp+var_8]
		jmp	loc_8212
; ---------------------------------------------------------------------------

loc_800D:				; CODE XREF: icu_56::UnicodeSet::add(int)+5Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		sub	eax, 1
		cmp	[ebp+arg_0], eax
		jnz	loc_8114
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		cmp	[ebp+arg_0], 10FFFFh
		jnz	short loc_8097
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_20]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8075
		mov	eax, [ebp+var_8]
		jmp	loc_8212
; ---------------------------------------------------------------------------

loc_8075:				; CODE XREF: icu_56::UnicodeSet::add(int)+C7j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	dword ptr [eax+ecx*4], 110000h
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	[eax+8], edx

loc_8097:				; CODE XREF: icu_56::UnicodeSet::add(int)+97j
		cmp	[ebp+var_14], 0
		jle	short loc_810F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4-4]
		jnz	short loc_810F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4-4]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		add	eax, 8
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		lea	ecx, [eax+ecx*4]
		mov	[ebp+var_44], ecx

loc_80DA:				; CODE XREF: icu_56::UnicodeSet::add(int)+15Aj
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jnb	short loc_8100
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_38]
		mov	edx, [ecx]
		mov	[eax], edx
		mov	eax, [ebp+var_2C]
		add	eax, 4
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 4
		mov	[ebp+var_38], ecx
		jmp	short loc_80DA
; ---------------------------------------------------------------------------

loc_8100:				; CODE XREF: icu_56::UnicodeSet::add(int)+13Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 2
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_810F:				; CODE XREF: icu_56::UnicodeSet::add(int)+F7j
					; icu_56::UnicodeSet::add(int)+109j
		jmp	loc_8207
; ---------------------------------------------------------------------------

loc_8114:				; CODE XREF: icu_56::UnicodeSet::add(int)+7Bj
		cmp	[ebp+var_14], 0
		jle	short loc_814E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4-4]
		jnz	short loc_814E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4-4]
		add	eax, 1
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	ecx, [ebp+var_14]
		mov	[edx+ecx*4-4], eax
		jmp	loc_8207
; ---------------------------------------------------------------------------

loc_814E:				; CODE XREF: icu_56::UnicodeSet::add(int)+174j
					; icu_56::UnicodeSet::add(int)+186j
		mov	[ebp+var_50], 0
		lea	eax, [ebp+var_50]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, 2
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_50]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8186
		mov	eax, [ebp+var_8]
		jmp	loc_8212
; ---------------------------------------------------------------------------

loc_8186:				; CODE XREF: icu_56::UnicodeSet::add(int)+1D8j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		lea	ecx, [eax+ecx*4]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_5C]
		add	eax, 8
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4]
		mov	[ebp+var_74], eax

loc_81B0:				; CODE XREF: icu_56::UnicodeSet::add(int)+230j
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_74]
		jbe	short loc_81D6
		mov	eax, [ebp+var_5C]
		sub	eax, 4
		mov	[ebp+var_5C], eax
		mov	ecx, [ebp+var_68]
		sub	ecx, 4
		mov	[ebp+var_68], ecx
		mov	edx, [ebp+var_68]
		mov	eax, [ebp+var_5C]
		mov	ecx, [eax]
		mov	[edx], ecx
		jmp	short loc_81B0
; ---------------------------------------------------------------------------

loc_81D6:				; CODE XREF: icu_56::UnicodeSet::add(int)+212j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	ecx, [ebp+var_14]
		mov	[edx+ecx*4+4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 2
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_8207:				; CODE XREF: icu_56::UnicodeSet::add(int):loc_810Fj
					; icu_56::UnicodeSet::add(int)+1A5j
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	eax, [ebp+var_8]

loc_8212:				; CODE XREF: icu_56::UnicodeSet::add(int)+64j
					; icu_56::UnicodeSet::add(int)+CCj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?add@UnicodeSet@icu_56@@QAEAAV12@H@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN20		dd 2			; DATA XREF: icu_56::UnicodeSet::add(int)+272o
		dd offset $LN19
$LN19		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00008240o
		dd offset $LN17		; "status"
		dd 0FFFFFFB0h, 4
		dd offset $LN18		; "status"
$LN18		db 'status',0           ; DATA XREF: .text:00008258o
$LN17		db 'status',0           ; DATA XREF: .text:0000824Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 826Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::add(icu_56::UnicodeSet *this, const	struct icu_56::UnicodeString *)
		public ?add@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?add@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::createFrom(icu_56::UnicodeString const	&)+A3p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		test	eax, eax
		jz	short loc_82B9
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_82B9
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_82BE

loc_82B9:				; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &)+2Dj
					; icu_56::UnicodeSet::add(icu_56::UnicodeString	const &)+3Cj
		mov	eax, [ebp+var_8]
		jmp	short loc_830E
; ---------------------------------------------------------------------------

loc_82BE:				; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &)+4Bj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z ; icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_82FF
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?contains@UVector@icu_56@@QBECPAX@Z ; icu_56::UVector::contains(void *)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_82FD
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z ; icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)

loc_82FD:				; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &)+7Bj
		jmp	short loc_830B
; ---------------------------------------------------------------------------

loc_82FF:				; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &)+65j
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?add@UnicodeSet@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeSet::add(int)

loc_830B:				; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &):loc_82FDj
		mov	eax, [ebp+var_8]

loc_830E:				; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &)+50j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?add@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8324h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::_add(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString	*)
		public ?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z
?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z proc	near
					; CODE XREF: icu_56::UnicodeSet::add(icu_56::UnicodeString const &)+84p
					; icu_56::UnicodeSet::complement(icu_56::UnicodeString const &)+95p ...

var_124		= dword	ptr -124h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_8384
		mov	ecx, [ebp+var_14] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_8389

loc_8384:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+4Fj
		jmp	loc_8480
; ---------------------------------------------------------------------------

loc_8389:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+5Ej
		push	40h ; '@'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_110], 0
		jz	short loc_83C0
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_110] ; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	[ebp+var_124], eax
		jmp	short loc_83CA
; ---------------------------------------------------------------------------

loc_83C0:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+83j
		mov	[ebp+var_124], 0

loc_83CA:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+9Aj
		mov	ecx, [ebp+var_124]
		mov	[ebp+var_11C], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_11C]
		mov	[ebp+var_20], edx
		cmp	[ebp+var_20], 0
		jnz	short loc_83F9
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	loc_8480
; ---------------------------------------------------------------------------

loc_83F9:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+C6j
		mov	[ebp+var_2C], 0
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		push	offset ?compareUnicodeString@icu_56@@YACTUElement@@0@Z ; signed	__int8 (__cdecl	__high *)(union	UElement, union	UElement)
		mov	ecx, [ebp+var_20]
		push	ecx		; void *
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+28h]	; this
		call	?sortedInsert@UVector@icu_56@@QAEXPAXP6ACTUElement@@1@ZAAW4UErrorCode@@@Z ; icu_56::UVector::sortedInsert(void *,signed	char (*)(UElement,UElement),UErrorCode &)
		mov	eax, [ebp+var_2C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_8480
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		mov	eax, [ebp+var_20]
		mov	[ebp+var_F8], eax
		mov	ecx, [ebp+var_F8]
		mov	[ebp+var_104], ecx
		cmp	[ebp+var_104], 0
		jz	short loc_8476
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_104]
		mov	eax, [edx]
		mov	ecx, [ebp+var_104]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_124], eax
		jmp	short loc_8480
; ---------------------------------------------------------------------------

loc_8476:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+12Bj
		mov	[ebp+var_124], 0

loc_8480:				; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &):loc_8384j
					; icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+D0j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN15		dd 1			; DATA XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+160o
		dd offset $LN14_0
$LN14_0		dd 0FFFFFFD4h, 4	; DATA XREF: .text:000084B8o
		dd offset $LN12_0
$LN12_0		db 65h,	63h, 0		; DATA XREF: .text:000084C4o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 84CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:000084FCo
		mov	eax, [ebp-110h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-128h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 84F8h
__unwindtable$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008508o
		dd offset __unwindfunclet$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z$0
__ehfuncinfo$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8524h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	__high icu_56::compareUnicodeString(union UElement, union UElement)
?compareUnicodeString@icu_56@@YACTUElement@@0@Z	proc near
					; DATA XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+E0o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECABV12@@Z ; icu_56::UnicodeString::compare(icu_56::UnicodeString const &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compareUnicodeString@icu_56@@YACTUElement@@0@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::UnicodeSet::getSingleCP(const struct icu_56::UnicodeString *)
		public ?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z
?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::contains(icu_56::UnicodeString	const &)+37p
					; icu_56::UnicodeSet::add(icu_56::UnicodeString	const &)+56p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	eax, 2
		jle	short loc_85A0
		or	eax, 0FFFFFFFFh
		jmp	short loc_85DA
; ---------------------------------------------------------------------------

loc_85A0:				; CODE XREF: icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)+29j
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	eax, 1
		jnz	short loc_85BC
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	eax, ax
		jmp	short loc_85DA
; ---------------------------------------------------------------------------

loc_85BC:				; CODE XREF: icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)+3Bj
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?char32At@UnicodeString@icu_56@@QBEHH@Z	; icu_56::UnicodeString::char32At(int)
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFh
		jle	short loc_85D7
		mov	eax, [ebp+var_8]
		jmp	short loc_85DA
; ---------------------------------------------------------------------------

loc_85D7:				; CODE XREF: icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)+60j
		or	eax, 0FFFFFFFFh

loc_85DA:				; CODE XREF: icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)+2Ej
					; icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString	const &)+4Aj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 85F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::addAll(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString	*)
		public ?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeString const &)+58p
					; icu_56::UnicodeSet::complementAll(icu_56::UnicodeString const	&)+58p	...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_20], 0
		jmp	short loc_8631
; ---------------------------------------------------------------------------

loc_861C:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)+69j
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_14]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_20]
		mov	[ebp+var_20], ecx

loc_8631:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)+2Aj
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+var_20], eax
		jge	short loc_865B
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?char32At@UnicodeString@icu_56@@QBEHH@Z	; icu_56::UnicodeString::char32At(int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?add@UnicodeSet@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeSet::add(int)
		jmp	short loc_861C
; ---------------------------------------------------------------------------

loc_865B:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)+4Cj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8674h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet *this,	const struct icu_56::UnicodeString *)
		public ?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near

var_120		= byte ptr -120h
var_11C		= dword	ptr -11Ch
var_50		= byte ptr -50h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		lea	ecx, [ebp+var_50] ; this
		call	??0UnicodeSet@icu_56@@QAE@XZ ; icu_56::UnicodeSet::UnicodeSet(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_50] ; this
		call	?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)
		mov	esi, esp
		lea	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+3Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_50] ; this
		call	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	eax, [ebp+var_11C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_2		dd 1			; DATA XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeString const &)+99o
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFB0h, 34h	; DATA XREF: .text:00008740o
		dd offset $LN4
$LN4		dd 746573h		; DATA XREF: .text:0000874Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8754h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:00008780o
		lea	ecx, [ebp-50h]	; this
		jmp	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
__unwindfunclet$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeString const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-124h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 877Ch
__unwindtable$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000878Co
		dd offset __unwindfunclet$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0
__ehfuncinfo$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?retainAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near

var_120		= byte ptr -120h
var_11C		= dword	ptr -11Ch
var_50		= byte ptr -50h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		lea	ecx, [ebp+var_50] ; this
		call	??0UnicodeSet@icu_56@@QAE@XZ ; icu_56::UnicodeSet::UnicodeSet(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_50] ; this
		call	?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)
		mov	esi, esp
		lea	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+40h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_50] ; this
		call	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	eax, [ebp+var_11C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN7_3		dd 1			; DATA XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeString const &)+99o
		dd offset $LN6_1
$LN6_1		dd 0FFFFFFB0h, 34h	; DATA XREF: .text:00008874o
		dd offset $LN4_0
$LN4_0		dd 746573h		; DATA XREF: .text:00008880o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8888h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0 proc	near
					; DATA XREF: .xdata$x:000088B4o
		lea	ecx, [ebp-50h]	; this
		jmp	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
__unwindfunclet$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeString const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-124h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 88B0h
__unwindtable$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000088C0o
		dd offset __unwindfunclet$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0
__ehfuncinfo$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?complementAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 88DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet *this,	const struct icu_56::UnicodeString *)
		public ?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near

var_120		= byte ptr -120h
var_11C		= dword	ptr -11Ch
var_50		= byte ptr -50h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_120]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		lea	ecx, [ebp+var_50] ; this
		call	??0UnicodeSet@icu_56@@QAE@XZ ; icu_56::UnicodeSet::UnicodeSet(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_50] ; this
		call	?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)
		mov	esi, esp
		lea	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+44h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_50] ; this
		call	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
		mov	eax, [ebp+var_11C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7_4		dd 1			; DATA XREF: icu_56::UnicodeSet::removeAll(icu_56::UnicodeString const &)+99o
		dd offset $LN6_2
$LN6_2		dd 0FFFFFFB0h, 34h	; DATA XREF: .text:000089A8o
		dd offset $LN4_1
$LN4_1		dd 746573h		; DATA XREF: .text:000089B4o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 89BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:000089E8o
		lea	ecx, [ebp-50h]	; this
		jmp	??1UnicodeSet@icu_56@@UAE@XZ ; icu_56::UnicodeSet::~UnicodeSet(void)
__unwindfunclet$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::removeAll(icu_56::UnicodeString const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-124h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 89E4h
__unwindtable$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000089F4o
		dd offset __unwindfunclet$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z$0
__ehfuncinfo$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?removeAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::removeAllStrings(icu_56::UnicodeSet	*__hidden this)
		public ?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ
?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ proc near ; DATA XREF:	.rdata:00005E80o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]	; this
		call	?removeAllElements@UVector@icu_56@@QAEXXZ ; icu_56::UVector::removeAllElements(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?removeAllStrings@UnicodeSet@icu_56@@UAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::createFrom(const struct icu_56::UnicodeString *)
		public ?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		push	34h ; '4'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_8AC8
		mov	ecx, [ebp+var_E0] ; this
		call	??0UnicodeSet@icu_56@@QAE@XZ ; icu_56::UnicodeSet::UnicodeSet(void)
		mov	[ebp+var_F4], eax
		jmp	short loc_8AD2
; ---------------------------------------------------------------------------

loc_8AC8:				; CODE XREF: icu_56::UnicodeSet::createFrom(icu_56::UnicodeString const	&)+5Bj
		mov	[ebp+var_F4], 0

loc_8AD2:				; CODE XREF: icu_56::UnicodeSet::createFrom(icu_56::UnicodeString const	&)+6Ej
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jz	short loc_8B00
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?add@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z ; icu_56::UnicodeSet::add(icu_56::UnicodeString const &)

loc_8B00:				; CODE XREF: icu_56::UnicodeSet::createFrom(icu_56::UnicodeString const	&)+9Aj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8B24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:00008B54o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::createFrom(icu_56::UnicodeString const	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8B50h
__unwindtable$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008B60o
		dd offset __unwindfunclet$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z$0
__ehfuncinfo$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?createFrom@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::createFromAll(const struct icu_56::UnicodeString *)
		public ?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z	proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		push	34h ; '4'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_8BEC
		mov	ecx, [ebp+var_E0] ; this
		call	??0UnicodeSet@icu_56@@QAE@XZ ; icu_56::UnicodeSet::UnicodeSet(void)
		mov	[ebp+var_F4], eax
		jmp	short loc_8BF6
; ---------------------------------------------------------------------------

loc_8BEC:				; CODE XREF: icu_56::UnicodeSet::createFromAll(icu_56::UnicodeString const &)+5Bj
		mov	[ebp+var_F4], 0

loc_8BF6:				; CODE XREF: icu_56::UnicodeSet::createFromAll(icu_56::UnicodeString const &)+6Ej
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jz	short loc_8C24
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?addAll@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z ; icu_56::UnicodeSet::addAll(icu_56::UnicodeString const &)

loc_8C24:				; CODE XREF: icu_56::UnicodeSet::createFromAll(icu_56::UnicodeString const &)+9Aj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8C48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:00008C78o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::createFromAll(icu_56::UnicodeString const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8C74h
__unwindtable$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008C84o
		dd offset __unwindfunclet$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z$0
__ehfuncinfo$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z dd	19930522h, 1
					; DATA XREF: __ehhandler$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?createFromAll@UnicodeSet@icu_56@@SAPAV12@ABVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8CA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::retain(icu_56::UnicodeSet *this, int, int)
		public ?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z
?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z proc near ; DATA XREF:	.rdata:00005E6Co

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+arg_0]
		push	eax
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+arg_4]
		push	ecx
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		cmp	esi, eax
		jg	short loc_8D13
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], 110000h
		push	0		; signed __int8
		push	2		; int
		lea	eax, [ebp+var_20]
		push	eax		; int *
		mov	ecx, [ebp+var_C] ; this
		call	?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::retain(int	const *,int,signed char)
		jmp	short loc_8D29
; ---------------------------------------------------------------------------

loc_8D13:				; CODE XREF: icu_56::UnicodeSet::retain(int,int)+49j
		mov	eax, [ebp+var_C]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_C]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8D29:				; CODE XREF: icu_56::UnicodeSet::retain(int,int)+71j
		mov	eax, [ebp+var_C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7_5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retain@UnicodeSet@icu_56@@UAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN7_5		dd 1			; DATA XREF: icu_56::UnicodeSet::retain(int,int)+90o
		dd offset $LN6_3
$LN6_3		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:00008D64o
		dd offset $LN5		; "range"
$LN5		db 'range',0            ; DATA XREF: .text:00008D70o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::retain(icu_56::UnicodeSet *this, int)
		public ?retain@UnicodeSet@icu_56@@QAEAAV12@H@Z
?retain@UnicodeSet@icu_56@@QAEAAV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+48h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?retain@UnicodeSet@icu_56@@QAEAAV12@H@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8DD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::remove(icu_56::UnicodeSet *this, int, int)
		public ?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z
?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z proc near ; DATA XREF:	.rdata:00005E70o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+arg_0]
		push	eax
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+arg_4]
		push	ecx
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		cmp	esi, eax
		jg	short loc_8E45
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], 110000h
		push	2		; signed __int8
		push	2		; int
		lea	eax, [ebp+var_20]
		push	eax		; int *
		mov	ecx, [ebp+var_C] ; this
		call	?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::retain(int	const *,int,signed char)

loc_8E45:				; CODE XREF: icu_56::UnicodeSet::remove(int,int)+49j
		mov	eax, [ebp+var_C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6_4
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeSet@icu_56@@UAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN6_4		dd 1			; DATA XREF: icu_56::UnicodeSet::remove(int,int)+78o
		dd offset $LN5_0
$LN5_0		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:00008E80o
		dd offset $LN4_2	; "range"
$LN4_2		db 'range',0            ; DATA XREF: .text:00008E8Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::remove(icu_56::UnicodeSet *this, int)
		public ?remove@UnicodeSet@icu_56@@QAEAAV12@H@Z
?remove@UnicodeSet@icu_56@@QAEAAV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?remove@UnicodeSet@icu_56@@QAEAAV12@H@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8EF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::remove(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString	*)
		public ?remove@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?remove@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		test	eax, eax
		jz	short loc_8F3D
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_8F3D
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_8F42

loc_8F3D:				; CODE XREF: icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+2Dj
					; icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+3Cj
		mov	eax, [ebp+var_8]
		jmp	short loc_8F91
; ---------------------------------------------------------------------------

loc_8F42:				; CODE XREF: icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+4Bj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z ; icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_8F70
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?removeElement@UVector@icu_56@@QAECPAX@Z ; icu_56::UVector::removeElement(void *)
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		jmp	short loc_8F8E
; ---------------------------------------------------------------------------

loc_8F70:				; CODE XREF: icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+65j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8F8E:				; CODE XREF: icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+7Ej
		mov	eax, [ebp+var_8]

loc_8F91:				; CODE XREF: icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+50j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?remove@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8FA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::complement(icu_56::UnicodeSet *this, int, int)
		public ?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z
?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(int,int)+12Fp
					; DATA XREF: .rdata:00005E74o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	ecx, [ebp+var_C] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_8FF3
		mov	ecx, [ebp+var_C] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_8FF8

loc_8FF3:				; CODE XREF: icu_56::UnicodeSet::complement(int,int)+3Aj
		mov	eax, [ebp+var_C]
		jmp	short loc_9047
; ---------------------------------------------------------------------------

loc_8FF8:				; CODE XREF: icu_56::UnicodeSet::complement(int,int)+49j
		lea	eax, [ebp+arg_0]
		push	eax
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		mov	esi, eax
		lea	ecx, [ebp+arg_4]
		push	ecx
		call	?pinCodePoint@icu_56@@YAHAAH@Z ; icu_56::pinCodePoint(int &)
		add	esp, 4
		cmp	esi, eax
		jg	short loc_903C
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+var_1C], eax
		mov	[ebp+var_18], 110000h
		push	0		; signed __int8
		push	2		; int
		lea	eax, [ebp+var_20]
		push	eax		; int *
		mov	ecx, [ebp+var_C] ; this
		call	?exclusiveOr@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::exclusiveOr(int const	*,int,signed char)

loc_903C:				; CODE XREF: icu_56::UnicodeSet::complement(int,int)+6Cj
		mov	ecx, [ebp+var_C] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	eax, [ebp+var_C]

loc_9047:				; CODE XREF: icu_56::UnicodeSet::complement(int,int)+4Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN8_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?complement@UnicodeSet@icu_56@@UAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
$LN8_0		dd 1			; DATA XREF: icu_56::UnicodeSet::complement(int,int)+A3o
		dd offset $LN7_6
$LN7_6		dd 0FFFFFFE0h, 0Ch	; DATA XREF: .text:0000907Co
		dd offset $LN6_5	; "range"
$LN6_5		db 'range',0            ; DATA XREF: .text:00009088o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9094h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::complement(icu_56::UnicodeSet *this, int)
		public ?complement@UnicodeSet@icu_56@@QAEAAV12@H@Z
?complement@UnicodeSet@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+50h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?complement@UnicodeSet@icu_56@@QAEAAV12@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::complement(icu_56::UnicodeSet *__hidden this)
		public ?complement@UnicodeSet@icu_56@@UAEAAV12@XZ
?complement@UnicodeSet@icu_56@@UAEAAV12@XZ proc	near ; DATA XREF: .rdata:00005E78o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_912D
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_9135

loc_912D:				; CODE XREF: icu_56::UnicodeSet::complement(void)+30j
		mov	eax, [ebp+var_8]
		jmp	loc_9254
; ---------------------------------------------------------------------------

loc_9135:				; CODE XREF: icu_56::UnicodeSet::complement(void)+3Fj
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		cmp	dword ptr [ecx], 0
		jnz	short loc_91C4
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		sub	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_9178
		mov	eax, [ebp+var_8]
		jmp	loc_9254
; ---------------------------------------------------------------------------

loc_9178:				; CODE XREF: icu_56::UnicodeSet::complement(void)+82j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		add	ecx, 4
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_8]
		mov	eax, [edx+8]
		lea	ecx, ds:0FFFFFFFCh[eax*4]
		push	ecx		; Size
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		add	eax, 4
		push	eax		; Src
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+18h]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx
		jmp	short loc_9241
; ---------------------------------------------------------------------------

loc_91C4:				; CODE XREF: icu_56::UnicodeSet::complement(void)+59j
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_91F2
		mov	eax, [ebp+var_8]
		jmp	short loc_9254
; ---------------------------------------------------------------------------

loc_91F2:				; CODE XREF: icu_56::UnicodeSet::complement(void)+FFj
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_8]
		mov	eax, [edx+8]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		push	edx		; Src
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		add	ecx, 4
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	dword ptr [ecx], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+8], ecx

loc_9241:				; CODE XREF: icu_56::UnicodeSet::complement(void)+D6j
		mov	ecx, [ebp+var_8] ; this
		call	?swapBuffers@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::swapBuffers(void)
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	eax, [ebp+var_8]

loc_9254:				; CODE XREF: icu_56::UnicodeSet::complement(void)+44j
					; icu_56::UnicodeSet::complement(void)+87j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?complement@UnicodeSet@icu_56@@UAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
$LN11_1		dd 1			; DATA XREF: icu_56::UnicodeSet::complement(void)+16Co
		dd offset $LN10_1
$LN10_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:00009280o
		dd offset $LN9_2	; "status"
$LN9_2		db 'status',0           ; DATA XREF: .text:0000928Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9298h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::complement(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?complement@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z
?complement@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		test	eax, eax
		jz	short loc_92E5
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_92E5
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_92EA

loc_92E5:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+2Dj
					; icu_56::UnicodeSet::complement(icu_56::UnicodeString const &)+3Cj
		mov	eax, [ebp+var_8]
		jmp	short loc_935D
; ---------------------------------------------------------------------------

loc_92EA:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+4Bj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?getSingleCP@UnicodeSet@icu_56@@CAHABVUnicodeString@2@@Z ; icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString const &)
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_933C
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?contains@UVector@icu_56@@QBECPAX@Z ; icu_56::UVector::contains(void *)
		movsx	edx, al
		test	edx, edx
		jz	short loc_9326
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?removeElement@UVector@icu_56@@QAECPAX@Z ; icu_56::UVector::removeElement(void *)
		jmp	short loc_9332
; ---------------------------------------------------------------------------

loc_9326:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+7Bj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z ; icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)

loc_9332:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+8Cj
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		jmp	short loc_935A
; ---------------------------------------------------------------------------

loc_933C:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+65j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+50h]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_935A:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+A2j
		mov	eax, [ebp+var_8]

loc_935D:				; CODE XREF: icu_56::UnicodeSet::complement(icu_56::UnicodeString const	&)+50j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?complement@UnicodeSet@icu_56@@QAEAAV12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9374h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::addAll(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z
?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z proc near ; DATA XREF: .rdata:00005E5Co

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jle	short loc_93C1
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_93C1
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?add@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::add(int const	*,int,signed char)

loc_93C1:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)+2Aj
					; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet	const &)+33j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_9422
		mov	[ebp+var_14], 0
		jmp	short loc_93DC
; ---------------------------------------------------------------------------

loc_93D3:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &):loc_9420j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_93DC:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)+5Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_9422
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+28h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?contains@UVector@icu_56@@QBECPAX@Z ; icu_56::UVector::contains(void *)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_9420
		mov	eax, [ebp+var_20]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z ; icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)

loc_9420:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)+9Ej
		jmp	short loc_93D3
; ---------------------------------------------------------------------------

loc_9422:				; CODE XREF: icu_56::UnicodeSet::addAll(icu_56::UnicodeSet const &)+54j
					; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet	const &)+76j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?addAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 943Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet *this,	const struct icu_56::UnicodeSet	*)
		public ?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z
?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z	proc near ; DATA XREF: .rdata:00005E60o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_947D
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_9482

loc_947D:				; CODE XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)+30j
		mov	eax, [ebp+var_8]
		jmp	short loc_94AF
; ---------------------------------------------------------------------------

loc_9482:				; CODE XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)+3Fj
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::retain(int	const *,int,signed char)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		push	ecx		; struct icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+28h]	; this
		call	?retainAll@UVector@icu_56@@QAECABV12@@Z	; icu_56::UVector::retainAll(icu_56::UVector const &)
		mov	eax, [ebp+var_8]

loc_94AF:				; CODE XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?retainAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 94C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet *this,	const struct icu_56::UnicodeSet	*)
		public ?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z
?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z	proc near ; DATA XREF: .rdata:00005E68o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9509
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_950E

loc_9509:				; CODE XREF: icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)+30j
		mov	eax, [ebp+var_8]
		jmp	short loc_953B
; ---------------------------------------------------------------------------

loc_950E:				; CODE XREF: icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)+3Fj
		push	2		; signed __int8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::retain(int	const *,int,signed char)
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		push	ecx		; struct icu_56::UVector *
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+28h]	; this
		call	?removeAll@UVector@icu_56@@QAECABV12@@Z	; icu_56::UVector::removeAll(icu_56::UVector const &)
		mov	eax, [ebp+var_8]

loc_953B:				; CODE XREF: icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?removeAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9554h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z
?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z proc near ;	DATA XREF: .rdata:00005E64o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9595
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_959A

loc_9595:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&)+30j
		mov	eax, [ebp+var_8]
		jmp	short loc_960D
; ---------------------------------------------------------------------------

loc_959A:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&)+3Fj
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?exclusiveOr@UnicodeSet@icu_56@@AAEXPBHHC@Z ; icu_56::UnicodeSet::exclusiveOr(int const	*,int,signed char)
		mov	[ebp+var_14], 0
		jmp	short loc_95C4
; ---------------------------------------------------------------------------

loc_95BB:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&):loc_9608j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_95C4:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&)+65j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_960A
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+28h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		push	eax		; void *
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?removeElement@UVector@icu_56@@QAECPAX@Z ; icu_56::UVector::removeElement(void *)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_9608
		mov	eax, [ebp+var_20]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?_add@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z ; icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)

loc_9608:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&)+A6j
		jmp	short loc_95BB
; ---------------------------------------------------------------------------

loc_960A:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&)+7Ej
		mov	eax, [ebp+var_8]

loc_960D:				; CODE XREF: icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const	&)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?complementAll@UnicodeSet@icu_56@@UAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::clear(icu_56::UnicodeSet *__hidden this)
		public ?clear@UnicodeSet@icu_56@@UAEAAV12@XZ
?clear@UnicodeSet@icu_56@@UAEAAV12@XZ proc near	; DATA XREF: .rdata:00005E7Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_965B
		mov	eax, [ebp+var_8]
		jmp	short loc_96B2
; ---------------------------------------------------------------------------

loc_965B:				; CODE XREF: icu_56::UnicodeSet::clear(void)+30j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_9670
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	dword ptr [ecx], 110000h

loc_9670:				; CODE XREF: icu_56::UnicodeSet::clear(void)+3Ej
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+8], 1
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_9696
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]	; this
		call	?removeAllElements@UVector@icu_56@@QAEXXZ ; icu_56::UVector::removeAllElements(void)

loc_9696:				; CODE XREF: icu_56::UnicodeSet::clear(void)+65j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_96AF
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_96AF
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+30h], 0

loc_96AF:				; CODE XREF: icu_56::UnicodeSet::clear(void)+79j
					; icu_56::UnicodeSet::clear(void)+82j
		mov	eax, [ebp+var_8]

loc_96B2:				; CODE XREF: icu_56::UnicodeSet::clear(void)+35j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@UnicodeSet@icu_56@@UAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::getRangeCount(icu_56::UnicodeSet *__hidden	this)
		public ?getRangeCount@UnicodeSet@icu_56@@UBEHXZ
?getRangeCount@UnicodeSet@icu_56@@UBEHXZ proc near ; DATA XREF:	.rdata:00005E84o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		cdq
		sub	eax, edx
		sar	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getRangeCount@UnicodeSet@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9700h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::getRangeStart(icu_56::UnicodeSet *this, int)
		public ?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z
?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z proc near ; DATA XREF: .rdata:00005E88o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 1
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	eax, [edx+eax*4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getRangeStart@UnicodeSet@icu_56@@UBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 973Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::getRangeEnd(icu_56::UnicodeSet *this, int)
		public ?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z
?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z	proc near ; DATA XREF: .rdata:00005E8Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 1
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		mov	eax, [edx+eax*4+4]
		sub	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getRangeEnd@UnicodeSet@icu_56@@UBEHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 977Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::getStringCount(icu_56::UnicodeSet *__hidden this)
		public ?getStringCount@UnicodeSet@icu_56@@ABEHXZ
?getStringCount@UnicodeSet@icu_56@@ABEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getStringCount@UnicodeSet@icu_56@@ABEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 97C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::UnicodeSet::getString(icu_56::UnicodeSet *this, int)
		public ?getString@UnicodeSet@icu_56@@ABEPBVUnicodeString@2@H@Z
?getString@UnicodeSet@icu_56@@ABEPBVUnicodeString@2@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+28h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getString@UnicodeSet@icu_56@@ABEPBVUnicodeString@2@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9808h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__thiscall	icu_56::UnicodeSet::compact(icu_56::UnicodeSet *__hidden this)
		public ?compact@UnicodeSet@icu_56@@UAEAAV12@XZ
?compact@UnicodeSet@icu_56@@UAEAAV12@XZ	proc near ; DATA XREF: .rdata:00005E90o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_9849
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_984E

loc_9849:				; CODE XREF: icu_56::UnicodeSet::compact(void)+30j
		mov	eax, [ebp+var_8]
		jmp	short loc_98C7
; ---------------------------------------------------------------------------

loc_984E:				; CODE XREF: icu_56::UnicodeSet::compact(void)+3Fj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_9870
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+18h], 0

loc_9870:				; CODE XREF: icu_56::UnicodeSet::compact(void)+4Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jge	short loc_98C4
		mov	eax, [ebp+var_8]
		xor	ecx, ecx
		cmp	dword ptr [eax+8], 0
		setz	cl
		mov	edx, [ebp+var_8]
		add	ecx, [edx+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		shl	eax, 2
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		push	edx
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_98C4
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+0Ch], ecx

loc_98C4:				; CODE XREF: icu_56::UnicodeSet::compact(void)+74j
					; icu_56::UnicodeSet::compact(void)+A8j
		mov	eax, [ebp+var_8]

loc_98C7:				; CODE XREF: icu_56::UnicodeSet::compact(void)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compact@UnicodeSet@icu_56@@UAEAAV12@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 98DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::UnicodeSet::UnicodeSet(unsigned short const * const, int, enum  icu_56::UnicodeSet::ESerialization, enum  UErrorCode &)
		public ??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z
??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z proc near

var_100		= byte ptr -100h
var_FE		= word ptr -0FEh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UnicodeFilter@icu_56@@QAE@XZ	; icu_56::UnicodeFilter::UnicodeFilter(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UnicodeSet@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], offset ??_7UnicodeSet@icu_56@@6BUnicodeMatcher@1@@ ;	const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 11h
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+30h], 0
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_99CD
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	loc_9B89
; ---------------------------------------------------------------------------

loc_99CD:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+E2j
		cmp	[ebp+arg_8], 0
		jnz	short loc_99DF
		cmp	[ebp+arg_0], 0
		jz	short loc_99DF
		cmp	[ebp+arg_4], 1
		jge	short loc_99F5

loc_99DF:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+F5j
					; icu_56::UnicodeSet::UnicodeSet(ushort	const *	const,int,icu_56::UnicodeSet::ESerialization,UErrorCode	&)+FBj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	loc_9B89
; ---------------------------------------------------------------------------

loc_99F5:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+101j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::allocateStrings(UErrorCode &)
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9A23
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	loc_9B89
; ---------------------------------------------------------------------------

loc_9A23:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+138j
		mov	eax, [ebp+arg_0]
		movzx	ecx, word ptr [eax]
		and	ecx, 8000h
		neg	ecx
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		mov	[ebp+var_20], ecx
		cmp	[ebp+var_20], 1
		jnz	short loc_9A50
		mov	eax, [ebp+arg_0]
		mov	cx, [eax]
		mov	[ebp+var_FE], cx
		jmp	short loc_9A5E
; ---------------------------------------------------------------------------

loc_9A50:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+163j
		mov	edx, [ebp+arg_0]
		mov	ax, [edx+2]
		mov	[ebp+var_FE], ax

loc_9A5E:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+172j
		movzx	ecx, [ebp+var_FE]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		movzx	eax, word ptr [eax]
		and	eax, 7FFFh
		sub	eax, [ebp+var_2C]
		cdq
		sub	eax, edx
		sar	eax, 1
		add	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		add	ecx, 1
		mov	edx, [ebp+var_14]
		mov	[edx+0Ch], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_14]
		mov	[edx+10h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_9AC9
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9AD6

loc_9AC9:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+1D6j
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	loc_9B89
; ---------------------------------------------------------------------------

loc_9AD6:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+1EBj
		mov	[ebp+var_38], 0
		jmp	short loc_9AE8
; ---------------------------------------------------------------------------

loc_9ADF:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+22Dj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_9AE8:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+201j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_2C]
		jge	short loc_9B0B
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+10h]
		mov	eax, [ebp+var_38]
		mov	[ecx+eax*4], edx
		jmp	short loc_9ADF
; ---------------------------------------------------------------------------

loc_9B0B:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+212j
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_38], eax
		jmp	short loc_9B1C
; ---------------------------------------------------------------------------

loc_9B13:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+289j
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_9B1C:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+235j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_38]
		cmp	ecx, [eax+8]
		jge	short loc_9B67
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_38]
		sub	ecx, [ebp+var_2C]
		lea	edx, [eax+ecx*2]
		mov	eax, [ebp+arg_0]
		movzx	ecx, word ptr [eax+edx*2]
		shl	ecx, 10h
		mov	edx, [ebp+var_20]
		add	edx, [ebp+var_2C]
		mov	eax, [ebp+var_38]
		sub	eax, [ebp+var_2C]
		lea	edx, [edx+eax*2]
		mov	eax, [ebp+arg_0]
		movzx	edx, word ptr [eax+edx*2+2]
		add	ecx, edx
		mov	eax, [ebp+var_14]
		mov	edx, [eax+10h]
		mov	eax, [ebp+var_38]
		mov	[edx+eax*4], ecx
		jmp	short loc_9B13
; ---------------------------------------------------------------------------

loc_9B67:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+249j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+10h]
		mov	dword ptr [eax+ecx*4], 110000h
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+8]
		add	edx, 1
		mov	eax, [ebp+var_14]
		mov	[eax+8], edx

loc_9B89:				; CODE XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+ECj
					; icu_56::UnicodeSet::UnicodeSet(ushort	const *	const,int,icu_56::UnicodeSet::ESerialization,UErrorCode	&)+114j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9BB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00009BE0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
__unwindfunclet$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::UnicodeSet(ushort const * const,int,icu_56::UnicodeSet::ESerialization,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9BDCh
__unwindtable$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00009BECo
		dd offset __unwindfunclet$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UnicodeSet@icu_56@@QAE@QBGHW4ESerialization@01@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeSet::serialize(icu_56::UnicodeSet *this, unsigned __int16 *, int, enum UErrorCode *)
		public ?serialize@UnicodeSet@icu_56@@QBEHPAGHAAW4UErrorCode@@@Z
?serialize@UnicodeSet@icu_56@@QBEHPAGHAAW4UErrorCode@@@Z proc near

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9C47
		xor	eax, eax
		jmp	loc_9E25
; ---------------------------------------------------------------------------

loc_9C47:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+36j
		cmp	[ebp+arg_4], 0
		jl	short loc_9C59
		cmp	[ebp+arg_4], 0
		jle	short loc_9C69
		cmp	[ebp+arg_0], 0
		jnz	short loc_9C69

loc_9C59:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+43j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_9E25
; ---------------------------------------------------------------------------

loc_9C69:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+49j
					; icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode	&)+4Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		sub	ecx, 1
		mov	[ebp+var_20], ecx
		jnz	short loc_9C9A
		cmp	[ebp+arg_4], 0
		jle	short loc_9C87
		xor	eax, eax
		mov	ecx, [ebp+arg_0]
		mov	[ecx], ax
		jmp	short loc_9C90
; ---------------------------------------------------------------------------

loc_9C87:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+73j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Fh

loc_9C90:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+7Dj
		mov	eax, 1
		jmp	loc_9E25
; ---------------------------------------------------------------------------

loc_9C9A:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+6Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		cmp	dword ptr [ecx+edx*4-4], 0FFFFh
		jg	short loc_9CB5
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jmp	short loc_9D11
; ---------------------------------------------------------------------------

loc_9CB5:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+A3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		cmp	dword ptr [ecx], 10000h
		jl	short loc_9CD4
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_20]
		shl	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_9D11
; ---------------------------------------------------------------------------

loc_9CD4:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+B9j
		mov	[ebp+var_14], 0
		jmp	short loc_9CE6
; ---------------------------------------------------------------------------

loc_9CDD:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+F8j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_9CE6:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+D3j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jge	short loc_9D02
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		cmp	dword ptr [ecx+edx*4], 0FFFFh
		jg	short loc_9D02
		jmp	short loc_9CDD
; ---------------------------------------------------------------------------

loc_9D02:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+E4j
					; icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode	&)+F6j
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_20], edx

loc_9D11:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+ABj
					; icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode	&)+CAj
		cmp	[ebp+var_20], 7FFFh
		jle	short loc_9D2A
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_9E25
; ---------------------------------------------------------------------------

loc_9D2A:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+110j
		mov	eax, [ebp+var_20]
		xor	ecx, ecx
		cmp	eax, [ebp+var_14]
		setnle	cl
		add	ecx, 1
		add	ecx, [ebp+var_20]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_4]
		jg	loc_9E19
		mov	eax, [ebp+arg_0]
		mov	cx, word ptr [ebp+var_20]
		mov	[eax], cx
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jle	short loc_9D81
		mov	eax, [ebp+arg_0]
		movzx	ecx, word ptr [eax]
		or	ecx, 8000h
		mov	edx, [ebp+arg_0]
		mov	[edx], cx
		mov	eax, [ebp+arg_0]
		add	eax, 2
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_0]
		mov	dx, word ptr [ebp+var_14]
		mov	[ecx], dx

loc_9D81:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+152j
		mov	eax, [ebp+arg_0]
		add	eax, 2
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_38], ecx
		mov	[ebp+var_44], 0
		jmp	short loc_9DA5
; ---------------------------------------------------------------------------

loc_9D9C:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+1C3j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_9DA5:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+192j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_14]
		jge	short loc_9DCD
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	dx, [ecx]
		mov	[eax], dx
		mov	eax, [ebp+arg_0]
		add	eax, 2
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 4
		mov	[ebp+var_38], ecx
		jmp	short loc_9D9C
; ---------------------------------------------------------------------------

loc_9DCD:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+1A3j
		jmp	short loc_9DD8
; ---------------------------------------------------------------------------

loc_9DCF:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+20Dj
		mov	eax, [ebp+var_44]
		add	eax, 2
		mov	[ebp+var_44], eax

loc_9DD8:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &):loc_9DCDj
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_20]
		jge	short loc_9E17
		mov	eax, [ebp+var_38]
		mov	ecx, [eax]
		sar	ecx, 10h
		mov	edx, [ebp+arg_0]
		mov	[edx], cx
		mov	eax, [ebp+arg_0]
		add	eax, 2
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	dx, [ecx]
		mov	[eax], dx
		mov	eax, [ebp+arg_0]
		add	eax, 2
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 4
		mov	[ebp+var_38], ecx
		jmp	short loc_9DCF
; ---------------------------------------------------------------------------

loc_9E17:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+1D6j
		jmp	short loc_9E22
; ---------------------------------------------------------------------------

loc_9E19:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+13Cj
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Fh

loc_9E22:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &):loc_9E17j
		mov	eax, [ebp+var_2C]

loc_9E25:				; CODE XREF: icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode &)+3Aj
					; icu_56::UnicodeSet::serialize(ushort *,int,UErrorCode	&)+5Cj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?serialize@UnicodeSet@icu_56@@QBEHPAGHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::allocateStrings(icu_56::UnicodeSet *this, enum UErrorCode *)
		public ?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z
?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+DDp
					; icu_56::UnicodeSet::UnicodeSet(int,int)+DDp ...

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9E9A
		xor	al, al
		jmp	loc_9F91
; ---------------------------------------------------------------------------

loc_9E9A:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+55j
		push	18h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_9EDD
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	1		; int
		push	offset _uhash_compareUnicodeString_56 ;	signed __int8 (__cdecl __high *)(union UElement, union UElement)
		push	offset _uprv_deleteUObject_56 ;	void (__cdecl *)(void *)
		mov	ecx, [ebp+var_F8] ; this
		call	??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z ;	icu_56::UVector::UVector(void (*)(void *),signed char (*)(UElement,UElement),int,UErrorCode &)
		mov	[ebp+var_10C], eax
		jmp	short loc_9EE7
; ---------------------------------------------------------------------------

loc_9EDD:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+7Cj
		mov	[ebp+var_10C], 0

loc_9EE7:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+9Fj
		mov	ecx, [ebp+var_10C]
		mov	[ebp+var_104], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_104]
		mov	[edx+28h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_9F1C
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_9F91
; ---------------------------------------------------------------------------

loc_9F1C:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+D1j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9F8F
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_9F77
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_9F81
; ---------------------------------------------------------------------------

loc_9F77:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+114j
		mov	[ebp+var_10C], 0

loc_9F81:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+139j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+28h], 0
		xor	al, al
		jmp	short loc_9F91
; ---------------------------------------------------------------------------

loc_9F8F:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+F3j
		mov	al, 1

loc_9F91:				; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+59j
					; icu_56::UnicodeSet::allocateStrings(UErrorCode &)+DEj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 9FB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00009FE4o
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9FE0h
__unwindtable$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00009FF0o
		dd offset __unwindfunclet$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z$0
__ehfuncinfo$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?allocateStrings@UnicodeSet@icu_56@@AAECAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A00Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::ensureCapacity(icu_56::UnicodeSet	*this, int, enum UErrorCode *)
		public ?ensureCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z
?ensureCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+A0p
					; icu_56::UnicodeSet::add(int)+B1p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+0Ch]
		jg	short loc_A03C
		jmp	short loc_A087
; ---------------------------------------------------------------------------

loc_A03C:				; CODE XREF: icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)+2Cj
		mov	eax, [ebp+arg_0]
		lea	ecx, ds:40h[eax*4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_A072
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	ecx, [ebp+var_8] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	short loc_A087
; ---------------------------------------------------------------------------

loc_A072:				; CODE XREF: icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)+51j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		add	eax, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+0Ch], eax

loc_A087:				; CODE XREF: icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)+2Ej
					; icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)+64j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::ensureBufferCapacity(icu_56::UnicodeSet *this, int, enum UErrorCode *)
		public ?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z
?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::complement(void)+6Cp
					; icu_56::UnicodeSet::complement(void)+E9p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_A0D9
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+1Ch]
		jg	short loc_A0D9
		jmp	short loc_A124
; ---------------------------------------------------------------------------

loc_A0D9:				; CODE XREF: icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)+2Aj
					; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)+35j
		mov	eax, [ebp+arg_0]
		lea	ecx, ds:40h[eax*4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+18h]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_A10F
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		mov	ecx, [ebp+var_8] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		jmp	short loc_A124
; ---------------------------------------------------------------------------

loc_A10F:				; CODE XREF: icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)+5Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+18h], ecx
		mov	eax, [ebp+arg_0]
		add	eax, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx+1Ch], eax

loc_A124:				; CODE XREF: icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)+37j
					; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)+6Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A13Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::swapBuffers(icu_56::UnicodeSet *__hidden this)
		public ?swapBuffers@UnicodeSet@icu_56@@AAEXXZ
?swapBuffers@UnicodeSet@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeSet::complement(void)+158p
					; icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+1D1p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+18h]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+18h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+1Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		mov	[eax+1Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?swapBuffers@UnicodeSet@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A1A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::setToBogus(icu_56::UnicodeSet *__hidden this)
		public ?setToBogus@UnicodeSet@icu_56@@QAEXXZ
?setToBogus@UnicodeSet@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+129p
					; icu_56::UnicodeSet::UnicodeSet(int,int)+139p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+58h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+30h], 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToBogus@UnicodeSet@icu_56@@QAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A1F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::exclusiveOr(icu_56::UnicodeSet *this, const int *, int, signed __int8)
		public ?exclusiveOr@UnicodeSet@icu_56@@AAEXPBHHC@Z
?exclusiveOr@UnicodeSet@icu_56@@AAEXPBHHC@Z proc near
					; CODE XREF: icu_56::UnicodeSet::complement(int,int)+8Fp
					; icu_56::UnicodeSet::complementAll(icu_56::UnicodeSet const &)+59p

var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A239
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_A23E

loc_A239:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+30j
		jmp	loc_A3D6
; ---------------------------------------------------------------------------

loc_A23E:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+3Fj
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A273
		jmp	loc_A3D6
; ---------------------------------------------------------------------------

loc_A273:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+74j
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		cmp	eax, 1
		jz	short loc_A2B2
		movsx	eax, [ebp+arg_8]
		cmp	eax, 2
		jnz	short loc_A2DC

loc_A2B2:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+AFj
		mov	[ebp+var_50], 0
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4], 0
		jnz	short loc_A2DA
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx

loc_A2DA:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+CBj
		jmp	short loc_A2F1
; ---------------------------------------------------------------------------

loc_A2DC:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+B8j
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_A2F1:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char):loc_A2DAj
					; icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char):loc_A3C1j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_50]
		jge	short loc_A32E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		jmp	loc_A3C1
; ---------------------------------------------------------------------------

loc_A32E:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+FFj
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_A365
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		jmp	short loc_A3C1
; ---------------------------------------------------------------------------

loc_A365:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+13Cj
		cmp	[ebp+var_44], 110000h
		jz	short loc_A39D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		jmp	short loc_A3C1
; ---------------------------------------------------------------------------

loc_A39D:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+174j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	dword ptr [ecx+edx*4], 110000h
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		mov	[eax+8], ecx
		jmp	short loc_A3C6
; ---------------------------------------------------------------------------

loc_A3C1:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+131j
					; icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+16Bj ...
		jmp	loc_A2F1
; ---------------------------------------------------------------------------

loc_A3C6:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+1C7j
		mov	ecx, [ebp+var_8] ; this
		call	?swapBuffers@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::swapBuffers(void)
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)

loc_A3D6:				; CODE XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char):loc_A239j
					; icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+76j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?exclusiveOr@UnicodeSet@icu_56@@AAEXPBHHC@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN20_0		dd 1			; DATA XREF: icu_56::UnicodeSet::exclusiveOr(int const *,int,signed char)+1E2o
		dd offset $LN19_0
$LN19_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000A404o
		dd offset $LN18_0	; "status"
$LN18_0		db 'status',0           ; DATA XREF: .text:0000A410o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A41Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::add(icu_56::UnicodeSet *this, const int *, int, signed __int8)
		public ?add@UnicodeSet@icu_56@@AAEXPBHHC@Z
?add@UnicodeSet@icu_56@@AAEXPBHHC@Z proc near
					; CODE XREF: icu_56::UnicodeSet::add(int,int)+6Cp
					; icu_56::UnicodeSet::addAll(icu_56::UnicodeSet	const &)+48p

var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A463
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_A463
		cmp	[ebp+arg_0], 0
		jnz	short loc_A468

loc_A463:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+30j
					; icu_56::UnicodeSet::add(int const *,int,signed char)+3Fj
		jmp	loc_A93A
; ---------------------------------------------------------------------------

loc_A468:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+45j
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_A49D
		jmp	loc_A93A
; ---------------------------------------------------------------------------

loc_A49D:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+7Aj
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_A4DF:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char):loc_A903j
		movsx	eax, [ebp+arg_8]
		mov	[ebp+var_118], eax
		cmp	[ebp+var_118], 3 ; switch 4 cases
		ja	loc_A903	; jumptable 0000A4FC default case
		mov	ecx, [ebp+var_118]
		jmp	ds:$LN47[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN34:					; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+E0j
					; DATA XREF: .text:$LN47o
		mov	eax, [ebp+var_44] ; jumptable 0000A4FC case 0
		cmp	eax, [ebp+var_50]
		jge	loc_A596
		cmp	[ebp+var_38], 0
		jle	short loc_A557
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		cmp	eax, [ecx+edx*4-4]
		jg	short loc_A557
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+18h]
		mov	eax, [ebp+var_38]
		mov	ecx, [edx+eax*4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	ecx, [ebp+var_20]
		mov	edx, [eax+ecx*4]
		push	edx
		call	?max@icu_56@@YAHHH@Z ; icu_56::max(int,int)
		add	esp, 8
		mov	[ebp+var_44], eax
		jmp	short loc_A57E
; ---------------------------------------------------------------------------

loc_A557:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+F7j
					; icu_56::UnicodeSet::add(int const *,int,signed char)+109j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax

loc_A57E:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+139j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	loc_A6D7
; ---------------------------------------------------------------------------

loc_A596:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+EDj
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	loc_A623
		cmp	[ebp+var_38], 0
		jle	short loc_A5E7
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		cmp	eax, [ecx+edx*4-4]
		jg	short loc_A5E7
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+18h]
		mov	eax, [ebp+var_38]
		mov	ecx, [edx+eax*4]
		push	ecx
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+edx*4]
		push	ecx
		call	?max@icu_56@@YAHHH@Z ; icu_56::max(int,int)
		add	esp, 8
		mov	[ebp+var_50], eax
		jmp	short loc_A60B
; ---------------------------------------------------------------------------

loc_A5E7:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+18Aj
					; icu_56::UnicodeSet::add(int const *,int,signed char)+19Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx

loc_A60B:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+1C9j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	loc_A6D7
; ---------------------------------------------------------------------------

loc_A623:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+180j
		cmp	[ebp+var_44], 110000h
		jnz	short loc_A636
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------

loc_A636:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+20Ej
		cmp	[ebp+var_38], 0
		jle	short loc_A67E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		cmp	eax, [ecx+edx*4-4]
		jg	short loc_A67E
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+18h]
		mov	eax, [ebp+var_38]
		mov	ecx, [edx+eax*4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	ecx, [ebp+var_20]
		mov	edx, [eax+ecx*4]
		push	edx
		call	?max@icu_56@@YAHHH@Z ; icu_56::max(int,int)
		add	esp, 8
		mov	[ebp+var_44], eax
		jmp	short loc_A6A5
; ---------------------------------------------------------------------------

loc_A67E:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+21Ej
					; icu_56::UnicodeSet::add(int const *,int,signed char)+230j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax

loc_A6A5:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+260j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_A6D7:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+175j
					; icu_56::UnicodeSet::add(int const *,int,signed char)+202j
		jmp	loc_A903	; jumptable 0000A4FC default case
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+E0j
					; DATA XREF: .text:$LN47o
		mov	eax, [ebp+var_50] ; jumptable 0000A4FC case 3
		cmp	eax, [ebp+var_44]
		jg	short loc_A711
		cmp	[ebp+var_44], 110000h
		jnz	short loc_A6F7
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------

loc_A6F7:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+2CFj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		jmp	short loc_A73C
; ---------------------------------------------------------------------------

loc_A711:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+2C6j
		cmp	[ebp+var_50], 110000h
		jnz	short loc_A724
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------

loc_A724:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+2FCj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx

loc_A73C:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+2F3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	loc_A903	; jumptable 0000A4FC default case
; ---------------------------------------------------------------------------

$LN14_1:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+E0j
					; DATA XREF: .text:$LN47o
		mov	eax, [ebp+var_44] ; jumptable 0000A4FC case 1
		cmp	eax, [ebp+var_50]
		jge	short loc_A7C6
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	short loc_A843
; ---------------------------------------------------------------------------

loc_A7C6:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+36Cj
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_A7EF
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	short loc_A843
; ---------------------------------------------------------------------------

loc_A7EF:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+3B0j
		cmp	[ebp+var_44], 110000h
		jnz	short loc_A802
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------
		jmp	$loop_end$37768
; ---------------------------------------------------------------------------

loc_A802:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+3DAj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_A843:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+3A8j
					; icu_56::UnicodeSet::add(int const *,int,signed char)+3D1j
		jmp	loc_A903	; jumptable 0000A4FC default case
; ---------------------------------------------------------------------------

$LN7_7:					; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+E0j
					; DATA XREF: .text:$LN47o
		mov	eax, [ebp+var_50] ; jumptable 0000A4FC case 2
		cmp	eax, [ebp+var_44]
		jge	short loc_A889
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	short loc_A903	; jumptable 0000A4FC default case
; ---------------------------------------------------------------------------

loc_A889:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+432j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_50]
		jge	short loc_A8B5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	short loc_A903	; jumptable 0000A4FC default case
; ---------------------------------------------------------------------------

loc_A8B5:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+473j
		cmp	[ebp+var_44], 110000h
		jnz	short loc_A8C2
		jmp	short $loop_end$37768
; ---------------------------------------------------------------------------
		jmp	short $loop_end$37768
; ---------------------------------------------------------------------------

loc_A8C2:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+4A0j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_A903:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+D4j
					; icu_56::UnicodeSet::add(int const *,int,signed char):loc_A6D7j ...
		jmp	loc_A4DF	; jumptable 0000A4FC default case
; ---------------------------------------------------------------------------

$loop_end$37768:			; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+210j
					; icu_56::UnicodeSet::add(int const *,int,signed char)+215j ...
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	dword ptr [ecx+edx*4], 110000h
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		mov	[eax+8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?swapBuffers@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::swapBuffers(void)
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)

loc_A93A:				; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char):loc_A463j
					; icu_56::UnicodeSet::add(int const *,int,signed char)+7Cj
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN46
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?add@UnicodeSet@icu_56@@AAEXPBHHC@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN46		dd 1			; DATA XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+522o
		dd offset $LN45
$LN45		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000A968o
		dd offset $LN44		; "status"
$LN44		db 'status',0           ; DATA XREF: .text:0000A974o
		align 10h
$LN47		dd offset $LN34		; DATA XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+E0r
		dd offset $LN14_1	; jump table for switch	statement
		dd offset $LN7_7
		dd offset $LN21
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A990h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::max(int, int)
?max@icu_56@@YAHHH@Z proc near		; CODE XREF: icu_56::UnicodeSet::add(int const *,int,signed char)+12Ep
					; icu_56::UnicodeSet::add(int const *,int,signed char)+1BEp ...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jle	short loc_A9C1
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_C4], ecx
		jmp	short loc_A9CA
; ---------------------------------------------------------------------------

loc_A9C1:				; CODE XREF: icu_56::max(int,int)+24j
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_C4], edx

loc_A9CA:				; CODE XREF: icu_56::max(int,int)+2Fj
		mov	eax, [ebp+var_C4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?max@icu_56@@YAHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A9D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::retain(icu_56::UnicodeSet	*this, const int *, int, signed	__int8)
		public ?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z
?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z proc near
					; CODE XREF: icu_56::UnicodeSet::retain(int,int)+6Cp
					; icu_56::UnicodeSet::remove(int,int)+6Cp ...

var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_AA19
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_AA1E

loc_AA19:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+30j
		jmp	loc_AE39
; ---------------------------------------------------------------------------

loc_AA1E:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+3Fj
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		add	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureBufferCapacity@UnicodeSet@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UnicodeSet::ensureBufferCapacity(int,UErrorCode &)
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AA53
		jmp	loc_AE39
; ---------------------------------------------------------------------------

loc_AA53:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+74j
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_AA95:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char):loc_AE02j
		movsx	eax, [ebp+arg_8]
		mov	[ebp+var_118], eax
		cmp	[ebp+var_118], 3 ; switch 4 cases
		ja	loc_AE02	; jumptable 0000AAB2 default case
		mov	ecx, [ebp+var_118]
		jmp	ds:$LN41[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN28:					; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+DAj
					; DATA XREF: .text:$LN41o
		mov	eax, [ebp+var_44] ; jumptable 0000AAB2 case 0
		cmp	eax, [ebp+var_50]
		jge	short loc_AAE8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	loc_AB7D
; ---------------------------------------------------------------------------

loc_AAE8:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+E7j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_AB11
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	short loc_AB7D
; ---------------------------------------------------------------------------

loc_AB11:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+116j
		cmp	[ebp+var_44], 110000h
		jnz	short loc_AB24
		jmp	$loop_end$37821
; ---------------------------------------------------------------------------
		jmp	$loop_end$37821
; ---------------------------------------------------------------------------

loc_AB24:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+140j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_AB7D:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+10Bj
					; icu_56::UnicodeSet::retain(int const *,int,signed char)+137j
		jmp	loc_AE02	; jumptable 0000AAB2 default case
; ---------------------------------------------------------------------------

$LN21_0:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+DAj
					; DATA XREF: .text:$LN41o
		mov	eax, [ebp+var_44] ; jumptable 0000AAB2 case 3
		cmp	eax, [ebp+var_50]
		jge	short loc_ABC9
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	loc_AC76
; ---------------------------------------------------------------------------

loc_ABC9:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+1B0j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_AC0A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	short loc_AC76
; ---------------------------------------------------------------------------

loc_AC0A:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+1F7j
		cmp	[ebp+var_44], 110000h
		jnz	short loc_AC1D
		jmp	$loop_end$37821
; ---------------------------------------------------------------------------
		jmp	$loop_end$37821
; ---------------------------------------------------------------------------

loc_AC1D:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+239j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_AC76:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+1ECj
					; icu_56::UnicodeSet::retain(int const *,int,signed char)+230j
		jmp	loc_AE02	; jumptable 0000AAB2 default case
; ---------------------------------------------------------------------------

$LN14_2:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+DAj
					; DATA XREF: .text:$LN41o
		mov	eax, [ebp+var_44] ; jumptable 0000AAB2 case 1
		cmp	eax, [ebp+var_50]
		jge	short loc_ACAA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	loc_AD3F
; ---------------------------------------------------------------------------

loc_ACAA:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+2A9j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_ACEB
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_50]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	short loc_AD3F
; ---------------------------------------------------------------------------

loc_ACEB:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+2D8j
		cmp	[ebp+var_44], 110000h
		jnz	short loc_ACFE
		jmp	$loop_end$37821
; ---------------------------------------------------------------------------
		jmp	$loop_end$37821
; ---------------------------------------------------------------------------

loc_ACFE:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+31Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_AD3F:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+2CDj
					; icu_56::UnicodeSet::retain(int const *,int,signed char)+311j
		jmp	loc_AE02	; jumptable 0000AAB2 default case
; ---------------------------------------------------------------------------

$LN7_8:					; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+DAj
					; DATA XREF: .text:$LN41o
		mov	eax, [ebp+var_50] ; jumptable 0000AAB2 case 2
		cmp	eax, [ebp+var_44]
		jge	short loc_AD70
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al
		jmp	loc_AE02	; jumptable 0000AAB2 default case
; ---------------------------------------------------------------------------

loc_AD70:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+372j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_50]
		jge	short loc_ADB4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_44]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 1
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		jmp	short loc_AE02	; jumptable 0000AAB2 default case
; ---------------------------------------------------------------------------

loc_ADB4:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+39Ej
		cmp	[ebp+var_44], 110000h
		jnz	short loc_ADC1
		jmp	short $loop_end$37821
; ---------------------------------------------------------------------------
		jmp	short $loop_end$37821
; ---------------------------------------------------------------------------

loc_ADC1:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+3E3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		movsx	eax, [ebp+arg_8]
		xor	eax, 1
		mov	[ebp+arg_8], al
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		movsx	eax, [ebp+arg_8]
		xor	eax, 2
		mov	[ebp+arg_8], al

loc_AE02:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+CEj
					; icu_56::UnicodeSet::retain(int const *,int,signed char):loc_AB7Dj ...
		jmp	loc_AA95	; jumptable 0000AAB2 default case
; ---------------------------------------------------------------------------

$loop_end$37821:			; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+142j
					; icu_56::UnicodeSet::retain(int const *,int,signed char)+147j	...
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+18h]
		mov	edx, [ebp+var_38]
		mov	dword ptr [ecx+edx*4], 110000h
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		mov	[eax+8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?swapBuffers@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::swapBuffers(void)
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)

loc_AE39:				; CODE XREF: icu_56::UnicodeSet::retain(int const *,int,signed char):loc_AA19j
					; icu_56::UnicodeSet::retain(int const *,int,signed char)+76j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN40
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?retain@UnicodeSet@icu_56@@AAEXPBHHC@Z endp

; ---------------------------------------------------------------------------
$LN40		dd 1			; DATA XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+465o
		dd offset $LN39
$LN39		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000AE64o
		dd offset $LN38		; "status"
$LN38		db 'status',0           ; DATA XREF: .text:0000AE70o
		align 4
$LN41		dd offset $LN28		; DATA XREF: icu_56::UnicodeSet::retain(int const *,int,signed char)+DAr
		dd offset $LN14_2	; jump table for switch	statement
		dd offset $LN7_8
		dd offset $LN21_0
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AE8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UnicodeSet::_appendToPat(struct icu_56::UnicodeString *,	const struct icu_56::UnicodeString *, char)
		public ?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@ABV32@C@Z
?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@ABV32@C@Z proc near
					; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+23Dp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0
		jmp	short loc_AEC8
; ---------------------------------------------------------------------------

loc_AEB3:				; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,icu_56::UnicodeString const &,signed char)+6Dj
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_8]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_14]
		mov	[ebp+var_14], ecx

loc_AEC8:				; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,icu_56::UnicodeString const &,signed char)+25j
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+var_14], eax
		jge	short loc_AEFB
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_4] ; this
		call	?char32At@UnicodeString@icu_56@@QBEHH@Z	; icu_56::UnicodeString::char32At(int)
		mov	[ebp+var_8], eax
		movzx	ecx, [ebp+arg_8]
		push	ecx		; char
		mov	edx, [ebp+var_8]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z ; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)
		add	esp, 0Ch
		jmp	short loc_AEB3
; ---------------------------------------------------------------------------

loc_AEFB:				; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,icu_56::UnicodeString const &,signed char)+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@ABV32@C@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AF10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UnicodeSet::_appendToPat(struct icu_56::UnicodeString *,	int, char)
		public ?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z
?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z proc near
					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,icu_56::UnicodeString const &,signed char)+65p
					; icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString &,signed char)+110p ...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_AF62
		mov	eax, [ebp+arg_4]
		push	eax		; int
		call	?isUnprintable@ICU_Utility@icu_56@@SACH@Z ; icu_56::ICU_Utility::isUnprintable(int)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AF62
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		call	?escapeUnprintable@ICU_Utility@icu_56@@SACAAVUnicodeString@2@H@Z ; icu_56::ICU_Utility::escapeUnprintable(icu_56::UnicodeString	&,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_AF62
		jmp	short loc_AFCC
; ---------------------------------------------------------------------------

loc_AF62:				; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+24j
					; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+37j ...
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_C4], eax
		mov	ecx, [ebp+var_C4]
		sub	ecx, 24h ; '$'
		mov	[ebp+var_C4], ecx
		cmp	[ebp+var_C4], 59h ; 'Y' ; switch 90 cases
		ja	short $LN2	; jumptable 0000AF90 default case
		mov	edx, [ebp+var_C4]
		movzx	eax, ds:$LN10_2[edx]
		jmp	ds:$LN11_2[eax*4] ; switch jump
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+80j
					; DATA XREF: .text:$LN11_2o
		push	5Ch ; '\'       ; jumptable 0000AF90 cases 0,2,9,22,55-58,87,89
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		jmp	short loc_AFC0
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+71j
					; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+80j
					; DATA XREF: ...
		mov	eax, [ebp+arg_4] ; jumptable 0000AF90 default case
		push	eax		; int
		call	?isWhiteSpace@PatternProps@icu_56@@SACH@Z ; icu_56::PatternProps::isWhiteSpace(int)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_AFC0
		push	5Ch ; '\'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)

loc_AFC0:				; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+91j
					; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+A4j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)

loc_AFCC:				; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+50j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z endp

; ---------------------------------------------------------------------------
$LN11_2		dd offset $LN3,	offset $LN2
					; DATA XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+80r
					; jump table for switch	statement
$LN10_2		db	0,     1,     0,     1
					; DATA XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+79r
		db	1,     1,     1,     1 ; indirect table	for switch statement
		db	1,     0,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     0,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     0
		db	0,     0,     0,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     0
		db	1,     0
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeSet::_toPattern(icu_56::UnicodeSet *this, struct icu_56::UnicodeString *, signed __int8)
		public ?_toPattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z
?_toPattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z proc near
					; CODE XREF: icu_56::UnicodeSet::toPattern(icu_56::UnicodeString &,signed char)+3Cp

var_FC		= byte ptr -0FCh
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+24h], 0
		jz	loc_B18E
		mov	[ebp+var_20], 0
		mov	[ebp+var_14], 0

loc_B082:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char):loc_B184j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+20h]
		jge	loc_B189
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		mov	edx, [ebp+var_14]
		movzx	eax, word ptr [ecx+edx*2]
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_B104
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+20h]
		jz	short loc_B104
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		mov	edx, [ebp+var_14]
		mov	ax, [ecx+edx*2]
		mov	[ebp+var_38], ax
		movzx	ecx, [ebp+var_38]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_B104
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_2C]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_38]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_2C], edx

loc_B104:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+73j
					; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed	char)+7Ej ...
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_B160
		mov	eax, [ebp+var_2C]
		push	eax		; int
		call	?isUnprintable@ICU_Utility@icu_56@@SACH@Z ; icu_56::ICU_Utility::isUnprintable(int)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_B160
		mov	eax, [ebp+var_20]
		and	eax, 80000001h
		jns	short loc_B12E
		dec	eax
		or	eax, 0FFFFFFFEh
		inc	eax

loc_B12E:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+E3j
		cmp	eax, 1
		jnz	short loc_B147
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, 1
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)

loc_B147:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+EDj
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		call	?escapeUnprintable@ICU_Utility@icu_56@@SACAAVUnicodeString@2@H@Z ; icu_56::ICU_Utility::escapeUnprintable(icu_56::UnicodeString	&,int)
		add	esp, 8
		mov	[ebp+var_20], 0
		jmp	short loc_B184
; ---------------------------------------------------------------------------

loc_B160:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+C6j
					; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed	char)+D9j
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		cmp	[ebp+var_2C], 5Ch ; '\'
		jnz	short loc_B17D
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_B184
; ---------------------------------------------------------------------------

loc_B17D:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+12Cj
		mov	[ebp+var_20], 0

loc_B184:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+11Aj
					; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed	char)+137j
		jmp	loc_B082
; ---------------------------------------------------------------------------

loc_B189:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+47j
		mov	eax, [ebp+arg_0]
		jmp	short loc_B19F
; ---------------------------------------------------------------------------

loc_B18E:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+2Aj
		movzx	eax, [ebp+arg_4]
		push	eax		; signed __int8
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?_generatePattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z ; icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString &,signed char)

loc_B19F:				; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+148j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_toPattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B1B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeSet::toPattern(icu_56::UnicodeSet *this, struct icu_56::UnicodeString	*, signed __int8)
		public ?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z
?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z proc near
					; DATA XREF: .rdata:00005E14o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		movzx	eax, [ebp+arg_4]
		push	eax		; signed __int8
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8]
		sub	ecx, 4		; this
		call	?_toPattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z ; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?toPattern@UnicodeSet@icu_56@@UBEAAVUnicodeString@2@AAV32@C@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeSet *this, struct icu_56::UnicodeString *, signed __int8)
		public ?_generatePattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z
?_generatePattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z proc near
					; CODE XREF: icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed char)+156p

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	5Bh ; '['       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+60h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 1
		jle	loc_B364
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	loc_B364
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, 10FFFFh
		jnz	loc_B364
		push	5Eh ; '^'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		mov	[ebp+var_20], 1
		jmp	short loc_B2C4
; ---------------------------------------------------------------------------

loc_B2BB:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char):loc_B35Aj
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_B2C4:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+A9j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	loc_B35F
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		sub	eax, 1
		mov	[ebp+var_38], eax
		movzx	eax, [ebp+arg_4]
		push	eax		; char
		mov	ecx, [ebp+var_2C]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		call	?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z ; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)
		add	esp, 0Ch
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jz	short loc_B35A
		mov	eax, [ebp+var_2C]
		add	eax, 1
		cmp	eax, [ebp+var_38]
		jz	short loc_B345
		push	2Dh ; '-'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)

loc_B345:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+129j
		movzx	eax, [ebp+arg_4]
		push	eax		; char
		mov	ecx, [ebp+var_38]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		call	?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z ; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)
		add	esp, 0Ch

loc_B35A:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+11Ej
		jmp	loc_B2BB
; ---------------------------------------------------------------------------

loc_B35F:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+BAj
		jmp	loc_B408
; ---------------------------------------------------------------------------

loc_B364:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+4Aj
					; icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString &,signed char)+6Aj ...
		mov	[ebp+var_44], 0
		jmp	short loc_B376
; ---------------------------------------------------------------------------

loc_B36D:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char):loc_B403j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_B376:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+15Bj
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_14]
		jge	loc_B408
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+68h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_5C], eax
		movzx	eax, [ebp+arg_4]
		push	eax		; char
		mov	ecx, [ebp+var_50]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		call	?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z ; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)
		add	esp, 0Ch
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_5C]
		jz	short loc_B403
		mov	eax, [ebp+var_50]
		add	eax, 1
		cmp	eax, [ebp+var_5C]
		jz	short loc_B3EE
		push	2Dh ; '-'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)

loc_B3EE:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+1D2j
		movzx	eax, [ebp+arg_4]
		push	eax		; char
		mov	ecx, [ebp+var_5C]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		call	?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@HC@Z ; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)
		add	esp, 0Ch

loc_B403:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+1C7j
		jmp	loc_B36D
; ---------------------------------------------------------------------------

loc_B408:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char):loc_B35Fj
					; icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString &,signed char)+16Cj
		mov	[ebp+var_68], 0
		jmp	short loc_B41A
; ---------------------------------------------------------------------------

loc_B411:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+24Fj
		mov	eax, [ebp+var_68]
		add	eax, 1
		mov	[ebp+var_68], eax

loc_B41A:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+1FFj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+28h]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_68], eax
		jge	short loc_B461
		push	7Bh ; '{'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		movzx	eax, [ebp+arg_4]
		push	eax		; char
		mov	ecx, [ebp+var_68]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+28h]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		push	eax		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?_appendToPat@UnicodeSet@icu_56@@CAXAAVUnicodeString@2@ABV32@C@Z ; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,icu_56::UnicodeString const	&,signed char)
		add	esp, 0Ch
		push	7Dh ; '}'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		jmp	short loc_B411
; ---------------------------------------------------------------------------

loc_B461:				; CODE XREF: icu_56::UnicodeSet::_generatePattern(icu_56::UnicodeString	&,signed char)+218j
		push	5Dh ; ']'       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_generatePattern@UnicodeSet@icu_56@@ABEAAVUnicodeString@2@AAV32@C@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B484h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::releasePattern(icu_56::UnicodeSet	*__hidden this)
		public ?releasePattern@UnicodeSet@icu_56@@AAEXXZ
?releasePattern@UnicodeSet@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+166p
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+27Fp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+24h], 0
		jz	short loc_B4D3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+20h], 0

loc_B4D3:				; CODE XREF: icu_56::UnicodeSet::releasePattern(void)+2Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releasePattern@UnicodeSet@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B4E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeSet::setPattern(icu_56::UnicodeSet *this, const struct	icu_56::UnicodeString *)
		public ?setPattern@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z
?setPattern@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+1E3p
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+2C9p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?releasePattern@UnicodeSet@icu_56@@AAEXXZ ; icu_56::UnicodeSet::releasePattern(void)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		lea	ecx, [eax+eax+2]
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+var_8]
		mov	[edx+24h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+24h], 0
		jz	short loc_B572
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+20h], ecx
		push	0		; int
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+24h]
		push	ecx		; wchar_t *
		mov	edx, [ebp+var_8]
		mov	eax, [edx+20h]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z ; icu_56::UnicodeString::extractBetween(int,int,wchar_t *,int)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+20h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+24h]
		xor	edx, edx
		mov	[eax+ecx*2], dx

loc_B572:				; CODE XREF: icu_56::UnicodeSet::setPattern(icu_56::UnicodeString const	&)+53j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setPattern@UnicodeSet@icu_56@@AAEXABVUnicodeString@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B588h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeFunctor	*__thiscall icu_56::UnicodeSet::freeze(icu_56::UnicodeSet *__hidden this)
		public ?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ
?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ proc near

var_124		= dword	ptr -124h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	?isFrozen@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isFrozen(void)
		movsx	eax, al
		test	eax, eax
		jnz	loc_B7E1
		mov	ecx, [ebp+var_14] ; this
		call	?isBogus@UnicodeSet@icu_56@@QBECXZ ; icu_56::UnicodeSet::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	loc_B7E1
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_B612
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+18h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+18h], 0

loc_B612:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+6Fj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		add	ecx, 10h
		mov	edx, [ebp+var_14]
		cmp	[edx+0Ch], ecx
		jle	short loc_B673
		mov	eax, [ebp+var_14]
		xor	ecx, ecx
		cmp	dword ptr [eax+8], 0
		setz	cl
		mov	edx, [ebp+var_14]
		add	ecx, [edx+8]
		mov	eax, [ebp+var_14]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]
		shl	ecx, 2
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+10h]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	ecx, [ebp+var_14]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_B673
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)
		mov	eax, [ebp+var_14]
		jmp	loc_B7E4
; ---------------------------------------------------------------------------

loc_B673:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+99j
					; icu_56::UnicodeSet::freeze(void)+D9j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]	; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_B75A
		push	0D8h ; ''      ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_110], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_110], 0
		jz	short loc_B6CC
		push	3Fh ; '?'       ; unsigned int
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+28h]
		push	ecx		; struct icu_56::UVector *
		mov	edx, [ebp+var_14]
		push	edx		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_110] ; this
		call	??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z ; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)
		mov	[ebp+var_124], eax
		jmp	short loc_B6D6
; ---------------------------------------------------------------------------

loc_B6CC:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+122j
		mov	[ebp+var_124], 0

loc_B6D6:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+142j
		mov	eax, [ebp+var_124]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_11C]
		mov	[ecx+2Ch], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_B75A
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2Ch]	; this
		call	?needsStringSpanUTF16@UnicodeSetStringSpan@icu_56@@QAECXZ ; icu_56::UnicodeSetStringSpan::needsStringSpanUTF16(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_B75A
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+2Ch]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_B746
		push	1
		mov	ecx, [ebp+var_104]
		call	??_GUnicodeSetStringSpan@icu_56@@QAEPAXI@Z ; icu_56::UnicodeSetStringSpan::`scalar deleting destructor'(uint)
		mov	[ebp+var_124], eax
		jmp	short loc_B750
; ---------------------------------------------------------------------------

loc_B746:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+1A7j
		mov	[ebp+var_124], 0

loc_B750:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+1BCj
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2Ch], 0

loc_B75A:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+FBj
					; icu_56::UnicodeSet::freeze(void)+174j ...
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+2Ch], 0
		jnz	short loc_B7E1
		push	314h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_B7A7
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		mov	eax, [edx+10h]
		push	eax		; int *
		mov	ecx, [ebp+var_E0] ; this
		call	??0BMPSet@icu_56@@QAE@PBHH@Z ; icu_56::BMPSet::BMPSet(int const	*,int)
		mov	[ebp+var_124], eax
		jmp	short loc_B7B1
; ---------------------------------------------------------------------------

loc_B7A7:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+1FCj
		mov	[ebp+var_124], 0

loc_B7B1:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+21Dj
		mov	ecx, [ebp+var_124]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_EC]
		mov	[edx+14h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_B7E1
		mov	ecx, [ebp+var_14] ; this
		call	?setToBogus@UnicodeSet@icu_56@@QAEXXZ ;	icu_56::UnicodeSet::setToBogus(void)

loc_B7E1:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+4Fj
					; icu_56::UnicodeSet::freeze(void)+62j	...
		mov	eax, [ebp+var_14]

loc_B7E4:				; CODE XREF: icu_56::UnicodeSet::freeze(void)+E6j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B804h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ$0 proc near
					; DATA XREF: .xdata$x:0000B844o
		mov	eax, [ebp-110h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ$1 proc near
					; DATA XREF: .xdata$x:0000B84Co
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ proc near
					; DATA XREF: icu_56::UnicodeSet::freeze(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-128h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B840h
__unwindtable$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000B858o
		dd offset __unwindfunclet$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ$1
__ehfuncinfo$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ dd 19930522h,	2
					; DATA XREF: __ehhandler$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ+14o
		dd offset __unwindtable$?freeze@UnicodeSet@icu_56@@QAEPAVUnicodeFunctor@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B874h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSetStringSpan::needsStringSpanUTF16(icu_56::UnicodeSetStringSpan *__hidden this)
		public ?needsStringSpanUTF16@UnicodeSetStringSpan@icu_56@@QAECXZ
?needsStringSpanUTF16@UnicodeSetStringSpan@icu_56@@QAECXZ proc near
					; CODE XREF: icu_56::UnicodeSet::freeze(void)+17Cp
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+113p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4Ch], 0
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?needsStringSpanUTF16@UnicodeSetStringSpan@icu_56@@QAECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B8A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::span(wchar_t const	*, int,	enum  USetSpanCondition)const
		public ?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+68p
					; icu_56::UnicodeSet::containsAll(icu_56::UnicodeString	const &)+3Ap ...

var_204		= byte ptr -204h
var_200		= dword	ptr -200h
var_134		= word ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= byte ptr -104h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1F8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_204]
		mov	ecx, 7Eh ; '~'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_4], 0
		jle	short loc_B923
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_B923
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+14h]
		call	?span@BMPSet@icu_56@@QBEPB_WPB_W0W4USetSpanCondition@@@Z ; icu_56::BMPSet::span(wchar_t	const *,wchar_t	const *,USetSpanCondition)
		sub	eax, [ebp+arg_0]
		sar	eax, 1
		jmp	loc_BB0E
; ---------------------------------------------------------------------------

loc_B923:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+49j
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+52j
		cmp	[ebp+arg_4], 0
		jge	short loc_B938
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_B938:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+7Fj
		cmp	[ebp+arg_4], 0
		jnz	short loc_B945
		xor	eax, eax
		jmp	loc_BB0E
; ---------------------------------------------------------------------------

loc_B945:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+94j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_B96F
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2Ch]
		call	?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)
		jmp	loc_BB0E
; ---------------------------------------------------------------------------
		jmp	loc_BA13
; ---------------------------------------------------------------------------

loc_B96F:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+A4j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]	; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_BA13
		xor	eax, eax
		cmp	[ebp+arg_8], 0
		setnz	al
		add	eax, 29h ; ')'
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+28h]
		push	edx		; struct icu_56::UVector *
		mov	eax, [ebp+var_18]
		push	eax		; struct icu_56::UnicodeSet *
		lea	ecx, [ebp+var_104] ; this
		call	??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z ; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_104] ; this
		call	?needsStringSpanUTF16@UnicodeSetStringSpan@icu_56@@QAECXZ ; icu_56::UnicodeSetStringSpan::needsStringSpanUTF16(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_BA01
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		lea	ecx, [ebp+var_104]
		call	?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSetStringSpan::span(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_200], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_104] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
		mov	eax, [ebp+var_200]
		jmp	loc_BB0E
; ---------------------------------------------------------------------------

loc_BA01:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+11Dj
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_104] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)

loc_BA13:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+C2j
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+D7j
		cmp	[ebp+arg_8], 0
		jz	short loc_BA20
		mov	[ebp+arg_8], 1

loc_BA20:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+16Fj
		mov	[ebp+var_11C], 0
		mov	[ebp+var_128], 0

loc_BA34:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+25Aj
		mov	eax, [ebp+var_11C]
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_110], edx
		mov	eax, [ebp+var_11C]
		add	eax, 1
		mov	[ebp+var_11C], eax
		mov	eax, [ebp+var_110]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_BAC6
		mov	eax, [ebp+var_11C]
		cmp	eax, [ebp+arg_4]
		jz	short loc_BAC6
		mov	eax, [ebp+var_11C]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2]
		mov	[ebp+var_134], dx
		movzx	eax, [ebp+var_134]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_BAC6
		mov	eax, [ebp+var_11C]
		add	eax, 1
		mov	[ebp+var_11C], eax
		mov	eax, [ebp+var_110]
		shl	eax, 0Ah
		movzx	ecx, [ebp+var_134]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_110], edx

loc_BAC6:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+1BEj
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+1C9j	...
		mov	esi, esp
		mov	eax, [ebp+var_110]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		cmp	[ebp+arg_8], ecx
		jz	short loc_BAED
		jmp	short loc_BB08
; ---------------------------------------------------------------------------

loc_BAED:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+241j
		mov	eax, [ebp+var_11C]
		mov	[ebp+var_128], eax
		mov	ecx, [ebp+var_128]
		cmp	ecx, [ebp+arg_4]
		jl	loc_BA34

loc_BB08:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+243j
		mov	eax, [ebp+var_128]

loc_BB0E:				; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+76j
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+98j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 204h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
$LN21_1		dd 1			; DATA XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+26Ao
		dd offset $LN20_1
$LN20_1		dd 0FFFFFEFCh, 0D8h	; DATA XREF: .text:0000BB50o
		dd offset $LN18_1	; "strSpan"
$LN18_1		db 'strSpan',0          ; DATA XREF: .text:0000BB5Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0BB68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000BBA0o
		lea	ecx, [ebp-104h]	; this
		jmp	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
__unwindfunclet$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-208h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0BB9Ch
__unwindtable$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000BBACo
		dd offset __unwindfunclet$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BBC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanBack(wchar_t const *, int, enum  USetSpanCondition)const
		public ?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z proc near
					; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+5Fp

var_1F8		= byte ptr -1F8h
var_1F4		= dword	ptr -1F4h
var_128		= word ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= byte ptr -104h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1ECh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1F8]
		mov	ecx, 7Bh ; '{'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_4], 0
		jle	short loc_BC43
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_BC43
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*2]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_18]
		mov	ecx, [edx+14h]
		call	?spanBack@BMPSet@icu_56@@QBEPB_WPB_W0W4USetSpanCondition@@@Z ; icu_56::BMPSet::spanBack(wchar_t	const *,wchar_t	const *,USetSpanCondition)
		sub	eax, [ebp+arg_0]
		sar	eax, 1
		jmp	loc_BE08
; ---------------------------------------------------------------------------

loc_BC43:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+49j
					; icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)+52j
		cmp	[ebp+arg_4], 0
		jge	short loc_BC58
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_BC58:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+7Fj
		cmp	[ebp+arg_4], 0
		jnz	short loc_BC65
		xor	eax, eax
		jmp	loc_BE08
; ---------------------------------------------------------------------------

loc_BC65:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+94j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_BC8F
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2Ch]
		call	?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)
		jmp	loc_BE08
; ---------------------------------------------------------------------------
		jmp	loc_BD33
; ---------------------------------------------------------------------------

loc_BC8F:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+A4j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]	; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_BD33
		xor	eax, eax
		cmp	[ebp+arg_8], 0
		setnz	al
		add	eax, 19h
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+28h]
		push	edx		; struct icu_56::UVector *
		mov	eax, [ebp+var_18]
		push	eax		; struct icu_56::UnicodeSet *
		lea	ecx, [ebp+var_104] ; this
		call	??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z ; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_104] ; this
		call	?needsStringSpanUTF16@UnicodeSetStringSpan@icu_56@@QAECXZ ; icu_56::UnicodeSetStringSpan::needsStringSpanUTF16(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_BD21
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		lea	ecx, [ebp+var_104]
		call	?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z	; icu_56::UnicodeSetStringSpan::spanBack(wchar_t const *,int,USetSpanCondition)
		mov	[ebp+var_1F4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_104] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
		mov	eax, [ebp+var_1F4]
		jmp	loc_BE08
; ---------------------------------------------------------------------------

loc_BD21:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+11Dj
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_104] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)

loc_BD33:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+C2j
					; icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)+D7j
		cmp	[ebp+arg_8], 0
		jz	short loc_BD40
		mov	[ebp+arg_8], 1

loc_BD40:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+16Fj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_11C], eax

loc_BD49:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+234j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_110], eax
		mov	eax, [ebp+var_110]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_BDC5
		cmp	[ebp+arg_4], 0
		jle	short loc_BDC5
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+eax*2-2]
		mov	[ebp+var_128], dx
		movzx	eax, [ebp+var_128]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_BDC5
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		movzx	eax, [ebp+var_128]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_110]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_110], edx

loc_BDC5:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+1AAj
					; icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)+1B0j ...
		mov	esi, esp
		mov	eax, [ebp+var_110]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		cmp	[ebp+arg_8], ecx
		jz	short loc_BDEC
		jmp	short loc_BE02
; ---------------------------------------------------------------------------

loc_BDEC:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+220j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_11C], eax
		cmp	[ebp+var_11C], 0
		jg	loc_BD49

loc_BE02:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+222j
		mov	eax, [ebp+var_11C]

loc_BE08:				; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+76j
					; icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)+98j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN21_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
$LN21_2		dd 1			; DATA XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+244o
		dd offset $LN20_2
$LN20_2		dd 0FFFFFEFCh, 0D8h	; DATA XREF: .text:0000BE48o
		dd offset $LN18_2	; "strSpan"
$LN18_2		db 'strSpan',0          ; DATA XREF: .text:0000BE54o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0BE60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0	proc near
					; DATA XREF: .xdata$x:0000BE98o
		lea	ecx, [ebp-104h]	; this
		jmp	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
__unwindfunclet$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1FCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0BE94h
__unwindtable$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000BEA4o
		dd offset __unwindfunclet$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BEC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanUTF8(char const *, int, enum  USetSpanCondition)const
		public ?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z proc near

var_21C		= byte ptr -21Ch
var_218		= dword	ptr -218h
var_149		= byte ptr -149h
var_13D		= byte ptr -13Dh
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= byte ptr -110h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 210h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_21C]
		mov	ecx, 84h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_4], 0
		jle	short loc_BF39
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_BF39
		mov	eax, [ebp+Str]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+14h]
		call	?spanUTF8@BMPSet@icu_56@@QBEPBEPBEHW4USetSpanCondition@@@Z ; icu_56::BMPSet::spanUTF8(uchar const *,int,USetSpanCondition)
		sub	eax, [ebp+var_24]
		jmp	loc_C218
; ---------------------------------------------------------------------------

loc_BF39:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+49j
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+52j
		cmp	[ebp+arg_4], 0
		jge	short loc_BF4E
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_BF4E:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+7Dj
		cmp	[ebp+arg_4], 0
		jnz	short loc_BF5B
		xor	eax, eax
		jmp	loc_C218
; ---------------------------------------------------------------------------

loc_BF5B:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+92j
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_BF85
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2Ch]
		call	?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z ; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)
		jmp	loc_C218
; ---------------------------------------------------------------------------
		jmp	loc_C029
; ---------------------------------------------------------------------------

loc_BF85:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+A2j
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]	; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_C029
		xor	eax, eax
		cmp	[ebp+arg_8], 0
		setnz	al
		add	eax, 25h ; '%'
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_30]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+28h]
		push	edx		; struct icu_56::UVector *
		mov	eax, [ebp+var_18]
		push	eax		; struct icu_56::UnicodeSet *
		lea	ecx, [ebp+var_110] ; this
		call	??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z ; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_110] ; this
		call	?needsStringSpanUTF8@UnicodeSetStringSpan@icu_56@@QAECXZ ; icu_56::UnicodeSetStringSpan::needsStringSpanUTF8(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_C017
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		lea	ecx, [ebp+var_110]
		call	?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z ; icu_56::UnicodeSetStringSpan::spanUTF8(uchar const *,int,USetSpanCondition)
		mov	[ebp+var_218], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_110] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
		mov	eax, [ebp+var_218]
		jmp	loc_C218
; ---------------------------------------------------------------------------

loc_C017:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+11Bj
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_110] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)

loc_C029:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+C0j
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+D5j
		cmp	[ebp+arg_8], 0
		jz	short loc_C036
		mov	[ebp+arg_8], 1

loc_C036:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+16Dj
		mov	[ebp+var_128], 0
		mov	[ebp+var_134], 0

loc_C04A:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+34Cj
		mov	eax, [ebp+Str]
		add	eax, [ebp+var_128]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_11C], ecx
		mov	edx, [ebp+var_128]
		add	edx, 1
		mov	[ebp+var_128], edx
		cmp	[ebp+var_11C], 80h ; ''
		jl	loc_C1D0
		cmp	[ebp+var_11C], 0E0h ; ''
		jle	loc_C137
		cmp	[ebp+var_11C], 0ECh ; ''
		jg	loc_C137
		mov	eax, [ebp+var_128]
		add	eax, 1
		cmp	eax, [ebp+arg_4]
		jl	short loc_C0B3
		cmp	[ebp+arg_4], 0
		jge	loc_C137

loc_C0B3:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+1E7j
		mov	eax, [ebp+Str]
		add	eax, [ebp+var_128]
		movsx	ecx, byte ptr [eax]
		sub	ecx, 80h ; ''
		mov	[ebp+var_13D], cl
		movzx	edx, [ebp+var_13D]
		cmp	edx, 3Fh ; '?'
		jg	short loc_C137
		mov	eax, [ebp+Str]
		add	eax, [ebp+var_128]
		movsx	ecx, byte ptr [eax+1]
		sub	ecx, 80h ; ''
		mov	[ebp+var_149], cl
		movzx	edx, [ebp+var_149]
		cmp	edx, 3Fh ; '?'
		jg	short loc_C137
		mov	eax, [ebp+var_11C]
		shl	eax, 0Ch
		movzx	ecx, [ebp+var_13D]
		shl	ecx, 6
		or	eax, ecx
		movzx	edx, [ebp+var_149]
		or	eax, edx
		movzx	eax, ax
		mov	[ebp+var_11C], eax
		mov	eax, [ebp+var_128]
		add	eax, 2
		mov	[ebp+var_128], eax
		jmp	loc_C1D0
; ---------------------------------------------------------------------------

loc_C137:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+1C5j
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+1D5j ...
		cmp	[ebp+var_11C], 0E0h ; ''
		jge	short loc_C1AA
		cmp	[ebp+var_11C], 0C2h ; ''
		jl	short loc_C1AA
		mov	eax, [ebp+var_128]
		cmp	eax, [ebp+arg_4]
		jz	short loc_C1AA
		mov	eax, [ebp+Str]
		add	eax, [ebp+var_128]
		movsx	ecx, byte ptr [eax]
		sub	ecx, 80h ; ''
		mov	[ebp+var_13D], cl
		movzx	edx, [ebp+var_13D]
		cmp	edx, 3Fh ; '?'
		jg	short loc_C1AA
		mov	eax, [ebp+var_11C]
		and	eax, 1Fh
		shl	eax, 6
		movzx	ecx, [ebp+var_13D]
		or	eax, ecx
		mov	[ebp+var_11C], eax
		mov	eax, [ebp+var_128]
		add	eax, 1
		mov	[ebp+var_128], eax
		jmp	short loc_C1D0
; ---------------------------------------------------------------------------

loc_C1AA:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+281j
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+28Dj ...
		push	0FFFFFFFDh
		mov	eax, [ebp+var_11C]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		lea	edx, [ebp+var_128]
		push	edx
		mov	eax, [ebp+Str]
		push	eax
		call	_utf8_nextCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_11C], eax

loc_C1D0:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+1B5j
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+272j ...
		mov	esi, esp
		mov	eax, [ebp+var_11C]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		cmp	[ebp+arg_8], ecx
		jz	short loc_C1F7
		jmp	short loc_C212
; ---------------------------------------------------------------------------

loc_C1F7:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+333j
		mov	eax, [ebp+var_128]
		mov	[ebp+var_134], eax
		mov	ecx, [ebp+var_134]
		cmp	ecx, [ebp+arg_4]
		jl	loc_C04A

loc_C212:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+335j
		mov	eax, [ebp+var_134]

loc_C218:				; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+74j
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+96j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN26_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 21Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z endp ; sp-analysis	failed

; ---------------------------------------------------------------------------
$LN26_0		dd 2			; DATA XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+35Co
		dd offset $LN25_0
$LN25_0		dd 0FFFFFEF0h, 0D8h	; DATA XREF: .text:0000C258o
		dd offset $LN22		; "strSpan"
		dd 0FFFFFED8h, 4
		dd offset $LN23_0	; "start"
$LN23_0		db 'start',0            ; DATA XREF: .text:0000C270o
$LN22		db 'strSpan',0          ; DATA XREF: .text:0000C264o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C284h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000C2BCo
		lea	ecx, [ebp-110h]	; this
		jmp	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
__unwindfunclet$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-220h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C2B8h
__unwindtable$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C2C8o
		dd offset __unwindfunclet$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?spanUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C2E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSetStringSpan::needsStringSpanUTF8(icu_56::UnicodeSetStringSpan *__hidden this)
		public ?needsStringSpanUTF8@UnicodeSetStringSpan@icu_56@@QAECXZ
?needsStringSpanUTF8@UnicodeSetStringSpan@icu_56@@QAECXZ proc near
					; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+111p
					; icu_56::UnicodeSet::spanBackUTF8(char	const *,int,USetSpanCondition)+10Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+50h], 0
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?needsStringSpanUTF8@UnicodeSetStringSpan@icu_56@@QAECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanBackUTF8(char const *,	int, enum  USetSpanCondition)const
		public ?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z proc near

var_1F8		= byte ptr -1F8h
var_1F4		= dword	ptr -1F4h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= byte ptr -110h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
Str		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 1ECh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1F8]
		mov	ecx, 7Bh ; '{'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		cmp	[ebp+arg_4], 0
		jle	short loc_C38E
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_C38E
		mov	eax, [ebp+Str]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+14h]
		call	?spanBackUTF8@BMPSet@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z ; icu_56::BMPSet::spanBackUTF8(uchar const	*,int,USetSpanCondition)
		jmp	loc_C518
; ---------------------------------------------------------------------------

loc_C38E:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+49j
					; icu_56::UnicodeSet::spanBackUTF8(char	const *,int,USetSpanCondition)+52j
		cmp	[ebp+arg_4], 0
		jge	short loc_C3A3
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_C3A3:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+7Aj
		cmp	[ebp+arg_4], 0
		jnz	short loc_C3B0
		xor	eax, eax
		jmp	loc_C518
; ---------------------------------------------------------------------------

loc_C3B0:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+8Fj
		mov	eax, [ebp+var_18]
		cmp	dword ptr [eax+2Ch], 0
		jz	short loc_C3DA
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+2Ch]
		call	?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z ; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)
		jmp	loc_C518
; ---------------------------------------------------------------------------
		jmp	loc_C47E
; ---------------------------------------------------------------------------

loc_C3DA:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+9Fj
		mov	eax, [ebp+var_18]
		mov	ecx, [eax+28h]	; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_C47E
		xor	eax, eax
		cmp	[ebp+arg_8], 0
		setnz	al
		add	eax, 15h
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_30]
		push	eax		; unsigned int
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx+28h]
		push	edx		; struct icu_56::UVector *
		mov	eax, [ebp+var_18]
		push	eax		; struct icu_56::UnicodeSet *
		lea	ecx, [ebp+var_110] ; this
		call	??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z ; icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSet const &,icu_56::UVector const &,uint)
		mov	[ebp+var_4], 0
		lea	ecx, [ebp+var_110] ; this
		call	?needsStringSpanUTF8@UnicodeSetStringSpan@icu_56@@QAECXZ ; icu_56::UnicodeSetStringSpan::needsStringSpanUTF8(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_C46C
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+Str]
		push	edx
		lea	ecx, [ebp+var_110]
		call	?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z ; icu_56::UnicodeSetStringSpan::spanBackUTF8(uchar const *,int,USetSpanCondition)
		mov	[ebp+var_1F4], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_110] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
		mov	eax, [ebp+var_1F4]
		jmp	loc_C518
; ---------------------------------------------------------------------------

loc_C46C:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+118j
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_110] ; this
		call	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)

loc_C47E:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+BDj
					; icu_56::UnicodeSet::spanBackUTF8(char	const *,int,USetSpanCondition)+D2j
		cmp	[ebp+arg_8], 0
		jz	short loc_C48B
		mov	[ebp+arg_8], 1

loc_C48B:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+16Aj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_128], eax

loc_C494:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+1F8j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+Str]
		add	ecx, [ebp+arg_4]
		movzx	edx, byte ptr [ecx]
		mov	[ebp+var_11C], edx
		cmp	[ebp+var_11C], 80h ; ''
		jl	short loc_C4D9
		push	0FFFFFFFDh
		mov	eax, [ebp+var_11C]
		push	eax
		lea	ecx, [ebp+arg_4]
		push	ecx
		push	0
		mov	edx, [ebp+Str]
		push	edx
		call	_utf8_prevCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_11C], eax

loc_C4D9:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+19Ej
		mov	esi, esp
		mov	eax, [ebp+var_11C]
		push	eax
		mov	ecx, [ebp+var_18]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_18]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		cmp	[ebp+arg_8], ecx
		jz	short loc_C500
		jmp	short loc_C512
; ---------------------------------------------------------------------------

loc_C500:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+1E4j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_128], eax
		cmp	[ebp+var_128], 0
		jg	short loc_C494

loc_C512:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+1E6j
		mov	eax, [ebp+var_128]

loc_C518:				; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+71j
					; icu_56::UnicodeSet::spanBackUTF8(char	const *,int,USetSpanCondition)+93j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20_3
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z endp ;	sp-analysis failed

; ---------------------------------------------------------------------------
$LN20_3		dd 1			; DATA XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+204o
		dd offset $LN19_1
$LN19_1		dd 0FFFFFEF0h, 0D8h	; DATA XREF: .text:0000C558o
		dd offset $LN17_0	; "strSpan"
$LN17_0		db 'strSpan',0          ; DATA XREF: .text:0000C564o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z$0 proc	near
					; DATA XREF: .xdata$x:0000C5A8o
		lea	ecx, [ebp-110h]	; this
		jmp	??1UnicodeSetStringSpan@icu_56@@QAE@XZ ; icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(void)
__unwindfunclet$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z proc near
					; DATA XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-1FCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C5A4h
__unwindtable$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C5B4o
		dd offset __unwindfunclet$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z$0
__ehfuncinfo$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z+1Eo
		dd offset __unwindtable$?spanBackUTF8@UnicodeSet@icu_56@@QBEHPBDHW4USetSpanCondition@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C5D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C650h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<char, 40>::MaybeStackArray<char, 40>(void)
		public ??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ
??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::CharString::CharString(void)+45p
					; icu_56::CharString::CharString(icu_56::StringPiece const &,UErrorCode	&)+45p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 9
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C6CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<char, 40>::~MaybeStackArray<char, 40>(void)
		public ??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ
??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ proc	near
					; CODE XREF: __unwindfunclet$??0CharString@icu_56@@QAE@XZ$0+3j
					; __unwindfunclet$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z$0+3j ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,40>::releaseArray(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackArray@D$0CI@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C70Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackArray<char, 40>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackArray@D$0CI@@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackArray@D$0CI@@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackArray@D$0CI@@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C73Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackArray<char, 40>::getAlias(void)const
		public ?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ
?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ proc near
					; CODE XREF: icu_56::CharString::toStringPiece(void)+2Dp
					; icu_56::CharString::data(void)+26p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C76Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char * __thiscall icu_56::MaybeStackArray<char, 40>::getArrayLimit(void)const
		public ?getArrayLimit@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ
?getArrayLimit@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ ; icu_56::MaybeStackArray<char,40>::getAlias(void)
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getArrayLimit@?$MaybeStackArray@D$0CI@@icu_56@@QBEPADXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const & __thiscall icu_56::MaybeStackArray<char,	40>::operator[](int)const
		public ??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z
??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z proc near
					; CODE XREF: icu_56::CharString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@D$0CI@@icu_56@@QBEABDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char & __thiscall icu_56::MaybeStackArray<char, 40>::operator[](int)
		public ??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z
??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z proc near
					; CODE XREF: icu_56::CharString::CharString(void)+60p
					; icu_56::CharString::CharString(icu_56::StringPiece const &,UErrorCode	&)+60p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		add	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@D$0CI@@icu_56@@QAEAADH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C81Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MaybeStackArray<char,	40>::aliasInstead(char *, int)
		public ?aliasInstead@?$MaybeStackArray@D$0CI@@icu_56@@QAEXPADH@Z
?aliasInstead@?$MaybeStackArray@D$0CI@@icu_56@@QAEXPADH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_C86B
		cmp	[ebp+arg_4], 0
		jle	short loc_C86B
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,40>::releaseArray(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0

loc_C86B:				; CODE XREF: icu_56::MaybeStackArray<char,40>::aliasInstead(char *,int)+27j
					; icu_56::MaybeStackArray<char,40>::aliasInstead(char *,int)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?aliasInstead@?$MaybeStackArray@D$0CI@@icu_56@@QAEXPADH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C884h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<char, 40>::releaseArray(void)
		public ?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ
?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackArray<char,40>::~MaybeStackArray<char,40>(void)+26p
					; icu_56::MaybeStackArray<char,40>::aliasInstead(char *,int)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_C8C0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_C8C0:				; CODE XREF: icu_56::MaybeStackArray<char,40>::releaseArray(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackArray<char, 40>::operator==(class icu_56::MaybeStackArray<char, 40> const &)
		public ??8?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z
??8?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C904h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: bool	__thiscall icu_56::MaybeStackArray<char, 40>::operator!=(class icu_56::MaybeStackArray<char, 40> const &)
		public ??9?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z
??9?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??9?$MaybeStackArray@D$0CI@@icu_56@@AAE_NABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C934h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: __thiscall icu_56::MaybeStackArray<char, 40>::MaybeStackArray<char, 40>(class icu_56::MaybeStackArray<char, 40> const &)
		public ??0?$MaybeStackArray@D$0CI@@icu_56@@AAE@ABV01@@Z
??0?$MaybeStackArray@D$0CI@@icu_56@@AAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0?$MaybeStackArray@D$0CI@@icu_56@@AAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C964h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<char, 40>::operator=(class icu_56::MaybeStackArray<char, 40>	const &)
		public ??4?$MaybeStackArray@D$0CI@@icu_56@@AAEXABV01@@Z
??4?$MaybeStackArray@D$0CI@@icu_56@@AAEXABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4?$MaybeStackArray@D$0CI@@icu_56@@AAEXABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C990h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_C9CA
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_C9D6
; ---------------------------------------------------------------------------

loc_C9CA:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_C9D6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::MaybeStackArray<char,40>::resize(int, size_t Size)
		public ?resize@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHH@Z
?resize@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jle	loc_CA9B
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_CA94
		cmp	[ebp+Size], 0
		jle	short loc_CA74
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Size]
		cmp	ecx, [eax+4]
		jle	short loc_CA40
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+Size], ecx

loc_CA40:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+51j
		mov	eax, [ebp+Size]
		cmp	eax, [ebp+arg_0]
		jle	short loc_CA4E
		mov	eax, [ebp+arg_0]
		mov	[ebp+Size], eax

loc_CA4E:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+62j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_CA74:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+46j
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@D$0CI@@icu_56@@AAEXXZ ;	icu_56::MaybeStackArray<char,40>::releaseArray(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_CA94:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+40j
		mov	eax, [ebp+Dst]
		jmp	short loc_CA9D
; ---------------------------------------------------------------------------
		jmp	short loc_CA9D
; ---------------------------------------------------------------------------

loc_CA9B:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+27j
		xor	eax, eax

loc_CA9D:				; CODE XREF: icu_56::MaybeStackArray<char,40>::resize(int,int)+B3j
					; icu_56::MaybeStackArray<char,40>::resize(int,int)+B5j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CAB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::MaybeStackArray<char,40>::orphanOrClone(size_t Size, int)
		public ?orphanOrClone@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHAAH@Z
?orphanOrClone@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHAAH@Z proc near

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
Size		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_CAEC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	[ebp+Dst], ecx
		jmp	short loc_CB4B
; ---------------------------------------------------------------------------

loc_CAEC:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+2Cj
		cmp	[ebp+Size], 0
		jg	short loc_CAF8
		xor	eax, eax
		jmp	short loc_CB72
; ---------------------------------------------------------------------------
		jmp	short loc_CB4B
; ---------------------------------------------------------------------------

loc_CAF8:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+3Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Size]
		cmp	ecx, [eax+4]
		jle	short loc_CB0C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+Size], ecx

loc_CB0C:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+4Dj
		mov	eax, [ebp+Size]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_CB25
		xor	eax, eax
		jmp	short loc_CB72
; ---------------------------------------------------------------------------

loc_CB25:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+6Bj
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Size]
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_CB4B:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+36j
					; icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+42j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+Size]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 9
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 28h ; '('
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+Dst]

loc_CB72:				; CODE XREF: icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+40j
					; icu_56::MaybeStackArray<char,40>::orphanOrClone(int,int &)+6Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?orphanOrClone@?$MaybeStackArray@D$0CI@@icu_56@@QAEPADHAAH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeSet::`vector	deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeSet@icu_56@@W3AEPAXI@Z
??_EUnicodeSet@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeSet::`vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeSet@icu_56@@UAEPAXI@Z ; icu_56::UnicodeSet::`vector deleting	destructor'(uint)
??_EUnicodeSet@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CB90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeFilter@icu_56@@UAEPAXI@Z ; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000230o
					; .rdata:00001330o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::ParsePosition::`vector deleting destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::ParsePosition::`vector deleting destructor'(uint)+3Dp ...
; public: virtual void * __thiscall icu_56::ParsePosition::getDynamicClassID(void)const
		extrn ?getDynamicClassID@ParsePosition@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000004F0o
; _DWORD __thiscall icu_56::ParsePosition::~ParsePosition(icu_56::ParsePosition	*__hidden this)
		extrn ??1ParsePosition@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ParsePosition::`scalar deleting destructor'(uint)+26p
					; icu_56::ParsePosition::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __purecall:near	; DATA XREF: .rdata:0000091Co
					; .rdata:00000920o ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFunctor::toMatcher(void)const
		extrn ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:00000B7Co
; public: virtual class	icu_56::UnicodeReplacer	* __thiscall icu_56::UnicodeFunctor::toReplacer(void)const
		extrn ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ:near
					; DATA XREF: .rdata:00000B80o
					; .rdata:00001028o ...
; _DWORD __thiscall icu_56::UnicodeFunctor::~UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		extrn ??1UnicodeFunctor@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeMatcher::~UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		extrn ??1UnicodeMatcher@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFilter::toMatcher(void)const
		extrn ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:00001024o
					; .rdata:00005E30o
; public: virtual void __thiscall icu_56::UnicodeFilter::setData(class icu_56::TransliterationRuleData const *)
		extrn ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z:near
					; DATA XREF: .rdata:0000102Co
					; .rdata:00005E38o
; enum icu_56::UMatchDegree __thiscall __high icu_56::UnicodeFilter::matches(const struct icu_56::Replaceable *, int *,	int, signed __int8)
		extrn ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z:near
					; CODE XREF: icu_56::UnicodeSet::matches(icu_56::Replaceable const &,int &,int,signed char)+231p
					; DATA XREF: .rdata:00001004o
; _DWORD __thiscall icu_56::UnicodeFilter::~UnicodeFilter(icu_56::UnicodeFilter	*__hidden this)
		extrn ??1UnicodeFilter@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)+64p ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001340o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00001344o
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:000019F0o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:000019F4o
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001F6Co
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00001F70o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:00001F74o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00001F78o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001F7Co
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00001F80o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:00001F84o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00001F88o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00001F8Co
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
					; icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+B7p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *__hidden this, void *, int)
		extrn ?indexOf@UVector@icu_56@@QBEHPAXH@Z:near
					; CODE XREF: icu_56::UVector::contains(void *)+2Cp
; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *__hidden this, int, int)
		extrn ?indexOf@UVector@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::UVector::contains(int)+2Cp
; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *__hidden	this, int)
		extrn ?elementAt@UVector@icu_56@@QBEPAXH@Z:near
					; CODE XREF: icu_56::UVector::firstElement(void)+28p
					; icu_56::UVector::lastElement(void)+30p ...
; int __thiscall icu_56::UVector::elementAti(icu_56::UVector *__hidden this, int)
		extrn ?elementAti@UVector@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::UVector::lastElementi(void)+30p
; public: signed char __thiscall icu_56::UVector::operator==(class icu_56::UVector const &)
		extrn ??8UVector@icu_56@@QAECABV01@@Z:near
					; CODE XREF: icu_56::UVector::operator!=(icu_56::UVector const &)+2Ap
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, void *, enum UErrorCode *)
		extrn ?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UStack::push(void *,UErrorCode &)+2Ep
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, int, enum	UErrorCode *)
		extrn ?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UStack::push(int,UErrorCode &)+2Ep
		extrn ___security_cookie:near
					; DATA XREF: icu_56::CharString::CharString(void)+2Er
					; icu_56::CharString::CharString(icu_56::StringPiece const &,UErrorCode	&)+2Er	...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0CharString@icu_56@@QAE@XZ+19j
					; __ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0CharString@icu_56@@QAE@XZ+Fp
					; __ehhandler$??0CharString@icu_56@@QAE@ABVStringPiece@1@AAW4UErrorCode@@@Z+Fp	...
; struct icu_56::CharString *__thiscall	icu_56::CharString::append(icu_56::CharString *__hidden	this, const char *, int, enum UErrorCode *)
		extrn ?append@CharString@icu_56@@QAEAAV12@PBDHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::CharString::CharString(char const *,int,UErrorCode	&)+77p
					; icu_56::CharString::append(icu_56::StringPiece const &,UErrorCode &)+3Cp ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+101p
					; icu_56::UnicodeSet::UnicodeSet(int,int)+101p	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(void)+142p
					; icu_56::UnicodeSet::UnicodeSet(int,int)+152p	...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const wchar_t *,	int)
		extrn ??0UnicodeString@icu_56@@QAE@PB_WH@Z:near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+1BEp
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+2A1p
; void __thiscall icu_56::UVector::assign(icu_56::UVector *__hidden this, const	struct icu_56::UVector *, void (__cdecl	*)(union UElement *, union UElement *),	enum UErrorCode	*)
		extrn ?assign@UVector@icu_56@@QAEXABV12@P6AXPATUElement@@1@ZAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+190p
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+1CAp
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+160p
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+F5p ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::UnicodeSet::UnicodeSet(icu_56::UnicodeSet const &,signed char)+140p
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+D5p ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::cloneUnicodeString(UElement *,UElement *)+69p
					; icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+8Fp
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn ??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::cloneUnicodeString(UElement *,UElement *)+3Fp
					; icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+11Ap ...
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::UnicodeSet::~UnicodeSet(void)+63p
					; icu_56::UnicodeSet::~UnicodeSet(void)+CBp ...
; _DWORD __thiscall icu_56::UnicodeSetStringSpan::~UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan *__hidden this)
		extrn ??1UnicodeSetStringSpan@icu_56@@QAE@XZ:near
					; CODE XREF: icu_56::UnicodeSetStringSpan::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+149p	...
; _DWORD __thiscall icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan *__hidden this, const struct icu_56::UnicodeSetStringSpan *, const struct icu_56::UVector *)
		extrn ??0UnicodeSetStringSpan@icu_56@@QAE@ABV01@ABVUVector@1@@Z:near
					; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+230p
; _DWORD __thiscall icu_56::BMPSet::BMPSet(icu_56::BMPSet *__hidden this, const	struct icu_56::BMPSet *, const int *, int)
		extrn ??0BMPSet@icu_56@@QAE@ABV01@PBHH@Z:near
					; CODE XREF: icu_56::UnicodeSet::operator=(icu_56::UnicodeSet const &)+153p
; signed __int8	__thiscall icu_56::UVector::containsAll(icu_56::UVector	*__hidden this,	const struct icu_56::UVector *)
		extrn ?containsAll@UVector@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsAll(icu_56::UnicodeSet	const &)+BCp
; signed __int8	__thiscall icu_56::UVector::containsNone(icu_56::UVector *__hidden this, const struct icu_56::UVector *)
		extrn ?containsNone@UVector@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)+AEp
; int __thiscall icu_56::UnicodeString::char32At(icu_56::UnicodeString *__hidden this, int)
		extrn ?char32At@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::UnicodeSet::matchesIndexValue(uchar)+151p
					; icu_56::UnicodeSet::getSingleCP(icu_56::UnicodeString	const &)+51p ...
; void __thiscall icu_56::UVector::sortedInsert(icu_56::UVector	*__hidden this,	void *,	signed __int8 (__cdecl __high *)(union UElement, union UElement), enum UErrorCode *)
		extrn ?sortedInsert@UVector@icu_56@@QAEXPAXP6ACTUElement@@1@ZAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::_add(icu_56::UnicodeString const &)+EFp
; void __thiscall icu_56::UVector::removeAllElements(icu_56::UVector *__hidden this)
		extrn ?removeAllElements@UVector@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::UnicodeSet::removeAllStrings(void)+29p
					; icu_56::UnicodeSet::clear(void)+6Dp
; signed __int8	__thiscall icu_56::UVector::removeElement(icu_56::UVector *__hidden this, void *)
		extrn ?removeElement@UVector@icu_56@@QAECPAX@Z:near
					; CODE XREF: icu_56::UnicodeSet::remove(icu_56::UnicodeString const &)+71p
					; icu_56::UnicodeSet::complement(icu_56::UnicodeString const &)+87p ...
; signed __int8	__thiscall icu_56::UVector::retainAll(icu_56::UVector *__hidden	this, const struct icu_56::UVector *)
		extrn ?retainAll@UVector@icu_56@@QAECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::retainAll(icu_56::UnicodeSet const &)+6Bp
; signed __int8	__thiscall icu_56::UVector::removeAll(icu_56::UVector *__hidden	this, const struct icu_56::UVector *)
		extrn ?removeAll@UVector@icu_56@@QAECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::removeAll(icu_56::UnicodeSet const &)+6Bp
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::UnicodeSet::compact(void)+99p
					; icu_56::UnicodeSet::ensureCapacity(int,UErrorCode &)+42p ...
; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *__hidden this, void (__cdecl *)(void *), signed __int8 (__cdecl __high *)(union UElement,	union UElement), int, enum UErrorCode *)
		extrn ??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+94p
; void __cdecl uprv_deleteUObject_56(void *)
		extrn _uprv_deleteUObject_56:near
					; DATA XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+89o
; signed __int8	__cdecl	__high uhash_compareUnicodeString_56(union UElement, union UElement)
		extrn _uhash_compareUnicodeString_56:near
					; DATA XREF: icu_56::UnicodeSet::allocateStrings(UErrorCode &)+84o
; signed __int8	__cdecl	static icu_56::PatternProps::isWhiteSpace(int)
		extrn ?isWhiteSpace@PatternProps@icu_56@@SACH@Z:near
					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+97p
; signed __int8	__cdecl	static icu_56::ICU_Utility::escapeUnprintable(struct icu_56::UnicodeString *, int)
		extrn ?escapeUnprintable@ICU_Utility@icu_56@@SACAAVUnicodeString@2@H@Z:near
					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+41p
					; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed	char)+10Bp
; signed __int8	__cdecl	static icu_56::ICU_Utility::isUnprintable(int)
		extrn ?isUnprintable@ICU_Utility@icu_56@@SACH@Z:near
					; CODE XREF: icu_56::UnicodeSet::_appendToPat(icu_56::UnicodeString &,int,signed char)+2Ap
					; icu_56::UnicodeSet::_toPattern(icu_56::UnicodeString &,signed	char)+CCp
; _DWORD __thiscall icu_56::BMPSet::BMPSet(icu_56::BMPSet *__hidden this, const	int *, int)
		extrn ??0BMPSet@icu_56@@QAE@PBHH@Z:near
					; CODE XREF: icu_56::UnicodeSet::freeze(void)+212p
; _DWORD __thiscall icu_56::UnicodeSetStringSpan::UnicodeSetStringSpan(icu_56::UnicodeSetStringSpan *__hidden this, const struct icu_56::UnicodeSet *, const struct icu_56::UVector *, unsigned	int)
		extrn ??0UnicodeSetStringSpan@icu_56@@QAE@ABVUnicodeSet@1@ABVUVector@1@I@Z:near
					; CODE XREF: icu_56::UnicodeSet::freeze(void)+137p
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+101p	...
; int __thiscall __high	icu_56::UnicodeSetStringSpan::span(const wchar_t *, int, enum USetSpanCondition)
		extrn ?span@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+B8p
					; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+131p
; const	wchar_t	*__thiscall __high icu_56::BMPSet::span(const wchar_t *, const wchar_t *, enum USetSpanCondition)
		extrn ?span@BMPSet@icu_56@@QBEPB_WPB_W0W4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)+6Cp
; int __thiscall __high	icu_56::UnicodeSetStringSpan::spanBack(const wchar_t *,	int, enum USetSpanCondition)
		extrn ?spanBack@UnicodeSetStringSpan@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+B8p
					; icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)+131p
; const	wchar_t	*__thiscall __high icu_56::BMPSet::spanBack(const wchar_t *, const wchar_t *, enum USetSpanCondition)
		extrn ?spanBack@BMPSet@icu_56@@QBEPB_WPB_W0W4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBack(wchar_t const	*,int,USetSpanCondition)+6Cp
		extrn _utf8_nextCharSafeBody_56:near
					; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+302p
; int __thiscall __high	icu_56::UnicodeSetStringSpan::spanUTF8(const unsigned __int8 *,	int, enum USetSpanCondition)
		extrn ?spanUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+B6p
					; icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+12Fp
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+83p
					; icu_56::UnicodeSet::spanBackUTF8(char	const *,int,USetSpanCondition)+80p
; const	unsigned __int8	*__thiscall __high icu_56::BMPSet::spanUTF8(const unsigned __int8 *, int, enum USetSpanCondition)
		extrn ?spanUTF8@BMPSet@icu_56@@QBEPBEPBEHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanUTF8(char const *,int,USetSpanCondition)+6Cp
		extrn _utf8_prevCharSafeBody_56:near
					; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+1B3p
; int __thiscall __high	icu_56::UnicodeSetStringSpan::spanBackUTF8(const unsigned __int8 *, int, enum USetSpanCondition)
		extrn ?spanBackUTF8@UnicodeSetStringSpan@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+B3p
					; icu_56::UnicodeSet::spanBackUTF8(char	const *,int,USetSpanCondition)+12Cp
; int __thiscall __high	icu_56::BMPSet::spanBackUTF8(const unsigned __int8 *, int, enum	USetSpanCondition)
		extrn ?spanBackUTF8@BMPSet@icu_56@@QBEHPBEHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBackUTF8(char const *,int,USetSpanCondition)+6Cp


		end
