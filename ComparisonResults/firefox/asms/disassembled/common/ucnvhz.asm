;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	89F546AF20D15769931E2EE65854E9D4
; Input	CRC32 :	4C912DE8

; File Name   :	D:\compspace\objfiles\firefox\common\ucnvhz.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
__HZImpl	dd 17h,	2 dup(0)	; DATA XREF: .rdata:000000C4o
		dd offset __HZOpen
		dd offset __HZClose
		dd offset __HZReset
		dd offset _UConverter_toUnicode_HZ_OFFSETS_LOGIC
		dd offset _UConverter_toUnicode_HZ_OFFSETS_LOGIC
		dd offset _UConverter_fromUnicode_HZ_OFFSETS_LOGIC
		dd offset _UConverter_fromUnicode_HZ_OFFSETS_LOGIC
		dd 3 dup(0)
		dd offset __HZ_WriteSub
		dd offset __HZ_SafeClone
		dd offset __HZ_GetUnicodeSet
		dd 2 dup(0)
__HZStaticData	dd offset dword_64	; DATA XREF: .rdata:000000BCo
		dd 5A48h, 5 dup(0)
dword_64	dd 0Ah dup(0)		; DATA XREF: .rdata:__HZStaticDatao
		dd 4011700h, 1Ah, 1, 6 dup(0)
		public __HZData_56
__HZData_56	dd offset dword_E4
		dd 0FFFFFFFFh, 0
		dd offset __HZStaticData
		dd 0
		dd offset __HZImpl
		dd 7 dup(0)
dword_E4	dd 2Ch dup(0)		; DATA XREF: .rdata:__HZData_56o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 194h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__HZOpen	proc near		; DATA XREF: .rdata:0000000Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_1D3
		mov	eax, [ebp+arg_8]
		push	eax
		push	offset ??_C@_03LIOLIPAH@GBK?$AA@ ; `string'
		call	_ucnv_canCreateConverter_56
		add	esp, 8
		jmp	loc_256
; ---------------------------------------------------------------------------

loc_1D3:				; CODE XREF: __HZOpen+27j
		mov	eax, [ebp+arg_8]
		push	eax
		push	offset ??_C@_03LIOLIPAH@GBK?$AA@ ; `string'
		call	_ucnv_open_56
		add	esp, 8
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jle	short loc_1F1
		jmp	short loc_256
; ---------------------------------------------------------------------------

loc_1F1:				; CODE XREF: __HZOpen+59j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+38h], 0
		push	10h
		push	1
		call	_uprv_calloc_56
		add	esp, 8
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_241
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	[ecx], edx
		jmp	short loc_256
; ---------------------------------------------------------------------------

loc_241:				; CODE XREF: __HZOpen+9Ej
		mov	eax, [ebp+var_8]
		push	eax
		call	_ucnv_close_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_256:				; CODE XREF: __HZOpen+3Aj __HZOpen+5Bj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__HZOpen	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26Ch
		public ??_C@_03LIOLIPAH@GBK?$AA@
; `string'
??_C@_03LIOLIPAH@GBK?$AA@ dd 4B4247h	; DATA XREF: __HZOpen+2Do __HZOpen+43o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 270h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 274h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 278h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__HZClose	proc near		; DATA XREF: .rdata:00000010o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_2D4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ecx]
		push	edx
		call	_ucnv_close_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22h]
		test	ecx, ecx
		jnz	short loc_2CA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_2CA:				; CODE XREF: __HZClose+41j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0

loc_2D4:				; CODE XREF: __HZClose+25j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__HZClose	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__HZReset	proc near		; DATA XREF: .rdata:00000014o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 1
		jg	short loc_33D
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_33D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	byte ptr [ecx+0Dh], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	byte ptr [ecx+0Fh], 0

loc_33D:				; CODE XREF: __HZReset+22j
					; __HZReset+3Fj
		cmp	[ebp+arg_4], 1
		jz	short loc_38E
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+38h], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_38E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	byte ptr [ecx+0Ch], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	dword ptr [ecx+4], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	dword ptr [ecx+8], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	byte ptr [ecx+0Eh], 0

loc_38E:				; CODE XREF: __HZReset+59j
					; __HZReset+76j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
__HZReset	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 398h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_UConverter_toUnicode_HZ_OFFSETS_LOGIC proc near ; DATA	XREF: .rdata:00000018o
					; .rdata:0000001Co

var_140		= dword	ptr -140h
var_13C		= dword	ptr -13Ch
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= byte ptr -8
var_7		= byte ptr -7
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 140h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_140]
		mov	ecx, 50h ; 'P'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	[ebp+var_38], 0
		mov	[ebp+var_44], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_50], edx
		mov	[ebp+var_8], 0
		mov	[ebp+var_7], 0

loc_3F3:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC:$LN31j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC+126j ...
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	loc_818
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+14h]
		jnb	loc_808
		mov	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+30h], 7Eh ; '~'
		jnz	loc_5F4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+30h], 0
		mov	eax, [ebp+var_44]
		mov	[ebp+var_13C], eax
		mov	ecx, [ebp+var_13C]
		sub	ecx, 0Ah
		mov	[ebp+var_13C], ecx
		cmp	[ebp+var_13C], 74h ; 't' ; switch 117 cases
		ja	$LN26		; jumptable 0000046F default case
		mov	edx, [ebp+var_13C]
		movzx	eax, ds:$LN49[edx]
		jmp	ds:$LN53[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+D7j
					; DATA XREF: .text:$LN53o
		jmp	loc_3F3		; jumptable 0000046F case 0
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+D7j
					; DATA XREF: .text:$LN53o
		mov	eax, [ebp+arg_0] ; jumptable 0000046F case 116
		cmp	dword ptr [eax+18h], 0
		jz	short loc_4A4
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		sub	ecx, 2
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_4A4:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+EAj
		mov	eax, [ebp+var_20]
		mov	cx, word ptr [ebp+var_44]
		mov	[eax], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+0Fh], 0
		jmp	loc_3F3
; ---------------------------------------------------------------------------

$LN28:					; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+D7j
					; DATA XREF: .text:$LN53o
		xor	eax, eax	; jumptable 0000046F cases 113,115
		cmp	[ebp+var_44], 7Bh ; '{'
		setz	al
		mov	ecx, [ebp+var_50]
		mov	[ecx+0Dh], al
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+0Fh]
		test	ecx, ecx
		jz	short loc_534
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+0Fh], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 12h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+100h], 2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+25h], 7Eh	; '~'
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+26h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 2
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		jmp	loc_82A
; ---------------------------------------------------------------------------

loc_534:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+143j
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+0Fh], 1
		jmp	loc_3F3
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+C4j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC+D7j
					; DATA XREF: ...
		mov	eax, [ebp+var_50] ; jumptable 0000046F default case
		mov	byte ptr [eax+0Fh], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 12h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+25h], 7Eh	; '~'
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+0Dh]
		test	ecx, ecx
		jz	short loc_595
		cmp	[ebp+var_44], 21h ; '!'
		jl	short loc_57D
		cmp	[ebp+var_44], 7Eh ; '~'
		jg	short loc_57D
		mov	[ebp+var_13C], 1
		jmp	short loc_587
; ---------------------------------------------------------------------------

loc_57D:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+1D1j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC+1D7j
		mov	[ebp+var_13C], 0

loc_587:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+1E3j
		mov	edx, [ebp+var_13C]
		mov	[ebp+var_140], edx
		jmp	short loc_5A4
; ---------------------------------------------------------------------------

loc_595:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+1CBj
		xor	eax, eax
		cmp	[ebp+var_44], 7Fh ; ''
		setle	al
		mov	[ebp+var_140], eax

loc_5A4:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+1FBj
		cmp	[ebp+var_140], 0
		jz	short loc_5C2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_5D8
; ---------------------------------------------------------------------------

loc_5C2:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+213j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+26h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 2

loc_5D8:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+228j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		jmp	loc_82A
; ---------------------------------------------------------------------------
		jmp	loc_751
; ---------------------------------------------------------------------------

loc_5F4:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+92j
		mov	eax, [ebp+var_50]
		movsx	ecx, byte ptr [eax+0Dh]
		test	ecx, ecx
		jz	loc_713
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+2Ch], 0
		jnz	short loc_646
		cmp	[ebp+var_44], 7Eh ; '~'
		jnz	short loc_624
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+30h], 7Eh ; '~'
		jmp	short loc_63C
; ---------------------------------------------------------------------------

loc_624:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+27Bj
		mov	eax, [ebp+var_44]
		or	eax, 100h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+0Fh], 0

loc_63C:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+28Aj
		jmp	loc_3F3
; ---------------------------------------------------------------------------
		jmp	loc_711
; ---------------------------------------------------------------------------

loc_646:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+275j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+2Ch]
		and	edx, 0FFh
		mov	[ebp+var_74], edx
		mov	[ebp+var_38], 0FFFFh
		mov	eax, [ebp+var_74]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Ch ; '\'
		setle	dl
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+var_44]
		sub	eax, 21h ; '!'
		movzx	ecx, al
		xor	edx, edx
		cmp	ecx, 5Dh ; ']'
		setle	dl
		mov	[ebp+var_68], edx
		cmp	[ebp+var_5C], 0
		jz	short loc_6DC
		cmp	[ebp+var_68], 0
		jz	short loc_6DC
		mov	eax, [ebp+var_74]
		add	eax, 80h ; '€'
		mov	[ebp+var_8], al
		mov	eax, [ebp+var_44]
		add	eax, 80h ; '€'
		mov	[ebp+var_7], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movzx	edx, byte ptr [ecx+23h]
		push	edx
		push	2
		lea	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+var_50]
		mov	edx, [ecx]
		mov	eax, [edx+18h]
		push	eax
		call	_ucnv_MBCSSimpleGetNextUChar_56
		add	esp, 10h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_74]
		shl	eax, 8
		or	eax, [ebp+var_44]
		mov	[ebp+var_44], eax
		jmp	short loc_704
; ---------------------------------------------------------------------------

loc_6DC:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+2F3j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC+2F9j
		cmp	[ebp+var_68], 0
		jz	short loc_6F3
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_74]
		mov	[ebp+var_44], eax
		jmp	short loc_704
; ---------------------------------------------------------------------------

loc_6F3:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+348j
		mov	eax, [ebp+var_74]
		shl	eax, 8
		or	eax, 10000h
		or	eax, [ebp+var_44]
		mov	[ebp+var_44], eax

loc_704:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+342j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC+359j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+2Ch], 0

loc_711:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+2A9j
		jmp	short loc_751
; ---------------------------------------------------------------------------

loc_713:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+265j
		cmp	[ebp+var_44], 7Eh ; '~'
		jnz	short loc_72D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+30h], 7Eh ; '~'
		jmp	loc_3F3
; ---------------------------------------------------------------------------
		jmp	short loc_751
; ---------------------------------------------------------------------------

loc_72D:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+37Fj
		cmp	[ebp+var_44], 7Fh ; ''
		jg	short loc_743
		movzx	eax, word ptr [ebp+var_44]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+0Fh], 0
		jmp	short loc_751
; ---------------------------------------------------------------------------

loc_743:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+399j
		mov	[ebp+var_38], 0FFFFh
		mov	eax, [ebp+var_50]
		mov	byte ptr [eax+0Fh], 0

loc_751:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+257j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC:loc_711j ...
		cmp	[ebp+var_38], 0FFFEh
		jge	short loc_7A1
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_78C
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		sub	ecx, 1
		mov	edx, [ebp+var_50]
		movsx	eax, byte ptr [edx+0Dh]
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_20]
		sub	eax, [edx+10h]
		sar	eax, 1
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[edx+eax*4], ecx

loc_78C:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+3C9j
		mov	eax, [ebp+var_20]
		mov	cx, word ptr [ebp+var_38]
		mov	[eax], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		jmp	short loc_806
; ---------------------------------------------------------------------------

loc_7A1:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+3C0j
		cmp	[ebp+var_38], 0FFFEh
		jnz	short loc_7B5
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah
		jmp	short loc_7BE
; ---------------------------------------------------------------------------

loc_7B5:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+410j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_7BE:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+41Bj
		cmp	[ebp+var_44], 0FFh
		jle	short loc_7EE
		mov	eax, [ebp+var_44]
		sar	eax, 8
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+25h], al
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+26h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 2
		jmp	short loc_804
; ---------------------------------------------------------------------------

loc_7EE:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+42Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_44]
		mov	[ecx+25h], dl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 1

loc_804:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+454j
		jmp	short loc_818
; ---------------------------------------------------------------------------

loc_806:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+407j
		jmp	short loc_813
; ---------------------------------------------------------------------------

loc_808:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+70j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short loc_818
; ---------------------------------------------------------------------------

loc_813:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC:loc_806j
		jmp	loc_3F3
; ---------------------------------------------------------------------------

loc_818:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+61j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC:loc_804j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx

loc_82A:				; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+197j
					; _UConverter_toUnicode_HZ_OFFSETS_LOGIC+252j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN52
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 140h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_UConverter_toUnicode_HZ_OFFSETS_LOGIC endp

; ---------------------------------------------------------------------------
		align 10h
$LN52		dd 1			; DATA XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+496o
		dd offset $LN51
$LN51		dd 0FFFFFFF8h, 2	; DATA XREF: .text:00000854o
		dd offset $LN50		; "tempBuf"
$LN50		db 'tempBuf',0          ; DATA XREF: .text:00000860o
$LN53		dd offset $LN31, offset	$LN28, offset $LN30, offset $LN26
					; DATA XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+D7r
					; jump table for switch	statement
$LN49		db	0,     3,     3,     3
					; DATA XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+D0r
		db	3,     3,     3,     3 ; indirect table	for switch statement
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     3,     3,     3
		db	3,     1,     3,     1
		db	2
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_UConverter_fromUnicode_HZ_OFFSETS_LOGIC proc near ; DATA XREF:	.rdata:00000020o
					; .rdata:00000024o

var_184		= dword	ptr -184h
var_BC		= word ptr -0BCh
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_89		= byte ptr -89h
var_7D		= byte ptr -7Dh
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 184h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_184]
		mov	ecx, 61h ; 'a'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_20], ecx
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		sub	ecx, [ebp+var_14]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+8]
		sar	edx, 1
		mov	[ebp+var_50], edx
		mov	[ebp+var_5C], 0
		mov	[ebp+var_68], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+8]
		mov	[ebp+var_74], edx
		mov	eax, [ebp+var_74]
		mov	cl, [eax+0Eh]
		mov	[ebp+var_7D], cl
		mov	[ebp+var_98], 0
		mov	[ebp+var_A4], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+38h], 0
		jz	short loc_9A8
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	short loc_9A8
		jmp	$getTrail$9169
; ---------------------------------------------------------------------------

loc_9A8:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+A5j
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+ADj	...
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_50]
		jge	loc_FEA
		mov	[ebp+var_5C], 0FFFFh
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	loc_FD3
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_68], edx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	al, [ebp+var_7D]
		mov	[ebp+var_89], al
		cmp	[ebp+var_68], 7Eh ; '~'
		jnz	loc_AD8
		mov	[ebp+var_98], 2
		mov	[ebp+var_A4], offset ??_C@_02OPGNDHMP@?$HO?$HO?$AA@ ; `string'

loc_A04:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+1D8j
		mov	eax, [ebp+var_98]
		mov	ecx, [ebp+var_98]
		sub	ecx, 1
		mov	[ebp+var_98], ecx
		test	eax, eax
		jle	short loc_A29
		mov	[ebp+var_184], 1
		jmp	short loc_A33
; ---------------------------------------------------------------------------

loc_A29:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+127j
		mov	[ebp+var_184], 0

loc_A33:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+133j
		cmp	[ebp+var_184], 0
		jz	loc_AD1
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	short loc_A84
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_A4]
		mov	al, [eax]
		mov	[ecx+edx], al
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_A79
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx], eax
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx

loc_A79:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+16Fj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		jmp	short loc_ABD
; ---------------------------------------------------------------------------

loc_A84:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+152j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_A4]
		mov	al, [eax]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_ABD:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+18Ej
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax
		jmp	loc_A04
; ---------------------------------------------------------------------------

loc_AD1:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+146j
		jmp	loc_9A8
; ---------------------------------------------------------------------------
		jmp	short loc_B50
; ---------------------------------------------------------------------------

loc_AD8:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+F6j
		cmp	[ebp+var_68], 7Fh ; ''
		jg	short loc_AE6
		mov	eax, [ebp+var_68]
		mov	[ebp+var_5C], eax
		jmp	short loc_B50
; ---------------------------------------------------------------------------

loc_AE6:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+1E8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movzx	edx, byte ptr [ecx+23h]
		push	edx
		lea	eax, [ebp+var_5C]
		push	eax
		mov	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+var_74]
		mov	eax, [edx]
		mov	ecx, [eax+18h]
		push	ecx
		call	_ucnv_MBCSFromUChar32_56
		add	esp, 10h
		mov	[ebp+var_B0], eax
		cmp	[ebp+var_B0], 2
		jnz	short loc_B49
		mov	eax, [ebp+var_5C]
		sub	eax, 0A1A1h
		movzx	ecx, ax
		cmp	ecx, 5C5Dh
		jg	short loc_B49
		mov	eax, [ebp+var_5C]
		sub	eax, 0A1h ; '¡'
		movzx	ecx, al
		cmp	ecx, 5Dh ; ']'
		jg	short loc_B49
		mov	eax, [ebp+var_5C]
		sub	eax, 8080h
		mov	[ebp+var_5C], eax
		jmp	short loc_B50
; ---------------------------------------------------------------------------

loc_B49:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+223j
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+236j ...
		mov	[ebp+var_5C], 0FFFFh

loc_B50:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+1E2j
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+1F0j ...
		cmp	[ebp+var_5C], 0FFFFh
		jz	loc_EFF
		cmp	[ebp+var_5C], 0FFh
		setnbe	al
		mov	[ebp+var_7D], al
		mov	ecx, [ebp+var_74]
		mov	dl, [ebp+var_7D]
		mov	[ecx+0Eh], dl
		movsx	eax, [ebp+var_89]
		movsx	ecx, [ebp+var_7D]
		cmp	eax, ecx
		jnz	short loc_B91
		mov	eax, [ebp+var_74]
		movsx	ecx, byte ptr [eax+0Ch]
		test	ecx, ecx
		jnz	loc_D72

loc_B91:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+28Cj
		movsx	eax, [ebp+var_7D]
		test	eax, eax
		jnz	loc_C8A
		mov	[ebp+var_98], 2
		mov	[ebp+var_A4], offset ??_C@_02MEEAGEAM@?$HO?$HN?$AA@ ; `string'

loc_BB1:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+385j
		mov	eax, [ebp+var_98]
		mov	ecx, [ebp+var_98]
		sub	ecx, 1
		mov	[ebp+var_98], ecx
		test	eax, eax
		jle	short loc_BD6
		mov	[ebp+var_184], 1
		jmp	short loc_BE0
; ---------------------------------------------------------------------------

loc_BD6:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+2D4j
		mov	[ebp+var_184], 0

loc_BE0:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+2E0j
		cmp	[ebp+var_184], 0
		jz	loc_C7E
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	short loc_C31
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_A4]
		mov	al, [eax]
		mov	[ecx+edx], al
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_C26
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx], eax
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx

loc_C26:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+31Cj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		jmp	short loc_C6A
; ---------------------------------------------------------------------------

loc_C31:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+2FFj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_A4]
		mov	al, [eax]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_C6A:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+33Bj
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax
		jmp	loc_BB1
; ---------------------------------------------------------------------------

loc_C7E:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+2F3j
		mov	eax, [ebp+var_74]
		mov	byte ptr [eax+0Ch], 1
		jmp	loc_D72
; ---------------------------------------------------------------------------

loc_C8A:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+2A3j
		mov	[ebp+var_98], 2
		mov	[ebp+var_A4], offset ??_C@_02JCBKMDIK@?$HO?$HL?$AA@ ; `string'

loc_C9E:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+472j
		mov	eax, [ebp+var_98]
		mov	ecx, [ebp+var_98]
		sub	ecx, 1
		mov	[ebp+var_98], ecx
		test	eax, eax
		jle	short loc_CC3
		mov	[ebp+var_184], 1
		jmp	short loc_CCD
; ---------------------------------------------------------------------------

loc_CC3:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+3C1j
		mov	[ebp+var_184], 0

loc_CCD:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+3CDj
		cmp	[ebp+var_184], 0
		jz	loc_D6B
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	short loc_D1E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_38]
		mov	eax, [ebp+var_A4]
		mov	al, [eax]
		mov	[ecx+edx], al
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jz	short loc_D13
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx], eax
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx

loc_D13:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+409j
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		jmp	short loc_D57
; ---------------------------------------------------------------------------

loc_D1E:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+3ECj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_A4]
		mov	al, [eax]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_D57:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+428j
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax
		jmp	loc_C9E
; ---------------------------------------------------------------------------

loc_D6B:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+3E0j
		mov	eax, [ebp+var_74]
		mov	byte ptr [eax+0Ch], 1

loc_D72:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+297j
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+391j
		movsx	eax, [ebp+var_7D]
		test	eax, eax
		jz	loc_E8E
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	loc_E29
		mov	eax, [ebp+var_5C]
		shr	eax, 8
		mov	ecx, [ebp+var_14]
		add	ecx, [ebp+var_38]
		mov	[ecx], al
		mov	edx, [ebp+var_38]
		add	edx, 1
		mov	[ebp+var_38], edx
		cmp	[ebp+var_20], 0
		jz	short loc_DBB
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx], eax
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx

loc_DBB:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+4B1j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	short loc_DF3
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		mov	cl, byte ptr [ebp+var_5C]
		mov	[eax], cl
		mov	edx, [ebp+var_38]
		add	edx, 1
		mov	[ebp+var_38], edx
		cmp	[ebp+var_20], 0
		jz	short loc_DF1
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx], eax
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx

loc_DF1:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+4E7j
		jmp	short loc_E27
; ---------------------------------------------------------------------------

loc_DF3:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+4CDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	al, byte ptr [ebp+var_5C]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_E27:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_DF1j
		jmp	short loc_E8C
; ---------------------------------------------------------------------------

loc_E29:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+490j
		mov	eax, [ebp+var_5C]
		shr	eax, 8
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	ecx, [ebp+arg_0]
		mov	ecx, [ecx+4]
		movsx	ecx, byte ptr [ecx+3Fh]
		mov	[edx+ecx+4Ch], al
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	cl, [eax+3Fh]
		add	cl, 1
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		mov	[eax+3Fh], cl
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	al, byte ptr [ebp+var_5C]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_E8C:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_E27j
		jmp	short loc_EFA
; ---------------------------------------------------------------------------

loc_E8E:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+484j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_44]
		jge	short loc_EC6
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		mov	cl, byte ptr [ebp+var_5C]
		mov	[eax], cl
		mov	edx, [ebp+var_38]
		add	edx, 1
		mov	[ebp+var_38], edx
		cmp	[ebp+var_20], 0
		jz	short loc_EC4
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	ecx, [ebp+var_20]
		mov	[ecx], eax
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx

loc_EC4:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+5BAj
		jmp	short loc_EFA
; ---------------------------------------------------------------------------

loc_EC6:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+5A0j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	al, byte ptr [ebp+var_5C]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_EFA:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_E8Cj
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_EC4j
		jmp	loc_FD1
; ---------------------------------------------------------------------------

loc_EFF:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+263j
		mov	eax, [ebp+var_68]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_FBA
		mov	eax, [ebp+var_68]
		and	eax, 400h
		jnz	loc_FAF
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_68]
		mov	[ecx+38h], edx

$getTrail$9169:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+AFj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_50]
		jge	short loc_FA4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_2C]
		mov	ax, [ecx+edx*2]
		mov	[ebp+var_BC], ax
		movzx	eax, [ebp+var_BC]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_F99
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+38h]
		shl	edx, 0Ah
		movzx	eax, [ebp+var_BC]
		lea	ecx, [edx+eax-35FDC00h]
		mov	[ebp+var_68], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+38h], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah
		jmp	short loc_FA2
; ---------------------------------------------------------------------------

loc_F99:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+665j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_FA2:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+6A3j
		jmp	short loc_FAD
; ---------------------------------------------------------------------------

loc_FA4:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+63Ej
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0

loc_FAD:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_FA2j
		jmp	short loc_FB8
; ---------------------------------------------------------------------------

loc_FAF:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+626j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_FB8:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_FADj
		jmp	short loc_FC3
; ---------------------------------------------------------------------------

loc_FBA:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+618j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ah

loc_FC3:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_FB8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_68]
		mov	[ecx+38h], edx
		jmp	short loc_FEA
; ---------------------------------------------------------------------------

loc_FD1:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_EFAj
		jmp	short loc_FDE
; ---------------------------------------------------------------------------

loc_FD3:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+CDj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short loc_FEA
; ---------------------------------------------------------------------------

loc_FDE:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC:loc_FD1j
		mov	[ebp+var_5C], 0FFFFh
		jmp	loc_9A8
; ---------------------------------------------------------------------------

loc_FEA:				; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+BAj
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+6DBj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		add	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		mov	[edx+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_2C]
		lea	eax, [ecx+edx*2]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_74]
		mov	cl, [ebp+var_7D]
		mov	[eax+0Eh], cl
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN63
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 184h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_UConverter_fromUnicode_HZ_OFFSETS_LOGIC endp

; ---------------------------------------------------------------------------
		align 4
$LN63		dd 1			; DATA XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+724o
		dd offset $LN62
$LN62		dd 0FFFFFFA4h, 4	; DATA XREF: .text:00001040o
		dd offset $LN61		; "targetUniChar"
$LN61		db 'targetUniChar',0    ; DATA XREF: .text:0000104Co
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1060h
		public ??_C@_02JCBKMDIK@?$HO?$HL?$AA@
; `string'
??_C@_02JCBKMDIK@?$HO?$HL?$AA@ db 7Eh, 7Bh, 0
					; DATA XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+3A0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1064h
		public ??_C@_02MEEAGEAM@?$HO?$HN?$AA@
; `string'
??_C@_02MEEAGEAM@?$HO?$HN?$AA@ db 7Eh, 7Dh, 0
					; DATA XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+2B3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1068h
		public ??_C@_02OPGNDHMP@?$HO?$HO?$AA@
; `string'
??_C@_02OPGNDHMP@?$HO?$HO?$AA@ db 2 dup(7Eh), 0
					; DATA XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+106o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 106Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__HZ_WriteSub	proc near		; DATA XREF: .rdata:00000034o

var_F0		= byte ptr -0F0h
var_2C		= byte ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		lea	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		movsx	ecx, byte ptr [eax+0Eh]
		test	ecx, ecx
		jz	short loc_10D2
		mov	eax, [ebp+var_20]
		mov	byte ptr [eax],	7Eh ; '~'
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_20]
		mov	byte ptr [eax],	7Dh ; '}'
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+0Eh], 0

loc_10D2:				; CODE XREF: __HZ_WriteSub+3Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_20]
		mov	al, [ecx]
		mov	[edx], al
		mov	ecx, [ebp+var_20]
		add	ecx, 1
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_20]
		lea	eax, [ebp+var_2C]
		sub	edx, eax
		push	edx
		lea	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ucnv_cbFromUWriteBytes_56
		add	esp, 14h
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__HZ_WriteSub	endp

; ---------------------------------------------------------------------------
		align 10h
$LN6		dd 1			; DATA XREF: __HZ_WriteSub+A1o
		dd offset $LN5
$LN5		dd 0FFFFFFD4h, 4	; DATA XREF: .text:00001134o
		dd offset $LN4		; "buffer"
$LN4		db 'buffer',0           ; DATA XREF: .text:00001140o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 114Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__HZ_SafeClone	proc near		; DATA XREF: .rdata:00000038o

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_20], 220h
		mov	eax, [ebp+arg_C]
		cmp	dword ptr [eax], 0
		jle	short loc_1180
		xor	eax, eax
		jmp	loc_1210
; ---------------------------------------------------------------------------

loc_1180:				; CODE XREF: __HZ_SafeClone+2Bj
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax], 0
		jnz	short loc_1194
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		xor	eax, eax
		jmp	short loc_1210
; ---------------------------------------------------------------------------

loc_1194:				; CODE XREF: __HZ_SafeClone+3Aj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		push	10h		; Size
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		push	eax		; Src
		mov	ecx, [ebp+var_8]
		add	ecx, 210h
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		add	eax, 210h
		mov	ecx, [ebp+var_8]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+22h], 1
		mov	[ebp+var_14], 10Ch
		mov	eax, [ebp+arg_C]
		push	eax
		lea	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_8]
		add	edx, 104h
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ecx]
		push	edx
		call	_ucnv_safeClone_56
		add	esp, 10h
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[edx], eax
		mov	eax, [ebp+var_8]

loc_1210:				; CODE XREF: __HZ_SafeClone+2Fj
					; __HZ_SafeClone+46j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__HZ_SafeClone	endp

; ---------------------------------------------------------------------------
		align 4
$LN7		dd 1			; DATA XREF: __HZ_SafeClone+C8o
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000123Co
		dd offset $LN5_0	; "size"
$LN5_0		db 'size',0             ; DATA XREF: .text:00001248o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1254h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__HZ_GetUnicodeSet proc	near		; DATA XREF: .rdata:0000003Co

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		push	7Fh ; ''
		push	0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+8]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		push	eax
		push	5
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	edx, [ecx]
		mov	eax, [edx+18h]
		push	eax
		call	_ucnv_MBCSGetFilteredUnicodeSetForUnicode_56
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__HZ_GetUnicodeSet endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _ucnv_close_56:near ; CODE XREF: __HZOpen+B1p
					; __HZClose+30p
		extrn _uprv_calloc_56:near ; CODE XREF:	__HZOpen+89p
		extrn _ucnv_open_56:near ; CODE	XREF: __HZOpen+48p
		extrn _ucnv_canCreateConverter_56:near ; CODE XREF: __HZOpen+32p
		extrn __RTC_CheckEsp:near ; CODE XREF: __HZOpen+CDp
					; __HZClose+67p ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _uprv_free_56:near ; CODE	XREF: __HZClose+4Ap
		extrn _ucnv_MBCSSimpleGetNextUChar_56:near
					; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+32Bp
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: _UConverter_toUnicode_HZ_OFFSETS_LOGIC+49Cp
					; _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+72Ap ...
		extrn _ucnv_MBCSFromUChar32_56:near
					; CODE XREF: _UConverter_fromUnicode_HZ_OFFSETS_LOGIC+20Ep
		extrn _ucnv_cbFromUWriteBytes_56:near ;	CODE XREF: __HZ_WriteSub+95p
		extrn _ucnv_safeClone_56:near ;	CODE XREF: __HZ_SafeClone+B1p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: __HZ_SafeClone+72p
		extrn _uprv_checkValidMemory:near ; CODE XREF: __HZ_SafeClone+57p
		extrn _ucnv_MBCSGetFilteredUnicodeSetForUnicode_56:near
					; CODE XREF: __HZ_GetUnicodeSet+56p


		end
