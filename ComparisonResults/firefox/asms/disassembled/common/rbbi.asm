;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B5F56EDC7237CBCF4EC78016162F7532
; Input	CRC32 :	67B2E6D1

; File Name   :	D:\compspace\objfiles\firefox\common\rbbi.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset _gLanguageBreakFactories
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	locret_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_E00
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; class	icu_56::UnicodeString const * const `public: virtual class icu_56::UnicodeString const & __thiscall icu_56::RuleBasedBreakIterator::getRules(void)const'::`7'::s
?s@?6??getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@3@XZ@4PBV43@B dd ?
					; DATA XREF: icu_56::RuleBasedBreakIterator::getRules(void):loc_72B0r
					; icu_56::RuleBasedBreakIterator::getRules(void)+BFw ...
_fTrace		db ?			; DATA XREF: icu_56::RuleBasedBreakIterator::init(void)+12Dw
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+76r ...
; char `public:	static void * __cdecl icu_56::RuleBasedBreakIterator::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@RuleBasedBreakIterator@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::RuleBasedBreakIterator::getStaticClassID(void)+1Eo
; signed char `protected: void __thiscall icu_56::RuleBasedBreakIterator::init(void)'::`2'::debugInitDone
?debugInitDone@?1??init@RuleBasedBreakIterator@icu_56@@IAEXXZ@4CA db ?
					; DATA XREF: icu_56::RuleBasedBreakIterator::init(void)+EDr
					; icu_56::RuleBasedBreakIterator::init(void):loc_6C9Cw
		align 10h
; icu_56::UVector *gLanguageBreakFactories
_gLanguageBreakFactories dd ?		; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
					; icu_56::getLanguageBreakEngineFromFactory(int,int)+30r ...
; icu_56::UInitOnce gLanguageBreakFactoriesInitOnce
_gLanguageBreakFactoriesInitOnce dd 2 dup(?)
					; DATA XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+23o
					; _breakiterator_cleanup_dict:loc_C774o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10Ch
; wchar_t `icu_56::RuleBasedBreakIterator::setText'::`8'::c
?c@?7??setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z@4_WB db 2 dup(0)
					; DATA XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+CBo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 110h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 148h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 14Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 150h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near		; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+37p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+75p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 184h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]

loc_1BE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp

locret_200:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 204h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p
					; icu_56::UnicodeFunctor::UnicodeFunctor(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 23Ch
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 248h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:0000023Co
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 25Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000254o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 27Ch
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000258o
					; .rdata$r:000002B0o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 28Ch
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000288o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 298h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000568o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2B4h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000290o
					; .rdata$r:0000056Co ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2D0h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2F0h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000002CCo
					; .rdata$r:00000320o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 300h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000002FCo
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 308h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 324h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap
					; icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+49p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_35B
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_365
; ---------------------------------------------------------------------------

loc_35B:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_365:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap
					; icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3EB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_3EB:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp

loc_400:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 404h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_465
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_45D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_45D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_484
; ---------------------------------------------------------------------------

loc_465:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_481
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_481:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_484:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F0h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 51Ch
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:000004F0o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 530h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000528o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 554h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:0000052Co
					; .rdata$r:0000058Co
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 564h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00000560o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 574h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:000011A4o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 590h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_617
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_617:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 630h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_691
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_689
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_689:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_6B0
; ---------------------------------------------------------------------------

loc_691:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6AD
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6AD:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_6B0:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 714h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 764h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp

loc_800:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 80Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 914h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 974h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_A81
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_A65
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_A65:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_A81:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_ADB
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_AD1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_ADB
; ---------------------------------------------------------------------------

loc_AD1:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_ADB:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BACh
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BC0h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000BACo
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BD4h
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000BCCo
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BF4h
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00000BD0o
					; .rdata$r:00000C28o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C04h
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00000C00o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C10h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C6B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_C6B:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_CE5
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_CDD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_CDD:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_D04
; ---------------------------------------------------------------------------

loc_CE5:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D01
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_D01:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_D04:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi

loc_E00:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E73
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_E73:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_EED
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EE5
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_EE5:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F0C
; ---------------------------------------------------------------------------

loc_EED:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F09
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_F09:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F0C:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_F5A
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_F76
; ---------------------------------------------------------------------------

loc_F5A:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_F76
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_F76:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_FCD
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_FDF
; ---------------------------------------------------------------------------

loc_FCD:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_FDF
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_FDF:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_FF2
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_100E
; ---------------------------------------------------------------------------

loc_FF2:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx

loc_FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		jle	short loc_100E
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_100E:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &):loc_FFFj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1061
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_106D
; ---------------------------------------------------------------------------

loc_1061:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_106D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 107Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_10B9
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_10C5
; ---------------------------------------------------------------------------

loc_10B9:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_10C5:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+8Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 112Ch
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1158h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:0000112Co
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 116Ch
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001164o
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1190h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001168o
					; .rdata$r:000011CCo
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11A0h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:0000119Co
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11B4h
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1208h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 123Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_127E
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_128A
; ---------------------------------------------------------------------------

loc_127E:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_128A:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_12DF
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_12EB
; ---------------------------------------------------------------------------

loc_12DF:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_12EB:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1338h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 136Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_13F5
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_13EC
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_13F5

loc_13EC:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_13FC
; ---------------------------------------------------------------------------

loc_13F5:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_13FC:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1418h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+59p
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+56p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_144D
		xor	eax, eax
		jmp	short loc_1469
; ---------------------------------------------------------------------------
		jmp	short loc_1469
; ---------------------------------------------------------------------------

loc_144D:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1463
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_1469
; ---------------------------------------------------------------------------
		jmp	short loc_1469
; ---------------------------------------------------------------------------

loc_1463:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_1469:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1470h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_14B6
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_14E7
; ---------------------------------------------------------------------------
		jmp	short loc_14E7
; ---------------------------------------------------------------------------

loc_14B6:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_14E7:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1500h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_153E
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_1598
; ---------------------------------------------------------------------------
		jmp	short loc_1598
; ---------------------------------------------------------------------------

loc_153E:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_158B
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_158B
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_158B
		mov	[ebp+var_E5], 1
		jmp	short loc_1592
; ---------------------------------------------------------------------------

loc_158B:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_1592:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_1598:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1600h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1664h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 172Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1790h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1844h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 189Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1948h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1A42
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1A73
; ---------------------------------------------------------------------------
		jmp	short loc_1A73
; ---------------------------------------------------------------------------

loc_1A42:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_1A73:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D3E
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1D73
; ---------------------------------------------------------------------------
		jmp	short loc_1D73
; ---------------------------------------------------------------------------

loc_1D3E:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_1D73:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx

loc_2000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2014h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_207F
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_207F
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2082
; ---------------------------------------------------------------------------

loc_207F:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2082:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2098h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2160h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2220h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2274h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2314h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2368h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 241Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2480h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 253Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_25A7
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_25A7
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_25AA
; ---------------------------------------------------------------------------

loc_25A7:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_25AA:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2618h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2730h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2824h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2888h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2950h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_29E4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_29E4:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2A54
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2A54:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2BB4
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2BB4:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2C32
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2C32:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp

loc_2FFD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3008h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 305Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3108h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3174h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3223
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_3228
; ---------------------------------------------------------------------------
		jmp	short loc_3228
; ---------------------------------------------------------------------------

loc_3223:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_3228:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3240h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3288h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 330Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3348h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3390h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_33CA
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_33E7
; ---------------------------------------------------------------------------

loc_33CA:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_33E7:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3400h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3438h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3490h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3534h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3594h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3608h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3650h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 370Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3764h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3804h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3854h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3938h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3980h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3BFC
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_3C04
; ---------------------------------------------------------------------------

loc_3BFC:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_3C04:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_3C58
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_3C58
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_3C6E
; ---------------------------------------------------------------------------

loc_3C58:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_3C6E:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3D7A
		cmp	[ebp+arg_0], 0
		jnz	short loc_3D7A
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_3D9B
; ---------------------------------------------------------------------------
		jmp	short loc_3D9B
; ---------------------------------------------------------------------------

loc_3D7A:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3D99
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_3D9B
; ---------------------------------------------------------------------------
		jmp	short loc_3D9B
; ---------------------------------------------------------------------------

loc_3D99:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_3D9B:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: class icu_56::ForwardCharacterIterator & __thiscall icu_56::ForwardCharacterIterator::operator=(class icu_56::ForwardCharacterIterator const &)
		public ??4ForwardCharacterIterator@icu_56@@IAEAAV01@ABV01@@Z
??4ForwardCharacterIterator@icu_56@@IAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4ForwardCharacterIterator@icu_56@@IAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::ForwardCharacterIterator::operator!=(class icu_56::ForwardCharacterIterator const &)const
		public ??9ForwardCharacterIterator@icu_56@@QBECABV01@@Z
??9ForwardCharacterIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9ForwardCharacterIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ED8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::setToStart(icu_56::CharacterIterator *__hidden this)
		public ?setToStart@CharacterIterator@icu_56@@QAEHXZ
?setToStart@CharacterIterator@icu_56@@QAEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	0
		push	0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+5Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToStart@CharacterIterator@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::setToEnd(icu_56::CharacterIterator *__hidden this)
		public ?setToEnd@CharacterIterator@icu_56@@QAEHXZ
?setToEnd@CharacterIterator@icu_56@@QAEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	2
		push	0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+5Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToEnd@CharacterIterator@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::startIndex(icu_56::CharacterIterator *__hidden this)
		public ?startIndex@CharacterIterator@icu_56@@QBEHXZ
?startIndex@CharacterIterator@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+D0p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?startIndex@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::endIndex(icu_56::CharacterIterator *__hidden this)
		public ?endIndex@CharacterIterator@icu_56@@QBEHXZ
?endIndex@CharacterIterator@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?endIndex@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::getIndex(icu_56::CharacterIterator *__hidden this)
		public ?getIndex@CharacterIterator@icu_56@@QBEHXZ
?getIndex@CharacterIterator@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIndex@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4010h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::getLength(icu_56::CharacterIterator	*__hidden this)
		public ?getLength@CharacterIterator@icu_56@@QBEHXZ
?getLength@CharacterIterator@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLength@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4040h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration *this, const	struct icu_56::StringEnumeration *)
		public ??0StringEnumeration@icu_56@@QAE@ABV01@@Z
??0StringEnumeration@icu_56@@QAE@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7StringEnumeration@icu_56@@6B@ ; const icu_56::StringEnumeration::`vftable'
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 4		; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	esi, [ebp+arg_0]
		add	esi, 44h ; 'D'
		mov	edi, [ebp+var_14]
		add	edi, 44h ; 'D'
		mov	ecx, 8
		rep movsd
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+64h]
		mov	[eax+64h], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4108h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00004160o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z proc near
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4130h
		dd offset ??_R4StringEnumeration@icu_56@@6B@ ; const icu_56::StringEnumeration::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7StringEnumeration@icu_56@@6B@
; const	icu_56::StringEnumeration::`vftable'
??_7StringEnumeration@icu_56@@6B@ dd offset ??_EStringEnumeration@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+58o
					; icu_56::StringEnumeration::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ ; icu_56::StringEnumeration::clone(void)
		dd offset __purecall
		dd offset ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z ;	icu_56::StringEnumeration::next(int *,UErrorCode &)
		dd offset ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z	; icu_56::StringEnumeration::unext(int *,UErrorCode &)
		dd offset ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z ; icu_56::StringEnumeration::snext(UErrorCode &)
		dd offset __purecall
		dd offset ??8StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator==(icu_56::StringEnumeration const &)
		dd offset ??9StringEnumeration@icu_56@@UBECABV01@@Z ; icu_56::StringEnumeration::operator!=(icu_56::StringEnumeration const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 415Ch
__unwindtable$??0StringEnumeration@icu_56@@QAE@ABV01@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000416Co
		dd offset __unwindfunclet$??0StringEnumeration@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0StringEnumeration@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0StringEnumeration@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4188h
		public ??_R4StringEnumeration@icu_56@@6B@
; const	icu_56::StringEnumeration::`RTTI Complete Object Locator'
??_R4StringEnumeration@icu_56@@6B@ dd 3	dup(0) ; DATA XREF: .rdata:00004130o
		dd offset ??_R0?AVStringEnumeration@icu_56@@@8 ; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 419Ch
		public ??_R0?AVStringEnumeration@icu_56@@@8
; class	icu_56::StringEnumeration `RTTI	Type Descriptor'
??_R0?AVStringEnumeration@icu_56@@@8 dd	offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004194o
					; .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avstringenum	db '.?AVStringEnumeration@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 41C4h
		public ??_R3StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
??_R3StringEnumeration@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00004198o
					; .rdata$r:000041FCo
		dd 3
		dd offset ??_R2StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 41D4h
		public ??_R2StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Array'
??_R2StringEnumeration@icu_56@@8 dd offset ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
					; DATA XREF: .rdata$r:000041D0o
					; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 41E4h
		public ??_R1A@?0A@EA@StringEnumeration@icu_56@@8
; icu_56::StringEnumeration::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@StringEnumeration@icu_56@@8 dd offset ??_R0?AVStringEnumeration@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::StringEnumeration::`RTTI Base Class Array'o
					; icu_56::StringEnumeration `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3StringEnumeration@icu_56@@8 ; icu_56::StringEnumeration::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4200h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringEnumeration & __thiscall icu_56::StringEnumeration::operator=(class icu_56::StringEnumeration const &)
		public ??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z
??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+arg_0]
		add	eax, 4
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		mov	[ebp+var_14], 0
		jmp	short loc_4253
; ---------------------------------------------------------------------------

loc_424A:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+6Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_4253:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+48j
		cmp	[ebp+var_14], 20h ; ' '
		jnb	short loc_426D
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		add	ecx, [ebp+var_14]
		mov	dl, [ecx+44h]
		mov	[eax+44h], dl
		jmp	short loc_424A
; ---------------------------------------------------------------------------

loc_426D:				; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+57j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+64h]
		mov	[eax+64h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+68h]
		mov	[eax+68h], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringEnumeration@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringEnumeration::`scalar deleting	destructor'(unsigned int)
		public ??_GStringEnumeration@icu_56@@UAEPAXI@Z
??_GStringEnumeration@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_42DF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_42DF:				; CODE XREF: icu_56::StringEnumeration::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GStringEnumeration@icu_56@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 42F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::StringEnumeration::`vector deleting	destructor'(unsigned int)
		public ??_EStringEnumeration@icu_56@@UAEPAXI@Z
??_EStringEnumeration@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::StringEnumeration::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4359
		push	offset ??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	6Ch ; 'l'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4351
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4351:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4378
; ---------------------------------------------------------------------------

loc_4359:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1StringEnumeration@icu_56@@UAE@XZ ; icu_56::StringEnumeration::~StringEnumeration(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4375
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4375:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4378:				; CODE XREF: icu_56::StringEnumeration::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EStringEnumeration@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4390h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::Locale::operator!=(class icu_56::Locale const &)const
		public ??9Locale@icu_56@@QBECABV01@@Z
??9Locale@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Locale@icu_56@@QBECABV01@@Z ; icu_56::Locale::operator==(icu_56::Locale const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Locale@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::Locale::getCountry(icu_56::Locale *__hidden this)
		public ?getCountry@Locale@icu_56@@QBEPBDXZ
?getCountry@Locale@icu_56@@QBEPBDXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 16h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCountry@Locale@icu_56@@QBEPBDXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4410h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::Locale::getLanguage(icu_56::Locale *__hidden this)
		public ?getLanguage@Locale@icu_56@@QBEPBDXZ
?getLanguage@Locale@icu_56@@QBEPBDXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 4
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLanguage@Locale@icu_56@@QBEPBDXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4440h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::Locale::getScript(icu_56::Locale *__hidden this)
		public ?getScript@Locale@icu_56@@QBEPBDXZ
?getScript@Locale@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getScript@Locale@icu_56@@QBEPBDXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4470h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::Locale::getVariant(icu_56::Locale *__hidden this)
		public ?getVariant@Locale@icu_56@@QBEPBDXZ
?getVariant@Locale@icu_56@@QBEPBDXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0C4h]
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+1Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getVariant@Locale@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::Locale::getName(icu_56::Locale	*__hidden this)
		public ?getName@Locale@icu_56@@QBEPBDXZ
?getName@Locale@icu_56@@QBEPBDXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+20h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getName@Locale@icu_56@@QBEPBDXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::Locale::isBogus(icu_56::Locale *__hidden this)
		public ?isBogus@Locale@icu_56@@QBECXZ
?isBogus@Locale@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+0C8h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@Locale@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4510h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::BreakIterator::operator!=(class icu_56::BreakIterator const &)const
		public ??9BreakIterator@icu_56@@QBECABV01@@Z
??9BreakIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9BreakIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 456Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::BreakIterator::BreakIterator(icu_56::BreakIterator *this, const struct icu_56::BreakIterator *)
		public ??0BreakIterator@icu_56@@IAE@ABV01@@Z
??0BreakIterator@icu_56@@IAE@ABV01@@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator const &)+49p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7BreakIterator@icu_56@@6B@ ;	const icu_56::BreakIterator::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0BreakIterator@icu_56@@IAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 45C0h
		dd offset ??_R4BreakIterator@icu_56@@6B@ ; const icu_56::BreakIterator::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7BreakIterator@icu_56@@6B@
; const	icu_56::BreakIterator::`vftable'
??_7BreakIterator@icu_56@@6B@ dd offset	??_EBreakIterator@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::BreakIterator::BreakIterator(icu_56::BreakIterator	const &)+32o
					; icu_56::BreakIterator::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?getRuleStatus@BreakIterator@icu_56@@UBEHXZ ;	icu_56::BreakIterator::getRuleStatus(void)
		dd offset ?getRuleStatusVec@BreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z ; icu_56::BreakIterator::getRuleStatusVec(int *,int,UErrorCode &)
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 461Ch
		public ??_R4BreakIterator@icu_56@@6B@
; const	icu_56::BreakIterator::`RTTI Complete Object Locator'
??_R4BreakIterator@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000045C0o
		dd offset ??_R0?AVBreakIterator@icu_56@@@8 ; icu_56::BreakIterator `RTTI Type Descriptor'
		dd offset ??_R3BreakIterator@icu_56@@8 ; icu_56::BreakIterator::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4630h
		public ??_R0?AVBreakIterator@icu_56@@@8
; class	icu_56::BreakIterator `RTTI Type Descriptor'
??_R0?AVBreakIterator@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004628o
					; .rdata$r:icu_56::BreakIterator::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avbreakitera	db '.?AVBreakIterator@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4654h
		public ??_R3BreakIterator@icu_56@@8
; icu_56::BreakIterator::`RTTI Class Hierarchy Descriptor'
??_R3BreakIterator@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:0000462Co
					; .rdata$r:0000468Co
		dd 3
		dd offset ??_R2BreakIterator@icu_56@@8 ; icu_56::BreakIterator::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4664h
		public ??_R2BreakIterator@icu_56@@8
; icu_56::BreakIterator::`RTTI Base Class Array'
??_R2BreakIterator@icu_56@@8 dd	offset ??_R1A@?0A@EA@BreakIterator@icu_56@@8
					; DATA XREF: .rdata$r:00004660o
					; icu_56::BreakIterator::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4674h
		public ??_R1A@?0A@EA@BreakIterator@icu_56@@8
; icu_56::BreakIterator::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@BreakIterator@icu_56@@8 dd offset	??_R0?AVBreakIterator@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::BreakIterator::`RTTI Base	Class Array'o
					; .rdata$r:00005D00o
					; icu_56::BreakIterator	`RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3BreakIterator@icu_56@@8 ; icu_56::BreakIterator::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4690h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::BreakIterator::`scalar deleting destructor'(unsigned int)
		public ??_GBreakIterator@icu_56@@UAEPAXI@Z
??_GBreakIterator@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_46CF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_46CF:				; CODE XREF: icu_56::BreakIterator::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GBreakIterator@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::BreakIterator::`vector deleting destructor'(unsigned int)
		public ??_EBreakIterator@icu_56@@UAEPAXI@Z
??_EBreakIterator@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::BreakIterator::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_474C
		push	offset ??1BreakIterator@icu_56@@UAE@XZ ; icu_56::BreakIterator::~BreakIterator(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	140h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4744
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4744:				; CODE XREF: icu_56::BreakIterator::`vector deleting destructor'(uint)+4Bj
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_476B
; ---------------------------------------------------------------------------

loc_474C:				; CODE XREF: icu_56::BreakIterator::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4768
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4768:				; CODE XREF: icu_56::BreakIterator::`vector deleting destructor'(uint)+72j
		mov	eax, [ebp+var_8]

loc_476B:				; CODE XREF: icu_56::BreakIterator::`vector deleting destructor'(uint)+62j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EBreakIterator@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4784h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::BreakIterator::isBufferClone(icu_56::BreakIterator *__hidden	this)
		public ?isBufferClone@BreakIterator@icu_56@@QAECXZ
?isBufferClone@BreakIterator@icu_56@@QAECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	al, al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBufferClone@BreakIterator@icu_56@@QAECXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(unsigned int)
		public ??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z
??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleBasedBreakIterator@icu_56@@UAE@XZ ; icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_47EF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_47EF:				; CODE XREF: icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GRuleBasedBreakIterator@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4808h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::RuleBasedBreakIterator::`vector deleting destructor'(unsigned int)
		public ??_ERuleBasedBreakIterator@icu_56@@UAEPAXI@Z
??_ERuleBasedBreakIterator@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::RuleBasedBreakIterator::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_486C
		push	offset ??1RuleBasedBreakIterator@icu_56@@UAE@XZ	; icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	178h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4864
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4864:				; CODE XREF: icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)+4Bj
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_488B
; ---------------------------------------------------------------------------

loc_486C:				; CODE XREF: icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1RuleBasedBreakIterator@icu_56@@UAE@XZ ; icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4888
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4888:				; CODE XREF: icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)+72j
		mov	eax, [ebp+var_8]

loc_488B:				; CODE XREF: icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)+62j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ERuleBasedBreakIterator@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 48A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::RuleBasedBreakIterator::operator!=(class icu_56::BreakIterator	const &)const
		public ??9RuleBasedBreakIterator@icu_56@@QBECABVBreakIterator@1@@Z
??9RuleBasedBreakIterator@icu_56@@QBECABVBreakIterator@1@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9RuleBasedBreakIterator@icu_56@@QBECABVBreakIterator@1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4900h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		public ??0UnicodeFunctor@icu_56@@QAE@XZ
??0UnicodeFunctor@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFunctor@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 494Ch
		dd offset ??_R4UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`vftable'
??_7UnicodeFunctor@icu_56@@6B@ dd offset ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFunctor::UnicodeFunctor(void)+2Eo
					; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor	const &)+32o
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ ;	icu_56::UnicodeFunctor::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4968h
		public ??_R4UnicodeFunctor@icu_56@@6B@
; const	icu_56::UnicodeFunctor::`RTTI Complete Object Locator'
??_R4UnicodeFunctor@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:0000494Co
		dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8 ; icu_56::UnicodeFunctor `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 497Ch
		public ??_R0?AVUnicodeFunctor@icu_56@@@8
; class	icu_56::UnicodeFunctor `RTTI Type Descriptor'
??_R0?AVUnicodeFunctor@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004974o
					; .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodefun	db '.?AVUnicodeFunctor@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 49A0h
		public ??_R3UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeFunctor@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00004978o
					; .rdata$r:000049D8o
		dd 3
		dd offset ??_R2UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 49B0h
		public ??_R2UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Array'
??_R2UnicodeFunctor@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
					; DATA XREF: .rdata$r:000049ACo
					; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 49C0h
		public ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8
; icu_56::UnicodeFunctor::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 dd offset ??_R0?AVUnicodeFunctor@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFunctor::`RTTI Base Class Array'o
					; .rdata$r:00004E94o
					; icu_56::UnicodeFunctor `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFunctor@icu_56@@8	; icu_56::UnicodeFunctor::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor *this, const struct icu_56::UnicodeFunctor *)
		public ??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFunctor@icu_56@@6B@ ; const icu_56::UnicodeFunctor::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFunctor & __thiscall icu_56::UnicodeFunctor::operator=(class icu_56::UnicodeFunctor const &)
		public ??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFunctor@icu_56@@UAEPAXI@Z
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4AB7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4AB7:				; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFunctor@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFunctor::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFunctor@icu_56@@UAEPAXI@Z
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFunctor::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4B31
		push	offset ??1UnicodeFunctor@icu_56@@UAE@XZ	; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4B29
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_4B29:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4B50
; ---------------------------------------------------------------------------

loc_4B31:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFunctor@icu_56@@UAE@XZ ; icu_56::UnicodeFunctor::~UnicodeFunctor(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4B4D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4B4D:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4B50:				; CODE XREF: icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFunctor@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		public ??0UnicodeMatcher@icu_56@@QAE@XZ
??0UnicodeMatcher@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+31p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeMatcher@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4BA0h
		dd offset ??_R4UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`vftable'
??_7UnicodeMatcher@icu_56@@6B@ dd offset ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeMatcher::UnicodeMatcher(void)+26o
					; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher	const &)+26o
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4BB8h
		public ??_R4UnicodeMatcher@icu_56@@6B@
; const	icu_56::UnicodeMatcher::`RTTI Complete Object Locator'
??_R4UnicodeMatcher@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00004BA0o
		dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8 ; icu_56::UnicodeMatcher `RTTI Type	Descriptor'
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4BCCh
		public ??_R0?AVUnicodeMatcher@icu_56@@@8
; class	icu_56::UnicodeMatcher `RTTI Type Descriptor'
??_R0?AVUnicodeMatcher@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004BC4o
					; .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		dd 0
a_?avunicodemat	db '.?AVUnicodeMatcher@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4BF0h
		public ??_R3UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
??_R3UnicodeMatcher@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00004BC8o
					; .rdata$r:00004C20o ...
		dd 1
		dd offset ??_R2UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4C00h
		public ??_R2UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Array'
??_R2UnicodeMatcher@icu_56@@8 dd offset	??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
					; DATA XREF: .rdata$r:00004BFCo
					; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4C08h
		public ??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UnicodeMatcher@icu_56@@8 dd offset ??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeMatcher::`RTTI Base Class Array'o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher *this, const struct icu_56::UnicodeMatcher *)
		public ??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeMatcher@icu_56@@6B@ ; const icu_56::UnicodeMatcher::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeMatcher & __thiscall icu_56::UnicodeMatcher::operator=(class icu_56::UnicodeMatcher const &)
		public ??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeMatcher@icu_56@@UAEPAXI@Z
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4CCB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4CCB:				; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeMatcher@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeMatcher::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeMatcher@icu_56@@UAEPAXI@Z
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeMatcher::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_4D45
		push	offset ??1UnicodeMatcher@icu_56@@UAE@XZ	; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4D3D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_4D3D:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4D64
; ---------------------------------------------------------------------------

loc_4D45:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeMatcher@icu_56@@UAE@XZ ; icu_56::UnicodeMatcher::~UnicodeMatcher(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4D61
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_4D61:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4D64:				; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeMatcher@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete[](void *)
		public ??_V@YAXPAX@Z
??_V@YAXPAX@Z	proc near		; CODE XREF: icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+51p
					; icu_56::SymbolTable::`vector deleting	destructor'(uint)+51p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??_V@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4DB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *__hidden this)
		public ??0UnicodeFilter@icu_56@@QAE@XZ
??0UnicodeFilter@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@XZ ; icu_56::UnicodeFunctor::UnicodeFunctor(void)
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@XZ ; icu_56::UnicodeMatcher::UnicodeMatcher(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeFilter@icu_56@@QAE@XZ	endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E10h
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeMatcher'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ dd offset ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+42o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+6Bo
					; [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)
		dd offset ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z	; icu_56::UnicodeFilter::matches(icu_56::Replaceable const &,int &,int,signed char)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E28h
		dd offset ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`RTTI Complete	Object Locator'{for `icu_56::UnicodeFunctor'}
;
; Exported entry
;
		public ??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ dd offset ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeFilter::UnicodeFilter(void)+39o
					; icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter const &)+62o
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ ; icu_56::UnicodeFilter::toMatcher(void)
		dd offset ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ	; icu_56::UnicodeFunctor::toReplacer(void)
		dd offset ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z ; icu_56::UnicodeFilter::setData(icu_56::TransliterationRuleData const *)
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E48h
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeFunctor'}
??_R4UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@	dd 3 dup(0) ; DATA XREF: .rdata:00004E28o
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4E5Ch
		public ??_R0?AVUnicodeFilter@icu_56@@@8
; class	icu_56::UnicodeFilter `RTTI Type Descriptor'
??_R0?AVUnicodeFilter@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004E54o
					; .rdata$r:icu_56::UnicodeFilter::`RTTI	Base Class Descriptor at (0,-1,0,64)'o ...
					; const	type_info::`vftable'
		dd 0
a_?avunicodefil	db '.?AVUnicodeFilter@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E80h
		public ??_R3UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeFilter@icu_56@@8 dd	0	; DATA XREF: .rdata$r:00004E58o
					; .rdata$r:00004EC0o ...
		dd 1, 5
		dd offset ??_R2UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4E90h
		public ??_R2UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Array'
??_R2UnicodeFilter@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
					; DATA XREF: .rdata$r:00004E8Co
					; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UnicodeFunctor@icu_56@@8 ; icu_56::UnicodeFunctor::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		dd offset ??_R13?0A@EA@UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4EA8h
		public ??_R1A@?0A@EA@UnicodeFilter@icu_56@@8
; icu_56::UnicodeFilter::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeFilter@icu_56@@8 dd offset	??_R0?AVUnicodeFilter@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeFilter::`RTTI Base	Class Array'o
					; icu_56::UnicodeFilter	`RTTI Type Descriptor'
		dd 4, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4EC4h
		public ??_R13?0A@EA@UnicodeMatcher@icu_56@@8
; icu_56::UnicodeMatcher::`RTTI	Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UnicodeMatcher@icu_56@@8 dd offset	??_R0?AVUnicodeMatcher@icu_56@@@8
					; DATA XREF: .rdata$r:00004EA0o
					; icu_56::UnicodeMatcher `RTTI Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeMatcher@icu_56@@8	; icu_56::UnicodeMatcher::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4EE0h
		public ??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@
; const	icu_56::UnicodeFilter::`RTTI Complete Object Locator'{for `icu_56::UnicodeMatcher'}
??_R4UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@	dd 0 ; DATA XREF: .rdata:00004E10o
		dd 4, 0
		dd offset ??_R0?AVUnicodeFilter@icu_56@@@8 ; icu_56::UnicodeFilter `RTTI Type Descriptor'
		dd offset ??_R3UnicodeFilter@icu_56@@8 ; icu_56::UnicodeFilter::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4EF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter *this, const struct icu_56::UnicodeFilter *)
		public ??0UnicodeFilter@icu_56@@QAE@ABV01@@Z
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeFunctor	*
		mov	ecx, [ebp+var_8] ; this
		call	??0UnicodeFunctor@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeFunctor::UnicodeFunctor(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_4F37
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_4F41
; ---------------------------------------------------------------------------

loc_4F37:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+33j
		mov	[ebp+var_D0], 0

loc_4F41:				; CODE XREF: icu_56::UnicodeFilter::UnicodeFilter(icu_56::UnicodeFilter	const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx		; struct icu_56::UnicodeMatcher	*
		mov	ecx, [ebp+var_8]
		add	ecx, 4		; this
		call	??0UnicodeMatcher@icu_56@@QAE@ABV01@@Z ; icu_56::UnicodeMatcher::UnicodeMatcher(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeFilter@icu_56@@6BUnicodeFunctor@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], offset ??_7UnicodeFilter@icu_56@@6BUnicodeMatcher@1@@ ; const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UnicodeFilter@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeFilter &	__thiscall icu_56::UnicodeFilter::operator=(class icu_56::UnicodeFilter	const &)
		public ??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UnicodeFunctor@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeFunctor::operator=(icu_56::UnicodeFunctor const &)
		cmp	[ebp+arg_0], 0
		jz	short loc_4FC3
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_4FCD
; ---------------------------------------------------------------------------

loc_4FC3:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+33j
		mov	[ebp+var_D0], 0

loc_4FCD:				; CODE XREF: icu_56::UnicodeFilter::operator=(icu_56::UnicodeFilter const &)+41j
		mov	ecx, [ebp+var_D0]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 4
		call	??4UnicodeMatcher@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeMatcher::operator=(icu_56::UnicodeMatcher const &)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeFilter@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4FF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeFilter@icu_56@@UAEPAXI@Z
??_GUnicodeFilter@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5037
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_5037:				; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeFilter@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5050h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeFilter@icu_56@@UAEPAXI@Z
??_EUnicodeFilter@icu_56@@UAEPAXI@Z proc near
					; CODE XREF: [thunk]:icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (uint)+3j
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeFunctor'}o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_50B1
		push	offset ??1UnicodeFilter@icu_56@@UAE@XZ ; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	8
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_50A9
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_50A9:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_50D0
; ---------------------------------------------------------------------------

loc_50B1:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeFilter@icu_56@@UAE@XZ	; icu_56::UnicodeFilter::~UnicodeFilter(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_50CD
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_50CD:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_50D0:				; CODE XREF: icu_56::UnicodeFilter::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeFilter@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 50E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UnicodeSet::operator!=(class icu_56::UnicodeSet const &)const
		public ??9UnicodeSet@icu_56@@QBECABV01@@Z
??9UnicodeSet@icu_56@@QBECABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeSet@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5144h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isFrozen(icu_56::UnicodeSet *__hidden this)
		public ?isFrozen@UnicodeSet@icu_56@@QBECXZ
?isFrozen@UnicodeSet@icu_56@@QBECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_5182
		mov	ecx, [ebp+var_8]
		cmp	dword ptr [ecx+2Ch], 0
		jnz	short loc_5182
		mov	[ebp+var_CD], 0
		jmp	short loc_5189
; ---------------------------------------------------------------------------

loc_5182:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+2Aj
					; icu_56::UnicodeSet::isFrozen(void)+33j
		mov	[ebp+var_CD], 1

loc_5189:				; CODE XREF: icu_56::UnicodeSet::isFrozen(void)+3Cj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isFrozen@UnicodeSet@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5198h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, int, int)
		public ?containsSome@UnicodeSet@icu_56@@QBECHH@Z
?containsSome@UnicodeSet@icu_56@@QBECHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECHH@Z ; icu_56::UnicodeSet::containsNone(int,int)
		movsx	edx, al
		test	edx, edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?containsSome@UnicodeSet@icu_56@@QBECHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeSet *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeSet *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z ;	icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 523Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet *this, const struct icu_56::UnicodeString *)
		public ?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z ; icu_56::UnicodeSet::containsNone(icu_56::UnicodeString const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsSome@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 528Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeSet::isBogus(icu_56::UnicodeSet *__hidden this)
		public ?isBogus@UnicodeSet@icu_56@@QBECXZ
?isBogus@UnicodeSet@icu_56@@QBECXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movzx	eax, byte ptr [eax+30h]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeSet@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPAV12@PAUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeSet *__cdecl icu_56::UnicodeSet::fromUSet(const struct USet *)
		public ?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fromUSet@UnicodeSet@icu_56@@SAPBV12@PBUUSet@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5310h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct USet *__thiscall icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet	*__hidden this)
		public ?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QAEPAUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5340h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct USet *__thiscall	icu_56::UnicodeSet::toUSet(icu_56::UnicodeSet *__hidden	this)
		public ?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?toUSet@UnicodeSet@icu_56@@QBEPBUUSet@@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::span(class	icu_56::UnicodeString const &, int, enum  USetSpanCondition)const
		public ?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_53AD
		mov	[ebp+arg_4], 0
		jmp	short loc_53BB
; ---------------------------------------------------------------------------

loc_53AD:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_53BB
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_53BB:				; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_14]
		sub	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	edx, [ebp+arg_4]
		lea	eax, [eax+edx*2]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ; icu_56::UnicodeSet::span(wchar_t const *,int,USetSpanCondition)
		add	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?span@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::UnicodeSet::spanBack(class icu_56::UnicodeString const	&, int,	enum  USetSpanCondition)const
		public ?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_4], 0
		jge	short loc_5435
		mov	[ebp+arg_4], 0
		jmp	short loc_5443
; ---------------------------------------------------------------------------

loc_5435:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+32j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_14]
		jle	short loc_5443
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], eax

loc_5443:				; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+3Bj
					; icu_56::UnicodeSet::spanBack(icu_56::UnicodeString const &,int,USetSpanCondition)+43j
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax
		mov	ecx, [ebp+var_8]
		call	?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z ;	icu_56::UnicodeSet::spanBack(wchar_t const *,int,USetSpanCondition)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?spanBack@UnicodeSet@icu_56@@QBEHABVUnicodeString@2@HW4USetSpanCondition@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5474h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		public ?size@UVector@icu_56@@QBEHXZ
?size@UVector@icu_56@@QBEHXZ proc near	; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1169p
					; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+152p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@UVector@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::isEmpty(icu_56::UVector *__hidden this)
		public ?isEmpty@UVector@icu_56@@QBECXZ
?isEmpty@UVector@icu_56@@QBECXZ	proc near ; CODE XREF: icu_56::UStack::empty(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UVector@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, void *)
		public ?contains@UVector@icu_56@@QBECPAX@Z
?contains@UVector@icu_56@@QBECPAX@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHPAXH@Z ; icu_56::UVector::indexOf(void *,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5524h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, int)
		public ?contains@UVector@icu_56@@QBECH@Z
?contains@UVector@icu_56@@QBECH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHHH@Z ; icu_56::UVector::indexOf(int,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::firstElement(icu_56::UVector *__hidden this)
		public ?firstElement@UVector@icu_56@@QBEPAXXZ
?firstElement@UVector@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?firstElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 55B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::lastElement(icu_56::UVector	*__hidden this)
		public ?lastElement@UVector@icu_56@@QBEPAXXZ
?lastElement@UVector@icu_56@@QBEPAXXZ proc near	; CODE XREF: icu_56::UStack::peek(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5600h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::lastElementi(icu_56::UVector *__hidden this)
		public ?lastElementi@UVector@icu_56@@QBEHXZ
?lastElementi@UVector@icu_56@@QBEHXZ proc near ; CODE XREF: icu_56::UStack::peeki(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElementi@UVector@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 564Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::UVector::operator[](int)const
		public ??AUVector@icu_56@@QBEPAXH@Z
??AUVector@icu_56@@QBEPAXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUVector@icu_56@@QBEPAXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5694h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector::operator!=(class icu_56::UVector const &)
		public ??9UVector@icu_56@@QAECABV01@@Z
??9UVector@icu_56@@QAECABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8UVector@icu_56@@QAECABV01@@Z	; icu_56::UVector::operator==(icu_56::UVector const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UVector@icu_56@@QAECABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UStack::empty(icu_56::UStack	*__hidden this)
		public ?empty@UStack@icu_56@@QBECXZ
?empty@UStack@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?empty@UStack@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5724h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::peek(icu_56::UStack *__hidden this)
		public ?peek@UStack@icu_56@@QBEPAXXZ
?peek@UStack@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElement@UVector@icu_56@@QBEPAXXZ ;	icu_56::UVector::lastElement(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peek@UStack@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5764h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::peeki(icu_56::UStack *__hidden	this)
		public ?peeki@UStack@icu_56@@QBEHXZ
?peeki@UStack@icu_56@@QBEHXZ proc near	; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+11C2p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElementi@UVector@icu_56@@QBEHXZ ; icu_56::UVector::lastElementi(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peeki@UStack@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::push(icu_56::UStack *this, void *, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+1DFp
					; icu_56::initLanguageFactories(void)+164p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::UVector::addElement(void *,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::push(icu_56::UStack *this, int, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 583Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SymbolTable::SymbolTable(icu_56::SymbolTable *__hidden this)
		public ??0SymbolTable@icu_56@@QAE@XZ
??0SymbolTable@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0SymbolTable@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5874h
		dd offset ??_R4SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7SymbolTable@icu_56@@6B@
; const	icu_56::SymbolTable::`vftable'
??_7SymbolTable@icu_56@@6B@ dd offset ??_ESymbolTable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::SymbolTable::SymbolTable(void)+26o
					; icu_56::SymbolTable::SymbolTable(icu_56::SymbolTable const &)+26o
					; icu_56::SymbolTable::`vector deleting	destructor'(uint)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5888h
		public ??_R4SymbolTable@icu_56@@6B@
; const	icu_56::SymbolTable::`RTTI Complete Object Locator'
??_R4SymbolTable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00005874o
		dd offset ??_R0?AVSymbolTable@icu_56@@@8 ; icu_56::SymbolTable `RTTI Type Descriptor'
		dd offset ??_R3SymbolTable@icu_56@@8 ; icu_56::SymbolTable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 589Ch
		public ??_R0?AVSymbolTable@icu_56@@@8
; class	icu_56::SymbolTable `RTTI Type Descriptor'
??_R0?AVSymbolTable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00005894o
					; .rdata$r:icu_56::SymbolTable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avsymboltabl	db '.?AVSymbolTable@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 58C0h
		public ??_R3SymbolTable@icu_56@@8
; icu_56::SymbolTable::`RTTI Class Hierarchy Descriptor'
??_R3SymbolTable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00005898o
					; .rdata$r:000058F0o
		dd 1
		dd offset ??_R2SymbolTable@icu_56@@8 ; icu_56::SymbolTable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 58D0h
		public ??_R2SymbolTable@icu_56@@8
; icu_56::SymbolTable::`RTTI Base Class	Array'
??_R2SymbolTable@icu_56@@8 dd offset ??_R1A@?0A@EA@SymbolTable@icu_56@@8
					; DATA XREF: .rdata$r:000058CCo
					; icu_56::SymbolTable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 58D8h
		public ??_R1A@?0A@EA@SymbolTable@icu_56@@8
; icu_56::SymbolTable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@SymbolTable@icu_56@@8 dd offset ??_R0?AVSymbolTable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::SymbolTable::`RTTI Base Class Array'o
					; icu_56::SymbolTable `RTTI Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3SymbolTable@icu_56@@8 ; icu_56::SymbolTable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 58F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::SymbolTable::SymbolTable(icu_56::SymbolTable *this,	const struct icu_56::SymbolTable *)
		public ??0SymbolTable@icu_56@@QAE@ABV01@@Z
??0SymbolTable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7SymbolTable@icu_56@@6B@ ; const icu_56::SymbolTable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0SymbolTable@icu_56@@QAE@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 592Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::SymbolTable & __thiscall icu_56::SymbolTable::operator=(class icu_56::SymbolTable const	&)
		public ??4SymbolTable@icu_56@@QAEAAV01@ABV01@@Z
??4SymbolTable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4SymbolTable@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 595Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SymbolTable::`scalar deleting destructor'(unsigned int)
		public ??_GSymbolTable@icu_56@@UAEPAXI@Z
??_GSymbolTable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1SymbolTable@icu_56@@UAE@XZ ;	icu_56::SymbolTable::~SymbolTable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_599B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_599B:				; CODE XREF: icu_56::SymbolTable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GSymbolTable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::SymbolTable::`vector deleting destructor'(unsigned int)
		public ??_ESymbolTable@icu_56@@UAEPAXI@Z
??_ESymbolTable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::SymbolTable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_5A15
		push	offset ??1SymbolTable@icu_56@@UAE@XZ ; icu_56::SymbolTable::~SymbolTable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5A0D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_V@YAXPAX@Z	; operator delete[](void *)
		add	esp, 4

loc_5A0D:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_5A34
; ---------------------------------------------------------------------------

loc_5A15:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1SymbolTable@icu_56@@UAE@XZ ;	icu_56::SymbolTable::~SymbolTable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5A31
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3@YAXPAX@Z	; operator delete(void *)
		add	esp, 4

loc_5A31:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_5A34:				; CODE XREF: icu_56::SymbolTable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_ESymbolTable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::RuleBasedBreakIterator::getStaticClassID()
		public ?getStaticClassID@RuleBasedBreakIterator@icu_56@@SAPAXXZ
?getStaticClassID@RuleBasedBreakIterator@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@RuleBasedBreakIterator@icu_56@@SAPAXXZ@4DA ; char `icu_56::RuleBasedBreakIterator::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@RuleBasedBreakIterator@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::RuleBasedBreakIterator::getDynamicClassID(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?getDynamicClassID@RuleBasedBreakIterator@icu_56@@UBEPAXXZ
?getDynamicClassID@RuleBasedBreakIterator@icu_56@@UBEPAXXZ proc	near
					; DATA XREF: .rdata:00005C10o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@RuleBasedBreakIterator@icu_56@@SAPAXXZ ; icu_56::RuleBasedBreakIterator::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@RuleBasedBreakIterator@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5AB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *this, struct	icu_56::RBBIDataHeader *, enum UErrorCode *)
		public ??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z
??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@XZ	; icu_56::BreakIterator::BreakIterator(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		push	88h ; ''       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_5B51
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::RBBIDataHeader	*
		mov	ecx, [ebp+var_E0] ; this
		call	??0RBBIDataWrapper@icu_56@@QAE@PBURBBIDataHeader@1@AAW4UErrorCode@@@Z ;	icu_56::RBBIDataWrapper::RBBIDataWrapper(icu_56::RBBIDataHeader	const *,UErrorCode &)
		mov	[ebp+var_F4], eax
		jmp	short loc_5B5B
; ---------------------------------------------------------------------------

loc_5B51:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+80j
		mov	[ebp+var_F4], 0

loc_5B5B:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+9Bj
		mov	edx, [ebp+var_F4]
		mov	[ebp+var_EC], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+150h], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5B91
		jmp	short loc_5BA6
; ---------------------------------------------------------------------------

loc_5B91:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+D9j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jnz	short loc_5BA6
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7

loc_5BA6:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+DBj
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	*,UErrorCode &)+E7j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5BD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005C7Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00005C84o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5C08h
		dd offset ??_R4RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7RuleBasedBreakIterator@icu_56@@6B@
; const	icu_56::RuleBasedBreakIterator::`vftable'
??_7RuleBasedBreakIterator@icu_56@@6B@ dd offset ??_ERuleBasedBreakIterator@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+54o
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+54o ...
					; icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@RuleBasedBreakIterator@icu_56@@UBEPAXXZ ; icu_56::RuleBasedBreakIterator::getDynamicClassID(void)
		dd offset ??8RuleBasedBreakIterator@icu_56@@UBECABVBreakIterator@1@@Z ;	icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)
		dd offset ?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ ; icu_56::RuleBasedBreakIterator::clone(void)
		dd offset ?getText@RuleBasedBreakIterator@icu_56@@UBEAAVCharacterIterator@2@XZ ; icu_56::RuleBasedBreakIterator::getText(void)
		dd offset ?getUText@RuleBasedBreakIterator@icu_56@@UBEPAUUText@@PAU3@AAW4UErrorCode@@@Z	; icu_56::RuleBasedBreakIterator::getUText(UText *,UErrorCode &)
		dd offset ?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)
		dd offset ?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z ; icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)
		dd offset ?adoptText@RuleBasedBreakIterator@icu_56@@UAEXPAVCharacterIterator@2@@Z ; icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator	*)
		dd offset ?first@RuleBasedBreakIterator@icu_56@@UAEHXZ ; icu_56::RuleBasedBreakIterator::first(void)
		dd offset ?last@RuleBasedBreakIterator@icu_56@@UAEHXZ ;	icu_56::RuleBasedBreakIterator::last(void)
		dd offset ?previous@RuleBasedBreakIterator@icu_56@@UAEHXZ ; icu_56::RuleBasedBreakIterator::previous(void)
		dd offset ?next@RuleBasedBreakIterator@icu_56@@UAEHH@Z ; icu_56::RuleBasedBreakIterator::next(int)
		dd offset ?next@RuleBasedBreakIterator@icu_56@@UAEHXZ ;	icu_56::RuleBasedBreakIterator::next(void)
		dd offset ?current@RuleBasedBreakIterator@icu_56@@UBEHXZ ; icu_56::RuleBasedBreakIterator::current(void)
		dd offset ?following@RuleBasedBreakIterator@icu_56@@UAEHH@Z ; icu_56::RuleBasedBreakIterator::following(int)
		dd offset ?preceding@RuleBasedBreakIterator@icu_56@@UAEHH@Z ; icu_56::RuleBasedBreakIterator::preceding(int)
		dd offset ?isBoundary@RuleBasedBreakIterator@icu_56@@UAECH@Z ; icu_56::RuleBasedBreakIterator::isBoundary(int)
		dd offset ?getRuleStatus@RuleBasedBreakIterator@icu_56@@UBEHXZ ; icu_56::RuleBasedBreakIterator::getRuleStatus(void)
		dd offset ?getRuleStatusVec@RuleBasedBreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z ;	icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)
		dd offset ?createBufferClone@RuleBasedBreakIterator@icu_56@@UAEPAVBreakIterator@2@PAXAAHAAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)
		dd offset ?refreshInputText@RuleBasedBreakIterator@icu_56@@UAEAAV12@PAUUText@@AAW4UErrorCode@@@Z ; icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)
		dd offset ?hashCode@RuleBasedBreakIterator@icu_56@@UBEHXZ ; icu_56::RuleBasedBreakIterator::hashCode(void)
		dd offset ?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ ; icu_56::RuleBasedBreakIterator::getRules(void)
		dd offset ?getBinaryRules@RuleBasedBreakIterator@icu_56@@UAEPBEAAI@Z ; icu_56::RuleBasedBreakIterator::getBinaryRules(uint &)
		dd offset ?reset@RuleBasedBreakIterator@icu_56@@MAEXXZ ; icu_56::RuleBasedBreakIterator::reset(void)
		dd offset ?setBreakType@RuleBasedBreakIterator@icu_56@@MAEXH@Z ; icu_56::RuleBasedBreakIterator::setBreakType(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5C78h
__unwindtable$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005C90o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5CACh
		public ??_R4RuleBasedBreakIterator@icu_56@@6B@
; const	icu_56::RuleBasedBreakIterator::`RTTI Complete Object Locator'
??_R4RuleBasedBreakIterator@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:00005C08o
		dd offset ??_R0?AVRuleBasedBreakIterator@icu_56@@@8 ; icu_56::RuleBasedBreakIterator `RTTI Type	Descriptor'
		dd offset ??_R3RuleBasedBreakIterator@icu_56@@8	; icu_56::RuleBasedBreakIterator::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 5CC0h
		public ??_R0?AVRuleBasedBreakIterator@icu_56@@@8
; class	icu_56::RuleBasedBreakIterator `RTTI Type Descriptor'
??_R0?AVRuleBasedBreakIterator@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00005CB8o
					; .rdata$r:icu_56::RuleBasedBreakIterator::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avrulebasedb	db '.?AVRuleBasedBreakIterator@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5CECh
		public ??_R3RuleBasedBreakIterator@icu_56@@8
; icu_56::RuleBasedBreakIterator::`RTTI	Class Hierarchy	Descriptor'
??_R3RuleBasedBreakIterator@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:00005CBCo
					; .rdata$r:00005D28o
		dd 4
		dd offset ??_R2RuleBasedBreakIterator@icu_56@@8	; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5CFCh
		public ??_R2RuleBasedBreakIterator@icu_56@@8
; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Array'
??_R2RuleBasedBreakIterator@icu_56@@8 dd offset	??_R1A@?0A@EA@RuleBasedBreakIterator@icu_56@@8
					; DATA XREF: .rdata$r:00005CF8o
					; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@BreakIterator@icu_56@@8	; icu_56::BreakIterator::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 5D10h
		public ??_R1A@?0A@EA@RuleBasedBreakIterator@icu_56@@8
; icu_56::RuleBasedBreakIterator::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@RuleBasedBreakIterator@icu_56@@8 dd offset ??_R0?AVRuleBasedBreakIterator@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::RuleBasedBreakIterator::`RTTI Base Class Array'o
					; icu_56::RuleBasedBreakIterator `RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3RuleBasedBreakIterator@icu_56@@8	; icu_56::RuleBasedBreakIterator::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+CCp
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+CEp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5D58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: __thiscall	icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(struct icu_56::RBBIDataHeader const *, enum  icu_56::RuleBasedBreakIterator::EDontAdopt,	enum  UErrorCode &)
		public ??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z
??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@XZ	; icu_56::BreakIterator::BreakIterator(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		push	88h ; ''       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_5DF7
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_E0]
		call	??0RBBIDataWrapper@icu_56@@QAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z ;	icu_56::RBBIDataWrapper::RBBIDataWrapper(icu_56::RBBIDataHeader	const *,icu_56::RBBIDataWrapper::EDontAdopt,UErrorCode &)
		mov	[ebp+var_F4], eax
		jmp	short loc_5E01
; ---------------------------------------------------------------------------

loc_5DF7:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+80j
		mov	[ebp+var_F4], 0

loc_5E01:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+9Dj
		mov	edx, [ebp+var_F4]
		mov	[ebp+var_EC], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+150h], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5E37
		jmp	short loc_5E4C
; ---------------------------------------------------------------------------

loc_5E37:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+DBj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jnz	short loc_5E4C
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_5E4C:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+DDj
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+E9j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z endp ; sp-analysis	failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5E78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00005EB0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00005EB8o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5EACh
__unwindtable$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00005EC4o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z$0
		align 8
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@IAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5EE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *this, const unsigned	__int8 *, unsigned int,	enum UErrorCode	*)
		public ??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z
??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z proc near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@XZ	; icu_56::BreakIterator::BreakIterator(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5F5C
		jmp	loc_6027
; ---------------------------------------------------------------------------

loc_5F5C:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+75j
		cmp	[ebp+arg_0], 0
		jz	short loc_5F68
		cmp	[ebp+arg_4], 60h ; '`'
		jnb	short loc_5F76

loc_5F68:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+80j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_6027
; ---------------------------------------------------------------------------

loc_5F76:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+86j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_4]
		jbe	short loc_5F95
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_6027
; ---------------------------------------------------------------------------

loc_5F95:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+A5j
		push	88h ; ''       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_EC], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_5FD2
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	ecx, [ebp+var_EC]
		call	??0RBBIDataWrapper@icu_56@@QAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z ;	icu_56::RBBIDataWrapper::RBBIDataWrapper(icu_56::RBBIDataHeader	const *,icu_56::RBBIDataWrapper::EDontAdopt,UErrorCode &)
		mov	[ebp+var_100], eax
		jmp	short loc_5FDC
; ---------------------------------------------------------------------------

loc_5FD2:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+D3j
		mov	[ebp+var_100], 0

loc_5FDC:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+F0j
		mov	edx, [ebp+var_100]
		mov	[ebp+var_F8], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_F8]
		mov	[eax+150h], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6012
		jmp	short loc_6027
; ---------------------------------------------------------------------------

loc_6012:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+12Ej
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jnz	short loc_6027
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7

loc_6027:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+77j
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const *,uint,UErrorCode &)+91j ...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z endp ; sp-analysis	failed

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6054h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000608Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:00006094o
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const	*,uint,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6088h
__unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000060A0o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z$1
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z dd 19930522h,	2
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@PBEIAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *this, struct	UDataMemory *, enum UErrorCode *)
		public ??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z
??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z proc near

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@XZ	; icu_56::BreakIterator::BreakIterator(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		push	88h ; ''       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	byte ptr [ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_6159
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct UDataMemory *
		mov	ecx, [ebp+var_E0] ; this
		call	??0RBBIDataWrapper@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z ; icu_56::RBBIDataWrapper::RBBIDataWrapper(UDataMemory *,UErrorCode &)
		mov	[ebp+var_F4], eax
		jmp	short loc_6163
; ---------------------------------------------------------------------------

loc_6159:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory	*,UErrorCode &)+80j
		mov	[ebp+var_F4], 0

loc_6163:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory	*,UErrorCode &)+9Bj
		mov	edx, [ebp+var_F4]
		mov	[ebp+var_EC], edx
		mov	byte ptr [ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_EC]
		mov	[eax+150h], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6199
		jmp	short loc_61AE
; ---------------------------------------------------------------------------

loc_6199:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory	*,UErrorCode &)+D9j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jnz	short loc_61AE
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7

loc_61AE:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory	*,UErrorCode &)+DBj
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory *,UErrorCode &)+E7j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 61DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00006214o
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z$1 proc	near
					; DATA XREF: .xdata$x:0000621Co
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory	*,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6210h
__unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006228o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6244h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *this, const struct icu_56::UnicodeString *, struct UParseError *, enum UErrorCode *)
		public ??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z proc near

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@XZ	; icu_56::BreakIterator::BreakIterator(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_62C0
		jmp	loc_6345
; ---------------------------------------------------------------------------

loc_62C0:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+75j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		call	?createRuleBasedBreakIterator@RBBIRuleBuilder@icu_56@@SAPAVBreakIterator@2@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::RBBIRuleBuilder::createRuleBasedBreakIterator(icu_56::UnicodeString const &,UParseError *,UErrorCode	&)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6345
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		call	??4RuleBasedBreakIterator@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)
		mov	eax, [ebp+var_20]
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_F8], ecx
		cmp	[ebp+var_F8], 0
		jz	short loc_633B
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_F8]
		mov	eax, [edx]
		mov	ecx, [ebp+var_F8]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		jmp	short loc_6345
; ---------------------------------------------------------------------------

loc_633B:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+D0j
		mov	[ebp+var_100], 0

loc_6345:				; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+77j
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const &,UParseError &,UErrorCode	&)+A6j	...
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:0000639Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6398h
__unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000063A8o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@ABVUnicodeString@1@AAUUParseError@@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 63C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+99p
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+CFBp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 63F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *__hidden this)
		public ??0RuleBasedBreakIterator@icu_56@@QAE@XZ
??0RuleBasedBreakIterator@icu_56@@QAE@XZ proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@XZ	; icu_56::BreakIterator::BreakIterator(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0RuleBasedBreakIterator@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 647Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@XZ$0 proc	near
					; DATA XREF: .xdata$x:000064A8o
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 64A4h
__unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000064B4o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@XZ$0
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@XZ+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 64D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *this, const struct icu_56::RuleBasedBreakIterator *)
		public ??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z
??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::clone(void)+6Fp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::BreakIterator *
		mov	ecx, [ebp+var_14] ; this
		call	??0BreakIterator@icu_56@@IAE@ABV01@@Z ;	icu_56::BreakIterator::BreakIterator(icu_56::BreakIterator const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	ecx, [ebp+var_14] ; this
		call	?init@RuleBasedBreakIterator@icu_56@@IAEXXZ ; icu_56::RuleBasedBreakIterator::init(void)
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		call	??4RuleBasedBreakIterator@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:0000659Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z proc	near
					; DATA XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6598h
__unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:000065A8o
		dd offset __unwindfunclet$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 65C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator *__hidden this)
		public ??1RuleBasedBreakIterator@icu_56@@UAE@XZ
??1RuleBasedBreakIterator@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::`scalar deleting destructor'(uint)+26p
					; icu_56::RuleBasedBreakIterator::`vector deleting destructor'(uint)+67p
					; DATA XREF: ...

var_154		= dword	ptr -154h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1RuleBasedBreakIterator@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 148h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_154]
		mov	ecx, 52h ; 'R'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7RuleBasedBreakIterator@icu_56@@6B@ ; const icu_56::RuleBasedBreakIterator::`vftable'
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+148h]
		jz	short loc_6691
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+14Ch]
		jz	short loc_6691
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+144h]
		mov	[ebp+var_140], ecx
		mov	edx, [ebp+var_140]
		mov	[ebp+var_14C], edx
		cmp	[ebp+var_14C], 0
		jz	short loc_6687
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_14C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_14C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_154], eax
		jmp	short loc_6691
; ---------------------------------------------------------------------------

loc_6687:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+9Cj
		mov	[ebp+var_154], 0

loc_6691:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+64j
					; icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+78j ...
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+144h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+148h]
		mov	[ebp+var_128], ecx
		mov	edx, [ebp+var_128]
		mov	[ebp+var_134], edx
		cmp	[ebp+var_134], 0
		jz	short loc_66E7
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_134]
		mov	edx, [eax]
		mov	ecx, [ebp+var_134]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_154], eax
		jmp	short loc_66F1
; ---------------------------------------------------------------------------

loc_66E7:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+FCj
		mov	[ebp+var_154], 0

loc_66F1:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+121j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+144h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+14Ch]
		mov	[ebp+var_110], ecx
		mov	edx, [ebp+var_110]
		mov	[ebp+var_11C], edx
		cmp	[ebp+var_11C], 0
		jz	short loc_6747
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_11C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_11C]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_154], eax
		jmp	short loc_6751
; ---------------------------------------------------------------------------

loc_6747:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+15Cj
		mov	[ebp+var_154], 0

loc_6751:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+181j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14Ch], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_close_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_6797
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]	; this
		call	?removeReference@RBBIDataWrapper@icu_56@@QAEXXZ	; icu_56::RBBIDataWrapper::removeReference(void)
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+150h], 0

loc_6797:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+1B6j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+160h], 0
		jz	short loc_67C2
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+160h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+160h], 0

loc_67C2:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+1DDj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+16Ch], 0
		jz	short loc_682E
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+16Ch]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_6817
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_154], eax
		jmp	short loc_6821
; ---------------------------------------------------------------------------

loc_6817:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+22Cj
		mov	[ebp+var_154], 0

loc_6821:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+251j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0

loc_682E:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+208j
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+170h], 0
		jz	short loc_689A
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+170h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_6883
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_154], eax
		jmp	short loc_688D
; ---------------------------------------------------------------------------

loc_6883:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+298j
		mov	[ebp+var_154], 0

loc_688D:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+2BDj
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0

loc_689A:				; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+274j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 154h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1RuleBasedBreakIterator@icu_56@@UAE@XZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 68C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1RuleBasedBreakIterator@icu_56@@UAE@XZ$0 proc	near
					; DATA XREF: .xdata$x:000068F4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1BreakIterator@icu_56@@UAE@XZ	; icu_56::BreakIterator::~BreakIterator(void)
__unwindfunclet$??1RuleBasedBreakIterator@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1RuleBasedBreakIterator@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-158h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1RuleBasedBreakIterator@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1RuleBasedBreakIterator@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 68F0h
__unwindtable$??1RuleBasedBreakIterator@icu_56@@UAE@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00006900o
		dd offset __unwindfunclet$??1RuleBasedBreakIterator@icu_56@@UAE@XZ$0
__ehfuncinfo$??1RuleBasedBreakIterator@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1RuleBasedBreakIterator@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1RuleBasedBreakIterator@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 691Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::RuleBasedBreakIterator & __thiscall icu_56::RuleBasedBreakIterator::operator=(class icu_56::RuleBasedBreakIterator const &)
		public ??4RuleBasedBreakIterator@icu_56@@QAEAAV01@ABV01@@Z
??4RuleBasedBreakIterator@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+AFp
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator	const &)+6Dp

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_694F
		mov	eax, [ebp+var_8]
		jmp	loc_6B25
; ---------------------------------------------------------------------------

loc_694F:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+29j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+174h]
		mov	[eax+174h], edx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+16Ch], 0
		jz	short loc_69E3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+16Ch]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_69CC
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_104]
		mov	edx, [eax]
		mov	ecx, [ebp+var_104]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_69D6
; ---------------------------------------------------------------------------

loc_69CC:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+89j
		mov	[ebp+var_10C], 0

loc_69D6:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+AEj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+16Ch], 0

loc_69E3:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+65j
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax
		push	1
		push	0
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_clone_56
		add	esp, 14h
		mov	edx, [ebp+var_8]
		mov	[edx+140h], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+148h]
		jz	short loc_6A92
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+14Ch]
		jz	short loc_6A92
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+144h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_6A88
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_6A92
; ---------------------------------------------------------------------------

loc_6A88:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+145j
		mov	[ebp+var_10C], 0

loc_6A92:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+10Dj
					; icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+121j ...
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+144h], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+144h], 0
		jz	short loc_6AD8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+144h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+144h]
		mov	edx, [ecx]
		mov	esi, esp
		mov	ecx, eax
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_8]
		mov	[ecx+144h], eax

loc_6AD8:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+18Dj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_6AFF
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]	; this
		call	?removeReference@RBBIDataWrapper@icu_56@@QAEXXZ	; icu_56::RBBIDataWrapper::removeReference(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+150h], 0

loc_6AFF:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+1C6j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_6B22
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+150h]	; this
		call	?addReference@RBBIDataWrapper@icu_56@@QAEPAV12@XZ ; icu_56::RBBIDataWrapper::addReference(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+150h], eax

loc_6B22:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+1EDj
		mov	eax, [ebp+var_8]

loc_6B25:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+2Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4RuleBasedBreakIterator@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
$LN15		dd 1			; DATA XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+20Do
		dd offset $LN14
$LN14		dd 0FFFFFFECh, 4	; DATA XREF: .text:00006B50o
		dd offset $LN13		; "status"
$LN13		db 'status',0           ; DATA XREF: .text:00006B5Co
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::init(icu_56::RuleBasedBreakIterator *__hidden	this)
		public ?init@RuleBasedBreakIterator@icu_56@@IAEXXZ
?init@RuleBasedBreakIterator@icu_56@@IAEXXZ proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+5Dp
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+5Dp ...

var_E4		= byte ptr -0E4h
Str		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax
		push	0
		push	0
		push	0
		push	0
		call	_utext_openUChars_56
		add	esp, 14h
		mov	ecx, [ebp+var_8]
		mov	[ecx+140h], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+144h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+148h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+14Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+150h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+15Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+174h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+160h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+16Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+170h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+168h], 0
		movsx	eax, ds:?debugInitDone@?1??init@RuleBasedBreakIterator@icu_56@@IAEXXZ@4CA ; signed char	`icu_56::RuleBasedBreakIterator::init(void)'::`2'::debugInitDone
		test	eax, eax
		jnz	short loc_6CA3
		mov	esi, esp
		push	offset ??_C@_0M@NMJCIPMM@U_RBBIDEBUG?$AA@ ; "U_RBBIDEBUG"
		call	dword ptr ds:__imp__getenv
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+Str], eax
		cmp	[ebp+Str], 0
		jz	short loc_6C9C
		push	offset ??_C@_05IMBNNINJ@trace?$AA@ ; "trace"
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	?strstr@@YAPADPADPBD@Z ; strstr(char *,char const *)
		add	esp, 8
		test	eax, eax
		jz	short loc_6C9C
		mov	ds:_fTrace, 1

loc_6C9C:				; CODE XREF: icu_56::RuleBasedBreakIterator::init(void)+116j
					; icu_56::RuleBasedBreakIterator::init(void)+12Bj
		mov	ds:?debugInitDone@?1??init@RuleBasedBreakIterator@icu_56@@IAEXXZ@4CA, 1	; signed char `icu_56::RuleBasedBreakIterator::init(void)'::`2'::debugInitDone

loc_6CA3:				; CODE XREF: icu_56::RuleBasedBreakIterator::init(void)+F6j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?init@RuleBasedBreakIterator@icu_56@@IAEXXZ endp

; ---------------------------------------------------------------------------
$LN7		dd 1			; DATA XREF: icu_56::RuleBasedBreakIterator::init(void)+13Fo
		dd offset $LN6
$LN6		dd 0FFFFFFECh, 4	; DATA XREF: .text:00006CCCo
		dd offset $LN5		; "status"
$LN5		db 'status',0           ; DATA XREF: .text:00006CD8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6CE4h
		public ??_C@_05IMBNNINJ@trace?$AA@
; char `string'[]
??_C@_05IMBNNINJ@trace?$AA@ db 'trace',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::init(void)+118o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6CECh
		public ??_C@_0M@NMJCIPMM@U_RBBIDEBUG?$AA@
; char `string'[]
??_C@_0M@NMJCIPMM@U_RBBIDEBUG?$AA@ db 'U_RBBIDEBUG',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::init(void)+FAo
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6CF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; char *__cdecl	strstr(char *Str, const	char *SubStr)
		public ?strstr@@YAPADPADPBD@Z
?strstr@@YAPADPADPBD@Z proc near	; CODE XREF: icu_56::RuleBasedBreakIterator::init(void)+121p

var_C0		= byte ptr -0C0h
Str		= dword	ptr  8
SubStr		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+SubStr]
		push	eax		; SubStr
		mov	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strstr
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?strstr@@YAPADPADPBD@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6D44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::BreakIterator *__thiscall icu_56::RuleBasedBreakIterator::clone(icu_56::RuleBasedBreakIterator	*__hidden this)
		public ?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ
?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ proc near
					; DATA XREF: .rdata:00005C18o

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		push	178h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_6DC0
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::RuleBasedBreakIterator	*
		mov	ecx, [ebp+var_E0] ; this
		call	??0RuleBasedBreakIterator@icu_56@@QAE@ABV01@@Z ; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RuleBasedBreakIterator const &)
		mov	[ebp+var_F4], eax
		jmp	short loc_6DCA
; ---------------------------------------------------------------------------

loc_6DC0:				; CODE XREF: icu_56::RuleBasedBreakIterator::clone(void)+63j
		mov	[ebp+var_F4], 0

loc_6DCA:				; CODE XREF: icu_56::RuleBasedBreakIterator::clone(void)+7Aj
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_EC], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_EC]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 6E04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ$0 proc near
					; DATA XREF: .xdata$x:00006E34o
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ proc	near
					; DATA XREF: icu_56::RuleBasedBreakIterator::clone(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 6E30h
__unwindtable$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00006E40o
		dd offset __unwindfunclet$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ$0
__ehfuncinfo$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ+14o
		dd offset __unwindtable$?clone@RuleBasedBreakIterator@icu_56@@UBEPAVBreakIterator@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6E5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual signed char __thiscall icu_56::RuleBasedBreakIterator::operator==(class icu_56::BreakIterator	const &)const
		public ??8RuleBasedBreakIterator@icu_56@@UBECABVBreakIterator@1@@Z
??8RuleBasedBreakIterator@icu_56@@UBECABVBreakIterator@1@@Z proc near
					; DATA XREF: .rdata:00005C14o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	___RTtypeid
		add	esp, 4
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	___RTtypeid
		add	esp, 4
		mov	ecx, eax
		call	dword ptr ds:__imp_??9type_info@@QBE_NABV0@@Z ;	type_info::operator!=(type_info	const &)
		cmp	esi, esp
		call	__RTC_CheckEsp
		movzx	edx, al
		test	edx, edx
		jz	short loc_6EB4
		xor	al, al
		jmp	short loc_6F32
; ---------------------------------------------------------------------------

loc_6EB4:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+52j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_equals_56
		add	esp, 8
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_6EE1
		xor	al, al
		jmp	short loc_6F32
; ---------------------------------------------------------------------------

loc_6EE1:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+7Fj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+150h]
		cmp	edx, [ecx+150h]
		jz	short loc_6F2C
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_6F30
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_6F30
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+150h]
		call	??8RBBIDataWrapper@icu_56@@QBECABV01@@Z	; icu_56::RBBIDataWrapper::operator==(icu_56::RBBIDataWrapper const &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_6F30

loc_6F2C:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+97j
		mov	al, 1
		jmp	short loc_6F32
; ---------------------------------------------------------------------------

loc_6F30:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+A3j
					; icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+AFj ...
		xor	al, al

loc_6F32:				; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+56j
					; icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+83j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8RuleBasedBreakIterator@icu_56@@UBECABVBreakIterator@1@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::hashCode(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?hashCode@RuleBasedBreakIterator@icu_56@@UBEHXZ
?hashCode@RuleBasedBreakIterator@icu_56@@UBEHXZ	proc near ; DATA XREF: .rdata:00005C64o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_6F8F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]	; this
		call	?hashCode@RBBIDataWrapper@icu_56@@QAEHXZ ; icu_56::RBBIDataWrapper::hashCode(void)
		mov	[ebp+var_14], eax

loc_6F8F:				; CODE XREF: icu_56::RuleBasedBreakIterator::hashCode(void)+34j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@RuleBasedBreakIterator@icu_56@@UBEHXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::setText(icu_56::RuleBasedBreakIterator *this,	struct UText *,	enum UErrorCode	*)
		public ?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z
?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005C24o

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7004
		jmp	loc_7174
; ---------------------------------------------------------------------------

loc_7004:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+55j
		mov	eax, [ebp+var_14]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_clone_56
		add	esp, 14h
		mov	ecx, [ebp+var_14]
		mov	[ecx+140h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14Ch], 0
		jnz	loc_70D1
		push	18h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_708B
		push	0		; int
		push	offset ?c@?7??setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z@4_WB ; wchar_t *
		mov	ecx, [ebp+var_F8] ; this
		call	??0UCharCharacterIterator@icu_56@@QAE@PB_WH@Z ;	icu_56::UCharCharacterIterator::UCharCharacterIterator(wchar_t const *,int)
		mov	[ebp+var_10C], eax
		jmp	short loc_7095
; ---------------------------------------------------------------------------

loc_708B:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+C7j
		mov	[ebp+var_10C], 0

loc_7095:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+E1j
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_104]
		mov	[ecx+14Ch], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+14Ch], 0
		jnz	short loc_70D1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	loc_7174
; ---------------------------------------------------------------------------

loc_70D1:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+A3j
					; icu_56::RuleBasedBreakIterator::setText(UText	*,UErrorCode &)+119j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+148h]
		jz	short loc_714C
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+14Ch]
		jz	short loc_714C
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+144h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_7142
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_10C], eax
		jmp	short loc_714C
; ---------------------------------------------------------------------------

loc_7142:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+173j
		mov	[ebp+var_10C], 0

loc_714C:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+13Bj
					; icu_56::RuleBasedBreakIterator::setText(UText	*,UErrorCode &)+14Fj ...
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+14Ch]
		mov	[eax+144h], edx
		mov	eax, [ebp+var_14]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7174:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+57j
					; icu_56::RuleBasedBreakIterator::setText(UText	*,UErrorCode &)+124j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 7198h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:000071C8o
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 71C4h
__unwindtable$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000071D4o
		dd offset __unwindfunclet$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z$0
__ehfuncinfo$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?setText@RuleBasedBreakIterator@icu_56@@UAEXPAUUText@@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct UText *__thiscall icu_56::RuleBasedBreakIterator::getUText(icu_56::RuleBasedBreakIterator *this, struct UText *, enum UErrorCode *)
		public ?getUText@RuleBasedBreakIterator@icu_56@@UBEPAUUText@@PAU3@AAW4UErrorCode@@@Z
?getUText@RuleBasedBreakIterator@icu_56@@UBEPAUUText@@PAU3@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005C20o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		push	0
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_clone_56
		add	esp, 14h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getUText@RuleBasedBreakIterator@icu_56@@UBEPAUUText@@PAU3@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7250h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::RuleBasedBreakIterator::getRules(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ
?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ proc near
					; DATA XREF: .rdata:00005C68o

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_72B0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]	; this
		call	?getRuleSourceString@RBBIDataWrapper@icu_56@@QBEABVUnicodeString@2@XZ ;	icu_56::RBBIDataWrapper::getRuleSourceString(void)
		jmp	short loc_731A
; ---------------------------------------------------------------------------
		jmp	short loc_731A
; ---------------------------------------------------------------------------

loc_72B0:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+4Cj
		cmp	ds:?s@?6??getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@3@XZ@4PBV43@B, 0 ; icu_56::UnicodeString const * const `icu_56::RuleBasedBreakIterator::getRules(void)'::`7'::s
		jnz	short loc_7315
		push	40h ; '@'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_72EC
		mov	ecx, [ebp+var_E0] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	[ebp+var_F4], eax
		jmp	short loc_72F6
; ---------------------------------------------------------------------------

loc_72EC:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+87j
		mov	[ebp+var_F4], 0

loc_72F6:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+9Aj
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_EC]
		mov	ds:?s@?6??getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@3@XZ@4PBV43@B, ecx ; icu_56::UnicodeString const * const `icu_56::RuleBasedBreakIterator::getRules(void)'::`7'::s

loc_7315:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+67j
		mov	eax, ds:?s@?6??getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@3@XZ@4PBV43@B ; icu_56::UnicodeString const * const `icu_56::RuleBasedBreakIterator::getRules(void)'::`7'::s

loc_731A:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+5Cj
					; icu_56::RuleBasedBreakIterator::getRules(void)+5Ej
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 733Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ$0 proc near
					; DATA XREF: .xdata$x:0000736Co
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::getRules(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7368h
__unwindtable$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007378o
		dd offset __unwindfunclet$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ$0
__ehfuncinfo$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ+14o
		dd offset __unwindtable$?getRules@RuleBasedBreakIterator@icu_56@@UBEABVUnicodeString@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7394h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::CharacterIterator *__thiscall icu_56::RuleBasedBreakIterator::getText(icu_56::RuleBasedBreakIterator *__hidden	this)
		public ?getText@RuleBasedBreakIterator@icu_56@@UBEAAVCharacterIterator@2@XZ
?getText@RuleBasedBreakIterator@icu_56@@UBEAAVCharacterIterator@2@XZ proc near
					; DATA XREF: .rdata:00005C1Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+144h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getText@RuleBasedBreakIterator@icu_56@@UBEAAVCharacterIterator@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::adoptText(icu_56::RuleBasedBreakIterator *this, struct icu_56::CharacterIterator *)
		public ?adoptText@RuleBasedBreakIterator@icu_56@@UAEXPAVCharacterIterator@2@@Z
?adoptText@RuleBasedBreakIterator@icu_56@@UAEXPAVCharacterIterator@2@@Z	proc near
					; DATA XREF: .rdata:00005C2Co

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+148h]
		jz	short loc_7466
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+14Ch]
		jz	short loc_7466
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+144h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_745C
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_EC]
		mov	edx, [eax]
		mov	ecx, [ebp+var_EC]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F4], eax
		jmp	short loc_7466
; ---------------------------------------------------------------------------

loc_745C:				; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+6Dj
		mov	[ebp+var_F4], 0

loc_7466:				; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+35j
					; icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+49j ...
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+144h], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+arg_0], 0
		jz	short loc_74A1
		mov	ecx, [ebp+arg_0] ; this
		call	?startIndex@CharacterIterator@icu_56@@QBEHXZ ; icu_56::CharacterIterator::startIndex(void)
		test	eax, eax
		jz	short loc_74C8

loc_74A1:				; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+CBj
		lea	eax, [ebp+var_14]
		push	eax
		push	0
		push	0
		push	0
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		call	_utext_openUChars_56
		add	esp, 14h
		mov	ecx, [ebp+var_8]
		mov	[ecx+140h], eax
		jmp	short loc_74EB
; ---------------------------------------------------------------------------

loc_74C8:				; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+D7j
		lea	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_openCharacterIterator_56
		add	esp, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx+140h], eax

loc_74EB:				; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+FEj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?adoptText@RuleBasedBreakIterator@icu_56@@UAEXPAVCharacterIterator@2@@Z	endp

; ---------------------------------------------------------------------------
$LN11		dd 1			; DATA XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+13Do
		dd offset $LN10
$LN10		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000752Co
		dd offset $LN9		; "status"
$LN9		db 'status',0           ; DATA XREF: .text:00007538o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7544h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::setText(icu_56::RuleBasedBreakIterator *this,	const struct icu_56::UnicodeString *)
		public ?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z
?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z proc near
					; DATA XREF: .rdata:00005C28o

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_14]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_openConstUnicodeString_56
		add	esp, 0Ch
		mov	ecx, [ebp+var_14]
		mov	[ecx+140h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+148h], 0
		jnz	short loc_7637
		push	58h ; 'X'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_7609
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_104] ; this
		call	??0StringCharacterIterator@icu_56@@QAE@ABVUnicodeString@1@@Z ; icu_56::StringCharacterIterator::StringCharacterIterator(icu_56::UnicodeString const &)
		mov	[ebp+var_118], eax
		jmp	short loc_7613
; ---------------------------------------------------------------------------

loc_7609:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+ACj
		mov	[ebp+var_118], 0

loc_7613:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+C3j
		mov	ecx, [ebp+var_118]
		mov	[ebp+var_110], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_110]
		mov	[edx+148h], eax
		jmp	short loc_7649
; ---------------------------------------------------------------------------

loc_7637:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+8Cj
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+148h]	; this
		call	?setText@StringCharacterIterator@icu_56@@QAEXABVUnicodeString@2@@Z ; icu_56::StringCharacterIterator::setText(icu_56::UnicodeString const &)

loc_7649:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+F1j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+148h]
		jz	short loc_76C4
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+144h]
		cmp	edx, [ecx+14Ch]
		jz	short loc_76C4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+144h]
		mov	[ebp+var_EC], ecx
		mov	edx, [ebp+var_EC]
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jz	short loc_76BA
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_F8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_F8]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		jmp	short loc_76C4
; ---------------------------------------------------------------------------

loc_76BA:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+14Fj
		mov	[ebp+var_118], 0

loc_76C4:				; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+117j
					; icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString	const &)+12Bj ...
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+148h]
		mov	[eax+144h], edx
		mov	eax, [ebp+var_14]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN14_0		dd 1			; DATA XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+1ACo
		dd offset $LN13_0
$LN13_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00007724o
		dd offset $LN11_0	; "status"
$LN11_0		db 'status',0           ; DATA XREF: .text:00007730o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 773Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z$0 proc near
					; DATA XREF: .xdata$x:0000776Co
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 7768h
__unwindtable$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00007778o
		dd offset __unwindfunclet$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z$0
__ehfuncinfo$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z+14o
		dd offset __unwindtable$?setText@RuleBasedBreakIterator@icu_56@@UAEXABVUnicodeString@2@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7794h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::RuleBasedBreakIterator	*__thiscall icu_56::RuleBasedBreakIterator::refreshInputText(icu_56::RuleBasedBreakIterator *this, struct UText	*, enum	UErrorCode *)
		public ?refreshInputText@RuleBasedBreakIterator@icu_56@@UAEAAV12@PAUUText@@AAW4UErrorCode@@@Z
?refreshInputText@RuleBasedBreakIterator@icu_56@@UAEAAV12@PAUUText@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005C60o

var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_77D4
		mov	eax, [ebp+var_8]
		jmp	loc_789E
; ---------------------------------------------------------------------------

loc_77D4:				; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+36j
		cmp	[ebp+arg_0], 0
		jnz	short loc_77EB
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+var_8]
		jmp	loc_789E
; ---------------------------------------------------------------------------

loc_77EB:				; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+44j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_clone_56
		add	esp, 14h
		mov	ecx, [ebp+var_8]
		mov	[ecx+140h], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7844
		mov	eax, [ebp+var_8]
		jmp	short loc_789E
; ---------------------------------------------------------------------------

loc_7844:				; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+A9j
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+var_E4], eax
		mov	[ebp+var_E0], edx
		mov	edx, [ebp+var_E4]
		cmp	edx, [ebp+var_18]
		jnz	short loc_7892
		mov	eax, [ebp+var_E0]
		cmp	eax, [ebp+var_14]
		jz	short loc_789B

loc_7892:				; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+F1j
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1

loc_789B:				; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+FCj
		mov	eax, [ebp+var_8]

loc_789E:				; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+3Bj
					; icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+52j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?refreshInputText@RuleBasedBreakIterator@icu_56@@UAEAAV12@PAUUText@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::first(icu_56::RuleBasedBreakIterator *__hidden	this)
		public ?first@RuleBasedBreakIterator@icu_56@@UAEHXZ
?first@RuleBasedBreakIterator@icu_56@@UAEHXZ proc near ; DATA XREF: .rdata:00005C30o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 1
		push	0
		push	0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?first@RuleBasedBreakIterator@icu_56@@UAEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7930h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::last(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?last@RuleBasedBreakIterator@icu_56@@UAEHXZ
?last@RuleBasedBreakIterator@icu_56@@UAEHXZ proc near ;	DATA XREF: .rdata:00005C34o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+140h], 0
		jnz	short loc_7991
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 1
		or	eax, 0FFFFFFFFh
		jmp	short loc_79CB
; ---------------------------------------------------------------------------

loc_7991:				; CODE XREF: icu_56::RuleBasedBreakIterator::last(void)+43j
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_14]

loc_79CB:				; CODE XREF: icu_56::RuleBasedBreakIterator::last(void)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?last@RuleBasedBreakIterator@icu_56@@UAEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 79E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::next(icu_56::RuleBasedBreakIterator *this, int)
		public ?next@RuleBasedBreakIterator@icu_56@@UAEHH@Z
?next@RuleBasedBreakIterator@icu_56@@UAEHH@Z proc near ; DATA XREF: .rdata:00005C3Co

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax

loc_7A1C:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(int)+64j
		cmp	[ebp+arg_0], 0
		jle	short loc_7A46
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		mov	[ebp+arg_0], eax
		jmp	short loc_7A1C
; ---------------------------------------------------------------------------

loc_7A46:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(int)+40j
					; icu_56::RuleBasedBreakIterator::next(int)+8Ej
		cmp	[ebp+arg_0], 0
		jge	short loc_7A70
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		jmp	short loc_7A46
; ---------------------------------------------------------------------------

loc_7A70:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(int)+6Aj
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?next@RuleBasedBreakIterator@icu_56@@UAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::next(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?next@RuleBasedBreakIterator@icu_56@@UAEHXZ
?next@RuleBasedBreakIterator@icu_56@@UAEHXZ proc near ;	DATA XREF: .rdata:00005C40o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+160h], 0
		jz	short loc_7B34
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		cmp	[edx+168h], ecx
		jge	short loc_7B1E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+168h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	ecx, [eax+ecx*4]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_14]
		jmp	short loc_7B96
; ---------------------------------------------------------------------------
		jmp	short loc_7B34
; ---------------------------------------------------------------------------

loc_7B1E:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(void)+44j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7B34:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(void)+2Dj
					; icu_56::RuleBasedBreakIterator::next(void)+90j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+15Ch], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+4]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ;	icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const	*)
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+15Ch], 0
		jbe	short loc_7B93
		push	0		; signed __int8
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z ; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)
		mov	[ebp+var_2C], eax

loc_7B93:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(void)+F0j
		mov	eax, [ebp+var_2C]

loc_7B96:				; CODE XREF: icu_56::RuleBasedBreakIterator::next(void)+8Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?next@RuleBasedBreakIterator@icu_56@@UAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7BACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::previous(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?previous@RuleBasedBreakIterator@icu_56@@UAEHXZ
?previous@RuleBasedBreakIterator@icu_56@@UAEHXZ	proc near ; DATA XREF: .rdata:00005C38o

var_128		= dword	ptr -128h
var_124		= dword	ptr -124h
var_59		= byte ptr -59h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 128h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_128]
		mov	ecx, 4Ah ; 'J'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+160h], 0
		jz	loc_7C66
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+168h], 0
		jle	short loc_7C50
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+168h], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+168h], 0
		jg	short loc_7C16
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 0

loc_7C16:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+5Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	ecx, [eax+ecx*4]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_2C]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_2C]
		jmp	loc_7E78
; ---------------------------------------------------------------------------
		jmp	short loc_7C66
; ---------------------------------------------------------------------------

loc_7C50:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+3Dj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7C66:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+2Dj
					; icu_56::RuleBasedBreakIterator::previous(void)+A2j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+140h], 0
		jz	short loc_7C91
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_7CB0

loc_7C91:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+C4j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 1
		or	eax, 0FFFFFFFFh
		jmp	loc_7E78
; ---------------------------------------------------------------------------

loc_7CB0:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+E3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		cmp	dword ptr [ecx+10h], 0
		jnz	short loc_7CCE
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		cmp	dword ptr [ecx+0Ch], 0
		jz	short loc_7D0F

loc_7CCE:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+111j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+8]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const	*)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+15Ch], 0
		jbe	short loc_7D07
		push	1		; signed __int8
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z ; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)
		mov	[ebp+var_14], eax

loc_7D07:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+144j
		mov	eax, [ebp+var_14]
		jmp	loc_7E78
; ---------------------------------------------------------------------------

loc_7D0F:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+120j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_7DA0
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_7DA0
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_124], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_124]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_124]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_128], edx
		jmp	short loc_7DB8
; ---------------------------------------------------------------------------

loc_7DA0:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+189j
					; icu_56::RuleBasedBreakIterator::previous(void)+1ADj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_128], eax

loc_7DB8:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+1F2j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+8]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const	*)
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0FFFFFFFFh
		jnz	short loc_7DF3
		mov	[ebp+var_44], 0
		push	0
		push	0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_7DF3:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+228j
		mov	eax, [ebp+var_44]
		mov	[ebp+var_14], eax
		mov	[ebp+var_50], 0
		mov	[ebp+var_59], 0

loc_7E04:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+297j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0FFFFFFFFh
		jz	short loc_7E2B
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jl	short loc_7E2D

loc_7E2B:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+275j
		jmp	short loc_7E45
; ---------------------------------------------------------------------------

loc_7E2D:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+27Dj
		mov	eax, [ebp+var_14]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+154h]
		mov	[ebp+var_50], ecx
		mov	[ebp+var_59], 1
		jmp	short loc_7E04
; ---------------------------------------------------------------------------

loc_7E45:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void):loc_7E2Bj
		mov	eax, [ebp+var_44]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_50]
		mov	[eax+154h], ecx
		mov	eax, [ebp+var_8]
		mov	cl, [ebp+var_59]
		mov	[eax+158h], cl
		mov	eax, [ebp+var_44]

loc_7E78:				; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+9Dj
					; icu_56::RuleBasedBreakIterator::previous(void)+FFj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 128h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?previous@RuleBasedBreakIterator@icu_56@@UAEHXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::following(icu_56::RuleBasedBreakIterator *this, int)
		public ?following@RuleBasedBreakIterator@icu_56@@UAEHH@Z
?following@RuleBasedBreakIterator@icu_56@@UAEHH@Z proc near ; DATA XREF: .rdata:00005C48o

var_124		= dword	ptr -124h
var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+140h], 0
		jz	short loc_7F0B
		mov	eax, [ebp+arg_0]
		cdq
		mov	esi, eax
		mov	edi, edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_11C], esi
		mov	[ebp+var_118], edi
		mov	[ebp+var_124], eax
		mov	[ebp+var_120], edx
		mov	edx, [ebp+var_118]
		cmp	edx, [ebp+var_120]
		jl	short loc_7F3E
		jg	short loc_7F0B
		mov	eax, [ebp+var_11C]
		cmp	eax, [ebp+var_124]
		jb	short loc_7F3E

loc_7F0B:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+2Dj
					; icu_56::RuleBasedBreakIterator::following(int)+6Fj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+28h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_838B
; ---------------------------------------------------------------------------
		jmp	short loc_7F5F
; ---------------------------------------------------------------------------

loc_7F3E:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+6Dj
					; icu_56::RuleBasedBreakIterator::following(int)+7Dj
		cmp	[ebp+arg_0], 0
		jge	short loc_7F5F
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_838B
; ---------------------------------------------------------------------------

loc_7F5F:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+B0j
					; icu_56::RuleBasedBreakIterator::following(int)+B6j
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+160h], 0
		jz	loc_8059
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+160h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [ecx]
		jl	loc_8043
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [eax+ecx*4-4]
		jge	short loc_8043
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+168h], 0

loc_7FD8:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+17Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [eax+ecx*4]
		jl	short loc_8009
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		add	ecx, 1

loc_7FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		mov	edx, [ebp+var_8]
		mov	[edx+168h], ecx
		jmp	short loc_7FD8
; ---------------------------------------------------------------------------

loc_8009:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+164j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	ecx, [eax+ecx*4]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_14]
		jmp	loc_838B
; ---------------------------------------------------------------------------
		jmp	short loc_8059
; ---------------------------------------------------------------------------

loc_8043:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+11Ej
					; icu_56::RuleBasedBreakIterator::following(int)+13Dj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8059:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+10Aj
					; icu_56::RuleBasedBreakIterator::following(int)+1B5j
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		cmp	dword ptr [ecx+10h], 0
		jz	loc_8178
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+2Ch]
		jge	short loc_8107
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2]
		cmp	eax, 0D800h
		jge	short loc_8107
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+28h]
		mov	ecx, [edx+30h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_118], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+28h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	[ecx+28h], edx
		jmp	short loc_811F
; ---------------------------------------------------------------------------

loc_8107:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+217j
					; icu_56::RuleBasedBreakIterator::following(int)+23Aj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_118], eax

loc_811F:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+279j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+10h]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const	*)
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax

loc_814D:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+2E2j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_0]
		jg	short loc_8170
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax
		jmp	short loc_814D
; ---------------------------------------------------------------------------

loc_8170:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+2C7j
		mov	eax, [ebp+var_2C]
		jmp	loc_838B
; ---------------------------------------------------------------------------

loc_8178:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+1E1j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		cmp	dword ptr [ecx+0Ch], 0
		jz	loc_82DE
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_821B
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_821B
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_118], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_118]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_118]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_11C], edx
		jmp	short loc_8233
; ---------------------------------------------------------------------------

loc_821B:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+324j
					; icu_56::RuleBasedBreakIterator::following(int)+348j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_11C], eax

loc_8233:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+38Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+0Ch]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ;	icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const	*)
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax

loc_8261:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+40Cj
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_0]
		jle	short loc_829A
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+arg_0]
		jg	short loc_8292
		mov	eax, [ebp+var_38]
		jmp	loc_838B
; ---------------------------------------------------------------------------

loc_8292:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+3FCj
		mov	eax, [ebp+var_44]
		mov	[ebp+var_38], eax
		jmp	short loc_8261
; ---------------------------------------------------------------------------

loc_829A:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+3DBj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+arg_0]
		jg	short loc_82D6
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_838B
; ---------------------------------------------------------------------------

loc_82D6:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+42Dj
		mov	eax, [ebp+var_50]
		jmp	loc_838B
; ---------------------------------------------------------------------------

loc_82DE:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+2F9j
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		cmp	[ebp+arg_0], 0
		jz	short loc_832E
		cmp	[ebp+arg_0], 1
		jnz	short loc_8346
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+var_11C], eax
		mov	[ebp+var_118], edx
		mov	edx, [ebp+var_11C]
		or	edx, [ebp+var_118]
		jnz	short loc_8346

loc_832E:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+46Ej
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_838B
; ---------------------------------------------------------------------------

loc_8346:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+474j
					; icu_56::RuleBasedBreakIterator::following(int)+4A0j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax

loc_835F:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+4FAj
		cmp	[ebp+var_20], 0FFFFFFFFh
		jz	short loc_8388
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_0]
		jg	short loc_8388
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		jmp	short loc_835F
; ---------------------------------------------------------------------------

loc_8388:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+4D7j
					; icu_56::RuleBasedBreakIterator::following(int)+4DFj
		mov	eax, [ebp+var_20]

loc_838B:				; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+ABj
					; icu_56::RuleBasedBreakIterator::following(int)+CEj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?following@RuleBasedBreakIterator@icu_56@@UAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::preceding(icu_56::RuleBasedBreakIterator *this, int)
		public ?preceding@RuleBasedBreakIterator@icu_56@@UAEHH@Z
?preceding@RuleBasedBreakIterator@icu_56@@UAEHH@Z proc near ; DATA XREF: .rdata:00005C4Co

var_118		= dword	ptr -118h
var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 118h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_118]
		mov	ecx, 46h ; 'F'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+140h], 0
		jz	short loc_8423
		mov	eax, [ebp+arg_0]
		cdq
		mov	esi, eax
		mov	edi, edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_110], esi
		mov	[ebp+var_10C], edi
		mov	[ebp+var_118], eax
		mov	[ebp+var_114], edx
		mov	edx, [ebp+var_10C]
		cmp	edx, [ebp+var_114]
		jl	short loc_8440
		jg	short loc_8423
		mov	eax, [ebp+var_110]
		cmp	eax, [ebp+var_118]
		jbe	short loc_8440

loc_8423:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+2Dj
					; icu_56::RuleBasedBreakIterator::preceding(int)+6Fj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+28h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_8A54
; ---------------------------------------------------------------------------
		jmp	short loc_8461
; ---------------------------------------------------------------------------

loc_8440:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+6Dj
					; icu_56::RuleBasedBreakIterator::preceding(int)+7Dj
		cmp	[ebp+arg_0], 0
		jge	short loc_8461
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_8A54
; ---------------------------------------------------------------------------

loc_8461:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+9Aj
					; icu_56::RuleBasedBreakIterator::preceding(int)+A0j
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+160h], 0
		jz	loc_85AA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+160h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [ecx]
		jle	loc_8594
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+164h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [eax+ecx*4-4]
		jg	loc_8594
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+168h], 0

loc_84DE:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+17Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+168h]
		cmp	edx, [ecx+164h]
		jge	short loc_8523
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	edx, [ebp+arg_0]
		cmp	edx, [eax+ecx*4]
		jle	short loc_8523
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+168h], ecx
		jmp	short loc_84DE
; ---------------------------------------------------------------------------

loc_8523:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+14Cj
					; icu_56::RuleBasedBreakIterator::preceding(int)+166j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+168h], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+168h], 0
		jg	short loc_854E
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 0

loc_854E:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+19Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	eax, [eax+ecx*4]
		cdq
		push	edx
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+168h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+160h]
		mov	eax, [eax+ecx*4]
		jmp	loc_8A54
; ---------------------------------------------------------------------------
		jmp	short loc_85AA
; ---------------------------------------------------------------------------

loc_8594:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+108j
					; icu_56::RuleBasedBreakIterator::preceding(int)+127j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_85AA:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+F4j
					; icu_56::RuleBasedBreakIterator::preceding(int)+1EEj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		cmp	dword ptr [ecx+0Ch], 0
		jz	loc_88C5
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_8619
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		jmp	short loc_864C
; ---------------------------------------------------------------------------

loc_8619:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+249j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx

loc_864C:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+273j
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jz	loc_8775
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+2Ch]
		jge	short loc_86DD
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2]
		cmp	eax, 0D800h
		jge	short loc_86DD
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+28h]
		mov	ecx, [edx+30h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+28h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	[ecx+28h], edx
		jmp	short loc_86F5
; ---------------------------------------------------------------------------

loc_86DD:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+2D5j
					; icu_56::RuleBasedBreakIterator::preceding(int)+2F8j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_10C], eax

loc_86F5:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+337j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_8739
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		jmp	short loc_876C
; ---------------------------------------------------------------------------

loc_8739:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+369j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx

loc_876C:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+393j
		mov	ecx, [ebp+var_110]
		mov	[ebp+arg_0], ecx

loc_8775:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+2B7j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_87ED
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_87ED
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_10C], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_10C]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_10C]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_110], edx
		jmp	short loc_8805
; ---------------------------------------------------------------------------

loc_87ED:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+3DEj
					; icu_56::RuleBasedBreakIterator::preceding(int)+402j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_110], eax

loc_8805:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+447j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+0Ch]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ;	icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const	*)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_885E
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		jmp	short loc_8891
; ---------------------------------------------------------------------------

loc_885E:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+48Ej
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx

loc_8891:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+4B8j
		mov	ecx, [ebp+var_110]
		mov	[ebp+var_20], ecx

loc_889A:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+517j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_0]
		jl	short loc_88BD
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		jmp	short loc_889A
; ---------------------------------------------------------------------------

loc_88BD:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+4FCj
		mov	eax, [ebp+var_20]
		jmp	loc_8A54
; ---------------------------------------------------------------------------

loc_88C5:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+213j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		cmp	dword ptr [ecx+10h], 0
		jz	loc_8A26
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+2Ch]
		jge	short loc_896C
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2]
		cmp	eax, 0D800h
		jge	short loc_896C
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+28h]
		mov	ecx, [edx+30h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+28h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	[ecx+28h], edx
		jmp	short loc_8984
; ---------------------------------------------------------------------------

loc_896C:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+564j
					; icu_56::RuleBasedBreakIterator::preceding(int)+587j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_10C], eax

loc_8984:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+5C6j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+10h]
		push	edx		; struct icu_56::RBBIStateTable	*
		mov	ecx, [ebp+var_8] ; this
		call	?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z ; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const	*)
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_2C], eax

loc_89B2:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+642j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_0]
		jge	short loc_89E8
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_0]
		jl	short loc_89E0
		mov	eax, [ebp+var_2C]
		jmp	short loc_8A54
; ---------------------------------------------------------------------------

loc_89E0:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+635j
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax
		jmp	short loc_89B2
; ---------------------------------------------------------------------------

loc_89E8:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+614j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+arg_0]
		jl	short loc_8A21
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_8A54
; ---------------------------------------------------------------------------

loc_8A21:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+663j
		mov	eax, [ebp+var_44]
		jmp	short loc_8A54
; ---------------------------------------------------------------------------

loc_8A26:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+52Ej
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8A54:				; CODE XREF: icu_56::RuleBasedBreakIterator::preceding(int)+95j
					; icu_56::RuleBasedBreakIterator::preceding(int)+B8j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?preceding@RuleBasedBreakIterator@icu_56@@UAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::RuleBasedBreakIterator::isBoundary(icu_56::RuleBasedBreakIterator *this, int)
		public ?isBoundary@RuleBasedBreakIterator@icu_56@@UAECH@Z
?isBoundary@RuleBasedBreakIterator@icu_56@@UAECH@Z proc	near ; DATA XREF: .rdata:00005C50o

var_F4		= dword	ptr -0F4h
var_F0		= dword	ptr -0F0h
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_8AB2
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, 1
		jmp	loc_8C34
; ---------------------------------------------------------------------------

loc_8AB2:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+27j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_nativeLength_56
		add	esp, 4
		cmp	[ebp+arg_0], eax
		jnz	short loc_8AE6
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+28h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, 1
		jmp	loc_8C34
; ---------------------------------------------------------------------------

loc_8AE6:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+5Bj
		cmp	[ebp+arg_0], 0
		jge	short loc_8B09
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_8C34
; ---------------------------------------------------------------------------

loc_8B09:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+7Ej
		mov	eax, [ebp+arg_0]
		cdq
		mov	esi, eax
		mov	edi, edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_EC], esi
		mov	[ebp+var_E8], edi
		mov	[ebp+var_F4], eax
		mov	[ebp+var_F0], edx
		mov	edx, [ebp+var_E8]
		cmp	edx, [ebp+var_F0]
		jl	short loc_8B76
		jg	short loc_8B59
		mov	eax, [ebp+var_EC]
		cmp	eax, [ebp+var_F4]
		jbe	short loc_8B76

loc_8B59:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+DDj
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+28h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		xor	al, al
		jmp	loc_8C34
; ---------------------------------------------------------------------------

loc_8B76:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+DBj
					; icu_56::RuleBasedBreakIterator::isBoundary(int)+EBj
		mov	eax, [ebp+arg_0]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32From_56
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_8BD2
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_E8], edx
		jmp	short loc_8C05
; ---------------------------------------------------------------------------

loc_8BD2:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+13Aj
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_EC], eax
		mov	[ebp+var_E8], edx

loc_8C05:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+164j
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_14], ecx
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+3Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	eax, [ebp+arg_0]
		setz	cl
		mov	[ebp+var_1D], cl
		mov	al, [ebp+var_1D]

loc_8C34:				; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+41j
					; icu_56::RuleBasedBreakIterator::isBoundary(int)+75j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isBoundary@RuleBasedBreakIterator@icu_56@@UAECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::current(icu_56::RuleBasedBreakIterator	*__hidden this)
		public ?current@RuleBasedBreakIterator@icu_56@@UBEHXZ
?current@RuleBasedBreakIterator@icu_56@@UBEHXZ proc near ; DATA	XREF: .rdata:00005C44o

var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E0]
		mov	ecx, 38h ; '8'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_8CB3
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_E0], eax
		mov	[ebp+var_DC], edx
		jmp	short loc_8CE6
; ---------------------------------------------------------------------------

loc_8CB3:				; CODE XREF: icu_56::RuleBasedBreakIterator::current(void)+3Bj
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E0], eax
		mov	[ebp+var_DC], edx

loc_8CE6:				; CODE XREF: icu_56::RuleBasedBreakIterator::current(void)+65j
		mov	ecx, [ebp+var_E0]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?current@RuleBasedBreakIterator@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::handleNext(icu_56::RuleBasedBreakIterator *this, const	struct icu_56::RBBIStateTable *)
		public ?handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z
?handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::next(void)+DEp
					; icu_56::RuleBasedBreakIterator::following(int)+3B7p ...

var_1C4		= dword	ptr -1C4h
var_1C0		= dword	ptr -1C0h
var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_D8		= dword	ptr -0D8h
var_CC		= dword	ptr -0CCh
var_C8		= dword	ptr -0C8h
var_BC		= dword	ptr -0BCh
var_B0		= word ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_89		= byte ptr -89h
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 1C4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1C4]
		mov	ecx, 71h ; 'q'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		mov	[ebp+var_20], ax
		mov	[ebp+var_50], 0
		mov	[ebp+var_5C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_74], 0
		mov	[ebp+var_80], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 1
		setnz	dl
		mov	[ebp+var_89], dl
		mov	eax, [ebp+arg_0]
		add	eax, 10h
		mov	[ebp+var_98], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_A4], ecx
		movsx	eax, ds:_fTrace
		test	eax, eax
		jz	short loc_8DA0
		mov	esi, esp
		push	offset ??_C@_0CJ@PLMEEDH@Handle?5Next?5?5?5pos?5?5?5char?5?5state?5@ ; "Handle Next   pos   char  state	categor"...
		call	dword ptr ds:__imp__puts
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8DA0:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+7Fj
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 1
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_8DFB
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		jmp	short loc_8E2E
; ---------------------------------------------------------------------------

loc_8DFB:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+C7j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx

loc_8E2E:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+F1j
		mov	ecx, [ebp+var_1C4]
		mov	[ebp+var_74], ecx
		mov	eax, [ebp+var_74]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+2Ch]
		jge	short loc_8EB9
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2]
		cmp	eax, 0D800h
		jge	short loc_8EB9
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+28h]
		mov	ecx, [edx+30h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_1C0], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+28h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	[ecx+28h], edx
		jmp	short loc_8ED1
; ---------------------------------------------------------------------------

loc_8EB9:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+14Dj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+170j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_1C0], eax

loc_8ED1:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+1AFj
		mov	ecx, [ebp+var_1C0]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_8EEC
		cmp	[ebp+var_44], 0FFFFFFFFh
		jnz	short loc_8EF4

loc_8EEC:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+1DCj
		or	eax, 0FFFFFFFFh
		jmp	loc_9795
; ---------------------------------------------------------------------------

loc_8EF4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+1E2j
		mov	[ebp+var_14], 1
		mov	eax, [ebp+var_A4]
		imul	eax, [ebp+var_14]
		add	eax, [ebp+var_98]
		mov	[ebp+var_38], eax
		mov	[ebp+var_2C], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 2
		jz	short loc_8F30
		mov	eax, 2
		mov	[ebp+var_20], ax
		mov	[ebp+var_2C], 0

loc_8F30:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+216j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *):loc_951Bj
		cmp	[ebp+var_44], 0FFFFFFFFh
		jnz	short loc_8F72
		cmp	[ebp+var_2C], 2
		jnz	short loc_8F62
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_68]
		jle	short loc_8F5D
		mov	eax, [ebp+var_80]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_5C]
		mov	[eax+154h], ecx
		mov	[ebp+var_50], 0

loc_8F5D:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+23Aj
		jmp	loc_9520
; ---------------------------------------------------------------------------

loc_8F62:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+232j
		mov	[ebp+var_2C], 2
		mov	eax, 1
		mov	[ebp+var_20], ax

loc_8F72:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+22Cj
		cmp	[ebp+var_2C], 1
		jnz	loc_910A
		cmp	[ebp+var_44], 0FFFFh
		ja	short loc_8FEB
		cmp	[ebp+var_44], 0D800h
		jl	short loc_8FA3
		cmp	[ebp+var_44], 0DBFFh
		jg	short loc_8FA3
		mov	[ebp+var_1C0], 140h
		jmp	short loc_8FAD
; ---------------------------------------------------------------------------

loc_8FA3:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+284j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+28Dj
		mov	[ebp+var_1C0], 0

loc_8FAD:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+299j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_44]
		sar	edx, 5
		add	edx, [ebp+var_1C0]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_44]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_20], cx
		jmp	loc_90DD
; ---------------------------------------------------------------------------

loc_8FEB:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+27Bj
		cmp	[ebp+var_44], 10FFFFh
		ja	loc_90CC
		mov	eax, [ebp+var_44]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_B0], ax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_B0]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_B0]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_20], cx
		movzx	eax, [ebp+var_20]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_BC], eax
		cmp	[ebp+var_BC], 0
		jle	short loc_90B9
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_44]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_BC]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_44]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_20], cx
		jmp	short loc_90CA
; ---------------------------------------------------------------------------

loc_90B9:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+369j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_20], dx

loc_90CA:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+3AFj
		jmp	short loc_90DD
; ---------------------------------------------------------------------------

loc_90CC:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+2EAj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_20], dx

loc_90DD:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+2DEj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *):loc_90CAj
		movzx	eax, [ebp+var_20]
		and	eax, 4000h
		jz	short loc_910A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+15Ch]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+15Ch], ecx
		movzx	eax, [ebp+var_20]
		and	eax, 0FFFFBFFFh
		mov	[ebp+var_20], ax

loc_910A:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+26Ej
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+3DEj
		movsx	eax, ds:_fTrace
		test	eax, eax
		jz	loc_91A8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	esi, esp
		push	edx
		push	eax
		push	offset ??_C@_0BF@CHIKCOEI@?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF4ld?5?5?5?$AA@ ; "	       %4ld   "
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_44], 20h ; ' '
		jl	short loc_916D
		cmp	[ebp+var_44], 7Fh ; ''
		jge	short loc_916D
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		push	offset ??_C@_06BELAJENL@?$CC?$CFc?$CC?5?5?$AA@ ; "\"%c\"  "
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_9188
; ---------------------------------------------------------------------------

loc_916D:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+440j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+446j
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		push	offset ??_C@_05HDNPBHBO@?$CF5x?5?5?$AA@	; "%5x	"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9188:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+463j
		movzx	eax, [ebp+var_20]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		push	offset ??_C@_09GAIDENKM@?$CF3d?5?5?$CF3d?6?$AA@	; "%3d	%3d\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_91A8:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+40Bj
		movzx	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+150h]
		mov	ecx, [edx]
		cmp	eax, [ecx+0Ch]
		jb	short loc_91E2
		mov	edx, ds:?__LINE__Var@?1??handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@3@@Z@4JA ; long `icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)'::`2'::__LINE__Var
		add	edx, 73h ; 's'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@	; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1EG@BPJGGIHK@?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAy?$AA?$DM?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9?$AA?$DO?$AAf?$AAH?$AAe?$AAa?$AAd?$AAe?$AAr?$AA?9?$AA?$DO?$AAf?$AAC?$AAa?$AAt?$AAC?$AAo?$AAu@ ; "category<fData->fHeader->fCatCount"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_91E2:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+4B2j
		movzx	eax, [ebp+var_20]
		mov	ecx, [ebp+var_38]
		movzx	edx, word ptr [ecx+eax*2+8]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_A4]
		imul	eax, [ebp+var_14]
		add	eax, [ebp+var_98]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax]
		cmp	ecx, 0FFFFFFFFh
		jnz	loc_92AD
		cmp	[ebp+var_2C], 0
		jz	loc_929D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_9261
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		jmp	short loc_9294
; ---------------------------------------------------------------------------

loc_9261:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+52Dj
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx

loc_9294:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+557j
		mov	ecx, [ebp+var_1C4]
		mov	[ebp+var_68], ecx

loc_929D:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+50Fj
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax+4]
		mov	edx, [ebp+var_8]
		mov	[edx+154h], ecx

loc_92AD:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+505j
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax+2]
		test	ecx, ecx
		jz	loc_9449
		cmp	[ebp+var_50], 0
		jz	loc_93A5
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax]
		cmp	ecx, [ebp+var_50]
		jnz	loc_93A5
		mov	eax, [ebp+var_80]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_5C]
		mov	[eax+154h], ecx
		mov	[ebp+var_50], 0
		movsx	eax, [ebp+var_89]
		test	eax, eax
		jz	loc_939B
		mov	eax, [ebp+var_68]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_CC], eax
		mov	[ebp+var_C8], edx
		cmp	[ebp+var_C8], 0
		jl	short loc_937B
		jg	short loc_9330
		cmp	[ebp+var_CC], 0
		jb	short loc_937B

loc_9330:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+61Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		mov	edx, [ebp+var_C8]
		cmp	edx, [ebp+var_1C0]
		jg	short loc_937B
		jl	short loc_9367
		mov	eax, [ebp+var_CC]
		cmp	eax, [ebp+var_1C4]
		ja	short loc_937B

loc_9367:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+64Fj
		mov	eax, [ebp+var_CC]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_9393
; ---------------------------------------------------------------------------

loc_937B:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+61Bj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+626j ...
		mov	eax, [ebp+var_68]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_9393:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+671j
		mov	eax, [ebp+var_68]
		jmp	loc_9795
; ---------------------------------------------------------------------------

loc_939B:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+5EFj
		jmp	$continueOn$73002
; ---------------------------------------------------------------------------
		jmp	$continueOn$73002
; ---------------------------------------------------------------------------

loc_93A5:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+5B8j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+5C7j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_93E9
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		jmp	short loc_941C
; ---------------------------------------------------------------------------

loc_93E9:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+6B5j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx

loc_941C:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+6DFj
		mov	ecx, [ebp+var_1C4]
		mov	[ebp+var_D8], ecx
		mov	eax, [ebp+var_D8]
		mov	[ebp+var_80], eax
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax+2]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax+4]
		mov	[ebp+var_5C], ecx
		jmp	short $continueOn$73002
; ---------------------------------------------------------------------------
		jmp	short $continueOn$73002
; ---------------------------------------------------------------------------

loc_9449:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+5AEj
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax]
		test	ecx, ecx
		jz	short $continueOn$73002
		mov	[ebp+var_50], 0

$continueOn$73002:			; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *):loc_939Bj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+698j ...
		cmp	[ebp+var_14], 0
		jnz	short loc_9465
		jmp	loc_9520
; ---------------------------------------------------------------------------

loc_9465:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+756j
		cmp	[ebp+var_2C], 1
		jnz	loc_950E
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+2Ch]
		jge	short loc_94EB
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2]
		cmp	eax, 0D800h
		jge	short loc_94EB
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+28h]
		mov	ecx, [edx+30h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_1C0], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+28h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	[ecx+28h], edx
		jmp	short loc_9503
; ---------------------------------------------------------------------------

loc_94EB:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+77Fj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+7A2j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_1C0], eax

loc_9503:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+7E1j
		mov	ecx, [ebp+var_1C0]
		mov	[ebp+var_44], ecx
		jmp	short loc_951B
; ---------------------------------------------------------------------------

loc_950E:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+761j
		cmp	[ebp+var_2C], 0
		jnz	short loc_951B
		mov	[ebp+var_2C], 1

loc_951B:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+804j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+80Aj
		jmp	loc_8F30
; ---------------------------------------------------------------------------

loc_9520:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *):loc_8F5Dj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+758j
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_74]
		jnz	loc_96D6
		mov	eax, [ebp+var_74]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_E8], eax
		mov	[ebp+var_E4], edx
		cmp	[ebp+var_E4], 0
		jl	short loc_95AA
		jg	short loc_955F
		cmp	[ebp+var_E8], 0
		jb	short loc_95AA

loc_955F:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+84Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		mov	edx, [ebp+var_E4]
		cmp	edx, [ebp+var_1C0]
		jg	short loc_95AA
		jl	short loc_9596
		mov	eax, [ebp+var_E8]
		cmp	eax, [ebp+var_1C4]
		ja	short loc_95AA

loc_9596:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+87Ej
		mov	eax, [ebp+var_E8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_95C2
; ---------------------------------------------------------------------------

loc_95AA:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+84Aj
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+855j ...
		mov	eax, [ebp+var_74]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_95C2:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+8A0j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+2Ch]
		jge	short loc_963E
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2]
		cmp	eax, 0D800h
		jge	short loc_963E
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+28h]
		mov	ecx, [edx+30h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_1C0], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+28h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	[ecx+28h], edx
		jmp	short loc_9656
; ---------------------------------------------------------------------------

loc_963E:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+8D2j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+8F5j
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_1C0], eax

loc_9656:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+934j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_969A
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		jmp	short loc_96CD
; ---------------------------------------------------------------------------

loc_969A:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+966j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx

loc_96CD:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+990j
		mov	ecx, [ebp+var_1C4]
		mov	[ebp+var_68], ecx

loc_96D6:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+81Ej
		mov	eax, [ebp+var_68]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_F4], edx
		cmp	[ebp+var_F4], 0
		jl	short loc_9754
		jg	short loc_9709
		cmp	[ebp+var_F8], 0
		jb	short loc_9754

loc_9709:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+9F6j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1C4], eax
		mov	[ebp+var_1C0], edx
		mov	edx, [ebp+var_F4]
		cmp	edx, [ebp+var_1C0]
		jg	short loc_9754
		jl	short loc_9740
		mov	eax, [ebp+var_F8]
		cmp	eax, [ebp+var_1C4]
		ja	short loc_9754

loc_9740:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+A28j
		mov	eax, [ebp+var_F8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_976C
; ---------------------------------------------------------------------------

loc_9754:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+9F4j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+9FFj ...
		mov	eax, [ebp+var_68]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_976C:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+A4Aj
		movsx	eax, ds:_fTrace
		test	eax, eax
		jz	short loc_9792
		mov	esi, esp
		mov	eax, [ebp+var_68]
		push	eax
		push	offset ??_C@_0O@PBNPENIB@result?5?$DN?5?$CFd?6?6?$AA@ ;	"result	= %d\n\n"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9792:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+A6Dj
		mov	eax, [ebp+var_68]

loc_9795:				; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+1E7j
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+68Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 97ACh
		public ??_C@_0O@PBNPENIB@result?5?$DN?5?$CFd?6?6?$AA@
; char `string'[]
??_C@_0O@PBNPENIB@result?5?$DN?5?$CFd?6?6?$AA@ db 'result = %d',0Ah
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+A75o
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+BE4o
		db 0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 97BCh
		public ??_C@_1EG@BPJGGIHK@?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAy?$AA?$DM?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9?$AA?$DO?$AAf?$AAH?$AAe?$AAa?$AAd?$AAe?$AAr?$AA?9?$AA?$DO?$AAf?$AAC?$AAa?$AAt?$AAC?$AAo?$AAu@
; wchar_t `string'
??_C@_1EG@BPJGGIHK@?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAy?$AA?$DM?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9?$AA?$DO?$AAf?$AAH?$AAe?$AAa?$AAd?$AAe?$AAr?$AA?9?$AA?$DO?$AAf?$AAC?$AAa?$AAt?$AAC?$AAo?$AAu@:
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+4C5o
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+66Eo
		unicode	0, <category>
		dw 3Ch
		unicode	0, <fData->
		dw 3Eh
		unicode	0, <fHeader->
		dw 3Eh
		unicode	0, <fCatCount>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 9804h
		public ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+4C0o
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+669o ...
		unicode	0, <d:\mozilla\intl\icu\source\common\rbbi.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 985Ch
		public ?__LINE__Var@?1??handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@3@@Z@4JA
; long `private: int __thiscall	icu_56::RuleBasedBreakIterator::handleNext(struct icu_56::RBBIStateTable const *)'::`2'::__LINE__Var
?__LINE__Var@?1??handleNext@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@3@@Z@4JA dd 3E4h
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+4B4r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9860h
		public ??_C@_09GAIDENKM@?$CF3d?5?5?$CF3d?6?$AA@
; char `string'[]
??_C@_09GAIDENKM@?$CF3d?5?5?$CF3d?6?$AA@ db '%3d  %3d',0Ah,0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+48Bo
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+634o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 986Ch
		public ??_C@_05HDNPBHBO@?$CF5x?5?5?$AA@
; char `string'[]
??_C@_05HDNPBHBO@?$CF5x?5?5?$AA@ db '%5x  ',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+46Bo
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+614o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9874h
		public ??_C@_06BELAJENL@?$CC?$CFc?$CC?5?5?$AA@
; char `string'[]
??_C@_06BELAJENL@?$CC?$CFc?$CC?5?5?$AA@	db '"%c"  ',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+44Eo
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+5F7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 987Ch
		public ??_C@_0BF@CHIKCOEI@?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF4ld?5?5?5?$AA@
; char `string'[]
??_C@_0BF@CHIKCOEI@?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF4ld?5?5?5?$AA@	db '             %4ld   ',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+427o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9894h
		public ??_C@_0CJ@PLMEEDH@Handle?5Next?5?5?5pos?5?5?5char?5?5state?5@
; char `string'[]
??_C@_0CJ@PLMEEDH@Handle?5Next?5?5?5pos?5?5?5char?5?5state?5@ db 'Handle Next   pos   char  state category',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+83o
		align 10h
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 98C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RuleBasedBreakIterator *this, const struct icu_56::RBBIStateTable *)
		public ?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z
?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+132p
					; icu_56::RuleBasedBreakIterator::previous(void)+21Cp ...

var_1B0		= dword	ptr -1B0h
var_1AC		= dword	ptr -1ACh
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_C4		= dword	ptr -0C4h
var_B8		= dword	ptr -0B8h
var_B4		= dword	ptr -0B4h
var_A8		= dword	ptr -0A8h
var_9C		= word ptr -9Ch
var_90		= dword	ptr -90h
var_8C		= dword	ptr -8Ch
var_7D		= byte ptr -7Dh
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 1B0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1B0]
		mov	ecx, 6Ch ; 'l'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		xor	eax, eax
		mov	[ebp+var_20], ax
		mov	[ebp+var_50], 0
		mov	[ebp+var_5C], 0
		mov	[ebp+var_68], 0
		mov	[ebp+var_74], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 1
		setnz	dl
		mov	[ebp+var_7D], dl
		movsx	eax, ds:_fTrace
		test	eax, eax
		jz	short loc_9936
		mov	esi, esp
		push	offset ??_C@_0CN@HJKPBAFK@Handle?5Previous?5?5?5pos?5?5?5char?5?5st@ ; "Handle Previous	  pos	char  state cat"...
		call	dword ptr ds:__imp__puts
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9936:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+5Dj
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+140h], 0
		jz	loc_99F2
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+150h], 0
		jz	loc_99F2
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_99B1
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		jmp	short loc_99E4
; ---------------------------------------------------------------------------

loc_99B1:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+C5j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx

loc_99E4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+EFj
		mov	ecx, [ebp+var_1B0]
		or	ecx, [ebp+var_1AC]
		jnz	short loc_99FA

loc_99F2:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+97j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+A7j
		or	eax, 0FFFFFFFFh
		jmp	loc_A4BC
; ---------------------------------------------------------------------------

loc_99FA:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+130j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_9A3E
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		jmp	short loc_9A71
; ---------------------------------------------------------------------------

loc_9A3E:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+152j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx

loc_9A71:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+17Cj
		mov	ecx, [ebp+var_1B0]
		mov	[ebp+var_68], ecx
		mov	eax, [ebp+var_68]
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_9AF8
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_9AF8
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_1AC]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_1AC]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_1B0], edx
		jmp	short loc_9B10
; ---------------------------------------------------------------------------

loc_9AF8:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+1CDj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+1F1j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_1B0], eax

loc_9B10:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+236j
		mov	edx, [ebp+var_1B0]
		mov	[ebp+var_44], edx
		mov	[ebp+var_14], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		imul	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+10h]
		mov	[ebp+var_38], eax
		mov	eax, 3
		mov	[ebp+var_20], ax
		mov	[ebp+var_2C], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 2
		jz	short loc_9B5F
		mov	eax, 2
		mov	[ebp+var_20], ax
		mov	[ebp+var_2C], 0

loc_9B5F:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+28Dj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *):loc_A246j
		cmp	[ebp+var_44], 0FFFFFFFFh
		jnz	loc_9CD4
		cmp	[ebp+var_2C], 2
		jnz	loc_9CC4
		mov	eax, [ebp+var_74]
		cmp	eax, [ebp+var_5C]
		jge	short loc_9B8D
		mov	eax, [ebp+var_74]
		mov	[ebp+var_5C], eax
		mov	[ebp+var_50], 0
		jmp	loc_9CBF
; ---------------------------------------------------------------------------

loc_9B8D:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+2B9j
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_68]
		jnz	loc_9CBF
		mov	eax, [ebp+var_68]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_90], eax
		mov	[ebp+var_8C], edx
		cmp	[ebp+var_8C], 0
		jl	short loc_9C17
		jg	short loc_9BCC
		cmp	[ebp+var_90], 0
		jb	short loc_9C17

loc_9BCC:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+301j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		mov	edx, [ebp+var_8C]
		cmp	edx, [ebp+var_1AC]
		jg	short loc_9C17
		jl	short loc_9C03
		mov	eax, [ebp+var_90]
		cmp	eax, [ebp+var_1B0]
		ja	short loc_9C17

loc_9C03:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+333j
		mov	eax, [ebp+var_90]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_9C2F
; ---------------------------------------------------------------------------

loc_9C17:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+2FFj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+30Aj ...
		mov	eax, [ebp+var_68]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_9C2F:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+355j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_9CA7
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_9CA7
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_1AC]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_1AC]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_1B0], edx
		jmp	short loc_9CBF
; ---------------------------------------------------------------------------

loc_9CA7:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+37Cj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+3A0j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_1B0], eax

loc_9CBF:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+2C8j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+2D3j ...
		jmp	loc_A24B
; ---------------------------------------------------------------------------

loc_9CC4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+2ADj
		mov	[ebp+var_2C], 2
		mov	eax, 1
		mov	[ebp+var_20], ax

loc_9CD4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+2A3j
		cmp	[ebp+var_2C], 1
		jnz	loc_9E6C
		cmp	[ebp+var_44], 0FFFFh
		ja	short loc_9D4D
		cmp	[ebp+var_44], 0D800h
		jl	short loc_9D05
		cmp	[ebp+var_44], 0DBFFh
		jg	short loc_9D05
		mov	[ebp+var_1AC], 140h
		jmp	short loc_9D0F
; ---------------------------------------------------------------------------

loc_9D05:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+42Ej
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+437j
		mov	[ebp+var_1AC], 0

loc_9D0F:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+443j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_44]
		sar	edx, 5
		add	edx, [ebp+var_1AC]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_44]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_20], cx
		jmp	loc_9E3F
; ---------------------------------------------------------------------------

loc_9D4D:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+425j
		cmp	[ebp+var_44], 10FFFFh
		ja	loc_9E2E
		mov	eax, [ebp+var_44]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_9C], ax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_9C]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_9C]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_20], cx
		movzx	eax, [ebp+var_20]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A8], eax
		cmp	[ebp+var_A8], 0
		jle	short loc_9E1B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_44]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_A8]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_44]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_20], cx
		jmp	short loc_9E2C
; ---------------------------------------------------------------------------

loc_9E1B:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+513j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_20], dx

loc_9E2C:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+559j
		jmp	short loc_9E3F
; ---------------------------------------------------------------------------

loc_9E2E:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+494j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_20], dx

loc_9E3F:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+488j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *):loc_9E2Cj
		movzx	eax, [ebp+var_20]
		and	eax, 4000h
		jz	short loc_9E6C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+15Ch]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+15Ch], ecx
		movzx	eax, [ebp+var_20]
		and	eax, 0FFFFBFFFh
		mov	[ebp+var_20], ax

loc_9E6C:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+418j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+588j
		movsx	eax, ds:_fTrace
		test	eax, eax
		jz	loc_9F09
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	esi, esp
		push	eax
		push	offset ??_C@_0BE@JHAHEGBC@?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF4d?5?5?5?$AA@ ;	"	      %4d   "
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		cmp	[ebp+var_44], 20h ; ' '
		jl	short loc_9ECE
		cmp	[ebp+var_44], 7Fh ; ''
		jge	short loc_9ECE
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		push	offset ??_C@_06BELAJENL@?$CC?$CFc?$CC?5?5?$AA@ ; "\"%c\"  "
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_9EE9
; ---------------------------------------------------------------------------

loc_9ECE:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+5E9j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+5EFj
		mov	esi, esp
		mov	eax, [ebp+var_44]
		push	eax
		push	offset ??_C@_05HDNPBHBO@?$CF5x?5?5?$AA@	; "%5x	"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9EE9:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+60Cj
		movzx	eax, [ebp+var_20]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		push	offset ??_C@_09GAIDENKM@?$CF3d?5?5?$CF3d?6?$AA@	; "%3d	%3d\n"
		call	dword ptr ds:__imp__printf
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9F09:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+5B5j
		movzx	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+150h]
		mov	ecx, [edx]
		cmp	eax, [ecx+0Ch]
		jb	short loc_9F43
		mov	edx, ds:?__LINE__Var@?1??handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@3@@Z@4JA ;	long `icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)'::`2'::__LINE__Var
		add	edx, 76h ; 'v'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@	; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1EG@BPJGGIHK@?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAy?$AA?$DM?$AAf?$AAD?$AAa?$AAt?$AAa?$AA?9?$AA?$DO?$AAf?$AAH?$AAe?$AAa?$AAd?$AAe?$AAr?$AA?9?$AA?$DO?$AAf?$AAC?$AAa?$AAt?$AAC?$AAo?$AAu@ ; "category<fData->fHeader->fCatCount"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9F43:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+65Bj
		movzx	eax, [ebp+var_20]
		mov	ecx, [ebp+var_38]
		movzx	edx, word ptr [ecx+eax*2+8]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		imul	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx+10h]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax]
		cmp	ecx, 0FFFFFFFFh
		jnz	loc_9FF5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_9FB9
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		jmp	short loc_9FEC
; ---------------------------------------------------------------------------

loc_9FB9:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+6CDj
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx

loc_9FEC:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+6F7j
		mov	ecx, [ebp+var_1B0]
		mov	[ebp+var_5C], ecx

loc_9FF5:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+6AFj
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax+2]
		test	ecx, ecx
		jz	loc_A178
		cmp	[ebp+var_50], 0
		jz	loc_A0DE
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax]
		cmp	ecx, [ebp+var_50]
		jnz	loc_A0DE
		mov	eax, [ebp+var_74]
		mov	[ebp+var_5C], eax
		mov	[ebp+var_50], 0
		movsx	eax, [ebp+var_7D]
		test	eax, eax
		jz	loc_A0D4
		mov	eax, [ebp+var_5C]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_B8], eax
		mov	[ebp+var_B4], edx
		cmp	[ebp+var_B4], 0
		jl	short loc_A0B4
		jg	short loc_A069
		cmp	[ebp+var_B8], 0
		jb	short loc_A0B4

loc_A069:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+79Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		mov	edx, [ebp+var_B4]
		cmp	edx, [ebp+var_1AC]
		jg	short loc_A0B4
		jl	short loc_A0A0
		mov	eax, [ebp+var_B8]
		cmp	eax, [ebp+var_1B0]
		ja	short loc_A0B4

loc_A0A0:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+7D0j
		mov	eax, [ebp+var_B8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_A0CC
; ---------------------------------------------------------------------------

loc_A0B4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+79Cj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+7A7j ...
		mov	eax, [ebp+var_5C]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_A0CC:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+7F2j
		mov	eax, [ebp+var_5C]
		jmp	loc_A4BC
; ---------------------------------------------------------------------------

loc_A0D4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+770j
		jmp	$continueOn$73097
; ---------------------------------------------------------------------------
		jmp	$continueOn$73097
; ---------------------------------------------------------------------------

loc_A0DE:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+748j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+757j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_A122
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		jmp	short loc_A155
; ---------------------------------------------------------------------------

loc_A122:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+836j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx

loc_A155:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+860j
		mov	ecx, [ebp+var_1B0]
		mov	[ebp+var_C4], ecx
		mov	eax, [ebp+var_C4]
		mov	[ebp+var_74], eax
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax+2]
		mov	[ebp+var_50], ecx
		jmp	short $continueOn$73097
; ---------------------------------------------------------------------------
		jmp	short $continueOn$73097
; ---------------------------------------------------------------------------

loc_A178:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+73Ej
		mov	eax, [ebp+var_38]
		movsx	ecx, word ptr [eax]
		test	ecx, ecx
		jz	short $continueOn$73097
		mov	[ebp+var_50], 0

$continueOn$73097:			; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *):loc_A0D4j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+819j ...
		cmp	[ebp+var_14], 0
		jnz	short loc_A194
		jmp	loc_A24B
; ---------------------------------------------------------------------------

loc_A194:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+8CDj
		cmp	[ebp+var_2C], 1
		jnz	loc_A239
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_A216
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_A216
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_1AC]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_1AC]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_1B0], edx
		jmp	short loc_A22E
; ---------------------------------------------------------------------------

loc_A216:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+8EBj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+90Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_1B0], eax

loc_A22E:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+954j
		mov	edx, [ebp+var_1B0]
		mov	[ebp+var_44], edx
		jmp	short loc_A246
; ---------------------------------------------------------------------------

loc_A239:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+8D8j
		cmp	[ebp+var_2C], 0
		jnz	short loc_A246
		mov	[ebp+var_2C], 1

loc_A246:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+977j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+97Dj
		jmp	loc_9B5F
; ---------------------------------------------------------------------------

loc_A24B:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *):loc_9CBFj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+8CFj
		mov	eax, [ebp+var_5C]
		cmp	eax, [ebp+var_68]
		jnz	loc_A3FD
		mov	eax, [ebp+var_68]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_D4], eax
		mov	[ebp+var_D0], edx
		cmp	[ebp+var_D0], 0
		jl	short loc_A2D5
		jg	short loc_A28A
		cmp	[ebp+var_D4], 0
		jb	short loc_A2D5

loc_A28A:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+9BFj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		mov	edx, [ebp+var_D0]
		cmp	edx, [ebp+var_1AC]
		jg	short loc_A2D5
		jl	short loc_A2C1
		mov	eax, [ebp+var_D4]
		cmp	eax, [ebp+var_1B0]
		ja	short loc_A2D5

loc_A2C1:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+9F1j
		mov	eax, [ebp+var_D4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_A2ED
; ---------------------------------------------------------------------------

loc_A2D5:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+9BDj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+9C8j ...
		mov	eax, [ebp+var_68]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_A2ED:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+A13j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_A365
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_A365
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_1AC], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_1AC]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_1AC]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_1B0], edx
		jmp	short loc_A37D
; ---------------------------------------------------------------------------

loc_A365:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+A3Aj
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+A5Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_1B0], eax

loc_A37D:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+AA3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_A3C1
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		jmp	short loc_A3F4
; ---------------------------------------------------------------------------

loc_A3C1:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+AD5j
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx

loc_A3F4:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+AFFj
		mov	ecx, [ebp+var_1B0]
		mov	[ebp+var_5C], ecx

loc_A3FD:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+991j
		mov	eax, [ebp+var_5C]
		cdq
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+140h]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	[ebp+var_E4], eax
		mov	[ebp+var_E0], edx
		cmp	[ebp+var_E0], 0
		jl	short loc_A47B
		jg	short loc_A430
		cmp	[ebp+var_E4], 0
		jb	short loc_A47B

loc_A430:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+B65j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		mov	eax, [ecx+1Ch]
		cdq
		mov	[ebp+var_1B0], eax
		mov	[ebp+var_1AC], edx
		mov	edx, [ebp+var_E0]
		cmp	edx, [ebp+var_1AC]
		jg	short loc_A47B
		jl	short loc_A467
		mov	eax, [ebp+var_E4]
		cmp	eax, [ebp+var_1B0]
		ja	short loc_A47B

loc_A467:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+B97j
		mov	eax, [ebp+var_E4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+140h]
		mov	[edx+28h], eax
		jmp	short loc_A493
; ---------------------------------------------------------------------------

loc_A47B:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+B63j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+B6Ej ...
		mov	eax, [ebp+var_5C]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch

loc_A493:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+BB9j
		movsx	eax, ds:_fTrace
		test	eax, eax
		jz	short loc_A4B9
		mov	esi, esp
		mov	eax, [ebp+var_5C]
		push	eax
		push	offset ??_C@_0O@PBNPENIB@result?5?$DN?5?$CFd?6?6?$AA@ ;	"result	= %d\n\n"
		call	dword ptr ds:__imp__printf
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A4B9:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+BDCj
		mov	eax, [ebp+var_5C]

loc_A4BC:				; CODE XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+135j
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+80Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 1B0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@2@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A4D4h
		public ?__LINE__Var@?1??handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@3@@Z@4JA
; long `private: int __thiscall	icu_56::RuleBasedBreakIterator::handlePrevious(struct icu_56::RBBIStateTable const *)'::`2'::__LINE__Var
?__LINE__Var@?1??handlePrevious@RuleBasedBreakIterator@icu_56@@AAEHPBURBBIStateTable@3@@Z@4JA dd 4BDh
					; DATA XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+65Dr
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4D8h
		public ??_C@_0BE@JHAHEGBC@?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF4d?5?5?5?$AA@
; char `string'[]
??_C@_0BE@JHAHEGBC@?5?5?5?5?5?5?5?5?5?5?5?5?5?$CF4d?5?5?5?$AA@ db '             %4d   ',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+5D0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4ECh
		public ??_C@_0CN@HJKPBAFK@Handle?5Previous?5?5?5pos?5?5?5char?5?5st@
; char `string'[]
??_C@_0CN@HJKPBAFK@Handle?5Previous?5?5?5pos?5?5?5char?5?5st@ db 'Handle Previous   pos   char  state category',0
					; DATA XREF: icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable const *)+61o
		align 4
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A51Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::reset(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?reset@RuleBasedBreakIterator@icu_56@@MAEXXZ
?reset@RuleBasedBreakIterator@icu_56@@MAEXXZ proc near ; DATA XREF: .rdata:00005C70o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+160h], 0
		jz	short loc_A55D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+160h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_A55D:				; CODE XREF: icu_56::RuleBasedBreakIterator::reset(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+160h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+164h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+15Ch], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+168h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reset@RuleBasedBreakIterator@icu_56@@MAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A5A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::makeRuleStatusValid(icu_56::RuleBasedBreakIterator *__hidden this)
		public ?makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ
?makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ proc	near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatus(void)+2Cp
					; icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode	&)+48p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+158h]
		test	ecx, ecx
		jnz	loc_A6BF
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+140h], 0
		jz	short loc_A603
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		test	eax, eax
		jnz	short loc_A61F

loc_A603:				; CODE XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+154h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+158h], 1
		jmp	loc_A6BF
; ---------------------------------------------------------------------------

loc_A61F:				; CODE XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+59j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+2Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+164h], 0
		jle	short loc_A670
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A670:				; CODE XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+B0j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+34h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jz	short loc_A6BF
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jz	short loc_A6BF
		mov	ecx, ds:?__LINE__Var@?1??makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ@4JA ; long `icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)'::`2'::__LINE__Var
		add	ecx, 12h
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@	; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BC@HPDBKOEJ@?$AAp?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAb?$AA?$AA@ ; "pa == pb"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A6BF:				; CODE XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+2Fj
					; icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+72j ...
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+154h], 0
		jl	short loc_A6E2
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+150h]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+154h]
		cmp	ecx, [edx+1Ch]
		jl	short loc_A708

loc_A6E2:				; CODE XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+121j
		mov	edx, ds:?__LINE__Var@?1??makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ@4JA ; long `icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)'::`2'::__LINE__Var
		add	edx, 16h
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@	; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1JC@FMHHAABE@?$AAf?$AAL?$AAa?$AAs?$AAt?$AAR?$AAu?$AAl?$AAe?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAL?$AAa@ ; "fLastRuleStatusIndex >= 0 && fLastRuleS"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A708:				; CODE XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+138j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0A71Ch
		public ??_C@_1JC@FMHHAABE@?$AAf?$AAL?$AAa?$AAs?$AAt?$AAR?$AAu?$AAl?$AAe?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAL?$AAa@
; wchar_t `string'
??_C@_1JC@FMHHAABE@?$AAf?$AAL?$AAa?$AAs?$AAt?$AAR?$AAu?$AAl?$AAe?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAL?$AAa@:
					; DATA XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+14Bo
		unicode	0, <fLastRuleStatusIndex >
		dw 3Eh
		unicode	0, <= 0	&& fLastRuleStatusIndex	>
		dw 3Ch
		unicode	0, < fData->
		dw 3Eh
		unicode	0, <fStatusMaxIdx>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A7B0h
		public ??_C@_1BC@HPDBKOEJ@?$AAp?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAb?$AA?$AA@
; wchar_t `string'
??_C@_1BC@HPDBKOEJ@?$AAp?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAb?$AA?$AA@:
					; DATA XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+102o
		unicode	0, <pa == pb>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A7C4h
		public ?__LINE__Var@?1??makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ@4JA
; long `private: void __thiscall icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)'::`2'::__LINE__Var
?__LINE__Var@?1??makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ@4JA dd 5A0h
					; DATA XREF: icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)+F1r
					; icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void):loc_A6E2r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A7C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::getRuleStatus(icu_56::RuleBasedBreakIterator *__hidden	this)
		public ?getRuleStatus@RuleBasedBreakIterator@icu_56@@UBEHXZ
?getRuleStatus@RuleBasedBreakIterator@icu_56@@UBEHXZ proc near ; DATA XREF: .rdata:00005C54o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_14] ; this
		call	?makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ ; icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+154h]
		mov	ecx, [ecx+18h]
		mov	edx, [ebp+var_8]
		mov	edx, [edx+154h]
		add	edx, [ecx+eax*4]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx+18h]
		mov	eax, [ebp+var_20]
		mov	ecx, [edx+eax*4]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_2C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getRuleStatus@RuleBasedBreakIterator@icu_56@@UBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A84Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::getRuleStatusVec(icu_56::RuleBasedBreakIterator *this,	int *, int, enum UErrorCode *)
		public ?getRuleStatusVec@RuleBasedBreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z
?getRuleStatusVec@RuleBasedBreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005C58o

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A88B
		xor	eax, eax
		jmp	loc_A915
; ---------------------------------------------------------------------------

loc_A88B:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)+36j
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_14] ; this
		call	?makeRuleStatusValid@RuleBasedBreakIterator@icu_56@@AAEXXZ ; icu_56::RuleBasedBreakIterator::makeRuleStatusValid(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+154h]
		mov	ecx, [ecx+18h]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+arg_4]
		jle	short loc_A8D1
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0Fh
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_2C], eax

loc_A8D1:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)+74j
		mov	[ebp+var_38], 0
		jmp	short loc_A8E3
; ---------------------------------------------------------------------------

loc_A8DA:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)+C4j
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_A8E3:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)+8Cj
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_2C]
		jge	short loc_A912
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+154h]
		add	eax, [ebp+var_38]
		mov	ecx, [ecx+18h]
		mov	edx, [ebp+var_38]
		mov	esi, [ebp+arg_0]
		mov	eax, [ecx+eax*4+4]
		mov	[esi+edx*4], eax
		jmp	short loc_A8DA
; ---------------------------------------------------------------------------

loc_A912:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)+9Dj
		mov	eax, [ebp+var_20]

loc_A915:				; CODE XREF: icu_56::RuleBasedBreakIterator::getRuleStatusVec(int *,int,UErrorCode &)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?getRuleStatusVec@RuleBasedBreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A92Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	unsigned __int8	*__thiscall icu_56::RuleBasedBreakIterator::getBinaryRules(icu_56::RuleBasedBreakIterator *this, unsigned int *)
		public ?getBinaryRules@RuleBasedBreakIterator@icu_56@@UAEPBEAAI@Z
?getBinaryRules@RuleBasedBreakIterator@icu_56@@UAEPBEAAI@Z proc	near
					; DATA XREF: .rdata:00005C6Co

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+150h], 0
		jz	short loc_A98C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+150h]
		mov	edx, [ecx]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+8]
		mov	[eax], ecx

loc_A98C:				; CODE XREF: icu_56::RuleBasedBreakIterator::getBinaryRules(uint &)+3Dj
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getBinaryRules@RuleBasedBreakIterator@icu_56@@UAEPBEAAI@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A998h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::BreakIterator *__thiscall icu_56::RuleBasedBreakIterator::createBufferClone(icu_56::RuleBasedBreakIterator *this, void	*, int *, enum UErrorCode *)
		public ?createBufferClone@RuleBasedBreakIterator@icu_56@@UAEPAVBreakIterator@2@PAXAAHAAW4UErrorCode@@@Z
?createBufferClone@RuleBasedBreakIterator@icu_56@@UAEPAVBreakIterator@2@PAXAAHAAW4UErrorCode@@@Z proc near
					; DATA XREF: .rdata:00005C5Co

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A9D4
		xor	eax, eax
		jmp	short loc_AA1F
; ---------------------------------------------------------------------------

loc_A9D4:				; CODE XREF: icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)+36j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jnz	short loc_A9E9
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_AA1F
; ---------------------------------------------------------------------------

loc_A9E9:				; CODE XREF: icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)+42j
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_AA13
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_AA1C
; ---------------------------------------------------------------------------

loc_AA13:				; CODE XREF: icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)+6Ej
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 0FFFFFF82h

loc_AA1C:				; CODE XREF: icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)+79j
		mov	eax, [ebp+var_14]

loc_AA1F:				; CODE XREF: icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)+3Aj
					; icu_56::RuleBasedBreakIterator::createBufferClone(void *,int &,UErrorCode &)+4Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?createBufferClone@RuleBasedBreakIterator@icu_56@@UAEPAVBreakIterator@2@PAXAAHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AA38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::RuleBasedBreakIterator::checkDictionary(icu_56::RuleBasedBreakIterator	*this, int, int, signed	__int8)
		public ?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z
?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::next(void)+FFp
					; icu_56::RuleBasedBreakIterator::previous(void)+153p

var_250		= dword	ptr -250h
var_24C		= dword	ptr -24Ch
var_244		= dword	ptr -244h
var_238		= dword	ptr -238h
var_22C		= dword	ptr -22Ch
var_160		= dword	ptr -160h
var_154		= dword	ptr -154h
var_148		= dword	ptr -148h
var_13C		= dword	ptr -13Ch
var_130		= word ptr -130h
var_124		= dword	ptr -124h
var_118		= dword	ptr -118h
var_10C		= word ptr -10Ch
var_100		= dword	ptr -100h
var_F4		= word ptr -0F4h
var_E8		= dword	ptr -0E8h
var_DC		= word ptr -0DCh
var_D0		= dword	ptr -0D0h
var_C4		= word ptr -0C4h
var_B8		= dword	ptr -0B8h
var_AC		= word ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= word ptr -94h
var_88		= dword	ptr -88h
var_7C		= dword	ptr -7Ch
var_70		= byte ptr -70h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 244h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_250]
		mov	ecx, 91h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		cmp	eax, 1
		jg	short loc_AAC2
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_AAAE
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_24C], ecx
		jmp	short loc_AAB7
; ---------------------------------------------------------------------------

loc_AAAE:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+69j
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_24C], edx

loc_AAB7:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+74j
		mov	eax, [ebp+var_24C]
		jmp	loc_BDFE
; ---------------------------------------------------------------------------

loc_AAC2:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+61j
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_AAD5
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_24C], ecx
		jmp	short loc_AADE
; ---------------------------------------------------------------------------

loc_AAD5:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+90j
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_24C], edx

loc_AADE:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+9Bj
		mov	eax, [ebp+var_24C]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_AB95
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_AB7D
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_AB7D
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_24C], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_24C]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_24C]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_250], edx
		jmp	short loc_AB95
; ---------------------------------------------------------------------------

loc_AB7D:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+DAj
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+FEj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_250], eax

loc_AB95:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+C7j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+143j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_2C], eax
		mov	[ebp+var_50], 0
		lea	eax, [ebp+var_50]
		push	eax		; enum UErrorCode *
		lea	ecx, [ebp+var_70] ; this
		call	??0UStack@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UStack::UStack(UErrorCode &)
		mov	[ebp+var_4], 0
		mov	[ebp+var_7C], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_AC58
		cmp	[ebp+var_88], 0D800h
		jl	short loc_AC0A
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_AC0A
		mov	[ebp+var_24C], 140h
		jmp	short loc_AC14
; ---------------------------------------------------------------------------

loc_AC0A:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1B8j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1C4j
		mov	[ebp+var_24C], 0

loc_AC14:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1D0j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_AD56
; ---------------------------------------------------------------------------

loc_AC58:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1ACj
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_AD45
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_94], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_94]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_94]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A0], eax
		cmp	[ebp+var_A0], 0
		jle	short loc_AD32
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_A0]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_AD43
; ---------------------------------------------------------------------------

loc_AD32:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+2ACj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_AD43:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+2F8j
		jmp	short loc_AD56
; ---------------------------------------------------------------------------

loc_AD45:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+22Aj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_AD56:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+21Bj
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_AD43j
		movzx	eax, [ebp+var_38]
		and	eax, 4000h
		jz	loc_B577
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_B0FE

loc_AD71:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+4F1j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_next32_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_AE19
		cmp	[ebp+var_88], 0D800h
		jl	short loc_ADCB
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_ADCB
		mov	[ebp+var_24C], 140h
		jmp	short loc_ADD5
; ---------------------------------------------------------------------------

loc_ADCB:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+379j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+385j
		mov	[ebp+var_24C], 0

loc_ADD5:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+391j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_AF17
; ---------------------------------------------------------------------------

loc_AE19:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+36Dj
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_AF06
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_AC], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_AC]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_AC]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_B8], eax
		cmp	[ebp+var_B8], 0
		jle	short loc_AEF3
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_B8]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_AF04
; ---------------------------------------------------------------------------

loc_AEF3:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+46Dj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_AF04:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+4B9j
		jmp	short loc_AF17
; ---------------------------------------------------------------------------

loc_AF06:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+3EBj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_AF17:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+3DCj
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_AF04j
		cmp	[ebp+var_88], 0FFFFFFFFh
		jz	short loc_AF2F
		movzx	eax, [ebp+var_38]
		and	eax, 4000h
		jnz	loc_AD71

loc_AF2F:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+4E6j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_AF73
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_250], eax
		mov	[ebp+var_24C], edx
		jmp	short loc_AFA6
; ---------------------------------------------------------------------------

loc_AF73:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+50Fj
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_250], eax
		mov	[ebp+var_24C], edx

loc_AFA6:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+539j
		mov	ecx, [ebp+var_250]
		mov	[ebp+var_2C], ecx
		cmp	[ebp+var_88], 0FFFFFFFFh
		jnz	loc_B05D
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_B034
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_B034
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_24C], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_24C]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_24C]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_250], edx
		jmp	short loc_B04C
; ---------------------------------------------------------------------------

loc_B034:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+591j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+5B5j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_250], eax

loc_B04C:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+5FAj
		mov	edx, [ebp+var_250]
		mov	[ebp+var_88], edx
		jmp	loc_B0F9
; ---------------------------------------------------------------------------

loc_B05D:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+57Ej
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_B0D5
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_B0D5
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_24C], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_24C]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_24C]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_250], edx
		jmp	short loc_B0ED
; ---------------------------------------------------------------------------

loc_B0D5:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+632j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+656j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_250], eax

loc_B0ED:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+69Bj
		mov	edx, [ebp+var_250]
		mov	[ebp+var_88], edx

loc_B0F9:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+620j
		jmp	loc_B3FB
; ---------------------------------------------------------------------------

loc_B0FE:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+333j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+8F0j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		cmp	dword ptr [ecx+28h], 0
		jle	short loc_B176
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	ecx, [edx+28h]
		mov	edx, [eax+30h]
		movzx	eax, word ptr [edx+ecx*2-2]
		cmp	eax, 0D800h
		jge	short loc_B176
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+28h]
		sub	eax, 1
		mov	[ebp+var_24C], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [ebp+var_24C]
		mov	[edx+28h], eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		mov	eax, [edx+30h]
		mov	ecx, [ebp+var_24C]
		movzx	edx, word ptr [eax+ecx*2]
		mov	[ebp+var_250], edx
		jmp	short loc_B18E
; ---------------------------------------------------------------------------

loc_B176:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+6D3j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+6F7j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_250], eax

loc_B18E:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+73Cj
		mov	edx, [ebp+var_250]
		mov	[ebp+var_88], edx
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_B218
		cmp	[ebp+var_88], 0D800h
		jl	short loc_B1CA
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_B1CA
		mov	[ebp+var_24C], 140h
		jmp	short loc_B1D4
; ---------------------------------------------------------------------------

loc_B1CA:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+778j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+784j
		mov	[ebp+var_24C], 0

loc_B1D4:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+790j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_B316
; ---------------------------------------------------------------------------

loc_B218:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+76Cj
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_B305
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_C4], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_C4]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_C4]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_D0], eax
		cmp	[ebp+var_D0], 0
		jle	short loc_B2F2
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_D0]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_B303
; ---------------------------------------------------------------------------

loc_B2F2:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+86Cj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B303:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+8B8j
		jmp	short loc_B316
; ---------------------------------------------------------------------------

loc_B305:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+7EAj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B316:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+7DBj
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_B303j
		cmp	[ebp+var_88], 0FFFFFFFFh
		jz	short loc_B32E
		movzx	eax, [ebp+var_38]
		and	eax, 4000h
		jnz	loc_B0FE

loc_B32E:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+8E5j
		cmp	[ebp+var_88], 0FFFFFFFFh
		jnz	short loc_B351
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax
		jmp	short loc_B37B
; ---------------------------------------------------------------------------

loc_B351:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+8FDj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_next32_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax

loc_B37B:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+917j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_B3BF
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_250], eax
		mov	[ebp+var_24C], edx
		jmp	short loc_B3F2
; ---------------------------------------------------------------------------

loc_B3BF:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+95Bj
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_250], eax
		mov	[ebp+var_24C], edx

loc_B3F2:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+985j
		mov	ecx, [ebp+var_250]
		mov	[ebp+var_20], ecx

loc_B3FB:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_B0F9j
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_B479
		cmp	[ebp+var_88], 0D800h
		jl	short loc_B42B
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_B42B
		mov	[ebp+var_24C], 140h
		jmp	short loc_B435
; ---------------------------------------------------------------------------

loc_B42B:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+9D9j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+9E5j
		mov	[ebp+var_24C], 0

loc_B435:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+9F1j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_B577
; ---------------------------------------------------------------------------

loc_B479:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+9CDj
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_B566
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_DC], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_DC]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_DC]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		cmp	[ebp+var_E8], 0
		jle	short loc_B553
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_E8]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_B564
; ---------------------------------------------------------------------------

loc_B553:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+ACDj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B564:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+B19j
		jmp	short loc_B577
; ---------------------------------------------------------------------------

loc_B566:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+A4Bj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B577:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+327j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+A3Cj ...
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_B72F
		mov	eax, [ebp+var_20]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_B631
		cmp	[ebp+var_88], 0D800h
		jl	short loc_B5E3
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_B5E3
		mov	[ebp+var_24C], 140h
		jmp	short loc_B5ED
; ---------------------------------------------------------------------------

loc_B5E3:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+B91j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+B9Dj
		mov	[ebp+var_24C], 0

loc_B5ED:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+BA9j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_B72F
; ---------------------------------------------------------------------------

loc_B631:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+B85j
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_B71E
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_F4], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_F4]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_F4]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_100], eax
		cmp	[ebp+var_100], 0
		jle	short loc_B70B
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_100]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_B71C
; ---------------------------------------------------------------------------

loc_B70B:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+C85j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B71C:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+CD1j
		jmp	short loc_B72F
; ---------------------------------------------------------------------------

loc_B71E:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+C03j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B72F:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+B45j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+BF4j ...
		mov	eax, [ebp+var_50]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	loc_BB94

loc_B746:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_B987j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	ecx, [ecx+28h]
		cmp	ecx, [eax+1Ch]
		jg	short loc_B78A
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+140h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		mov	eax, [eax+28h]
		cdq
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_250], eax
		mov	[ebp+var_24C], edx
		jmp	short loc_B7BD
; ---------------------------------------------------------------------------

loc_B78A:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+D26j
		mov	esi, esp
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+140h]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_250], eax
		mov	[ebp+var_24C], edx

loc_B7BD:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+D50j
		mov	ecx, [ebp+var_250]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_44]
		cmp	edx, [ebp+var_2C]
		jge	loc_B98C
		movzx	eax, [ebp+var_38]
		and	eax, 4000h
		jnz	loc_B98C
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_next32_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_B889
		cmp	[ebp+var_88], 0D800h
		jl	short loc_B83B
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_B83B
		mov	[ebp+var_24C], 140h
		jmp	short loc_B845
; ---------------------------------------------------------------------------

loc_B83B:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+DE9j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+DF5j
		mov	[ebp+var_24C], 0

loc_B845:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+E01j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_B987
; ---------------------------------------------------------------------------

loc_B889:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+DDDj
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_B976
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_10C], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_10C]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_10C]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_118], eax
		cmp	[ebp+var_118], 0
		jle	short loc_B963
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_118]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_B974
; ---------------------------------------------------------------------------

loc_B963:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+EDDj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B974:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+F29j
		jmp	short loc_B987
; ---------------------------------------------------------------------------

loc_B976:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+E5Bj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_B987:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+E4Cj
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_B974j
		jmp	loc_B746
; ---------------------------------------------------------------------------

loc_B98C:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+D94j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+DA3j
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_2C]
		jl	short loc_B999
		jmp	loc_BB94
; ---------------------------------------------------------------------------

loc_B999:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+F5Aj
		mov	eax, [ebp+var_88]
		push	eax		; int
		mov	ecx, [ebp+var_14] ; this
		call	?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z ; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)
		mov	[ebp+var_124], eax
		cmp	[ebp+var_124], 0
		jz	short loc_B9FB
		mov	esi, esp
		lea	eax, [ebp+var_70]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+174h]
		push	edx
		push	0
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+140h]
		push	eax
		mov	ecx, [ebp+var_124]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_124]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		add	eax, [ebp+var_7C]
		mov	[ebp+var_7C], eax

loc_B9FB:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+F7Dj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_88], eax
		cmp	[ebp+var_88], 0FFFFh
		ja	short loc_BA91
		cmp	[ebp+var_88], 0D800h
		jl	short loc_BA43
		cmp	[ebp+var_88], 0DBFFh
		jg	short loc_BA43
		mov	[ebp+var_24C], 140h
		jmp	short loc_BA4D
; ---------------------------------------------------------------------------

loc_BA43:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+FF1j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+FFDj
		mov	[ebp+var_24C], 0

loc_BA4D:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1009j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		sar	edx, 5
		add	edx, [ebp+var_24C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	loc_BB8F
; ---------------------------------------------------------------------------

loc_BA91:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+FE5j
		cmp	[ebp+var_88], 10FFFFh
		ja	loc_BB7E
		mov	eax, [ebp+var_88]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	[ebp+var_130], ax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		movzx	edx, [ebp+var_130]
		sar	edx, 5
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		movzx	eax, [ebp+var_130]
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		movzx	eax, [ebp+var_38]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+150h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 0
		jle	short loc_BB6B
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+150h]
		mov	edx, [ebp+var_88]
		and	edx, 3FFh
		sar	edx, 5
		add	edx, [ebp+var_13C]
		mov	eax, [eax+20h]
		movzx	edx, word ptr [eax+edx*2]
		mov	eax, [ebp+var_88]
		and	eax, 3FFh
		and	eax, 1Fh
		lea	edx, [eax+edx*4]
		mov	eax, [ecx+20h]
		mov	cx, [eax+edx*2]
		mov	[ebp+var_38], cx
		jmp	short loc_BB7C
; ---------------------------------------------------------------------------

loc_BB6B:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+10E5j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_BB7C:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1131j
		jmp	short loc_BB8F
; ---------------------------------------------------------------------------

loc_BB7E:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1063j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+150h]
		mov	dx, [ecx+34h]
		mov	[ebp+var_38], dx

loc_BB8F:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1054j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char):loc_BB7Cj
		jmp	loc_B72F
; ---------------------------------------------------------------------------

loc_BB94:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+D08j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+F5Cj
		cmp	[ebp+var_7C], 0
		jle	loc_BD8A
		lea	ecx, [ebp+var_70] ; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_7C], eax
		jz	short loc_BBD0
		mov	eax, ds:?__LINE__Var@?1??checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z@4JA ;	long `icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)'::`2'::__LINE__Var
		add	eax, 70h ; 'p'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@	; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1EC@PLHCKIME@?$AAf?$AAo?$AAu?$AAn?$AAd?$AAB?$AAr?$AAe?$AAa?$AAk?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAb?$AAr?$AAe?$AAa?$AAk?$AAs?$AA?4?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ@ ; "foundBreakCount == breaks.size()"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_BBD0:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1171j
		mov	eax, [ebp+var_7C]
		mov	[ebp+var_148], eax
		push	0		; int
		lea	ecx, [ebp+var_70] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		cmp	[ebp+arg_0], eax
		jge	short loc_BBF7
		mov	eax, [ebp+var_148]
		add	eax, 1
		mov	[ebp+var_148], eax

loc_BBF7:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+11AEj
		lea	ecx, [ebp+var_70] ; this
		call	?peeki@UStack@icu_56@@QBEHXZ ; icu_56::UStack::peeki(void)
		cmp	[ebp+arg_4], eax
		jle	short loc_BC13
		mov	eax, [ebp+var_148]
		add	eax, 1
		mov	[ebp+var_148], eax

loc_BC13:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+11CAj
		mov	eax, [ebp+var_148]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_14]
		mov	[ecx+160h], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+160h], 0
		jz	loc_BD8A
		mov	[ebp+var_154], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_148]
		mov	[eax+164h], ecx
		push	0		; int
		lea	ecx, [ebp+var_70] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		cmp	[ebp+arg_0], eax
		jge	short loc_BC8A
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+160h]
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_154]
		add	ecx, 1
		mov	[ebp+var_154], ecx

loc_BC8A:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+122Cj
		mov	[ebp+var_160], 0
		jmp	short loc_BCA5
; ---------------------------------------------------------------------------

loc_BC96:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+12A8j
		mov	eax, [ebp+var_160]
		add	eax, 1
		mov	[ebp+var_160], eax

loc_BCA5:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+125Cj
		mov	eax, [ebp+var_160]
		cmp	eax, [ebp+var_7C]
		jge	short loc_BCE2
		mov	eax, [ebp+var_160]
		push	eax		; int
		lea	ecx, [ebp+var_70] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+160h]
		mov	ecx, [ebp+var_154]
		mov	[edx+ecx*4], eax
		mov	edx, [ebp+var_154]
		add	edx, 1
		mov	[ebp+var_154], edx
		jmp	short loc_BC96
; ---------------------------------------------------------------------------

loc_BCE2:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1276j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+160h]
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+arg_4]
		cmp	eax, [ecx+edx*4-4]
		jle	short loc_BD0F
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+160h]
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+arg_4]
		mov	[ecx+edx*4], eax

loc_BD0F:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+12C0j
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_BD53
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+40h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_244], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_70] ; this
		call	??1UStack@icu_56@@UAE@XZ ; icu_56::UStack::~UStack(void)
		mov	eax, [ebp+var_244]
		jmp	loc_BDFE
; ---------------------------------------------------------------------------
		jmp	short loc_BD8A
; ---------------------------------------------------------------------------

loc_BD53:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+12DDj
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_14]
		mov	eax, [edx+3Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_238], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_70] ; this
		call	??1UStack@icu_56@@UAE@XZ ; icu_56::UStack::~UStack(void)
		mov	eax, [ebp+var_238]
		jmp	short loc_BDFE
; ---------------------------------------------------------------------------

loc_BD8A:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1160j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1200j ...
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_BD9D
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_24C], ecx
		jmp	short loc_BDA6
; ---------------------------------------------------------------------------

loc_BD9D:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1358j
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_24C], edx

loc_BDA6:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1363j
		mov	eax, [ebp+var_24C]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+140h]
		push	ecx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_BDD4
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_24C], ecx
		jmp	short loc_BDDD
; ---------------------------------------------------------------------------

loc_BDD4:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+138Fj
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_24C], edx

loc_BDDD:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+139Aj
		mov	eax, [ebp+var_24C]
		mov	[ebp+var_22C], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		lea	ecx, [ebp+var_70] ; this
		call	??1UStack@icu_56@@UAE@XZ ; icu_56::UStack::~UStack(void)
		mov	eax, [ebp+var_22C]

loc_BDFE:				; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+85j
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1314j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN122
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 250h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z endp

; ---------------------------------------------------------------------------
$LN122		dd 2			; DATA XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+13CAo
		dd offset $LN121
$LN121		dd 0FFFFFFB0h, 4	; DATA XREF: .text:0000BE34o
		dd offset $LN118	; "status"
		db 90h
		db 3 dup(0FFh)
		dd 18h
		dd offset $LN119	; "breaks"
$LN119		db 'breaks',0           ; DATA XREF: .text:0000BE4Co
$LN118		db 'status',0           ; DATA XREF: .text:0000BE40o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0BE60h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z$0 proc near
					; DATA XREF: .xdata$x:0000BED4o
		lea	ecx, [ebp-70h]	; this
		jmp	??1UStack@icu_56@@UAE@XZ ; icu_56::UStack::~UStack(void)
__unwindfunclet$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z proc near
					; DATA XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-254h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z
		jmp	___CxxFrameHandler3
__ehhandler$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0BE88h
		public ??_C@_1EC@PLHCKIME@?$AAf?$AAo?$AAu?$AAn?$AAd?$AAB?$AAr?$AAe?$AAa?$AAk?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAb?$AAr?$AAe?$AAa?$AAk?$AAs?$AA?4?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ@
; wchar_t `string'
??_C@_1EC@PLHCKIME@?$AAf?$AAo?$AAu?$AAn?$AAd?$AAB?$AAr?$AAe?$AAa?$AAk?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAb?$AAr?$AAe?$AAa?$AAk?$AAs?$AA?4?$AAs?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ@:
					; DATA XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1183o
		unicode	0, <foundBreakCount == breaks.size()>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BECCh
		public ?__LINE__Var@?1??checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z@4JA
; long `protected: int __thiscall icu_56::RuleBasedBreakIterator::checkDictionary(int, int, signed char)'::`2'::__LINE__Var
?__LINE__Var@?1??checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z@4JA dd 62Ah
					; DATA XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1173r
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0BED0h
__unwindtable$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000BEE0o
		dd offset __unwindfunclet$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z$0
__ehfuncinfo$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z+14o
		dd offset __unwindtable$?checkDictionary@RuleBasedBreakIterator@icu_56@@IAEHHHC@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BEFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::LanguageBreakEngine *__thiscall icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(icu_56::RuleBasedBreakIterator *this, int)
		public ?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z
?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z proc near
					; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+F6Bp

var_160		= dword	ptr -160h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 154h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_160]
		mov	ecx, 55h ; 'U'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+16Ch], 0
		jnz	loc_C045
		push	18h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_14C], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_14C], 0
		jz	short loc_BF93
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14C] ; this
		call	??0UStack@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UStack::UStack(UErrorCode &)
		mov	[ebp+var_160], eax
		jmp	short loc_BF9D
; ---------------------------------------------------------------------------

loc_BF93:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+7Ej
		mov	[ebp+var_160], 0

loc_BF9D:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+95j
		mov	ecx, [ebp+var_160]
		mov	[ebp+var_158], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_158]
		mov	[edx+16Ch], eax
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+16Ch], 0
		jz	short loc_BFDE
		mov	eax, [ebp+var_2C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C045

loc_BFDE:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+CDj
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+16Ch]
		mov	[ebp+var_134], ecx
		mov	edx, [ebp+var_134]
		mov	[ebp+var_140], edx
		cmp	[ebp+var_140], 0
		jz	short loc_C027
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_140]
		mov	edx, [eax]
		mov	ecx, [ebp+var_140]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_160], eax
		jmp	short loc_C031
; ---------------------------------------------------------------------------

loc_C027:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+104j
		mov	[ebp+var_160], 0

loc_C031:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+129j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+16Ch], 0
		xor	eax, eax
		jmp	loc_C251
; ---------------------------------------------------------------------------

loc_C045:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+5Aj
					; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+E0j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+16Ch]	; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_38], eax

loc_C056:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int):loc_C0A9j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax
		js	short loc_C0AB
		mov	eax, [ebp+var_38]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		mov	ecx, [ecx+16Ch]	; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_20], eax
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+174h]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_20]
		mov	edx, [eax]
		mov	ecx, [ebp+var_20]
		mov	eax, [edx+4]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C0A9
		mov	eax, [ebp+var_20]
		jmp	loc_C251
; ---------------------------------------------------------------------------

loc_C0A9:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+1A3j
		jmp	short loc_C056
; ---------------------------------------------------------------------------

loc_C0AB:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+163j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+174h]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?getLanguageBreakEngineFromFactory@icu_56@@YAPBVLanguageBreakEngine@1@HH@Z ; icu_56::getLanguageBreakEngineFromFactory(int,int)
		add	esp, 8
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jz	short loc_C0E8
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_20]
		push	ecx		; void *
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+16Ch]	; this
		call	?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z ; icu_56::UStack::push(void *,UErrorCode &)
		mov	eax, [ebp+var_20]
		jmp	loc_C251
; ---------------------------------------------------------------------------

loc_C0E8:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+1CCj
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+170h], 0
		jnz	loc_C216
		push	14h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_11C], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_11C], 0
		jz	short loc_C12F
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_11C] ; this
		call	??0UnhandledEngine@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::UnhandledEngine::UnhandledEngine(UErrorCode	&)
		mov	[ebp+var_160], eax
		jmp	short loc_C139
; ---------------------------------------------------------------------------

loc_C12F:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+21Aj
		mov	[ebp+var_160], 0

loc_C139:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+231j
		mov	ecx, [ebp+var_160]
		mov	[ebp+var_128], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_128]
		mov	[edx+170h], eax
		mov	eax, [ebp+var_2C]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C181
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+170h], 0
		jnz	short loc_C181
		mov	[ebp+var_2C], 7

loc_C181:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+270j
					; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+27Cj
		lea	eax, [ebp+var_2C]
		push	eax		; enum UErrorCode *
		push	0		; int
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+170h]
		push	edx		; void *
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+16Ch]	; this
		call	?insertElementAt@UVector@icu_56@@QAEXPAXHAAW4UErrorCode@@@Z ; icu_56::UVector::insertElementAt(void *,int,UErrorCode &)
		mov	eax, [ebp+var_2C]
		push	eax
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C216
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+170h]
		mov	[ebp+var_104], ecx
		mov	edx, [ebp+var_104]
		mov	[ebp+var_110], edx
		cmp	[ebp+var_110], 0
		jz	short loc_C1FB
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_110]
		mov	edx, [eax]
		mov	ecx, [ebp+var_110]
		mov	eax, [edx]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_160], eax
		jmp	short loc_C205
; ---------------------------------------------------------------------------

loc_C1FB:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+2D8j
		mov	[ebp+var_160], 0

loc_C205:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+2FDj
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+170h], 0
		xor	eax, eax
		jmp	short loc_C251
; ---------------------------------------------------------------------------

loc_C216:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+1F6j
					; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+2B4j
		mov	esi, esp
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+174h]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+170h]
		mov	edx, [ebp+var_14]
		mov	eax, [edx+170h]
		mov	edx, [ecx]
		mov	ecx, eax
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_14]
		mov	eax, [eax+170h]

loc_C251:				; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+144j
					; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+1A8j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN26
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 160h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN26		dd 1			; DATA XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+359o
		dd offset $LN25
$LN25		dd 0FFFFFFD4h, 4	; DATA XREF: .text:0000C288o
		dd offset $LN23		; "status"
$LN23		db 'status',0           ; DATA XREF: .text:0000C294o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C2A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z$0 proc near
					; DATA XREF: .xdata$x:0000C2E0o
		mov	eax, [ebp-14Ch]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z$1 proc near
					; DATA XREF: .xdata$x:0000C2E8o
		mov	eax, [ebp-11Ch]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z proc	near
					; DATA XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-164h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z
		jmp	___CxxFrameHandler3
__ehhandler$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C2DCh
__unwindtable$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C2F4o
		dd offset __unwindfunclet$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z$1
__ehfuncinfo$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z+14o
		dd offset __unwindtable$?getLanguageBreakEngine@RuleBasedBreakIterator@icu_56@@AAEPBVLanguageBreakEngine@2@H@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C310h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; class	icu_56::LanguageBreakEngine const * __cdecl icu_56::getLanguageBreakEngineFromFactory(int, int)
?getLanguageBreakEngineFromFactory@icu_56@@YAPBVLanguageBreakEngine@1@HH@Z proc	near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+1BDp

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi		; void (__cdecl	*)()
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	offset ?initLanguageFactories@icu_56@@YAXXZ ; struct icu_56::UInitOnce *
		push	offset _gLanguageBreakFactoriesInitOnce	; this
		call	?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXXZ@Z ; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))
		add	esp, 8
		cmp	ds:_gLanguageBreakFactories, 0
		jnz	short loc_C34D
		xor	eax, eax
		jmp	short loc_C3AD
; ---------------------------------------------------------------------------

loc_C34D:				; CODE XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+37j
		mov	ecx, ds:_gLanguageBreakFactories ; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		mov	[ebp+var_8], eax
		mov	[ebp+var_14], 0

loc_C362:				; CODE XREF: icu_56::getLanguageBreakEngineFromFactory(int,int):loc_C3A8j
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax
		js	short loc_C3AA
		mov	eax, [ebp+var_8]
		push	eax		; int
		mov	ecx, ds:_gLanguageBreakFactories ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		mov	[ebp+var_20], eax
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_20]
		mov	eax, [edx]
		mov	ecx, [ebp+var_20]
		mov	edx, [eax+4]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_C3A8
		jmp	short loc_C3AA
; ---------------------------------------------------------------------------

loc_C3A8:				; CODE XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+94j
		jmp	short loc_C362
; ---------------------------------------------------------------------------

loc_C3AA:				; CODE XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+5Bj
					; icu_56::getLanguageBreakEngineFromFactory(int,int)+96j
		mov	eax, [ebp+var_14]

loc_C3AD:				; CODE XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+3Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getLanguageBreakEngineFromFactory@icu_56@@YAPBVLanguageBreakEngine@1@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C3C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::umtx_initOnce(icu_56 *__hidden this, struct icu_56::UInitOnce *,	void (__cdecl *)())
		public ?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXXZ@Z
?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXXZ@Z proc near
					; CODE XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+28p

var_C0		= byte ptr -0C0h
Destination	= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi		; struct icu_56::UInitOnce *
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+Destination]
		push	eax		; Destination
		call	?umtx_loadAcquire@icu_56@@YAHACJ@Z ; icu_56::umtx_loadAcquire(long volatile &)
		add	esp, 4
		cmp	eax, 2
		jnz	short loc_C3F5
		jmp	short loc_C420
; ---------------------------------------------------------------------------

loc_C3F5:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))+2Dj
		mov	eax, [ebp+Destination]
		push	eax		; this
		call	?umtx_initImplPreInit@icu_56@@YACAAUUInitOnce@1@@Z ; icu_56::umtx_initImplPreInit(icu_56::UInitOnce &)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C420
		mov	esi, esp
		call	[ebp+arg_4]
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+Destination]
		push	eax		; this
		call	?umtx_initImplPostInit@icu_56@@YAXAAUUInitOnce@1@@Z ; icu_56::umtx_initImplPostInit(icu_56::UInitOnce &)
		add	esp, 4

loc_C420:				; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))+2Fj
					; icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))+42j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_initOnce@icu_56@@YAXAAUUInitOnce@1@P6AXXZ@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C434h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::umtx_loadAcquire(volatile	LONG *Destination, volatile __int32 *)
		public ?umtx_loadAcquire@icu_56@@YAHACJ@Z
?umtx_loadAcquire@icu_56@@YAHACJ@Z proc	near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))+22p

var_C0		= byte ptr -0C0h
Destination	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		push	0		; Comperand
		push	0		; Exchange
		mov	eax, [ebp+Destination]
		push	eax		; Destination
		call	dword ptr ds:__imp__InterlockedCompareExchange@12 ; InterlockedCompareExchange(x,x,x)
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?umtx_loadAcquire@icu_56@@YAHACJ@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C480h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UInitOnce icu_56::initLanguageFactories
?initLanguageFactories@icu_56@@YAXXZ proc near
					; DATA XREF: icu_56::getLanguageBreakEngineFromFactory(int,int)+1Eo

var_118		= dword	ptr -118h
var_110		= dword	ptr -110h
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?initLanguageFactories@icu_56@@YAXXZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_118]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], 0
		cmp	ds:_gLanguageBreakFactories, 0
		jz	short loc_C4F2
		mov	eax, ds:?__LINE__Var@?1??initLanguageFactories@icu_56@@YAXXZ@4JA@9c7d53cf
		add	eax, 2
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FG@CBBHOA@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@	; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1DK@NEHJOPFH@?$AAg?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AAB?$AAr?$AAe?$AAa?$AAk?$AAF?$AAa?$AAc?$AAt?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@	; "gLanguageBreakFactories == 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_C4F2:				; CODE XREF: icu_56::initLanguageFactories(void)+4Bj
		push	18h		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_104], 0
		jz	short loc_C530
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		push	0		; signed __int8	(__cdecl __high	*)(union UElement, union UElement)
		push	offset __deleteFactory ; void (__cdecl *)(void *)
		mov	ecx, [ebp+var_104] ; this
		call	??0UStack@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z ; icu_56::UStack::UStack(void (*)(void *),signed char (*)(UElement,UElement),UErrorCode &)
		mov	[ebp+var_118], eax
		jmp	short loc_C53A
; ---------------------------------------------------------------------------

loc_C530:				; CODE XREF: icu_56::initLanguageFactories(void)+90j
		mov	[ebp+var_118], 0

loc_C53A:				; CODE XREF: icu_56::initLanguageFactories(void)+AEj
		mov	ecx, [ebp+var_118]
		mov	[ebp+var_110], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_110]
		mov	ds:_gLanguageBreakFactories, edx
		cmp	ds:_gLanguageBreakFactories, 0
		jz	loc_C5E9
		mov	eax, [ebp+var_14]
		push	eax
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_C5E9
		push	8		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_EC], 0
		jz	short loc_C5B0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_EC] ; this
		call	??0ICULanguageBreakFactory@icu_56@@QAE@AAW4UErrorCode@@@Z ; icu_56::ICULanguageBreakFactory::ICULanguageBreakFactory(UErrorCode	&)
		mov	[ebp+var_118], eax
		jmp	short loc_C5BA
; ---------------------------------------------------------------------------

loc_C5B0:				; CODE XREF: icu_56::initLanguageFactories(void)+117j
		mov	[ebp+var_118], 0

loc_C5BA:				; CODE XREF: icu_56::initLanguageFactories(void)+12Ej
		mov	ecx, [ebp+var_118]
		mov	[ebp+var_F8], ecx
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_20], edx
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_20]
		push	ecx		; void *
		mov	ecx, ds:_gLanguageBreakFactories ; this
		call	?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z ; icu_56::UStack::push(void *,UErrorCode &)

loc_C5E9:				; CODE XREF: icu_56::initLanguageFactories(void)+E0j
					; icu_56::initLanguageFactories(void)+F7j
		push	offset _breakiterator_cleanup_dict
		push	2
		call	_ucln_common_registerCleanup_56
		add	esp, 8
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN14_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 118h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?initLanguageFactories@icu_56@@YAXXZ endp

; ---------------------------------------------------------------------------
$LN14_1		dd 1			; DATA XREF: icu_56::initLanguageFactories(void)+17Co
		dd offset $LN13_1
$LN13_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:0000C62Co
		dd offset $LN11_1	; "status"
$LN11_1		db 'status',0           ; DATA XREF: .text:0000C638o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initLanguageFactories@icu_56@@YAXXZ$0 proc near
					; DATA XREF: .xdata$x:0000C6C4o
		mov	eax, [ebp-104h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?initLanguageFactories@icu_56@@YAXXZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?initLanguageFactories@icu_56@@YAXXZ$1 proc near
					; DATA XREF: .xdata$x:0000C6CCo
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?initLanguageFactories@icu_56@@YAXXZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?initLanguageFactories@icu_56@@YAXXZ proc near
					; DATA XREF: icu_56::initLanguageFactories(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-11Ch]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?initLanguageFactories@icu_56@@YAXXZ
		jmp	___CxxFrameHandler3
__ehhandler$?initLanguageFactories@icu_56@@YAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C680h
		public ??_C@_1DK@NEHJOPFH@?$AAg?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AAB?$AAr?$AAe?$AAa?$AAk?$AAF?$AAa?$AAc?$AAt?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1DK@NEHJOPFH@?$AAg?$AAL?$AAa?$AAn?$AAg?$AAu?$AAa?$AAg?$AAe?$AAB?$AAr?$AAe?$AAa?$AAk?$AAF?$AAa?$AAc?$AAt?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::initLanguageFactories(void)+5Do
		unicode	0, <gLanguageBreakFactories == 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0C6BCh
		public ?__LINE__Var@?1??initLanguageFactories@icu_56@@YAXXZ@4JA@9c7d53cf
?__LINE__Var@?1??initLanguageFactories@icu_56@@YAXXZ@4JA@9c7d53cf dd 6DDh
					; DATA XREF: icu_56::initLanguageFactories(void)+4Dr
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C6C0h
__unwindtable$?initLanguageFactories@icu_56@@YAXXZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000C6D8o
		dd offset __unwindfunclet$?initLanguageFactories@icu_56@@YAXXZ$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?initLanguageFactories@icu_56@@YAXXZ$1
__ehfuncinfo$?initLanguageFactories@icu_56@@YAXXZ dd 19930522h,	2
					; DATA XREF: __ehhandler$?initLanguageFactories@icu_56@@YAXXZ+14o
		dd offset __unwindtable$?initLanguageFactories@icu_56@@YAXXZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C6F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_breakiterator_cleanup_dict proc near	; DATA XREF: icu_56::initLanguageFactories(void):loc_C5E9o

var_DC		= dword	ptr -0DCh
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	ds:_gLanguageBreakFactories, 0
		jz	short loc_C774
		mov	eax, ds:_gLanguageBreakFactories
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+var_C8]
		mov	[ebp+var_D4], ecx
		cmp	[ebp+var_D4], 0
		jz	short loc_C760
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_D4]
		mov	eax, [edx]
		mov	ecx, [ebp+var_D4]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_DC], eax
		jmp	short loc_C76A
; ---------------------------------------------------------------------------

loc_C760:				; CODE XREF: _breakiterator_cleanup_dict+45j
		mov	[ebp+var_DC], 0

loc_C76A:				; CODE XREF: _breakiterator_cleanup_dict+6Aj
		mov	ds:_gLanguageBreakFactories, 0

loc_C774:				; CODE XREF: _breakiterator_cleanup_dict+25j
		mov	ecx, offset _gLanguageBreakFactoriesInitOnce ; this
		call	?reset@UInitOnce@icu_56@@QAEXXZ	; icu_56::UInitOnce::reset(void)
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_breakiterator_cleanup_dict endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C794h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UInitOnce::reset(icu_56::UInitOnce *__hidden this)
		public ?reset@UInitOnce@icu_56@@QAEXXZ
?reset@UInitOnce@icu_56@@QAEXXZ	proc near ; CODE XREF: _breakiterator_cleanup_dict+85p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?reset@UInitOnce@icu_56@@QAEXXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl _deleteFactory(void *)
__deleteFactory	proc near		; DATA XREF: icu_56::initLanguageFactories(void)+98o

var_DC		= dword	ptr -0DCh
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+var_C8]
		mov	[ebp+var_D4], ecx
		cmp	[ebp+var_D4], 0
		jz	short loc_C829
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_D4]
		mov	eax, [edx]
		mov	ecx, [ebp+var_D4]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_DC], eax
		jmp	short loc_C833
; ---------------------------------------------------------------------------

loc_C829:				; CODE XREF: __deleteFactory+3Aj
		mov	[ebp+var_DC], 0

loc_C833:				; CODE XREF: __deleteFactory+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__deleteFactory	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C848h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::RuleBasedBreakIterator::setBreakType(icu_56::RuleBasedBreakIterator *this, int)
		public ?setBreakType@RuleBasedBreakIterator@icu_56@@MAEXH@Z
?setBreakType@RuleBasedBreakIterator@icu_56@@MAEXH@Z proc near ; DATA XREF: .rdata:00005C74o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+174h], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+64h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setBreakType@RuleBasedBreakIterator@icu_56@@MAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C924h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_C98E
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_C99A
; ---------------------------------------------------------------------------

loc_C98E:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_C99A:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; [thunk]:public: virtual void * __thiscall icu_56::UnicodeFilter::`vector deleting destructor'`adjustor{4}' (unsigned int)
		public ??_EUnicodeFilter@icu_56@@W3AEPAXI@Z
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeFilter::`vftable'{for `icu_56::UnicodeMatcher'}o
		sub	ecx, 4
		jmp	??_EUnicodeFilter@icu_56@@UAEPAXI@Z ; icu_56::UnicodeFilter::`vector deleting destructor'(uint)
??_EUnicodeFilter@icu_56@@W3AEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000244o
					; .rdata:000004F8o ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:000004FCo
					; .rdata:00000500o ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00000508o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:0000050Co
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:00000BB8o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:00000BBCo
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001134o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00001138o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:0000113Co
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00001140o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001144o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00001148o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:0000114Co
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00001150o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00001154o
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+6Bp
		extrn ___security_cookie:near
					; DATA XREF: icu_56::StringEnumeration::StringEnumeration(icu_56::StringEnumeration const &)+2Er
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	*,UErrorCode &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+19j
					; __ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z+19j	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0StringEnumeration@icu_56@@QAE@ABV01@@Z+Fp
					; __ehhandler$??0RuleBasedBreakIterator@icu_56@@IAE@PAURBBIDataHeader@1@AAW4UErrorCode@@@Z+Fp ...
; public: virtual class	icu_56::StringEnumeration * __thiscall icu_56::StringEnumeration::clone(void)const
		extrn ?clone@StringEnumeration@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:0000413Co
; public: virtual char const * __thiscall icu_56::StringEnumeration::next(int *, enum  UErrorCode &)
		extrn ?next@StringEnumeration@icu_56@@UAEPBDPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004144o
; public: virtual wchar_t const	* __thiscall icu_56::StringEnumeration::unext(int *, enum  UErrorCode &)
		extrn ?unext@StringEnumeration@icu_56@@UAEPB_WPAHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004148o
; public: virtual class	icu_56::UnicodeString const * __thiscall icu_56::StringEnumeration::snext(enum	UErrorCode &)
		extrn ?snext@StringEnumeration@icu_56@@UAEPBVUnicodeString@2@AAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:0000414Co
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator==(class icu_56::StringEnumeration const &)const
		extrn ??8StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00004154o
; public: virtual signed char __thiscall icu_56::StringEnumeration::operator!=(class icu_56::StringEnumeration const &)const
		extrn ??9StringEnumeration@icu_56@@UBECABV01@@Z:near
					; DATA XREF: .rdata:00004158o
; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(class icu_56::UnicodeString	const &)
		extrn ??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::StringEnumeration::operator=(icu_56::StringEnumeration const &)+3Cp
; _DWORD __thiscall icu_56::StringEnumeration::~StringEnumeration(icu_56::StringEnumeration *__hidden this)
		extrn ??1StringEnumeration@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::StringEnumeration::`scalar	deleting destructor'(uint)+26p
					; icu_56::StringEnumeration::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: signed char __thiscall icu_56::Locale::operator==(class icu_56::Locale const &)const
		extrn ??8Locale@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::Locale::operator!=(icu_56::Locale const &)+2Ap
; public: virtual int __thiscall icu_56::BreakIterator::getRuleStatus(void)const
		extrn ?getRuleStatus@BreakIterator@icu_56@@UBEHXZ:near
					; DATA XREF: .rdata:0000460Co
; public: virtual int __thiscall icu_56::BreakIterator::getRuleStatusVec(int *,	int, enum  UErrorCode &)
		extrn ?getRuleStatusVec@BreakIterator@icu_56@@UAEHPAHHAAW4UErrorCode@@@Z:near
					; DATA XREF: .rdata:00004610o
; _DWORD __thiscall icu_56::BreakIterator::~BreakIterator(icu_56::BreakIterator	*__hidden this)
		extrn ??1BreakIterator@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::BreakIterator::`scalar deleting destructor'(uint)+26p
					; icu_56::BreakIterator::`vector deleting destructor'(uint)+67p ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFunctor::toMatcher(void)const
		extrn ?toMatcher@UnicodeFunctor@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:0000495Co
; public: virtual class	icu_56::UnicodeReplacer	* __thiscall icu_56::UnicodeFunctor::toReplacer(void)const
		extrn ?toReplacer@UnicodeFunctor@icu_56@@UBEPAVUnicodeReplacer@2@XZ:near
					; DATA XREF: .rdata:00004960o
					; .rdata:00004E3Co
; _DWORD __thiscall icu_56::UnicodeFunctor::~UnicodeFunctor(icu_56::UnicodeFunctor *__hidden this)
		extrn ??1UnicodeFunctor@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFunctor::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFunctor::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UnicodeMatcher::~UnicodeMatcher(icu_56::UnicodeMatcher *__hidden this)
		extrn ??1UnicodeMatcher@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeMatcher::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeMatcher::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual class	icu_56::UnicodeMatcher * __thiscall icu_56::UnicodeFilter::toMatcher(void)const
		extrn ?toMatcher@UnicodeFilter@icu_56@@UBEPAVUnicodeMatcher@2@XZ:near
					; DATA XREF: .rdata:00004E38o
; public: virtual void __thiscall icu_56::UnicodeFilter::setData(class icu_56::TransliterationRuleData const *)
		extrn ?setData@UnicodeFilter@icu_56@@UAEXPBVTransliterationRuleData@2@@Z:near
					; DATA XREF: .rdata:00004E40o
; public: virtual enum	icu_56::UMatchDegree __thiscall	icu_56::UnicodeFilter::matches(class icu_56::Replaceable const &, int &, int, signed char)
		extrn ?matches@UnicodeFilter@icu_56@@UAE?AW4UMatchDegree@2@ABVReplaceable@2@AAHHC@Z:near
					; DATA XREF: .rdata:00004E18o
; _DWORD __thiscall icu_56::UnicodeFilter::~UnicodeFilter(icu_56::UnicodeFilter	*__hidden this)
		extrn ??1UnicodeFilter@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeFilter::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeFilter::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, int, int)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECHH@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(int,int)+2Ep
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, const struct icu_56::UnicodeSet *)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECABV12@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeSet const &)+2Ap
; signed __int8	__thiscall icu_56::UnicodeSet::containsNone(icu_56::UnicodeSet *__hidden this, const struct icu_56::UnicodeString *)
		extrn ?containsNone@UnicodeSet@icu_56@@QBECABVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::UnicodeSet::containsSome(icu_56::UnicodeString const &)+2Ap
; int __thiscall __high	icu_56::UnicodeSet::span(const wchar_t *, int, enum USetSpanCondition)
		extrn ?span@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::span(icu_56::UnicodeString const &,int,USetSpanCondition)+68p
; int __thiscall __high	icu_56::UnicodeSet::spanBack(const wchar_t *, int, enum	USetSpanCondition)
		extrn ?spanBack@UnicodeSet@icu_56@@QBEHPB_WHW4USetSpanCondition@@@Z:near
					; CODE XREF: icu_56::UnicodeSet::spanBack(icu_56::UnicodeString	const &,int,USetSpanCondition)+5Fp
; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *__hidden this, void *, int)
		extrn ?indexOf@UVector@icu_56@@QBEHPAXH@Z:near
					; CODE XREF: icu_56::UVector::contains(void *)+2Cp
; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *__hidden this, int, int)
		extrn ?indexOf@UVector@icu_56@@QBEHHH@Z:near
					; CODE XREF: icu_56::UVector::contains(int)+2Cp
; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *__hidden	this, int)
		extrn ?elementAt@UVector@icu_56@@QBEPAXH@Z:near
					; CODE XREF: icu_56::UVector::firstElement(void)+28p
					; icu_56::UVector::lastElement(void)+30p ...
; int __thiscall icu_56::UVector::elementAti(icu_56::UVector *__hidden this, int)
		extrn ?elementAti@UVector@icu_56@@QBEHH@Z:near
					; CODE XREF: icu_56::UVector::lastElementi(void)+30p
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+11A6p ...
; public: signed char __thiscall icu_56::UVector::operator==(class icu_56::UVector const &)
		extrn ??8UVector@icu_56@@QAECABV01@@Z:near
					; CODE XREF: icu_56::UVector::operator!=(icu_56::UVector const &)+2Ap
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, void *, enum UErrorCode *)
		extrn ?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UStack::push(void *,UErrorCode &)+2Ep
; void __thiscall icu_56::UVector::addElement(icu_56::UVector *__hidden	this, int, enum	UErrorCode *)
		extrn ?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::UStack::push(int,UErrorCode &)+2Ep
; _DWORD __thiscall icu_56::SymbolTable::~SymbolTable(icu_56::SymbolTable *__hidden this)
		extrn ??1SymbolTable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::SymbolTable::`scalar deleting destructor'(uint)+26p
					; icu_56::SymbolTable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::RBBIDataWrapper::RBBIDataWrapper(icu_56::RBBIDataWrapper *__hidden this, const struct icu_56::RBBIDataHeader *, enum UErrorCode *)
		extrn ??0RBBIDataWrapper@icu_56@@QAE@PBURBBIDataHeader@1@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+90p
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn ??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+67p
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+67p ...
; _DWORD __thiscall icu_56::BreakIterator::BreakIterator(icu_56::BreakIterator *__hidden this)
		extrn ??0BreakIterator@icu_56@@IAE@XZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader *,UErrorCode	&)+45p
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader	const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+45p ...
; _DWORD __thiscall __high icu_56::RBBIDataWrapper::RBBIDataWrapper(const struct icu_56::RBBIDataHeader	*, enum	icu_56::RBBIDataWrapper::EDontAdopt, enum UErrorCode *)
		extrn ??0RBBIDataWrapper@icu_56@@QAE@PBURBBIDataHeader@1@W4EDontAdopt@01@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::RBBIDataHeader const *,icu_56::RuleBasedBreakIterator::EDontAdopt,UErrorCode &)+92p
					; icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(uchar const *,uint,UErrorCode &)+E5p
; _DWORD __thiscall icu_56::RBBIDataWrapper::RBBIDataWrapper(icu_56::RBBIDataWrapper *__hidden this, struct UDataMemory	*, enum	UErrorCode *)
		extrn ??0RBBIDataWrapper@icu_56@@QAE@PAUUDataMemory@@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory	*,UErrorCode &)+90p
; struct icu_56::BreakIterator *__cdecl	static icu_56::RBBIRuleBuilder::createRuleBasedBreakIterator(const struct icu_56::UnicodeString	*, struct UParseError *, enum UErrorCode *)
		extrn ?createRuleBasedBreakIterator@RBBIRuleBuilder@icu_56@@SAPAVBreakIterator@2@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::RuleBasedBreakIterator(icu_56::UnicodeString const	&,UParseError &,UErrorCode &)+88p
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+1E9p
					; icu_56::RuleBasedBreakIterator::reset(void)+39p
; void __thiscall icu_56::RBBIDataWrapper::removeReference(icu_56::RBBIDataWrapper *__hidden this)
		extrn ?removeReference@RBBIDataWrapper@icu_56@@QAEXXZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+1C1p
					; icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+1D1p
		extrn _utext_close_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::~RuleBasedBreakIterator(void)+1A4p
; struct icu_56::RBBIDataWrapper *__thiscall icu_56::RBBIDataWrapper::addReference(icu_56::RBBIDataWrapper *__hidden this)
		extrn ?addReference@RBBIDataWrapper@icu_56@@QAEPAV12@XZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+1F8p
		extrn _utext_clone_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+EAp
					; icu_56::RuleBasedBreakIterator::setText(UText	*,UErrorCode &)+88p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::operator=(icu_56::RuleBasedBreakIterator const &)+213p
					; icu_56::RuleBasedBreakIterator::init(void)+145p ...
; char *__cdecl	_getenv(const char *VarName)
		extrn __imp__getenv:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::init(void)+FFp
					; DATA XREF: icu_56::RuleBasedBreakIterator::init(void)+FFr
		extrn _utext_openUChars_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::init(void)+36p
					; icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+EDp
; char *__cdecl	_strstr(const char *Str, const char *SubStr)
		extrn __imp__strstr:near ; CODE	XREF: strstr(char *,char const *)+28p
					; DATA XREF: strstr(char *,char	const *)+28r
; public: signed char __thiscall icu_56::RBBIDataWrapper::operator==(class icu_56::RBBIDataWrapper const &)const
		extrn ??8RBBIDataWrapper@icu_56@@QBECABV01@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+C4p
		extrn _utext_equals_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+72p
; __declspec(dllimport)	public:	bool __thiscall	type_info::operator!=(class type_info const &)const
		extrn __imp_??9type_info@@QBE_NABV0@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+40p
					; DATA XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+40r
		extrn ___RTtypeid:near	; CODE XREF: icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+27p
					; icu_56::RuleBasedBreakIterator::operator==(icu_56::BreakIterator const &)+36p
; int __thiscall icu_56::RBBIDataWrapper::hashCode(icu_56::RBBIDataWrapper *__hidden this)
		extrn ?hashCode@RBBIDataWrapper@icu_56@@QAEHXZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::hashCode(void)+3Fp
; _DWORD __thiscall icu_56::UCharCharacterIterator::UCharCharacterIterator(icu_56::UCharCharacterIterator *__hidden this, const	wchar_t	*, int)
		extrn ??0UCharCharacterIterator@icu_56@@QAE@PB_WH@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::setText(UText *,UErrorCode	&)+D6p
; const	struct icu_56::UnicodeString *__thiscall icu_56::RBBIDataWrapper::getRuleSourceString(icu_56::RBBIDataWrapper *__hidden	this)
		extrn ?getRuleSourceString@RBBIDataWrapper@icu_56@@QBEABVUnicodeString@2@XZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getRules(void)+57p
		extrn _utext_openCharacterIterator_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::adoptText(icu_56::CharacterIterator *)+112p
; void __thiscall icu_56::StringCharacterIterator::setText(icu_56::StringCharacterIterator *__hidden this, const struct	icu_56::UnicodeString *)
		extrn ?setText@StringCharacterIterator@icu_56@@QAEXABVUnicodeString@2@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+100p
; _DWORD __thiscall icu_56::StringCharacterIterator::StringCharacterIterator(icu_56::StringCharacterIterator *__hidden this, const struct icu_56::UnicodeString	*)
		extrn ??0StringCharacterIterator@icu_56@@QAE@ABVUnicodeString@1@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+B8p
		extrn _utext_openConstUnicodeString_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::setText(icu_56::UnicodeString const &)+71p
		extrn _utext_setNativeIndex_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+C2p
					; icu_56::RuleBasedBreakIterator::first(void)+5Ep ...
		extrn _utext_getNativeIndex_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+61p
					; icu_56::RuleBasedBreakIterator::refreshInputText(UText *,UErrorCode &)+D4p ...
		extrn _utext_nativeLength_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::last(void)+75p
					; icu_56::RuleBasedBreakIterator::following(int)+41p ...
		extrn _utext_previous32_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::previous(void)+1FEp
					; icu_56::RuleBasedBreakIterator::following(int)+399p ...
		extrn _utext_next32_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::following(int)+285p
					; icu_56::RuleBasedBreakIterator::preceding(int)+343p ...
		extrn _utext_previous32From_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::isBoundary(int)+11Ap
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+4CAp
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+673p ...
; int _printf(const char *Format, ...)
		extrn __imp__printf:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+42Cp
					; icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+453p ...
; int __cdecl _puts(const char *Str)
		extrn __imp__puts:near	; CODE XREF: icu_56::RuleBasedBreakIterator::handleNext(icu_56::RBBIStateTable const *)+88p
					; icu_56::RuleBasedBreakIterator::handlePrevious(icu_56::RBBIStateTable	const *)+66p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::UStack::~UStack(icu_56::UStack *__hidden this)
		extrn ??1UStack@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1309p
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+1345p ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+11E5p
		extrn _utext_current32_56:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+194p
					; icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+355p ...
; _DWORD __thiscall icu_56::UStack::UStack(icu_56::UStack *__hidden this, enum UErrorCode *)
		extrn ??0UStack@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::checkDictionary(int,int,signed char)+177p
					; icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+8Ap
; void __thiscall icu_56::UVector::insertElementAt(icu_56::UVector *__hidden this, void	*, int,	enum UErrorCode	*)
		extrn ?insertElementAt@UVector@icu_56@@QAEXPAXHAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+29Ep
; _DWORD __thiscall icu_56::UnhandledEngine::UnhandledEngine(icu_56::UnhandledEngine *__hidden this, enum UErrorCode *)
		extrn ??0UnhandledEngine@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::RuleBasedBreakIterator::getLanguageBreakEngine(int)+226p
; void __cdecl icu_56::umtx_initImplPostInit(icu_56 *__hidden this, struct icu_56::UInitOnce *)
		extrn ?umtx_initImplPostInit@icu_56@@YAXAAUUInitOnce@1@@Z:near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))+54p
; signed __int8	__cdecl	icu_56::umtx_initImplPreInit(icu_56 *__hidden this, struct icu_56::UInitOnce *)
		extrn ?umtx_initImplPreInit@icu_56@@YACAAUUInitOnce@1@@Z:near
					; CODE XREF: icu_56::umtx_initOnce(icu_56::UInitOnce &,void (*)(void))+35p
; LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination,	LONG Exchange, LONG Comperand)
		extrn __imp__InterlockedCompareExchange@12:near
					; CODE XREF: icu_56::umtx_loadAcquire(long volatile &)+28p
					; DATA XREF: icu_56::umtx_loadAcquire(long volatile &)+28r
		extrn _ucln_common_registerCleanup_56:near
					; CODE XREF: icu_56::initLanguageFactories(void)+170p
; _DWORD __thiscall icu_56::ICULanguageBreakFactory::ICULanguageBreakFactory(icu_56::ICULanguageBreakFactory *__hidden this, enum UErrorCode *)
		extrn ??0ICULanguageBreakFactory@icu_56@@QAE@AAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::initLanguageFactories(void)+123p
; _DWORD __thiscall icu_56::UStack::UStack(icu_56::UStack *__hidden this, void (__cdecl	*)(void	*), signed __int8 (__cdecl __high *)(union UElement, union UElement), enum UErrorCode *)
		extrn ??0UStack@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z:near
					; CODE XREF: icu_56::initLanguageFactories(void)+A3p


		end
