;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	625DE474590D4F8B0B6AEAB8745EB004
; Input	CRC32 :	BE0F5678

; File Name   :	D:\compspace\objfiles\firefox\common\ucase.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9 ; DATA XREF: .rdata:00003618o
					; .rdata:00004558o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
					; DATA XREF: .rdata:00004468o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0	; DATA XREF: .rdata:00002640o
					; .rdata:00002A10o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset off_100
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_800
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset dword_1000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset aLlddddd ; "LLDDDDD"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset aDd ; "dd``"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ??PUnicodeString@icu_56@@QBECABV01@@Z ; icu_56::UnicodeString::operator>=(icu_56::UnicodeString const &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	dword_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_E00
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset dword_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
_ucase_props_indexes dd	10h, 67EAh	; DATA XREF: .rdata:000068DCo
off_100		dd offset dword_5658	; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		dd offset byte_737
		dd offset word_172
		dd 0Ah dup(0)
		dd 3
_ucase_props_trieIndex dd 31E0316h, 32E0326h, 344033Ch,	354034Ch, 364035Ch, 373036Bh
					; DATA XREF: .rdata:000068E8o
		dd 383037Bh, 393038Bh, 3A10399h, 3B103A9h, 3C103B9h, 3D103C9h
		dd 3E103D9h, 3F103E9h
		db 0F9h, 3
word_172	dw 401h			; DATA XREF: .rdata:00000108o
		dd 4110409h, 4210419h, 42D0425h, 43D0435h, 44D0445h, 4510449h
		dd 45E0456h, 46D0465h, 47D0475h, 48D0485h, 49D0495h, 33D0335h
		dd 4AA04A2h, 4B704AFh, 4C704BFh, 4CE04C6h, 4DB04D3h, 4E904E2h
		dd 33504EDh
dword_1C0	dd 3160335h, 4F50335h, 4FF04FDh, 50F0507h, 5140513h, 524051Ch
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		dd 514052Ch, 5390534h, 514052Ch, 5240541h, 5450513h, 524054Dh
		dd 3350552h, 335055Ah, 4C8048Ch, 5240562h
dword_200	dd 5450513h, 5240569h, 3350513h, 524051Ch, 3350335h, 335056Fh
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		dd 5750335h, 335057Ch, 5800335h, 3350588h, 593058Ch, 59A0335h
		dd 5A905A2h, 33505B1h, 5B60335h, 5C605BEh, 5D605CEh, 47B05DEh
		dd 9 dup(3350335h), 33505E2h, 5F20335h,	5EA05FAh, 0Ch dup(3350335h)
		dd 6020602h, 5200520h, 6080335h, 3350610h, 3350618h, 3350620h
		dd 6260335h, 3350335h, 62E0335h, 3 dup(3350335h), 3350635h
		dd 644063Ch, 64C0335h, 3350335h, 6570654h, 665065Fh, 675066Dh
		dd 67C0335h, 6810335h, 6870335h, 3350335h, 697068Fh, 6A4069Fh
		dd 6AF06A7h, 6B706BFh, 6C706CFh, 6D7035Ch, 6DF035Ch, 35C06E2h
		dd 35C06EAh, 6FA06F2h, 70A0702h, 71A0712h, 72A0722h, 7390732h
		dd 7410335h, 3350749h, 7590751h, 7690761h, 7790771h, 3350781h
		dd 0Bh dup(3350335h), 7840335h,	790078Ah, 1Ch dup(3350335h)
		dd 79D0798h, 7A907A1h
dword_400	dd 35C035Ch, 7B1035Ch, 7C107B9h, 7C60335h, 3350335h, 7CE0335h
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		dd 61D0335h, 7 dup(3350335h), 7D60512h,	3350335h, 33507DDh
		dd 7E50335h, 0BBh dup(3350335h)
		db 35h,	3, 35h
byte_737	db 3			; DATA XREF: .rdata:00000104o
		dd 32h dup(3350335h)
dword_800	dd 0CEh	dup(3350335h), 33507EDh, 12h dup(3350335h), 6870335h
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		dd 4 dup(3350335h), 33507F3h, 7FB035Ch,	3350803h, 80B0335h
		dd 81B0813h, 820035Ch, 82E0828h, 8340335h, 52B083Ch, 2 dup(3350335h)
		dd 84B0843h, 8520335h, 3350859h, 85E04FDh, 52B0866h, 86C0335h
		dd 8780874h, 8800335h, 8900888h, 8960335h, 8A2089Ah, 8AA08B2h
		dd 8BA0335h, 82h dup(3350335h)
dword_E00	dd 80h dup(3350335h)	; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
dword_1000	dd 3Ah dup(3350335h), 33508C2h,	3350335h, 8CA0335h, 335066Dh
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		dd 8 dup(3350335h), 8D708CFh, 33508DBh,	3350335h, 3180335h
		dd 8E3031Eh, 8F208EBh, 33504C8h, 8FA0335h, 10h dup(3350335h)
		dd 0CD80CD8h, 0D300CF0h, 0DAC0D70h, 0E2C0DECh, 0EA40E64h
		dd 0F240EE4h, 0FA40F64h, 10240FE4h, 10941064h, 111410D4h
		dd 11581124h, 11D41194h, 12541214h, 12880CD4h, 12FC12BCh
		dd 134C1318h, 0A1109E1h, 0A8C0A51h, 4 dup(1880188h), 0AB50188h
		dd 4 dup(1880188h), 0AF20188h, 1880188h, 0B660B27h, 0BA00188h
		dd 1880BD7h, 0C0h dup(1880188h), 3350C17h, 7 dup(3350335h)
		dd 3350621h, 3 dup(3350335h), 3350902h,	3350335h, 3350905h
		dd 3350335h, 90D0335h, 9170913h, 0Eh dup(3350335h), 91F0335h
		dd 3350923h, 2 dup(3350335h), 335092Bh,	5 dup(3350335h)
		dd 9330335h, 93F0937h, 3350943h, 0Bh dup(3350335h), 5130335h
		dd 94F0948h, 66D0951h, 3350959h, 9610335h, 3350968h, 66D0954h
		dd 976096Eh, 3350335h, 335097Bh, 3350335h, 3180335h, 66D0983h
		dd 98B0514h, 3350992h, 4 dup(3350335h),	9A00998h, 3 dup(3350335h)
		dd 9AC09A4h, 3350335h, 48C09B4h, 3350335h, 33509BCh, 9C20335h
		dd 33509CAh, 2 dup(3350335h), 41D0335h,	33509D2h, 1Ch dup(3350335h)
		dd 33509DAh, 65409E0h, 10h dup(3350335h), 9E60335h, 12h	dup(3350335h)
		dd 65409EEh, 0Dh dup(3350335h),	9FE09F6h, 3350A04h, 3350335h
		dd 0A0C0335h, 6	dup(3350335h), 0A140335h, 0A210A1Ch, 0A2F0A27h
		dd 0A3F0A37h, 0A470A18h, 0A570A4Fh, 0A190A5Eh, 0A1C0A14h
		dd 0A270A17h, 0A150A1Ah, 0A180A66h, 0A760A6Eh, 0A850A7Eh
		dd 0A790A71h, 0A880A81h, 0A900A74h, 8 dup(3350335h), 0A980813h
		dd 0A9F0813h, 0AAE0AA6h, 15h dup(3350335h), 3350AB2h, 1Ch dup(3350335h)
		dd 0ABA0A10h, 0AC00ABAh, 9 dup(3350335h), 3350963h, 0Fh	dup(3350335h)
		dd 5130335h, 8130813h, 3350813h, 3350335h, 8130335h, 3 dup(8130813h)
		dd 33509EAh, 17h dup(3350335h),	3150335h, 13h dup(0)
		dd 40000h, 3 dup(0)
		dd 4, 5	dup(0)
		dd 4, 2	dup(0)
		dd 100A0000h, 3	dup(100A100Ah),	1A100Ah, 0FA00BAh, 3 dup(100A100Ah)
		dd 17A100Ah, 3 dup(100A100Ah), 100Ah, 0
		dd 4, 0F0090004h, 3 dup(0F009F009h), 1F9F009h, 299F029h
		dd 3 dup(0F009F009h), 319F009h,	3 dup(0F009F009h), 0F009h
		dd 22h dup(0)
		dd 4, 1, 2 dup(40000h),	2 dup(0)
		dd 3990004h, 40000h, 4,	1, 2 dup(0)
		dd 2 dup(100A100Ah), 3FA100Ah, 3 dup(100A100Ah), 4BA047Ah
		dd 4 dup(100A100Ah), 100Ah, 3 dup(100A100Ah), 4F9100Ah
		dd 2 dup(0F009F009h), 639F009h,	8 dup(0F009F009h), 0F009h
		dd 3 dup(0F009F009h), 3C89F009h, 14h dup(0FF89008Ah), 0FF8906BAh
		dd 2 dup(0FF89008Ah), 0FFA906FAh, 7F9073Ah, 3 dup(0FF89008Ah)
		dd 8A0001h, 5 dup(8AFF89h), 899FF89h, 17h dup(0FF89008Ah)
		dd 8AC38Ah, 2 dup(8AFF89h), 999FF89h, 690A6189h, 2 dup(0FF89008Ah)
		dd 8A670Ah, 668AFF89h, 8A668Ah,	1FF89h,	650A278Ah, 8A658Ah
		dd 668AFF89h, 3089678Ah, 688A698Ah, 0FF89008Ah,	15189h
		dd 6A8A698Ah, 6B0A4109h, 3 dup(0FF89008Ah), 8A6D0Ah, 6D0AFF89h
		dd 10001h, 0FF89008Ah, 8A6D0Ah,	6C8AFF89h, 8A6C8Ah, 8AFF89h
		dd 6D8AFF89h, 0FF89008Ah, 1, 0FF89008Ah, 1C090001h, 2 dup(0)
dword_1D98	dd 0A5B09FAh, 0B3A0AD9h, 0C190B9Bh, 0CDB0C7Ah, 8A0D59h
		dd 7 dup(8AFF89h), 0D889FF89h, 9 dup(0FF89008Ah), 0EBA0DB9h
		dd 0F990F1Bh, 0FF89008Ah, 0E40ACF8Ah, 10h dup(0FF89008Ah)
		dd 1BF0Ah, 9 dup(0FF89008Ah), 3	dup(10001h), 8A0FFAh, 0AE8AFF89h
		dd 1079103Ah, 8A10B9h, 9E8AFF89h, 238A228Ah, 0FF89008Ah
		dd 0FFA9008Ah, 3 dup(0FF89008Ah), 113910F9h, 97091179h
		dd 19909h, 99899989h, 9B090001h, 9A890001h, 111B9h, 10001h
		dd 11F99989h, 98890001h, 12390001h, 11279h, 968997A9h
		dd 12B90001h, 112F9h, 96890001h, 13390001h, 19589h, 95090001h
		dd 3 dup(10001h), 13790001h, 10001h, 19309h, 93090001h
		dd 10001h, 13B90001h, 0DD899309h, 93899389h, 1DC89h, 2 dup(10001h)
		dd 19289h, 10000h, 3 dup(10001h), 13F90001h, 11439h, 8 dup(10001h)
		dd 50005h, 50025h, 2 dup(50005h), 40005h, 40004h, 2 dup(4000Ch)
		dd 50005h, 0Fh dup(40004h), 2 dup(50005h), 40005h, 0Dh dup(40004h)
aLlddddd:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		unicode	0, <LLDDDDD>
		dw 147Ch
aLdldlddddddldd:
		unicode	0, <LDLDLDDDDDDLDddddddddddddddddddddddddddddldddddddddddDDDD>
		unicode	0, <DLDD>
		dw 149Dh
aDdddddddd:
		unicode	0, <DdddDDDdd>
		dw 4
aDddddddddddddd:
		unicode	0, <DDDddddDdddDdddddddDDDDDDDDDDDDD>
		dw 8Ah
		dw 0FF89h
		dd 0FF89008Ah, 40004h, 0FF89008Ah, 0
		dd 41090005h, 41094109h, 3A0A0000h, 2 dup(0)
		dd 40004h, 4130Ah, 128A128Ah, 128Ah, 200Ah, 1F8A1F8Ah
		dd 100A1539h, 100A16DAh, 175A100Ah, 100A100Ah, 187A17DAh
		dd 100A191Ah, 100A199Ah, 100A100Ah, 1A9A1A1Ah, 1B1A0000h
		dd 100A100Ah, 100A1B9Ah, 1C1A100Ah, 100A100Ah, 0ED89ED09h
		dd 0ED89ED89h, 0F0091C99h, 0F0091E39h, 1EB9F009h, 0F009F009h
		dd 1FD91F39h, 0F0092079h, 0F00920F9h, 0F009F009h, 21F92179h
		dd 22D92279h, 0F009F009h, 0F0092359h, 23D9F009h, 0F009F009h
		dd 0E089E009h, 40AE089h, 24B92459h, 20002h, 25590002h
		dd 0FC0925B9h, 0Ch dup(0FF89008Ah), 26792619h, 0C6290389h
		dd 277926DAh, 8A0000h, 0FC8AFF89h, 0FF89008Ah, 0BF0A0001h
		dd 0BF0ABF0Ah, 8 dup(280A280Ah), 10h dup(100A100Ah), 8 dup(0F009F009h)
		dd 3 dup(0D809D809h), 2	dup(0D809D829h), 3 dup(0D809D809h)
		dd 11h dup(0FF89008Ah),	440000h, 2 dup(440044h), 40004h
		dd 1Bh dup(0FF89008Ah),	8A078Ah, 6 dup(8AFF89h), 0F889FF89h
		dd 18h dup(0FF89008Ah),	180A0000h, 0Ch dup(180A180Ah)
		dd 180Ah, 40000h, 3 dup(0)
		dd 0E8090000h, 10h dup(0E809E809h), 27D9E809h, 4 dup(0)
		dd 640000h, 2 dup(440044h), 440064h, 440044h, 640064h
		dd 3 dup(440044h), 3 dup(640064h), 440044h, 440064h, 640044h
		dd 440064h, 7 dup(640064h), 2 dup(640000h), 64h, 640044h
		dd 640000h, 16h	dup(0)
		dd 4, 5	dup(0)
		dd 3 dup(40004h), 5 dup(0)
aDdddddddddd:
		unicode	0, <DDDDDDDDddd>,0
		dd 4, 11h dup(0)
		dd 4, 4	dup(0)
		dd 640000h, 3 dup(640064h), 440064h, 640044h, 440064h
		dd 2 dup(440044h), 440064h, 640044h, 8 dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 0Ch dup(0)
aDdddddd:
		unicode	0, <DDDDDDD>
		dw 4
		dd 440000h, 440044h, 640044h, 40044h, 440004h, 44h, 440064h
		dd 640044h, 0Ah	dup(0)
		dd 40000h, 640000h, 0Fh	dup(0)
aDddddddddddd_0:
		unicode	0, <DdDDdDDdddDddDdDDDdDdDdDdDD>,0
		dd 1Bh dup(0)
		dd 5 dup(40004h), 4, 16h dup(0)
		dd 440000h, 3 dup(440044h), 440064h, 40004h, 2 dup(0)
		dd 4, 0Bh dup(0)
aDddd:
		unicode	0, <DDDD>
		dd 440004h, 2 dup(440044h), 440004h, 440044h, 440004h
		dd 2 dup(440044h), 0Dh dup(0)
		dd 640000h, 640064h, 3 dup(0)
		dd 640000h, 440044h, 440064h, 640044h, 440044h,	640044h
		dd 2 dup(640064h), 440064h, 440044h, 440064h, 640044h
		dd 440064h, 2 dup(440044h), 40004h, 4, 0Fh dup(0)
		dd 4, 64h, 0
		dd 40000h, 3 dup(40004h), 4, 0
		dd 640000h, 0
		dd 440000h, 440064h, 40044h, 40004h, 5 dup(0)
		dd 40004h, 6 dup(0)
		dd 40000h, 0Fh dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 0
		dd 40000h, 40004h, 4, 3	dup(0)
		dd 640000h, 0Ah	dup(0)
		dd 40004h, 0Eh dup(0)
		dd 40000h, 4, 0Eh dup(0)
		dd 40000h, 4, 0
		dd 40000h, 4, 40000h, 640004h, 0
		dd 40000h, 9 dup(0)
		dd 40004h, 0
		dd 40000h, 5 dup(0)
		dd 40000h, 2 dup(40004h), 40000h, 4, 0
		dd 640000h, 0Fh	dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 2 dup(40000h), 40004h, 4, 3 dup(0)
		dd 640000h, 4 dup(0)
		dd 4, 0Eh dup(0)
		dd 4, 5	dup(0)
		dd 640000h, 9 dup(0)
		dd 4, 2	dup(0)
		dd 40004h, 4, 40004h, 640004h, 3 dup(0)
		dd 640000h, 64h, 5 dup(0)
		dd 4, 2	dup(0)
		dd 640004h, 0Ah	dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 3 dup(0)
		dd 40004h, 2 dup(4), 8 dup(0)
		dd 40000h, 0
		dd 2 dup(40004h), 640064h, 64h,	3 dup(0)
		dd 40004h, 2 dup(640064h), 40004h, 4, 8	dup(0)
		dd 40000h, 0
		dd 2 dup(40004h), 640064h, 40000h, 4, 4	dup(0)
		dd 4, 2	dup(640064h), 40004h, 0Dh dup(0)
aDd_0:
		unicode	0, <dd>,0
		align 10h
		dd 0Ah dup(0)
		dd 3 dup(640000h), 9 dup(0)
		dd 640000h, 2 dup(40064h), 2 dup(40004h), 2 dup(640064h)
		dd 4, 40064h, 440044h, 64h, 440044h, 2 dup(0)
		dd 40000h, 5 dup(40004h), 40000h, 0Fh dup(40004h), 4, 4	dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 0Ch dup(0)
		dd 40000h, 40004h, 4, 2	dup(40004h), 640004h, 640000h
		dd 64h,	40000h,	4, 0Ch dup(0)
		dd 40004h, 2 dup(0)
		dd 40004h, 4, 7	dup(0)
		dd 40000h, 40004h, 4, 6	dup(0)
		dd 4, 40000h, 4, 2 dup(0)
		dd 640000h, 7 dup(0)
		dd 40000h, 0
		dd 291A28DAh, 299A295Ah, 2A1A29DAh, 2A9A2A5Ah, 2B1A2ADAh
		dd 2B9A2B5Ah
dword_3000	dd 2C1A2BDAh, 2C9A2C5Ah, 2D1A2CDAh, 2D9A2D5Ah, 2E1A2DDAh
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		dd 2E9A2E5Ah, 2F1A2EDAh, 2F9A2F5Ah, 301A2FDAh, 309A305Ah
		dd 311A30DAh, 319A315Ah, 321A31DAh, 325A0000h, 2 dup(0)
		dd 329A0000h, 0Fh dup(0)
		dd 440000h, 440044h, 4B3A4ADAh,	4BFA4B9Ah, 4CBA4C5Ah, 4D7A4D1Ah
		dd 4E3A4DDAh, 4EFA4E9Ah, 4FBA4F5Ah, 507A501Ah, 513A50DAh
		dd 51FA519Ah, 52BA525Ah, 0
		dd 53795319h, 543953D9h, 54F95499h, 0
		dd 333A32DAh, 33FA339Ah, 34BA345Ah, 357A351Ah, 363A35DAh
		dd 36FA369Ah, 37BA375Ah, 387A381Ah, 393A38DAh, 39FA399Ah
		dd 3ABA3A5Ah, 3B7A3B1Ah, 3C3A3BDAh, 3CFA3C9Ah, 3DBA3D5Ah
		dd 3E7A3E1Ah, 3F3A3EDAh, 3FFA3F9Ah, 40BA405Ah, 417A411Ah
		dd 423A41DAh, 42FA429Ah, 43BA435Ah, 447A441Ah, 453A44DAh
		dd 45FA459Ah, 46BA465Ah, 477A471Ah, 483A47DAh, 48FA489Ah
		dd 49BA495Ah, 4A7A4A1Ah, 9 dup(0)
		dd 40004h, 64h,	0Bh dup(0)
		dd 40004h, 40000h, 3 dup(40004h), 4 dup(0)
		dd 4, 40000h, 4	dup(40004h), 40064h, 0
		dd 40000h, 2 dup(0)
		dd 440000h, 6 dup(0)
		dd 40000h, 40004h, 4, 9	dup(0)
		dd 40000h, 0Eh dup(0)
		dd 640000h, 0Bh	dup(0)
		dd 40004h, 4, 0
		dd 40000h, 4, 4	dup(0)
		dd 4, 2	dup(0)
		dd 640000h, 640044h, 0Bh dup(0)
		dd 440000h, 64h, 40000h, 0Bh dup(0)
		dd 4, 3	dup(40004h), 4,	64h, 4,	40000h,	3 dup(40004h)
		dd 4, 2	dup(0)
		dd 40000h, 440004h, 3 dup(440044h), 44h, 640000h, 3 dup(0)
		dd 40000h, 4 dup(0)
aDddddddddddd_1:
		unicode	0, <DDDDDddddddDDd>
		dd 4, 2	dup(40004h), 0Eh dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 2 dup(40004h), 2 dup(4), 2 dup(0)
		dd 4, 60h, 0Eh dup(0)
		dd 440000h, 440064h, 3 dup(440044h), 6 dup(0)
		dd 40004h, 10h dup(0)
		dd 2 dup(40004h), 0
		dd 40004h, 640060h, 40004h, 0Ah	dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 40004h, 0
		dd 2 dup(40000h), 40004h, 600060h, 6 dup(0)
		dd 4 dup(40004h), 0
		dd 640004h, 0Ch	dup(0)
		dd 3 dup(40004h), 9 dup(0)
aDdd:
		unicode	0, <DDD>,0
aDdddddddddddd:
		unicode	0, <ddddddDDddddD>,0
aDdddddd_0:
		unicode	0, <ddddddd>,0
		dd 0
		dd 640000h, 3 dup(0)
		dd offset ?_Rank@?$_Arithmetic_traits@O@std@@2HB ; int const std::_Arithmetic_traits<long double>::_Rank
		align 10h
aDd_1:
		unicode	0, <DD>,0
		align 10h
		dd 10h dup(10001h), 11h	dup(50005h), 50025h, 3 dup(50005h)
		dd 10005h, 6 dup(10001h), 55590005h, 10001h, 55990001h
		dd 10001h, 2 dup(50005h), 50025h, 50005h, 50025h, 0Bh dup(50005h)
		dd 0Bh dup(10001h), 10021h, 10001h, 50001h, 2 dup(50005h)
		dd 0Bh dup(440044h), 3 dup(0)
aDddddddddddd_2:
		unicode	0, <ddDdDDdDDDDDDDdDDddddDDDDDDDDDDDDDDD>
		dw 8Ah
		dw 0FF89h
		dd 5 dup(0FF89008Ah), 0FFA9008Ah, 9 dup(0FF89008Ah), 565955DAh
		dd 10h dup(0FF89008Ah),	57D956D9h, 59D958D9h, 5BD95AD9h
		dd 10001h, 15C3Ah, 5 dup(0FF89008Ah), 0FFA9008Ah, 0Ah dup(0FF89008Ah)
		dd 4 dup(4090409h), 4 dup(0FC0AFC0Ah), 3 dup(4090409h)
		dd 0
		dd 3 dup(0FC0AFC0Ah), 0
		dd 4 dup(4090409h), 4 dup(0FC0AFC0Ah), 4 dup(4090409h)
		dd 4 dup(0FC0AFC0Ah), 3	dup(4090409h), 0
		dd 3 dup(0FC0AFC0Ah), 0
		dd 4095CD9h, 4095DD9h, 4095F39h, 4096099h, 4 dup(0FC0A0000h)
		dd 4 dup(4090409h), 4 dup(0FC0AFC0Ah), 25092509h, 2 dup(2B092B09h)
		dd 32093209h, 40094009h, 38093809h, 3F093F09h, 0
		dd 62D961F9h, 649963B9h, 66596579h, 68196739h, 69DB68FBh
		dd 6B9B6ABBh, 6D5B6C7Bh, 6F1B6E3Bh, 70D96FF9h, 729971B9h
		dd 74597379h, 76197539h, 77DB76FBh, 799B78BBh, 7B5B7A7Bh
		dd 7D1B7C3Bh, 7ED97DF9h, 80997FB9h, 82598179h, 84198339h
		dd 85DB84FBh, 879B86BBh, 895B887Bh, 8B1B8A3Bh, 4090409h
		dd 8CF98BF9h, 8DD9h, 8FD98ED9h,	0FC0AFC0Ah, 0DB0ADB0Ah
		dd 4913Bh, 49219h, 40004h, 93B992B9h, 9499h, 96999599h
		dd 2 dup(0D50AD50Ah), 497FBh, 40004h, 4090409h,	9A3998D9h
		dd 0
		dd 9CD99BD9h, 0FC0AFC0Ah, 0CE0ACE0Ah, 40000h, 40004h, 4090409h
		dd 9F999E39h, 389A139h,	0A339A239h, 0FC0AFC0Ah,	0C80AC80Ah
		dd 4FC8Ah, 40004h, 0
aSdseyj		db '™¤™¥y¦',0
		align 4
		dd 0A879A779h, 0C00AC00Ah, 0C10AC10Ah, 4A9DBh, 4, 5 dup(0)
		dd 40000h, 2 dup(40004h), 4 dup(0)
		dd 40004h, 3 dup(0)
		dd 4, 40000h, 0
		dd 2 dup(40004h), 4, 8 dup(0)
		dd 2 dup(40004h), 4, 5 dup(40004h), 250000h, 6 dup(0)
		dd 50000h, 8 dup(0)
		dd 6 dup(50005h), 5, 9 dup(0)
aDddddddddddd_3:
		unicode	0, <DDddDDDDdddDD>
		dw 4
		dd 40004h, 440004h, 40004h, 640004h, 2 dup(440064h), 3 dup(640064h)
		dd 44h,	8 dup(0)
		dd 2, 0
		dd 20000h, 0
		dd 20001h, 20002h, 10001h, 20002h, 10002h, 20000h, 0
		dd 20000h, 2 dup(20002h), 3 dup(0)
		dd 2, 0AABAh, 2, 0ABBAAB3Ah, 20002h, 10000h, 20002h, 20E0Ah
		dd 1, 0
		dd 10000h, 0
		dd 10001h, 20002h, 2 dup(0)
		dd 20000h, 10001h, 210021h, 2 dup(0)
		dd 0F209h, 8 dup(0)
		dd 8 dup(80A080Ah), 8 dup(0F809F809h), 0
		dd 8A0000h, 0FF89h, 0Eh	dup(0)
		dd 9 dup(0D0A0D0Ah), 9 dup(0F309F309h),	0Bh dup(0)
		dd 11h dup(180A180Ah), 180Ah, 0Fh dup(0E809E809h), 0E809h
		dd 0FF89008Ah, 0AC7AAC3Ah, 0ACF9ACBAh, 8AAD39h,	2 dup(8AFF89h)
		dd 0AD7AFF89h, 0ADFAADBAh, 1AE3Ah, 0FF89008Ah, 8A0001h
		dd 1FF89h, 2 dup(10001h), 50025h, 0AEBAAE7Ah, 2	dup(0FF89008Ah)
		dd 1, 2	dup(0)
		dd 8A0000h, 8AFF89h, 44FF89h, 440044h, 0FF89008Ah, 6 dup(0)
		dd 0AF39AEF9h, 0AFB9AF79h, 0B039AFF9h, 0B0B9B079h, 0B139B0F9h
		dd 0B1B9B179h, 0B239B1F9h, 0B2B9B279h, 0B339B2F9h, 0B3B9B379h
		dd 0B439B3F9h, 0B4B9B479h, 0B539B4F9h, 0B5B9B579h, 0B639B5F9h
		dd 0B6B9B679h, 0B739B6F9h, 0B7B9B779h, 0B839B7F9h, 0B8790000h
		dd 2 dup(0)
		dd 0B8B90000h, 0Ah dup(0)
		dd 40000h, 7 dup(0)
		dd 640000h, 10h	dup(440044h), 5	dup(0)
		dd 640064h
aDd:					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		unicode	0, <dd``>,0
		dw 4
		dd 2 dup(40004h), 2 dup(0)
		dd 40000h, 0Ch dup(0)
		dd 640000h, 40064h, 40004h, 4, 0Eh dup(0)
		dd 40004h, 4, 0Ah dup(0)
		dd 40000h, 7 dup(0)
		dd 4, 9	dup(0)
		dd 7 dup(0FF89008Ah), 440000h, 40004h, 4, 5 dup(440044h)
		dd 40000h, 0Eh dup(0FF89008Ah),	50005h,	440044h, 8 dup(0)
aDd_2:
		unicode	0, <DD>,0
		align 4
		dd 6 dup(0)
		dd 11h dup(40004h), 7 dup(0FF89008Ah), 10001h, 9 dup(0FF89008Ah)
		dd 10005h, 3 dup(10001h), 8A0001h, 8AFF89h, 0B8FAFF89h
		dd 5 dup(0FF89008Ah), 40004h, 8A0004h, 0B93AFF89h, 1, 2	dup(0FF89008Ah)
		dd 10001h, 6 dup(0FF89008Ah), 0B9BAB97Ah, 0BA3AB9FAh, 0
		dd 0BABABA7Ah, 0BB3ABAFAh, 2 dup(0FF89008Ah), 0Ch dup(0)
		dd 50005h, 1, 3	dup(0)
		dd 4, 0
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 0
		dd 40000h, 0Ah dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 0Dh dup(0)
aDddddddddddd_4:
		unicode	0, <DDDDDDDDDDDDDDDDDD>,0
		align 4
		dd 7 dup(0)
		dd 2 dup(40004h), 640004h, 640064h, 0Ah	dup(0)
		dd 40000h, 5 dup(40004h), 600000h, 9 dup(0)
		dd 640000h, 0
		dd 2 dup(40004h), 0
		dd 4, 0
		dd offset ?all@?$_Locbase@H@std@@2HB ; int const std::_Locbase<int>::all
		dd 6 dup(0)
		dd 40000h, 8 dup(0)
		dd 40000h, 2 dup(40004h), 4, 40000h, 4,	40000h,	4, 5 dup(0)
		dd 40000h, 4 dup(0)
		dd 4, 9	dup(0)
		dd 4, 5	dup(0)
		dd 4, 9	dup(0)
		dd offset ?_Rank@?$_Arithmetic_traits@O@std@@2HB ; int const std::_Arithmetic_traits<long double>::_Rank
aDdd_0:
		unicode	0, <DDd>,0
		dd 440000h, 44h, 2 dup(0)
aDd_3:
		unicode	0, <DD>,0
		dd offset ?_Rank@?$_Arithmetic_traits@O@std@@2HB ; int const std::_Arithmetic_traits<long double>::_Rank
		align 10h
		dd 0Ch dup(0)
		dd 40000h, 7 dup(0)
		dd 40004h, 2 dup(0)
		dd 40000h, 4, 64h, 8 dup(0)
		dd 9 dup(10001h), 0BB790001h, 3	dup(10001h), 40001h, 2 dup(50005h)
		dd 3 dup(10001h), 5 dup(0)
		dd 0BC19BBB9h, 0BCD9BC79h, 0BD99BD39h, 0BE59BDF9h, 0BF19BEB9h
		dd 0BFD9BF79h, 0C099C039h, 0C159C0F9h, 0CE19CDB9h, 0CED9CE79h
		dd 0CF99CF39h, 0D059CFF9h, 0D119D0B9h, 0D1D9D179h, 0D299D239h
		dd 0D359D2F9h, 0D419D3B9h, 0D4D9D479h, 0D599D539h, 0D659D5F9h
		dd 0D719D6B9h, 0D7D9D779h, 0D899D839h, 0D959D8F9h, 0C219C1B9h
		dd 0C2D9C279h, 0C399C339h, 0C459C3F9h, 0C519C4B9h, 0C5D9C579h
		dd 0C699C639h, 0C759C6F9h, 0C819C7B9h, 0C8D9C879h, 0C999C939h
		dd 0CA59C9F9h, 0CB19CAB9h, 0CBD9CB79h, 0CC99CC39h, 0CD59CCF9h
		dd 2 dup(0)
		dd 40000h, 0
		dd 4, 0
		dd 640000h, 9 dup(0)
		dd 0DAB9D9B9h, 0DCB9DBB9h, 0DF79DE19h, 0E0B9h, 5 dup(0)
		dd 0E1F90000h, 0E3F9E2F9h, 0E5F9E4F9h, 3 dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 9 dup(0)
		dd 9 dup(40004h), 0
		dd 40000h, 6 dup(0)
aDddddddddddd_5:
		unicode	0, <DDDDDDDdddddddDD>,0
		align 4
		dd 8 dup(0)
		dd 4, 40000h, 5	dup(0)
		dd 100A0000h, 0Ch dup(100A100Ah), 100Ah, 0
		dd 4, 0F0090004h, 0Ch dup(0F009F009h), 0F009h, 8 dup(0)
		dd 4, 8	dup(0)
		dd 40000h, 0Ah dup(0)
		dd 40000h, 40004h, 2 dup(0)
		dd offset ?none@?$_Locbase@H@std@@2HB ;	int const std::_Locbase<int>::none
		dd 10h dup(0)
aDdddd:
		unicode	0, <DDDDD>,0
		align 10h
		dd 10h dup(140A140Ah), 0Ch dup(0EC09EC09h), 8 dup(0)
		dd 40000h, 40004h, 40000h, 4, 2	dup(0)
		dd 640004h, 440004h, 0Ch dup(0)
aDdd_1:
		unicode	0, <Ddd>,0
		dd 0
		dd 640000h, 2 dup(0)
		dd 440000h, 64h, 0Ch dup(0)
		db 0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0Ah
		db ' ',0
		align 4
		dd 6 dup(0)
aRRRRRRRRRRRRRR	db 9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à'
		db 9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à'
		db 9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',9,'à',0
		align 4
		dd 0Ch dup(0)
		dd 5 dup(40004h), 64h, 0Fh dup(0)
		dd 640000h, 9 dup(0)
		dd 40000h, 40004h, 4, 640000h, 64h, 40000h, 0
aDdd_2:
		unicode	0, <DDD>,0
		dd 0Fh dup(0)
		dd 40000h, 2 dup(40004h), 40000h, 2 dup(40004h), 640004h
		dd 64h,	0Ch dup(0)
		dd 4 dup(40004h), 4, 60h, 4 dup(0)
		dd 40064h, 4, 0Ah dup(0)
		dd 40000h, 40004h, 0
		dd 600004h, 40064h, 5 dup(0)
		dd 40000h, 2 dup(40004h), 640004h, 64h,	0Ah dup(0)
		dd 4, 5	dup(0)
		dd 600000h, 0Ah	dup(0)
aDdddddd_1:
		unicode	0, <DDDDDDD>,0
		align 8
aDdddd_0:
		unicode	0, <DDDDD>,0
		dd 0Ah dup(0)
		dd 40000h, 2 dup(40004h), 2 dup(4), 0
		dd 40000h, 4, 640064h, 0Fh dup(0)
		dd 2 dup(40004h), 3 dup(0)
		dd 40004h, 640000h, 64h, 0Dh dup(0)
		dd 40004h, 0Ah dup(0)
		dd 40000h, 3 dup(40004h), 4, 40000h, 640000h, 5	dup(0)
		dd 2 dup(40000h), 0
		dd 3 dup(40004h), 640060h, 0Eh dup(0)
		dd 40000h, 40004h, 0
		dd 2 dup(40004h), 40000h, 40004h, 640004h, 0Ah dup(0)
		dd 10h dup(0F009F009h),	8 dup(0)
aDdddd_1:
		unicode	0, <ddddd>,0
		dd 9 dup(0)
aDdddddd_2:
		unicode	0, <DDDDDDD>,0
		dd 7 dup(0)
		dd 40000h, 8 dup(40004h), 0Eh dup(0)
		dd 40000h, 64h,	2 dup(0)
		dd 600000h, 640060h, 640064h, 0
		dd 600000h, 2 dup(600060h), 40060h, 3 dup(40004h), 640004h
		dd 3 dup(640064h), 64h,	440000h, 2 dup(440044h), 640064h
		dd 0Bh dup(0)
aDddd_0:
		unicode	0, <DDDD>,0
		align 4
		dd 9 dup(0)
aDdd_3:
		unicode	0, <DDD>,0
		dd 0Dh dup(0)
		dd 0Dh dup(20002h), 4 dup(10001h), 210021h, 8 dup(10001h)
		dd 7 dup(20002h), 3 dup(10001h), 1, 210021h, 4 dup(10001h)
		dd 0Dh dup(20002h), 4 dup(10001h), 210021h, 8 dup(10001h)
		dd 2, 20002h, 0
		dd 2, 20000h, 2, 20000h, 20002h, 2, 4 dup(20002h), 2 dup(10001h)
		dd 2 dup(10000h), 210021h, 2 dup(10001h), 10000h, 5 dup(10001h)
		dd 8 dup(20002h), 2 dup(10001h), 20002h, 20000h, 20002h
		dd 2, 20000h, 3	dup(20002h), 2,	3 dup(20002h), 2, 4 dup(10001h)
		dd 210021h, 8 dup(10001h), 20002h, 20000h, 20002h, 2, 2	dup(20002h)
		dd 2 dup(2), 0
		dd 3 dup(20002h), 2, 4 dup(10001h), 210021h, 6 dup(10001h)
		dd 0Ah dup(20002h), 8 dup(10001h), 8 dup(20002h), 3 dup(10001h)
		dd 0
		dd 0Ch dup(20002h), 2, 0Ch dup(10001h),	1, 3 dup(10001h)
		dd 0Ch dup(20002h), 2, 0Ah dup(10001h),	1, 3 dup(10001h)
		dd 8 dup(20002h), 10001h, 1, 3 dup(10001h), 10002h, 0Ah	dup(0)
		dd 0Bh dup(40004h), 4, 0
		dd 40000h, 6 dup(40004h), 4, 3 dup(0)
dword_5658	dd 40000h, 5 dup(0)	; DATA XREF: .rdata:off_100o
		dd 4, 0Ah dup(0)
		dd 40000h, 2 dup(40004h), 40000h, 7 dup(40004h), 8 dup(0)
aDdddddd_3:
		unicode	0, <ddddddd>,0
		dd 4 dup(0)
		dd 5 dup(20002h), 3 dup(0)
		dd 9 dup(20002h), 0Dh dup(0)
_ucase_props_exceptions	dd 69C041h, 1300002h, 40010131h, 41006Ah, 1006Bh, 41212Ah
					; DATA XREF: .rdata:000068E0o
		dd 10073h, 5044017Fh, 20049h, 1310130h,	4B0044h, 212A0001h
		dd 530044h, 17F0001h, 3BC0006h,	41039Ch, 100E5h, 4001212Bh
		dd 400100ECh, 0C000EDh,	22200001h, 730073h, 530053h, 730053h
		dd 441E9Eh, 100C5h, 4001212Bh, 40010129h, 0C043012Fh, 1300069h
		dd 490002h, 440131h, 20049h, 1300069h, 22200080h, 6E02BCh
		dd 2 dup(4E02BCh), 730006h, 90053h, 1C501C6h, 1C6000Dh
		dd 1C501C4h, 1C4000Ch, 901C5h, 1C801C9h, 1C9000Dh, 1C801C7h
		dd 1C7000Ch, 901C8h, 1CB01CCh, 1CC000Dh, 1CB01CAh, 1CA000Ch
		dd 8001CBh, 6A2220h, 2 dup(4A030Ch), 9030Ch, 1F201F3h
		dd 1F3000Dh, 1F201F1h, 1F1000Ch, 101F2h, 12C65h, 42C66h
		dd 42C7Eh, 42C7Fh, 42C6Fh, 42C6Dh, 42C70h, 4A7ABh, 4A7ACh
		dd 4A78Dh, 4A7AAh, 42C62h, 4A7ADh, 42C6Eh, 42C64h, 1004A7B1h
		dd 4A7B2h, 6000A7B0h, 3B93046h,	10399h,	0C01FBEh, 33300001h
		dd 30803B9h, 3990301h, 3010308h, 3080399h, 1FD30301h, 3B20041h
		dd 3D00001h, 3B50041h, 3F50001h, 3B80041h, 3D10002h, 4103F4h
		dd 203B9h, 1FBE0345h, 3BA0041h,	3F00001h, 3BC0041h, 0B50001h
		dd 3C00041h, 3D60001h, 3C10041h, 3F10001h, 3C34041h, 3C20001h
		dd 3C60041h, 3D50001h, 3C90041h, 21260001h, 100C0h, 3C53330h
		dd 3010308h, 30803A5h, 3A50301h, 3010308h, 441FE3h, 10392h
		dd 4403D0h, 10395h, 4403F5h, 20398h, 3F403D1h, 3990044h
		dd 3450002h, 441FBEh, 1039Ah, 4403F0h, 1039Ch, 4400B5h
		dd 103A0h, 4403D6h, 103A1h, 603F1h, 3A303C3h, 3A30044h
		dd 3C20001h, 3A60044h, 3D50001h, 3A90044h, 21260001h, 3B20006h
		dd 460392h, 39803B8h, 3F40001h,	3C60006h, 603A6h, 3A003C0h
		dd 3BA0006h, 6039Ah, 3A103C1h, 3B80041h, 3980002h, 603D1h
		dd 39503B5h, 22200080h,	5820565h, 5520535h, 5820535h, 2D000001h
		dd 2D010001h, 2D020001h, 2D030001h, 2D040001h, 2D050001h
		dd 2D060001h, 2D070001h, 2D080001h, 2D090001h, 2D0A0001h
		dd 2D0B0001h, 2D0C0001h, 2D0D0001h, 2D0E0001h, 2D0F0001h
		dd 2D100001h, 2D110001h, 2D120001h, 2D130001h, 2D140001h
		dd 2D150001h, 2D160001h, 2D170001h, 2D180001h, 2D190001h
		dd 2D1A0001h, 2D1B0001h, 2D1C0001h, 2D1D0001h, 2D1E0001h
		dd 2D1F0001h, 2D200001h, 2D210001h, 2D220001h, 2D230001h
		dd 2D240001h, 2D250001h, 2D270001h, 2D2D0001h, 0AB700003h
		dd 313A0h, 13A1AB71h, 0AB720003h, 313A2h, 13A3AB73h, 0AB740003h
		dd 313A4h, 13A5AB75h, 0AB760003h, 313A6h, 13A7AB77h, 0AB780003h
		dd 313A8h, 13A9AB79h, 0AB7A0003h, 313AAh, 13ABAB7Bh, 0AB7C0003h
		dd 313ACh, 13ADAB7Dh, 0AB7E0003h, 313AEh, 13AFAB7Fh, 0AB800003h
		dd 313B0h, 13B1AB81h, 0AB820003h, 313B2h, 13B3AB83h, 0AB840003h
		dd 313B4h, 13B5AB85h, 0AB860003h, 313B6h, 13B7AB87h, 0AB880003h
		dd 313B8h, 13B9AB89h, 0AB8A0003h, 313BAh, 13BBAB8Bh, 0AB8C0003h
		dd 313BCh, 13BDAB8Dh, 0AB8E0003h, 313BEh, 13BFAB8Fh, 0AB900003h
		dd 313C0h, 13C1AB91h, 0AB920003h, 313C2h, 13C3AB93h, 0AB940003h
		dd 313C4h, 13C5AB95h, 0AB960003h, 313C6h, 13C7AB97h, 0AB980003h
		dd 313C8h, 13C9AB99h, 0AB9A0003h, 313CAh, 13CBAB9Bh, 0AB9C0003h
		dd 313CCh, 13CDAB9Dh, 0AB9E0003h, 313CEh, 13CFAB9Fh, 0ABA00003h
		dd 313D0h, 13D1ABA1h, 0ABA20003h, 313D2h, 13D3ABA3h, 0ABA40003h
		dd 313D4h, 13D5ABA5h, 0ABA60003h, 313D6h, 13D7ABA7h, 0ABA80003h
		dd 313D8h, 13D9ABA9h, 0ABAA0003h, 313DAh, 13DBABABh, 0ABAC0003h
		dd 313DCh, 13DDABADh, 0ABAE0003h, 313DEh, 13DFABAFh, 0ABB00003h
		dd 313E0h, 13E1ABB1h, 0ABB20003h, 313E2h, 13E3ABB3h, 0ABB40003h
		dd 313E4h, 13E5ABB5h, 0ABB60003h, 313E6h, 13E7ABB7h, 0ABB80003h
		dd 313E8h, 13E9ABB9h, 0ABBA0003h, 313EAh, 13EBABBBh, 0ABBC0003h
		dd 313ECh, 13EDABBDh, 0ABBE0003h, 313EEh, 13EFABBFh, 13F80003h
		dd 313F0h, 13F113F9h, 13FA0003h, 313F2h, 13F313FBh, 13FC0003h
		dd 313F4h, 13F513FDh, 13F00006h, 613F0h, 13F113F1h, 13F20006h
		dd 613F2h, 13F313F3h, 13F40006h, 613F4h, 13F513F5h, 0A77D0004h
		dd 2C630004h, 1E610041h, 1E9B0001h, 1E600044h, 1E9B0001h
		dd 22200080h, 3310068h,	2 dup(3310048h), 22200080h, 3080074h
		dd 2 dup(3080054h), 22200080h, 30A0077h, 2 dup(30A0057h)
		dd 22200080h, 30A0079h,	2 dup(30A0059h), 22200080h, 2BE0061h
		dd 2 dup(2BE0041h), 1E610006h, 811E60h,	2000DFh, 730073h
		dd 22200080h, 31303C5h,	2 dup(31303A5h), 33300080h, 31303C5h
		dd 3A50300h, 3000313h, 31303A5h, 800300h, 3C53330h, 3010313h
		dd 31303A5h, 3A50301h, 3010313h, 33300080h, 31303C5h, 3A50342h
		dd 3420313h, 31303A5h, 840342h,	2201F88h, 3B91F00h, 3991F08h
		dd 1F890084h, 1F010220h, 1F0903B9h, 840399h, 2201F8Ah
		dd 3B91F02h, 3991F0Ah, 1F8B0084h, 1F030220h, 1F0B03B9h
		dd 840399h, 2201F8Ch, 3B91F04h,	3991F0Ch, 1F8D0084h, 1F050220h
		dd 1F0D03B9h, 840399h, 2201F8Eh, 3B91F06h, 3991F0Eh, 1F8F0084h
		dd 1F070220h, 1F0F03B9h, 810399h, 2201F80h, 3B91F00h, 3991F08h
		dd 1F810081h, 1F010220h, 1F0903B9h, 810399h, 2201F82h
		dd 3B91F02h, 3991F0Ah, 1F830081h, 1F030220h, 1F0B03B9h
		dd 810399h, 2201F84h, 3B91F04h,	3991F0Ch, 1F850081h, 1F050220h
		dd 1F0D03B9h, 810399h, 2201F86h, 3B91F06h, 3991F0Eh, 1F870081h
		dd 1F070220h, 1F0F03B9h, 840399h, 2201F98h, 3B91F20h, 3991F28h
		dd 1F990084h, 1F210220h, 1F2903B9h, 840399h, 2201F9Ah
		dd 3B91F22h, 3991F2Ah, 1F9B0084h, 1F230220h, 1F2B03B9h
		dd 840399h, 2201F9Ch, 3B91F24h,	3991F2Ch, 1F9D0084h, 1F250220h
		dd 1F2D03B9h, 840399h, 2201F9Eh, 3B91F26h, 3991F2Eh, 1F9F0084h
		dd 1F270220h, 1F2F03B9h, 810399h, 2201F90h, 3B91F20h, 3991F28h
		dd 1F910081h, 1F210220h, 1F2903B9h, 810399h, 2201F92h
		dd 3B91F22h, 3991F2Ah, 1F930081h, 1F230220h, 1F2B03B9h
		dd 810399h, 2201F94h, 3B91F24h,	3991F2Ch, 1F950081h, 1F250220h
		dd 1F2D03B9h, 810399h, 2201F96h, 3B91F26h, 3991F2Eh, 1F970081h
		dd 1F270220h, 1F2F03B9h, 840399h, 2201FA8h, 3B91F60h, 3991F68h
		dd 1FA90084h, 1F610220h, 1F6903B9h, 840399h, 2201FAAh
		dd 3B91F62h, 3991F6Ah, 1FAB0084h, 1F630220h, 1F6B03B9h
		dd 840399h, 2201FACh, 3B91F64h
		dd 3991F6Ch, 1FAD0084h,	1F650220h, 1F6D03B9h, 840399h
		dd 2201FAEh, 3B91F66h, 3991F6Eh, 1FAF0084h, 1F670220h
		dd 1F6F03B9h, 810399h, 2201FA0h, 3B91F60h, 3991F68h, 1FA10081h
		dd 1F610220h, 1F6903B9h, 810399h, 2201FA2h, 3B91F62h, 3991F6Ah
		dd 1FA30081h, 1F630220h, 1F6B03B9h, 810399h, 2201FA4h
		dd 3B91F64h, 3991F6Ch, 1FA50081h, 1F650220h, 1F6D03B9h
		dd 810399h, 2201FA6h, 3B91F66h,	3991F6Eh, 1FA70081h, 1F670220h
		dd 1F6F03B9h, 800399h, 1F702220h, 1FBA03B9h, 1FBA0399h
		dd 840345h, 2201FBCh, 3B903B1h,	3990391h, 22200080h, 3B903ACh
		dd 3990386h, 3450386h, 22200080h, 34203B1h, 2 dup(3420391h)
		dd 33300080h, 34203B1h,	39103B9h, 3990342h, 3420391h, 810345h
		dd 2201FB3h, 3B903B1h, 3990391h, 3B90046h, 10399h, 800345h
		dd 1F742220h, 1FCA03B9h, 1FCA0399h, 840345h, 2201FCCh
		dd 3B903B7h, 3990397h, 22200080h, 3B903AEh, 3990389h, 3450389h
		dd 22200080h, 34203B7h,	2 dup(3420397h), 33300080h, 34203B7h
		dd 39703B9h, 3990342h, 3420397h, 810345h, 2201FC3h, 3B903B7h
		dd 3990397h, 33300080h,	30803B9h, 3990300h, 3000308h, 3080399h
		dd 0C00300h, 33300001h,	30803B9h, 3990301h, 3010308h, 3080399h
		dd 3900301h, 22200080h,	34203B9h, 2 dup(3420399h), 33300080h
		dd 30803B9h, 3990342h, 3420308h, 3080399h, 800342h, 3C53330h
		dd 3000308h, 30803A5h, 3A50300h, 3000308h, 100C0h, 3C53330h
		dd 3010308h, 30803A5h, 3A50301h, 3010308h, 8003B0h, 3C12220h
		dd 2 dup(3A10313h), 800313h, 3C52220h, 2 dup(3A50342h)
		dd 800342h, 3C53330h, 3420308h,	30803A5h, 3A50342h, 3420308h
		dd 22200080h, 3B91F7Ch,	3991FFAh, 3451FFAh, 1FFC0084h
		dd 3C90220h, 3A903B9h, 800399h,	3CE2220h, 38F03B9h, 38F0399h
		dd 800345h, 3C92220h, 2	dup(3A90342h), 800342h,	3C93330h
		dd 3B90342h, 34203A9h, 3A90399h, 3450342h, 1FF30081h, 3C90220h
		dd 3A903B9h, 410399h, 103C9h, 4103A9h, 1006Bh, 41004Bh
		dd 100E5h, 100C5h, 1026Bh, 11D7Dh, 4027Dh, 4023Ah, 1023Eh
		dd 10251h, 10271h, 10250h, 10252h, 1023Fh, 40240h, 410A0h
		dd 410A1h, 410A2h, 410A3h, 410A4h, 410A5h, 410A6h, 410A7h
		dd 410A8h, 410A9h, 410AAh, 410ABh, 410ACh, 410ADh, 410AEh
		dd 410AFh, 410B0h, 410B1h, 410B2h, 410B3h, 410B4h, 410B5h
		dd 410B6h, 410B7h, 410B8h, 410B9h, 410BAh, 410BBh, 410BCh
		dd 410BDh, 410BEh, 410BFh, 410C0h, 410C1h, 410C2h, 410C3h
		dd 410C4h, 410C5h, 410C7h, 110CDh, 11D79h, 10265h, 10266h
		dd 1025Ch, 10261h, 1026Ch, 1029Eh, 10287h, 1029Dh, 4AB53h
		dd 6A7B3h, 13A013A0h, 13A10006h, 613A1h, 13A213A2h, 13A30006h
		dd 613A3h, 13A413A4h, 13A50006h, 613A5h, 13A613A6h, 13A70006h
		dd 613A7h, 13A813A8h, 13A90006h, 613A9h, 13AA13AAh, 13AB0006h
		dd 613ABh, 13AC13ACh, 13AD0006h, 613ADh, 13AE13AEh, 13AF0006h
		dd 613AFh, 13B013B0h, 13B10006h, 613B1h, 13B213B2h, 13B30006h
		dd 613B3h, 13B413B4h, 13B50006h, 613B5h, 13B613B6h, 13B70006h
		dd 613B7h, 13B813B8h, 13B90006h, 613B9h, 13BA13BAh, 13BB0006h
		dd 613BBh, 13BC13BCh, 13BD0006h, 613BDh, 13BE13BEh, 13BF0006h
		dd 613BFh, 13C013C0h, 13C10006h, 613C1h, 13C213C2h, 13C30006h
		dd 613C3h, 13C413C4h, 13C50006h, 613C5h, 13C613C6h, 13C70006h
		dd 613C7h, 13C813C8h, 13C90006h, 613C9h, 13CA13CAh, 13CB0006h
		dd 613CBh, 13CC13CCh, 13CD0006h, 613CDh, 13CE13CEh, 13CF0006h
		dd 613CFh, 13D013D0h, 13D10006h, 613D1h, 13D213D2h, 13D30006h
		dd 613D3h, 13D413D4h, 13D50006h, 613D5h, 13D613D6h, 13D70006h
		dd 613D7h, 13D813D8h, 13D90006h, 613D9h, 13DA13DAh, 13DB0006h
		dd 613DBh, 13DC13DCh, 13DD0006h, 613DDh, 13DE13DEh, 13DF0006h
		dd 613DFh, 13E013E0h, 13E10006h, 613E1h, 13E213E2h, 13E30006h
		dd 613E3h, 13E413E4h, 13E50006h, 613E5h, 13E613E6h, 13E70006h
		dd 613E7h, 13E813E8h, 13E90006h, 613E9h, 13EA13EAh, 13EB0006h
		dd 613EBh, 13EC13ECh, 13ED0006h, 613EDh, 13EE13EEh, 13EF0006h
		dd 8013EFh, 662220h, 460066h, 460046h, 800066h,	662220h
		dd 460069h, 460049h, 800069h, 662220h, 46006Ch,	46004Ch
		dd 80006Ch, 663330h, 690066h, 460046h, 460049h,	690066h
		dd 33300080h, 660066h, 46006Ch,	4C0046h, 660046h, 0C0006Ch
		dd 22200001h, 740073h, 540053h,	740053h, 0C0FB06h, 22200001h
		dd 740073h, 540053h, 740053h, 80FB05h, 5742220h, 5440576h
		dd 5440546h, 800576h, 5742220h,	5440565h, 5440535h, 800565h
		dd 5742220h, 544056Bh, 544053Bh, 80056Bh, 57E2220h, 54E0576h
		dd 54E0546h, 800576h, 5742220h,	544056Dh, 544053Dh, 56Dh
_ucase_props_unfold dd 50049h, 3, 610000h, 2BEh, 1E9Ah,	660066h, 0FB000000h
					; DATA XREF: .rdata:off_68E4o
		dd 660000h, 690066h, 0FB03h, 660066h, 0FB04006Ch, 660000h
		dd 69h,	0FB01h,	6C0066h, 0FB020000h, 680000h, 331h, 1E96h
		dd 3070069h, 1300000h, 6A0000h,	30Ch, 1F0h, 730073h, 0DF0000h
		dd 731E9Eh, 74h, 0FB06FB05h, 3080074h, 1E970000h, 770000h
		dd 30Ah, 1E98h,	30A0079h, 1E990000h, 2BC0000h, 6Eh, 149h
		dd 3B903ACh, 1FB40000h,	3AE0000h, 3B9h,	1FC4h, 34203B1h
		dd 1FB60000h, 3B10000h,	3B90342h, 1FB7h, 3B903B1h, 1FB30000h
		dd 3B71FBCh, 342h, 1FC6h, 34203B7h, 1FC703B9h, 3B70000h
		dd 3B9h, 1FCC1FC3h, 30803B9h, 1FD20300h, 3B90000h, 3010308h
		dd 1FD30390h, 30803B9h,	1FD70342h, 3B90000h, 342h, 1FD6h
		dd 31303C1h, 1FE40000h,	3C50000h, 3000308h, 1FE2h, 30803C5h
		dd 3B00301h, 3C51FE3h, 3420308h, 1FE7h,	31303C5h, 1F500000h
		dd 3C50000h, 3000313h, 1F52h, 31303C5h,	1F540301h, 3C50000h
		dd 3420313h, 1F56h, 34203C5h, 1FE60000h, 3C90000h, 342h
		dd 1FF6h, 34203C9h, 1FF703B9h, 3C90000h, 3B9h, 1FFC1FF3h
		dd 3B903CEh, 1FF40000h,	5650000h, 582h,	587h, 5650574h
		dd 0FB140000h, 5740000h, 56Bh, 0FB15h, 56D0574h, 0FB170000h
		dd 5740000h, 576h, 0FB13h, 576057Eh, 0FB160000h, 1F000000h
		dd 3B9h, 1F881F80h, 3B91F01h, 1F810000h, 1F021F89h, 3B9h
		dd 1F8A1F82h, 3B91F03h,	1F830000h, 1F041F8Bh, 3B9h, 1F8C1F84h
		dd 3B91F05h, 1F850000h,	1F061F8Dh, 3B9h, 1F8E1F86h, 3B91F07h
		dd 1F870000h, 1F201F8Fh, 3B9h, 1F981F90h, 3B91F21h, 1F910000h
		dd 1F221F99h, 3B9h, 1F9A1F92h, 3B91F23h, 1F930000h, 1F241F9Bh
		dd 3B9h, 1F9C1F94h, 3B91F25h, 1F950000h, 1F261F9Dh, 3B9h
		dd 1F9E1F96h, 3B91F27h,	1F970000h, 1F601F9Fh, 3B9h, 1FA81FA0h
		dd 3B91F61h, 1FA10000h,	1F621FA9h, 3B9h, 1FAA1FA2h, 3B91F63h
		dd 1FA30000h, 1F641FABh, 3B9h, 1FAC1FA4h, 3B91F65h, 1FA50000h
		dd 1F661FADh, 3B9h, 1FAE1FA6h, 3B91F67h, 1FA70000h, 1F701FAFh
		dd 3B9h, 1FB2h,	3B91F74h, 1FC20000h, 1F7C0000h,	3B9h, 1FF2h
_iDot		dd 3070069h		; DATA XREF: _ucase_addCaseClosure_56+A0o
					; _ucase_toFullLower_56+246o ...
_ucase_props_singleton dd 0		; DATA XREF: _ucase_getSingleton_56+1Eo
					; _u_isULowercase_56+22o ...
		dd offset _ucase_props_indexes
		dd offset _ucase_props_exceptions
off_68E4	dd offset _ucase_props_unfold
					; DATA XREF: icu_56::FullCaseFoldingIterator::FullCaseFoldingIterator(void)+26r
		dd offset _ucase_props_trieIndex
		dd offset dword_1000+9E8h
		dd 0
		dd offset dword_800+458h
		dd offset dword_1D98+134h
		dd 0CD40188h, 2	dup(0)
		dd 0E0800h, 2B20h, 4 dup(0)
		dd 3
_jDot		dd 307006Ah		; DATA XREF: _ucase_toFullLower_56+259o
_flagsOffset	db 0			; DATA XREF: _ucase_tolower_56+19Br
					; _ucase_tolower_56+1BDr ...
		db 2 dup(1), 2
		dd 2 dup(3020201h), 4030302h, 3020201h,	2 dup(4030302h)
		dd 5040403h, 3020201h, 2 dup(4030302h),	5040403h, 4030302h
		dd 2 dup(5040403h), 6050504h, 3020201h,	2 dup(4030302h)
		dd 5040403h, 4030302h, 2 dup(5040403h),	6050504h, 4030302h
		dd 2 dup(5040403h), 6050504h, 5040403h,	2 dup(6050504h)
		dd 7060605h, 3020201h, 2 dup(4030302h),	5040403h, 4030302h
		dd 2 dup(5040403h), 6050504h, 4030302h,	2 dup(5040403h)
		dd 6050504h, 5040403h, 2 dup(6050504h),	7060605h, 4030302h
		dd 2 dup(5040403h), 6050504h, 5040403h,	2 dup(6050504h)
		dd 7060605h, 5040403h, 2 dup(6050504h),	7060605h, 6050504h
		dd 2 dup(7060605h), 8070706h
_iOgonekDot	dd 307012Fh, 0		; DATA XREF: _ucase_toFullLower_56+26Co
_iDotGrave	dd 3070069h, 300h	; DATA XREF: _ucase_toFullLower_56+27Fo
_iDotAcute	dd 3070069h, 301h	; DATA XREF: _ucase_toFullLower_56+292o
_iDotTilde	dd 3070069h		; DATA XREF: _ucase_toFullLower_56+2A5o
		db 2 dup(3)
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6A48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 6A80h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 6A84h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6A88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6AE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6B74h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6B80h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00006B74o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6B94h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00006B8Co
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6BB4h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00006B90o
					; .rdata$r:00006BE8o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6BC4h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00006BC0o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6BD0h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00006EA0o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6BECh
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00006BC8o
					; .rdata$r:00006EA4o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6C08h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6C28h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00006C04o
					; .rdata$r:00006C58o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6C38h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00006C34o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6C40h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6C5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_6C93
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_6C9D
; ---------------------------------------------------------------------------

loc_6C93:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_6C9D:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6CB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6CE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6D23
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6D23:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6D3Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_6D9D
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6D95
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_6D95:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_6DBC
; ---------------------------------------------------------------------------

loc_6D9D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6DB9
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6DB9:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_6DBC:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6DD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6E28h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E54h
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00006E28o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6E68h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00006E60o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E8Ch
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00006E64o
					; .rdata$r:00006EC4o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6E9Ch
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00006E98o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6EACh
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:00007ADCo
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6EC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6F4F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6F4F:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_6FC9
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6FC1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_6FC1:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_6FE8
; ---------------------------------------------------------------------------

loc_6FC9:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6FE5
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6FE5:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_6FE8:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7000h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 704Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 709Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 70F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7144h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7184h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 71DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 721Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 724Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 727Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7360h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_73B9
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_739D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_739D:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_73B9:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_7413
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_7409
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_7413
; ---------------------------------------------------------------------------

loc_7409:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_7413:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 741Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 746Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 74ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74E4h
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 74F8h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000074E4o
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 750Ch
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00007504o
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 752Ch
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00007508o
					; .rdata$r:00007560o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 753Ch
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00007538o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7548h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7564h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_75A3
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_75A3:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 75BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_761D
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_7615
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_7615:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_763C
; ---------------------------------------------------------------------------

loc_761D:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_7639
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_7639:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_763C:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7654h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7684h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 76B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 76E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 772Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 776Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_77AB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_77AB:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 77C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_7825
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_781D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_781D:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_7844
; ---------------------------------------------------------------------------

loc_7825:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_7841
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_7841:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_7844:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 785Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_7892
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_78AE
; ---------------------------------------------------------------------------

loc_7892:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_78AE
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_78AE:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_7905
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_7917
; ---------------------------------------------------------------------------

loc_7905:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_7917
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_7917:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_792A
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_7946
; ---------------------------------------------------------------------------

loc_792A:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_7946
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_7946:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 795Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_7999
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_79A5
; ---------------------------------------------------------------------------

loc_7999:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_79A5:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 79B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_79F1
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_79FD
; ---------------------------------------------------------------------------

loc_79F1:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_79FD:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7A64h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7A90h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00007A64o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7AA4h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00007A9Co
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7AC8h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00007AA0o
					; .rdata$r:00007B04o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7AD8h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:00007AD4o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 7AECh
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7BB6
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_7BC2
; ---------------------------------------------------------------------------

loc_7BB6:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_7BC2:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7BDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_7C17
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_7C23
; ---------------------------------------------------------------------------

loc_7C17:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_7C23:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7CA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7CDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_7D2D
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_7D24
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_7D2D

loc_7D24:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_7D34
; ---------------------------------------------------------------------------

loc_7D2D:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_7D34:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_7D85
		xor	eax, eax
		jmp	short loc_7DA1
; ---------------------------------------------------------------------------
		jmp	short loc_7DA1
; ---------------------------------------------------------------------------

loc_7D85:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_7D9B
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_7DA1
; ---------------------------------------------------------------------------
		jmp	short loc_7DA1
; ---------------------------------------------------------------------------

loc_7D9B:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_7DA1:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7DA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7DEE
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_7E1F
; ---------------------------------------------------------------------------
		jmp	short loc_7E1F
; ---------------------------------------------------------------------------

loc_7DEE:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_7E1F:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_7E76
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_7ED0
; ---------------------------------------------------------------------------
		jmp	short loc_7ED0
; ---------------------------------------------------------------------------

loc_7E76:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_7EC3
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_7EC3
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7EC3
		mov	[ebp+var_E5], 1
		jmp	short loc_7ECA
; ---------------------------------------------------------------------------

loc_7EC3:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_7ECA:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_7ED0:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7EE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7F9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8000h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8064h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 80C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8124h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 817Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 81D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 822Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8280h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 82D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8334h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_837A
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_83AB
; ---------------------------------------------------------------------------
		jmp	short loc_83AB
; ---------------------------------------------------------------------------

loc_837A:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_83AB:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8420h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8478h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8528h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 857Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 85D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8630h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_8676
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_86AB
; ---------------------------------------------------------------------------
		jmp	short loc_86AB
; ---------------------------------------------------------------------------

loc_8676:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_86AB:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 86C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8724h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8838h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8890h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 88ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 894Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_89B7
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_89B7
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_89BA
; ---------------------------------------------------------------------------

loc_89B7:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_89BA:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 89D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8A98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8CA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8CF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8D54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_8EDF
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_8EDF
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_8EE2
; ---------------------------------------------------------------------------

loc_8EDF:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_8EE2:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8EF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9018h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9068h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 910Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 915Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 91C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9288h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 92E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_931C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_931C:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9354h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_938C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_938C:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 93C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 943Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 94B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_94EC
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_94EC:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 952Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_956A
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_956A:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 95ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9604h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 965Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 96B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9708h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 975Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 97B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9814h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9880h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 98E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9940h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9994h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 99E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9AACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B18h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_9B5B
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_9B60
; ---------------------------------------------------------------------------
		jmp	short loc_9B60
; ---------------------------------------------------------------------------

loc_9B5B:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_9B60:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9BC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9C80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9CC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_9D02
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_9D1F
; ---------------------------------------------------------------------------

loc_9D02:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_9D1F:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9ECCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9FE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A09Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A13Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A18Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A1D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A2B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A308h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A35Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A3B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A408h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A45Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A4ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A4F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_A534
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_A53C
; ---------------------------------------------------------------------------

loc_A534:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_A53C:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A554h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_A590
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_A590
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_A5A6
; ---------------------------------------------------------------------------

loc_A590:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_A5A6:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A5BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A610h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A66Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_A6B2
		cmp	[ebp+arg_0], 0
		jnz	short loc_A6B2
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_A6D3
; ---------------------------------------------------------------------------
		jmp	short loc_A6D3
; ---------------------------------------------------------------------------

loc_A6B2:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_A6D1
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_A6D3
; ---------------------------------------------------------------------------
		jmp	short loc_A6D3
; ---------------------------------------------------------------------------

loc_A6D1:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_A6D3:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A6ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A738h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A784h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::Mutex::`default constructor closure'(void)
		public ??_FMutex@icu_56@@QAEXXZ
??_FMutex@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; struct UMutex	*
		mov	ecx, [ebp+var_8] ; this
		call	??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ; icu_56::Mutex::Mutex(UMutex *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??_FMutex@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A7C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Mutex::Mutex(icu_56::Mutex *this, struct UMutex *)
		public ??0Mutex@icu_56@@QAE@PAUUMutex@@@Z
??0Mutex@icu_56@@QAE@PAUUMutex@@@Z proc	near
					; CODE XREF: icu_56::Mutex::`default constructor closure'(void)+28p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_umtx_lock_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Mutex@icu_56@@QAE@PAUUMutex@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A81Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Mutex::~Mutex(icu_56::Mutex	*__hidden this)
		public ??1Mutex@icu_56@@QAE@XZ
??1Mutex@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_umtx_unlock_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1Mutex@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A864h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_getSingleton_56
_ucase_getSingleton_56 proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset _ucase_props_singleton
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_getSingleton_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A890h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_addPropertyStarts_56
_ucase_addPropertyStarts_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A8C5
		jmp	short loc_A8DF
; ---------------------------------------------------------------------------

loc_A8C5:				; CODE XREF: _ucase_addPropertyStarts_56+31j
		mov	eax, [ebp+arg_4]
		push	eax
		push	offset ?_enumPropertyStartsRange@@YACPBXHHI@Z ;	_enumPropertyStartsRange(void const *,int,int,uint)
		push	0
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		push	ecx
		call	_utrie2_enum_56
		add	esp, 10h

loc_A8DF:				; CODE XREF: _ucase_addPropertyStarts_56+33j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_addPropertyStarts_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A8F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _ucase_addPropertyStarts_56+24p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A920h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl _enumPropertyStartsRange(void const *, int, int, unsigned	int)
?_enumPropertyStartsRange@@YACPBXHHI@Z proc near
					; DATA XREF: _ucase_addPropertyStarts_56+39o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		call	ecx
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	al, 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_enumPropertyStartsRange@@YACPBXHHI@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A978h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_tolower_56
_ucase_tolower_56 proc near		; CODE XREF: _u_tolower_56+27p

var_F4		= dword	ptr -0F4h
var_F0		= dword	ptr -0F0h
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_A9C3
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_E8], edx
		jmp	loc_AA97
; ---------------------------------------------------------------------------

loc_A9C3:				; CODE XREF: _ucase_tolower_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_AA06
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_EC], ecx
		jmp	loc_AA8B
; ---------------------------------------------------------------------------

loc_AA06:				; CODE XREF: _ucase_tolower_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_AA22
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_F0], eax
		jmp	short loc_AA7F
; ---------------------------------------------------------------------------

loc_AA22:				; CODE XREF: _ucase_tolower_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_AA3B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_F4], ecx
		jmp	short loc_AA73
; ---------------------------------------------------------------------------

loc_AA3B:				; CODE XREF: _ucase_tolower_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_F4], eax

loc_AA73:				; CODE XREF: _ucase_tolower_56+C1j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_F0], ecx

loc_AA7F:				; CODE XREF: _ucase_tolower_56+A8j
		mov	edx, [ebp+var_F0]
		mov	[ebp+var_EC], edx

loc_AA8B:				; CODE XREF: _ucase_tolower_56+89j
		mov	eax, [ebp+var_EC]
		mov	[ebp+var_E8], eax

loc_AA97:				; CODE XREF: _ucase_tolower_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_E8]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 10h
		jnz	short loc_AAD2
		movzx	eax, [ebp+var_8]
		and	eax, 3
		cmp	eax, 2
		jl	short loc_AACD
		movsx	eax, [ebp+var_8]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+arg_4], eax

loc_AACD:				; CODE XREF: _ucase_tolower_56+146j
		jmp	loc_AB6A
; ---------------------------------------------------------------------------

loc_AAD2:				; CODE XREF: _ucase_tolower_56+13Aj
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	cx, [eax]
		mov	[ebp+var_20], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		movzx	eax, [ebp+var_20]
		and	eax, 1
		jz	short loc_AB6A
		movzx	eax, [ebp+var_20]
		and	eax, 100h
		jnz	short loc_AB2E
		movzx	eax, [ebp+var_20]
		and	eax, 0
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		jmp	short loc_AB6A
; ---------------------------------------------------------------------------

loc_AB2E:				; CODE XREF: _ucase_tolower_56+192j
		movzx	eax, [ebp+var_20]
		and	eax, 0
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_4]
		shl	eax, 10h
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+arg_4], eax

loc_AB6A:				; CODE XREF: _ucase_tolower_56:loc_AACDj
					; _ucase_tolower_56+187j ...
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_tolower_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AB74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_toupper_56
_ucase_toupper_56 proc near		; CODE XREF: _u_toupper_56+27p

var_F4		= dword	ptr -0F4h
var_F0		= dword	ptr -0F0h
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_ABBF
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_E8], edx
		jmp	loc_AC93
; ---------------------------------------------------------------------------

loc_ABBF:				; CODE XREF: _ucase_toupper_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_AC02
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_EC], ecx
		jmp	loc_AC87
; ---------------------------------------------------------------------------

loc_AC02:				; CODE XREF: _ucase_toupper_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_AC1E
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_F0], eax
		jmp	short loc_AC7B
; ---------------------------------------------------------------------------

loc_AC1E:				; CODE XREF: _ucase_toupper_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_AC37
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_F4], ecx
		jmp	short loc_AC6F
; ---------------------------------------------------------------------------

loc_AC37:				; CODE XREF: _ucase_toupper_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_F4], eax

loc_AC6F:				; CODE XREF: _ucase_toupper_56+C1j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_F0], ecx

loc_AC7B:				; CODE XREF: _ucase_toupper_56+A8j
		mov	edx, [ebp+var_F0]
		mov	[ebp+var_EC], edx

loc_AC87:				; CODE XREF: _ucase_toupper_56+89j
		mov	eax, [ebp+var_EC]
		mov	[ebp+var_E8], eax

loc_AC93:				; CODE XREF: _ucase_toupper_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_E8]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 10h
		jnz	short loc_ACCE
		movzx	eax, [ebp+var_8]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_ACC9
		movsx	eax, [ebp+var_8]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+arg_4], eax

loc_ACC9:				; CODE XREF: _ucase_toupper_56+146j
		jmp	loc_AD66
; ---------------------------------------------------------------------------

loc_ACCE:				; CODE XREF: _ucase_toupper_56+13Aj
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	cx, [eax]
		mov	[ebp+var_20], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		movzx	eax, [ebp+var_20]
		and	eax, 4
		jz	short loc_AD66
		movzx	eax, [ebp+var_20]
		and	eax, 100h
		jnz	short loc_AD2A
		movzx	eax, [ebp+var_20]
		and	eax, 3
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		jmp	short loc_AD66
; ---------------------------------------------------------------------------

loc_AD2A:				; CODE XREF: _ucase_toupper_56+192j
		movzx	eax, [ebp+var_20]
		and	eax, 3
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_4]
		shl	eax, 10h
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+arg_4], eax

loc_AD66:				; CODE XREF: _ucase_toupper_56:loc_ACC9j
					; _ucase_toupper_56+187j ...
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_toupper_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AD70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_totitle_56
_ucase_totitle_56 proc near		; CODE XREF: _u_totitle_56+27p

var_100		= dword	ptr -100h
var_FC		= dword	ptr -0FCh
var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_ADBB
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_F4], edx
		jmp	loc_AE8F
; ---------------------------------------------------------------------------

loc_ADBB:				; CODE XREF: _ucase_totitle_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_ADFE
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_F8], ecx
		jmp	loc_AE83
; ---------------------------------------------------------------------------

loc_ADFE:				; CODE XREF: _ucase_totitle_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_AE1A
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_FC], eax
		jmp	short loc_AE77
; ---------------------------------------------------------------------------

loc_AE1A:				; CODE XREF: _ucase_totitle_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_AE33
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_100], ecx
		jmp	short loc_AE6B
; ---------------------------------------------------------------------------

loc_AE33:				; CODE XREF: _ucase_totitle_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_100], eax

loc_AE6B:				; CODE XREF: _ucase_totitle_56+C1j
		mov	ecx, [ebp+var_100]
		mov	[ebp+var_FC], ecx

loc_AE77:				; CODE XREF: _ucase_totitle_56+A8j
		mov	edx, [ebp+var_FC]
		mov	[ebp+var_F8], edx

loc_AE83:				; CODE XREF: _ucase_totitle_56+89j
		mov	eax, [ebp+var_F8]
		mov	[ebp+var_F4], eax

loc_AE8F:				; CODE XREF: _ucase_totitle_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_F4]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 10h
		jnz	short loc_AECA
		movzx	eax, [ebp+var_8]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_AEC5
		movsx	eax, [ebp+var_8]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+arg_4], eax

loc_AEC5:				; CODE XREF: _ucase_totitle_56+146j
		jmp	loc_AF9D
; ---------------------------------------------------------------------------

loc_AECA:				; CODE XREF: _ucase_totitle_56+13Aj
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	cx, [eax]
		mov	[ebp+var_20], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		movzx	eax, [ebp+var_20]
		and	eax, 8
		jz	short loc_AF02
		mov	[ebp+var_2C], 3
		jmp	short loc_AF1C
; ---------------------------------------------------------------------------

loc_AF02:				; CODE XREF: _ucase_totitle_56+187j
		movzx	eax, [ebp+var_20]
		and	eax, 4
		jz	short loc_AF14
		mov	[ebp+var_2C], 2
		jmp	short loc_AF1C
; ---------------------------------------------------------------------------

loc_AF14:				; CODE XREF: _ucase_totitle_56+199j
		mov	eax, [ebp+arg_4]
		jmp	loc_AFA0
; ---------------------------------------------------------------------------

loc_AF1C:				; CODE XREF: _ucase_totitle_56+190j
					; _ucase_totitle_56+1A2j
		movzx	eax, [ebp+var_20]
		and	eax, 100h
		jnz	short loc_AF55
		movzx	eax, [ebp+var_20]
		mov	edx, 1
		mov	ecx, [ebp+var_2C]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		jmp	short loc_AF9D
; ---------------------------------------------------------------------------

loc_AF55:				; CODE XREF: _ucase_totitle_56+1B5j
		movzx	eax, [ebp+var_20]
		mov	edx, 1
		mov	ecx, [ebp+var_2C]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		shl	eax, 1
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_4]
		shl	eax, 10h
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+arg_4], eax

loc_AF9D:				; CODE XREF: _ucase_totitle_56:loc_AEC5j
					; _ucase_totitle_56+1E3j
		mov	eax, [ebp+arg_4]

loc_AFA0:				; CODE XREF: _ucase_totitle_56+1A7j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_totitle_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AFA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_addCaseClosure_56
_ucase_addCaseClosure_56 proc near	; CODE XREF: _ucase_addStringCaseClosure_56+170p

var_148		= dword	ptr -148h
var_144		= dword	ptr -144h
var_140		= dword	ptr -140h
var_13C		= dword	ptr -13Ch
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= word ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 148h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_148]
		mov	ecx, 52h ; 'R'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_13C], eax
		mov	ecx, [ebp+var_13C]
		sub	ecx, 49h ; 'I'
		mov	[ebp+var_13C], ecx
		cmp	[ebp+var_13C], 0E8h ; 'è' ; switch 233 cases
		ja	$LN27		; jumptable 0000AFFB default case
		mov	edx, [ebp+var_13C]
		movzx	eax, ds:$LN39[edx]
		jmp	ds:$LN40[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _ucase_addCaseClosure_56+53j
					; DATA XREF: .text:$LN40o
		mov	esi, esp	; jumptable 0000AFFB case 0
		push	69h ; 'i'
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx+4]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_B4FF
; ---------------------------------------------------------------------------

$LN25:					; CODE XREF: _ucase_addCaseClosure_56+53j
					; DATA XREF: .text:$LN40o
		mov	esi, esp	; jumptable 0000AFFB case 32
		push	49h ; 'I'
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx+4]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_B4FF
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _ucase_addCaseClosure_56+53j
					; DATA XREF: .text:$LN40o
		mov	esi, esp	; jumptable 0000AFFB case 231
		push	2
		push	offset _iDot
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx+0Ch]
		call	eax
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	loc_B4FF
; ---------------------------------------------------------------------------

$LN23:					; CODE XREF: _ucase_addCaseClosure_56+53j
					; DATA XREF: .text:$LN40o
		jmp	loc_B4FF	; jumptable 0000AFFB case 232
; ---------------------------------------------------------------------------

$LN27:					; CODE XREF: _ucase_addCaseClosure_56+40j
					; _ucase_addCaseClosure_56+53j
					; DATA XREF: ...
		cmp	[ebp+arg_4], 0D800h ; jumptable	0000AFFB default case
		jnb	short loc_B09C
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_13C], edx
		jmp	loc_B170
; ---------------------------------------------------------------------------

loc_B09C:				; CODE XREF: _ucase_addCaseClosure_56+CEj
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_B0DF
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_140], ecx
		jmp	loc_B164
; ---------------------------------------------------------------------------

loc_B0DF:				; CODE XREF: _ucase_addCaseClosure_56+FBj
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_B0FB
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_144], eax
		jmp	short loc_B158
; ---------------------------------------------------------------------------

loc_B0FB:				; CODE XREF: _ucase_addCaseClosure_56+13Ej
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_B114
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_148], ecx
		jmp	short loc_B14C
; ---------------------------------------------------------------------------

loc_B114:				; CODE XREF: _ucase_addCaseClosure_56+15Cj
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_148], eax

loc_B14C:				; CODE XREF: _ucase_addCaseClosure_56+16Aj
		mov	ecx, [ebp+var_148]
		mov	[ebp+var_144], ecx

loc_B158:				; CODE XREF: _ucase_addCaseClosure_56+151j
		mov	edx, [ebp+var_144]
		mov	[ebp+var_140], edx

loc_B164:				; CODE XREF: _ucase_addCaseClosure_56+132j
		mov	eax, [ebp+var_140]
		mov	[ebp+var_13C], eax

loc_B170:				; CODE XREF: _ucase_addCaseClosure_56+EFj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_13C]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 10h
		jnz	short loc_B1CC
		movzx	eax, [ebp+var_8]
		and	eax, 3
		jz	short loc_B1C7
		movsx	eax, [ebp+var_8]
		sar	eax, 7
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_B1C7
		mov	eax, [ebp+arg_4]
		add	eax, [ebp+var_14]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		call	ecx
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_B1C7:				; CODE XREF: _ucase_addCaseClosure_56+1ECj
					; _ucase_addCaseClosure_56+1FCj
		jmp	loc_B4FF
; ---------------------------------------------------------------------------

loc_B1CC:				; CODE XREF: _ucase_addCaseClosure_56+1E3j
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		mov	cx, [eax]
		mov	[ebp+var_44], cx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		mov	[ebp+var_50], 0
		jmp	short loc_B20A
; ---------------------------------------------------------------------------

loc_B201:				; CODE XREF: _ucase_addCaseClosure_56:loc_B2CFj
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax

loc_B20A:				; CODE XREF: _ucase_addCaseClosure_56+257j
		cmp	[ebp+var_50], 3
		jg	loc_B2D4
		movzx	eax, [ebp+var_44]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		and	eax, edx
		jz	loc_B2CF
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		movzx	eax, [ebp+var_44]
		and	eax, 100h
		jnz	short loc_B269
		movzx	eax, [ebp+var_44]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		jmp	short loc_B2B1
; ---------------------------------------------------------------------------

loc_B269:				; CODE XREF: _ucase_addCaseClosure_56+291j
		movzx	eax, [ebp+var_44]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		shl	eax, 1
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+arg_4]
		shl	eax, 10h
		mov	ecx, [ebp+var_2C]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+arg_4], eax

loc_B2B1:				; CODE XREF: _ucase_addCaseClosure_56+2BFj
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		call	ecx
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_B2CF:				; CODE XREF: _ucase_addCaseClosure_56+27Cj
		jmp	loc_B201
; ---------------------------------------------------------------------------

loc_B2D4:				; CODE XREF: _ucase_addCaseClosure_56+266j
		movzx	eax, [ebp+var_44]
		and	eax, 40h
		jz	loc_B364
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		movzx	eax, [ebp+var_44]
		and	eax, 100h
		jnz	short loc_B314
		movzx	eax, [ebp+var_44]
		and	eax, 3Fh
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_2C]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_5C], ecx
		jmp	short loc_B350
; ---------------------------------------------------------------------------

loc_B314:				; CODE XREF: _ucase_addCaseClosure_56+348j
		movzx	eax, [ebp+var_44]
		and	eax, 3Fh
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_2C]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_5C], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_5C]
		shl	eax, 10h
		mov	ecx, [ebp+var_2C]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_5C], eax

loc_B350:				; CODE XREF: _ucase_addCaseClosure_56+36Aj
		mov	eax, [ebp+var_5C]
		and	eax, 0Fh
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_2C]
		add	eax, 2
		mov	[ebp+var_38], eax
		jmp	short loc_B372
; ---------------------------------------------------------------------------

loc_B364:				; CODE XREF: _ucase_addCaseClosure_56+333j
		mov	[ebp+var_5C], 0
		mov	[ebp+var_38], 0

loc_B372:				; CODE XREF: _ucase_addCaseClosure_56+3BAj
		movzx	eax, [ebp+var_44]
		and	eax, 80h
		jz	loc_B488
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		movzx	eax, [ebp+var_44]
		and	eax, 100h
		jnz	short loc_B3B4
		movzx	eax, [ebp+var_44]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_2C]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_68], ecx
		jmp	short loc_B3F0
; ---------------------------------------------------------------------------

loc_B3B4:				; CODE XREF: _ucase_addCaseClosure_56+3E8j
		movzx	eax, [ebp+var_44]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_2C]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_68], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_68]
		shl	eax, 10h
		mov	ecx, [ebp+var_2C]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_68], eax

loc_B3F0:				; CODE XREF: _ucase_addCaseClosure_56+40Aj
		mov	eax, [ebp+var_2C]
		add	eax, 2
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_68]
		and	eax, 0FFFFh
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		and	eax, 0Fh
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_68]
		sar	eax, 4
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		and	eax, 0Fh
		mov	[ebp+var_74], eax
		jz	short loc_B455
		mov	esi, esp
		mov	eax, [ebp+var_74]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx+0Ch]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_74]
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx

loc_B455:				; CODE XREF: _ucase_addCaseClosure_56+47Dj
		mov	eax, [ebp+var_68]
		sar	eax, 4
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		and	eax, 0Fh
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_68]
		sar	eax, 4
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_38], eax

loc_B488:				; CODE XREF: _ucase_addCaseClosure_56+3D3j
		mov	[ebp+var_50], 0

loc_B48F:				; CODE XREF: _ucase_addCaseClosure_56+555j
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_5C]
		jge	short loc_B4FF
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_38]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+arg_4], edx
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		mov	eax, [ebp+arg_4]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_B4DF
		mov	eax, [ebp+arg_4]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_50]
		mov	edx, [ebp+var_38]
		movzx	ecx, word ptr [edx+ecx*2]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+arg_4], edx
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax

loc_B4DF:				; CODE XREF: _ucase_addCaseClosure_56+512j
		mov	esi, esp
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+4]
		call	ecx
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_B48F
; ---------------------------------------------------------------------------

loc_B4FF:				; CODE XREF: _ucase_addCaseClosure_56+76j
					; _ucase_addCaseClosure_56+97j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 148h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_addCaseClosure_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN40		dd offset $LN26, offset	$LN25, offset $LN24, offset $LN23
					; DATA XREF: _ucase_addCaseClosure_56+53r
		dd offset $LN27		; jump table for switch	statement
$LN39		db 0, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
					; DATA XREF: _ucase_addCaseClosure_56+4Cr
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 1,	4, 4, 4	; indirect table for switch statement
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4, 4, 4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	2, 3
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_addStringCaseClosure_56
_ucase_addStringCaseClosure_56 proc near

var_138		= byte ptr -138h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_B641
		cmp	[ebp+arg_4], 0
		jnz	short loc_B648

loc_B641:				; CODE XREF: _ucase_addStringCaseClosure_56+25j
		xor	al, al
		jmp	loc_B7B5
; ---------------------------------------------------------------------------

loc_B648:				; CODE XREF: _ucase_addStringCaseClosure_56+2Bj
		cmp	[ebp+arg_8], 1
		jg	short loc_B655
		xor	al, al
		jmp	loc_B7B5
; ---------------------------------------------------------------------------

loc_B655:				; CODE XREF: _ucase_addStringCaseClosure_56+38j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+var_5C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_5C]
		movzx	ecx, word ptr [eax+2]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_5C]
		movzx	ecx, word ptr [eax+4]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+var_5C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_50]
		jle	short loc_B696
		xor	al, al
		jmp	loc_B7B5
; ---------------------------------------------------------------------------

loc_B696:				; CODE XREF: _ucase_addStringCaseClosure_56+79j
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_38]
		mov	[ebp+var_20], eax

loc_B6A3:				; CODE XREF: _ucase_addStringCaseClosure_56:loc_B7AEj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jge	loc_B7B3
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		imul	eax, [ebp+var_44]
		mov	ecx, [ebp+var_5C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_68], edx
		mov	eax, [ebp+var_50]
		push	eax
		mov	ecx, [ebp+var_68]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		call	?strcmpMax@@YAHPB_WH0H@Z ; strcmpMax(wchar_t const *,int,wchar_t const *,int)
		add	esp, 10h
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jnz	loc_B797
		mov	eax, [ebp+var_50]
		mov	[ebp+var_8], eax

loc_B6F8:				; CODE XREF: _ucase_addStringCaseClosure_56+178j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_44]
		jge	loc_B791
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_68]
		movzx	edx, word ptr [ecx+eax*2]
		test	edx, edx
		jz	short loc_B791
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_68]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_74], edx
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_74]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_B75A
		mov	eax, [ebp+var_74]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_68]
		movzx	ecx, word ptr [edx+ecx*2]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_74], edx
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_B75A:				; CODE XREF: _ucase_addStringCaseClosure_56+121j
		mov	esi, esp
		mov	eax, [ebp+var_74]
		push	eax
		mov	ecx, [ebp+arg_C]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax+4]
		call	ecx
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_74]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ucase_addCaseClosure_56
		add	esp, 0Ch
		jmp	loc_B6F8
; ---------------------------------------------------------------------------

loc_B791:				; CODE XREF: _ucase_addStringCaseClosure_56+EAj
					; _ucase_addStringCaseClosure_56+FCj
		mov	al, 1
		jmp	short loc_B7B5
; ---------------------------------------------------------------------------
		jmp	short loc_B7AE
; ---------------------------------------------------------------------------

loc_B797:				; CODE XREF: _ucase_addStringCaseClosure_56+D8j
		cmp	[ebp+var_2C], 0
		jge	short loc_B7A5
		mov	eax, [ebp+var_8]
		mov	[ebp+var_20], eax
		jmp	short loc_B7AE
; ---------------------------------------------------------------------------

loc_B7A5:				; CODE XREF: _ucase_addStringCaseClosure_56+187j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_B7AE:				; CODE XREF: _ucase_addStringCaseClosure_56+181j
					; _ucase_addStringCaseClosure_56+18Fj
		jmp	loc_B6A3
; ---------------------------------------------------------------------------

loc_B7B3:				; CODE XREF: _ucase_addStringCaseClosure_56+95j
		xor	al, al

loc_B7B5:				; CODE XREF: _ucase_addStringCaseClosure_56+2Fj
					; _ucase_addStringCaseClosure_56+3Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_addStringCaseClosure_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B7CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl strcmpMax(wchar_t	const *, int, wchar_t const *, int)
?strcmpMax@@YAHPB_WH0H@Z proc near	; CODE XREF: _ucase_addStringCaseClosure_56+C9p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		sub	eax, [ebp+arg_4]
		mov	[ebp+arg_C], eax

loc_B7F3:				; CODE XREF: strcmpMax(wchar_t const *,int,wchar_t const *,int)+75j
		mov	eax, [ebp+arg_0]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 2
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+arg_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_14], ecx
		mov	edx, [ebp+arg_8]
		add	edx, 2
		mov	[ebp+arg_8], edx
		cmp	[ebp+var_14], 0
		jnz	short loc_B824
		mov	eax, 1
		jmp	short loc_B85E
; ---------------------------------------------------------------------------

loc_B824:				; CODE XREF: strcmpMax(wchar_t const *,int,wchar_t const *,int)+4Fj
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+var_14]
		mov	[ebp+var_8], eax
		jz	short loc_B834
		mov	eax, [ebp+var_8]
		jmp	short loc_B85E
; ---------------------------------------------------------------------------

loc_B834:				; CODE XREF: strcmpMax(wchar_t const *,int,wchar_t const *,int)+61j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		cmp	[ebp+arg_4], 0
		jg	short loc_B7F3
		cmp	[ebp+arg_C], 0
		jz	short loc_B853
		mov	eax, [ebp+arg_8]
		movzx	ecx, word ptr [eax]
		test	ecx, ecx
		jnz	short loc_B859

loc_B853:				; CODE XREF: strcmpMax(wchar_t const *,int,wchar_t const *,int)+7Bj
		xor	eax, eax
		jmp	short loc_B85E
; ---------------------------------------------------------------------------
		jmp	short loc_B85E
; ---------------------------------------------------------------------------

loc_B859:				; CODE XREF: strcmpMax(wchar_t const *,int,wchar_t const *,int)+85j
		mov	eax, [ebp+arg_C]
		neg	eax

loc_B85E:				; CODE XREF: strcmpMax(wchar_t const *,int,wchar_t const *,int)+56j
					; strcmpMax(wchar_t const *,int,wchar_t	const *,int)+66j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?strcmpMax@@YAHPB_WH0H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B868h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::FullCaseFoldingIterator::FullCaseFoldingIterator(icu_56::FullCaseFoldingIterator *__hidden this)
		public ??0FullCaseFoldingIterator@icu_56@@QAE@XZ
??0FullCaseFoldingIterator@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, ds:off_68E4
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx]
		mov	eax, [ebp+var_8]
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+2]
		mov	eax, [ebp+var_8]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+4]
		mov	eax, [ebp+var_8]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_8]
		mov	eax, [edx]
		lea	ecx, [eax+ecx*2]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0FullCaseFoldingIterator@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B8F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::FullCaseFoldingIterator::next(icu_56::FullCaseFoldingIterator *this, struct icu_56::UnicodeString *)
		public ?next@FullCaseFoldingIterator@icu_56@@QAEHAAVUnicodeString@2@@Z
?next@FullCaseFoldingIterator@icu_56@@QAEHAAVUnicodeString@2@@Z	proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+10h]
		imul	edx, [ecx+8]
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		lea	edx, [ecx+edx*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+14h]
		cmp	edx, [ecx+8]
		jge	short loc_B952
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		movzx	eax, word ptr [edx+ecx*2]
		test	eax, eax
		jnz	short loc_B97C

loc_B952:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+47j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax+14h], edx

loc_B97C:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+58j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+10h]
		cmp	edx, [ecx+4]
		jl	short loc_B992
		or	eax, 0FFFFFFFFh
		jmp	loc_BA2A
; ---------------------------------------------------------------------------

loc_B992:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+90j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx

loc_B99B:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+C1j
		cmp	[ebp+var_20], 0
		jle	short loc_B9BB
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2-2]
		test	edx, edx
		jnz	short loc_B9BB
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_B99B
; ---------------------------------------------------------------------------

loc_B9BB:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+A7j
					; icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+B6j
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; wchar_t *
		push	0		; signed __int8
		mov	ecx, [ebp+arg_0] ; this
		call	?setTo@UnicodeString@icu_56@@QAEAAV12@CPB_WH@Z ; icu_56::UnicodeString::setTo(signed char,wchar_t const	*,int)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	edx, [ebp+var_14]
		movzx	eax, word ptr [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	[eax+14h], edx
		mov	eax, [ebp+var_2C]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_BA27
		mov	eax, [ebp+var_2C]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+edx*2]
		lea	eax, [eax+edx-35FDC00h]
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+14h]
		add	edx, 1
		mov	eax, [ebp+var_8]
		mov	[eax+14h], edx

loc_BA27:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+101j
		mov	eax, [ebp+var_2C]

loc_BA2A:				; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+95j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?next@FullCaseFoldingIterator@icu_56@@QAEHAAVUnicodeString@2@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BA40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_getType_56
_ucase_getType_56 proc near		; CODE XREF: _u_isULowercase_56+27p
					; _u_isUUppercase_56+27p ...

var_DC		= dword	ptr -0DCh
var_D8		= dword	ptr -0D8h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_BA8B
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_D0], edx
		jmp	loc_BB5F
; ---------------------------------------------------------------------------

loc_BA8B:				; CODE XREF: _ucase_getType_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_BACE
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_D4], ecx
		jmp	loc_BB53
; ---------------------------------------------------------------------------

loc_BACE:				; CODE XREF: _ucase_getType_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_BAEA
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_D8], eax
		jmp	short loc_BB47
; ---------------------------------------------------------------------------

loc_BAEA:				; CODE XREF: _ucase_getType_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_BB03
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_DC], ecx
		jmp	short loc_BB3B
; ---------------------------------------------------------------------------

loc_BB03:				; CODE XREF: _ucase_getType_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_DC], eax

loc_BB3B:				; CODE XREF: _ucase_getType_56+C1j
		mov	ecx, [ebp+var_DC]
		mov	[ebp+var_D8], ecx

loc_BB47:				; CODE XREF: _ucase_getType_56+A8j
		mov	edx, [ebp+var_D8]
		mov	[ebp+var_D4], edx

loc_BB53:				; CODE XREF: _ucase_getType_56+89j
		mov	eax, [ebp+var_D4]
		mov	[ebp+var_D0], eax

loc_BB5F:				; CODE XREF: _ucase_getType_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_D0]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 3
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_getType_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BB84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_getTypeOrIgnorable_56
_ucase_getTypeOrIgnorable_56 proc near	; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+57p
					; _ucase_hasBinaryProperty_56+FCp

var_DC		= dword	ptr -0DCh
var_D8		= dword	ptr -0D8h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_BBCF
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_D0], edx
		jmp	loc_BCA3
; ---------------------------------------------------------------------------

loc_BBCF:				; CODE XREF: _ucase_getTypeOrIgnorable_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_BC12
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_D4], ecx
		jmp	loc_BC97
; ---------------------------------------------------------------------------

loc_BC12:				; CODE XREF: _ucase_getTypeOrIgnorable_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_BC2E
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_D8], eax
		jmp	short loc_BC8B
; ---------------------------------------------------------------------------

loc_BC2E:				; CODE XREF: _ucase_getTypeOrIgnorable_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_BC47
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_DC], ecx
		jmp	short loc_BC7F
; ---------------------------------------------------------------------------

loc_BC47:				; CODE XREF: _ucase_getTypeOrIgnorable_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_DC], eax

loc_BC7F:				; CODE XREF: _ucase_getTypeOrIgnorable_56+C1j
		mov	ecx, [ebp+var_DC]
		mov	[ebp+var_D8], ecx

loc_BC8B:				; CODE XREF: _ucase_getTypeOrIgnorable_56+A8j
		mov	edx, [ebp+var_D8]
		mov	[ebp+var_D4], edx

loc_BC97:				; CODE XREF: _ucase_getTypeOrIgnorable_56+89j
		mov	eax, [ebp+var_D4]
		mov	[ebp+var_D0], eax

loc_BCA3:				; CODE XREF: _ucase_getTypeOrIgnorable_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_D0]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 7
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_getTypeOrIgnorable_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BCC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_isSoftDotted_56
_ucase_isSoftDotted_56 proc near	; CODE XREF: _ucase_hasBinaryProperty_56+AFp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getDotType@@YAHPBUUCaseProps@@H@Z ; getDotType(UCaseProps const *,int)
		add	esp, 8
		cmp	eax, 20h ; ' '
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_isSoftDotted_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BD10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getDotType(struct	UCaseProps const *, int)
?getDotType@@YAHPBUUCaseProps@@H@Z proc	near ; CODE XREF: _ucase_isSoftDotted_56+26p
					; isPrecededBy_I(UCaseProps const *,int	(*)(void *,signed char),void *)+65p ...

var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_BD5B
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_DC], edx
		jmp	loc_BE2F
; ---------------------------------------------------------------------------

loc_BD5B:				; CODE XREF: getDotType(UCaseProps const *,int)+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_BD9E
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_E0], ecx
		jmp	loc_BE23
; ---------------------------------------------------------------------------

loc_BD9E:				; CODE XREF: getDotType(UCaseProps const *,int)+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_BDBA
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_E4], eax
		jmp	short loc_BE17
; ---------------------------------------------------------------------------

loc_BDBA:				; CODE XREF: getDotType(UCaseProps const *,int)+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_BDD3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_E8], ecx
		jmp	short loc_BE0B
; ---------------------------------------------------------------------------

loc_BDD3:				; CODE XREF: getDotType(UCaseProps const *,int)+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_E8], eax

loc_BE0B:				; CODE XREF: getDotType(UCaseProps const *,int)+C1j
		mov	ecx, [ebp+var_E8]
		mov	[ebp+var_E4], ecx

loc_BE17:				; CODE XREF: getDotType(UCaseProps const *,int)+A8j
		mov	edx, [ebp+var_E4]
		mov	[ebp+var_E0], edx

loc_BE23:				; CODE XREF: getDotType(UCaseProps const *,int)+89j
		mov	eax, [ebp+var_E0]
		mov	[ebp+var_DC], eax

loc_BE2F:				; CODE XREF: getDotType(UCaseProps const *,int)+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_DC]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 10h
		jnz	short loc_BE57
		movzx	eax, [ebp+var_8]
		and	eax, 60h
		jmp	short loc_BE76
; ---------------------------------------------------------------------------
		jmp	short loc_BE76
; ---------------------------------------------------------------------------

loc_BE57:				; CODE XREF: getDotType(UCaseProps const *,int)+13Aj
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		movzx	eax, word ptr [eax]
		sar	eax, 7
		and	eax, 60h

loc_BE76:				; CODE XREF: getDotType(UCaseProps const *,int)+143j
					; getDotType(UCaseProps	const *,int)+145j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getDotType@@YAHPBUUCaseProps@@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BE80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_isCaseSensitive_56
_ucase_isCaseSensitive_56 proc near	; CODE XREF: _ucase_hasBinaryProperty_56+C7p

var_DC		= dword	ptr -0DCh
var_D8		= dword	ptr -0D8h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_BECB
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_D0], edx
		jmp	loc_BF9F
; ---------------------------------------------------------------------------

loc_BECB:				; CODE XREF: _ucase_isCaseSensitive_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_BF0E
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_D4], ecx
		jmp	loc_BF93
; ---------------------------------------------------------------------------

loc_BF0E:				; CODE XREF: _ucase_isCaseSensitive_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_BF2A
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_D8], eax
		jmp	short loc_BF87
; ---------------------------------------------------------------------------

loc_BF2A:				; CODE XREF: _ucase_isCaseSensitive_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_BF43
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_DC], ecx
		jmp	short loc_BF7B
; ---------------------------------------------------------------------------

loc_BF43:				; CODE XREF: _ucase_isCaseSensitive_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_DC], eax

loc_BF7B:				; CODE XREF: _ucase_isCaseSensitive_56+C1j
		mov	ecx, [ebp+var_DC]
		mov	[ebp+var_D8], ecx

loc_BF87:				; CODE XREF: _ucase_isCaseSensitive_56+A8j
		mov	edx, [ebp+var_D8]
		mov	[ebp+var_D4], edx

loc_BF93:				; CODE XREF: _ucase_isCaseSensitive_56+89j
		mov	eax, [ebp+var_D4]
		mov	[ebp+var_D0], eax

loc_BF9F:				; CODE XREF: _ucase_isCaseSensitive_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_D0]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 8
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_isCaseSensitive_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BFC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_getCaseLocale_56
_ucase_getCaseLocale_56	proc near	; CODE XREF: _ucase_toFullLower_56+1A3p
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+19Fp

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jz	short loc_BFFE
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jz	short loc_BFFE
		mov	eax, [ebp+var_8]
		jmp	loc_C23A
; ---------------------------------------------------------------------------

loc_BFFE:				; CODE XREF: _ucase_getCaseLocale_56+22j
					; _ucase_getCaseLocale_56+30j
		mov	[ebp+var_8], 1
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 74h ; 't'
		jz	short loc_C028
		movsx	eax, [ebp+var_11]
		cmp	eax, 54h ; 'T'
		jnz	short loc_C09C

loc_C028:				; CODE XREF: _ucase_getCaseLocale_56+59j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 75h ; 'u'
		jz	short loc_C04B
		movsx	eax, [ebp+var_11]
		cmp	eax, 55h ; 'U'
		jnz	short loc_C05C

loc_C04B:				; CODE XREF: _ucase_getCaseLocale_56+7Cj
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx

loc_C05C:				; CODE XREF: _ucase_getCaseLocale_56+85j
		movsx	eax, [ebp+var_11]
		cmp	eax, 72h ; 'r'
		jz	short loc_C06E
		movsx	eax, [ebp+var_11]
		cmp	eax, 52h ; 'R'
		jnz	short loc_C097

loc_C06E:				; CODE XREF: _ucase_getCaseLocale_56+9Fj
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		movsx	eax, [ebp+var_11]
		cmp	eax, 5Fh ; '_'
		jz	short loc_C090
		movsx	eax, [ebp+var_11]
		cmp	eax, 2Dh ; '-'
		jz	short loc_C090
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_C097

loc_C090:				; CODE XREF: _ucase_getCaseLocale_56+B9j
					; _ucase_getCaseLocale_56+C2j
		mov	[ebp+var_8], 2

loc_C097:				; CODE XREF: _ucase_getCaseLocale_56+A8j
					; _ucase_getCaseLocale_56+CAj
		jmp	loc_C229
; ---------------------------------------------------------------------------

loc_C09C:				; CODE XREF: _ucase_getCaseLocale_56+62j
		movsx	eax, [ebp+var_11]
		cmp	eax, 61h ; 'a'
		jz	short loc_C0AE
		movsx	eax, [ebp+var_11]
		cmp	eax, 41h ; 'A'
		jnz	short loc_C122

loc_C0AE:				; CODE XREF: _ucase_getCaseLocale_56+DFj
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 7Ah ; 'z'
		jz	short loc_C0D1
		movsx	eax, [ebp+var_11]
		cmp	eax, 5Ah ; 'Z'
		jnz	short loc_C11D

loc_C0D1:				; CODE XREF: _ucase_getCaseLocale_56+102j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 65h ; 'e'
		jz	short loc_C0F4
		movsx	eax, [ebp+var_11]
		cmp	eax, 45h ; 'E'
		jnz	short loc_C0FC

loc_C0F4:				; CODE XREF: _ucase_getCaseLocale_56+125j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl

loc_C0FC:				; CODE XREF: _ucase_getCaseLocale_56+12Ej
		movsx	eax, [ebp+var_11]
		cmp	eax, 5Fh ; '_'
		jz	short loc_C116
		movsx	eax, [ebp+var_11]
		cmp	eax, 2Dh ; '-'
		jz	short loc_C116
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_C11D

loc_C116:				; CODE XREF: _ucase_getCaseLocale_56+13Fj
					; _ucase_getCaseLocale_56+148j
		mov	[ebp+var_8], 2

loc_C11D:				; CODE XREF: _ucase_getCaseLocale_56+10Bj
					; _ucase_getCaseLocale_56+150j
		jmp	loc_C229
; ---------------------------------------------------------------------------

loc_C122:				; CODE XREF: _ucase_getCaseLocale_56+E8j
		movsx	eax, [ebp+var_11]
		cmp	eax, 6Ch ; 'l'
		jz	short loc_C134
		movsx	eax, [ebp+var_11]
		cmp	eax, 4Ch ; 'L'
		jnz	short loc_C1A8

loc_C134:				; CODE XREF: _ucase_getCaseLocale_56+165j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 69h ; 'i'
		jz	short loc_C157
		movsx	eax, [ebp+var_11]
		cmp	eax, 49h ; 'I'
		jnz	short loc_C168

loc_C157:				; CODE XREF: _ucase_getCaseLocale_56+188j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx

loc_C168:				; CODE XREF: _ucase_getCaseLocale_56+191j
		movsx	eax, [ebp+var_11]
		cmp	eax, 74h ; 't'
		jz	short loc_C17A
		movsx	eax, [ebp+var_11]
		cmp	eax, 54h ; 'T'
		jnz	short loc_C1A3

loc_C17A:				; CODE XREF: _ucase_getCaseLocale_56+1ABj
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		movsx	eax, [ebp+var_11]
		cmp	eax, 5Fh ; '_'
		jz	short loc_C19C
		movsx	eax, [ebp+var_11]
		cmp	eax, 2Dh ; '-'
		jz	short loc_C19C
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_C1A3

loc_C19C:				; CODE XREF: _ucase_getCaseLocale_56+1C5j
					; _ucase_getCaseLocale_56+1CEj
		mov	[ebp+var_8], 3

loc_C1A3:				; CODE XREF: _ucase_getCaseLocale_56+1B4j
					; _ucase_getCaseLocale_56+1D6j
		jmp	loc_C229
; ---------------------------------------------------------------------------

loc_C1A8:				; CODE XREF: _ucase_getCaseLocale_56+16Ej
		movsx	eax, [ebp+var_11]
		cmp	eax, 6Eh ; 'n'
		jz	short loc_C1BA
		movsx	eax, [ebp+var_11]
		cmp	eax, 4Eh ; 'N'
		jnz	short loc_C229

loc_C1BA:				; CODE XREF: _ucase_getCaseLocale_56+1EBj
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 6Ch ; 'l'
		jz	short loc_C1DD
		movsx	eax, [ebp+var_11]
		cmp	eax, 4Ch ; 'L'
		jnz	short loc_C229

loc_C1DD:				; CODE XREF: _ucase_getCaseLocale_56+20Ej
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+var_11]
		cmp	eax, 64h ; 'd'
		jz	short loc_C200
		movsx	eax, [ebp+var_11]
		cmp	eax, 44h ; 'D'
		jnz	short loc_C208

loc_C200:				; CODE XREF: _ucase_getCaseLocale_56+231j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl

loc_C208:				; CODE XREF: _ucase_getCaseLocale_56+23Aj
		movsx	eax, [ebp+var_11]
		cmp	eax, 5Fh ; '_'
		jz	short loc_C222
		movsx	eax, [ebp+var_11]
		cmp	eax, 2Dh ; '-'
		jz	short loc_C222
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_C229

loc_C222:				; CODE XREF: _ucase_getCaseLocale_56+24Bj
					; _ucase_getCaseLocale_56+254j
		mov	[ebp+var_8], 4

loc_C229:				; CODE XREF: _ucase_getCaseLocale_56:loc_C097j
					; _ucase_getCaseLocale_56:loc_C11Dj ...
		cmp	[ebp+arg_4], 0
		jz	short loc_C237
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_8]
		mov	[eax], ecx

loc_C237:				; CODE XREF: _ucase_getCaseLocale_56+269j
		mov	eax, [ebp+var_8]

loc_C23A:				; CODE XREF: _ucase_getCaseLocale_56+35j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_getCaseLocale_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C244h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_toFullLower_56
_ucase_toFullLower_56 proc near		; CODE XREF: _ucase_hasBinaryProperty_56+12Fp
					; _ucase_hasBinaryProperty_56+1CEp

var_124		= dword	ptr -124h
var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_C295
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_118], edx
		jmp	loc_C369
; ---------------------------------------------------------------------------

loc_C295:				; CODE XREF: _ucase_toFullLower_56+2Bj
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_C2D8
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_11C], ecx
		jmp	loc_C35D
; ---------------------------------------------------------------------------

loc_C2D8:				; CODE XREF: _ucase_toFullLower_56+58j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_C2F4
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_120], eax
		jmp	short loc_C351
; ---------------------------------------------------------------------------

loc_C2F4:				; CODE XREF: _ucase_toFullLower_56+9Bj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_C30D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_124], ecx
		jmp	short loc_C345
; ---------------------------------------------------------------------------

loc_C30D:				; CODE XREF: _ucase_toFullLower_56+B9j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_124], eax

loc_C345:				; CODE XREF: _ucase_toFullLower_56+C7j
		mov	ecx, [ebp+var_124]
		mov	[ebp+var_120], ecx

loc_C351:				; CODE XREF: _ucase_toFullLower_56+AEj
		mov	edx, [ebp+var_120]
		mov	[ebp+var_11C], edx

loc_C35D:				; CODE XREF: _ucase_toFullLower_56+8Fj
		mov	eax, [ebp+var_11C]
		mov	[ebp+var_118], eax

loc_C369:				; CODE XREF: _ucase_toFullLower_56+4Cj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_118]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_14], cx
		movzx	eax, [ebp+var_14]
		and	eax, 10h
		jnz	short loc_C3A4
		movzx	eax, [ebp+var_14]
		and	eax, 3
		cmp	eax, 2
		jl	short loc_C39F
		movsx	eax, [ebp+var_14]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax

loc_C39F:				; CODE XREF: _ucase_toFullLower_56+14Cj
		jmp	loc_C704
; ---------------------------------------------------------------------------

loc_C3A4:				; CODE XREF: _ucase_toFullLower_56+140j
		movzx	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	cx, [eax]
		mov	[ebp+var_38], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		movzx	eax, [ebp+var_38]
		and	eax, 4000h
		jz	loc_C5FC
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		call	_ucase_getCaseLocale_56
		add	esp, 8
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 3
		jnz	loc_C505
		cmp	[ebp+arg_4], 49h ; 'I'
		jz	short loc_C411
		cmp	[ebp+arg_4], 4Ah ; 'J'
		jz	short loc_C411
		cmp	[ebp+arg_4], 12Eh
		jnz	short loc_C42C

loc_C411:				; CODE XREF: _ucase_toFullLower_56+1BCj
					; _ucase_toFullLower_56+1C2j
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?isFollowedByMoreAbove@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z	; isFollowedByMoreAbove(UCaseProps const *,int (*)(void	*,signed char),void *)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jnz	short loc_C44B

loc_C42C:				; CODE XREF: _ucase_toFullLower_56+1CBj
		cmp	[ebp+arg_4], 0CCh ; 'Ì'
		jz	short loc_C44B
		cmp	[ebp+arg_4], 0CDh ; 'Í'
		jz	short loc_C44B
		cmp	[ebp+arg_4], 128h
		jnz	loc_C505

loc_C44B:				; CODE XREF: _ucase_toFullLower_56+1E6j
					; _ucase_toFullLower_56+1EFj ...
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_118], eax
		mov	ecx, [ebp+var_118]
		sub	ecx, 49h ; 'I'
		mov	[ebp+var_118], ecx
		cmp	[ebp+var_118], 0E5h ; 'å' ; switch 230 cases
		ja	$LN20		; jumptable 0000C480 default case
		mov	edx, [ebp+var_118]
		movzx	eax, ds:$LN50[edx]
		jmp	ds:$LN51[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN26_0:				; CODE XREF: _ucase_toFullLower_56+23Cj
					; DATA XREF: .text:$LN51o
		mov	eax, [ebp+arg_10] ; jumptable 0000C480 case 0
		mov	dword ptr [eax], offset	_iDot
		mov	eax, 2
		jmp	loc_C728
; ---------------------------------------------------------------------------

$LN25_0:				; CODE XREF: _ucase_toFullLower_56+23Cj
					; DATA XREF: .text:$LN51o
		mov	eax, [ebp+arg_10] ; jumptable 0000C480 case 1
		mov	dword ptr [eax], offset	_jDot
		mov	eax, 2
		jmp	loc_C728
; ---------------------------------------------------------------------------

$LN24_0:				; CODE XREF: _ucase_toFullLower_56+23Cj
					; DATA XREF: .text:$LN51o
		mov	eax, [ebp+arg_10] ; jumptable 0000C480 case 229
		mov	dword ptr [eax], offset	_iOgonekDot
		mov	eax, 2
		jmp	loc_C728
; ---------------------------------------------------------------------------

$LN23_0:				; CODE XREF: _ucase_toFullLower_56+23Cj
					; DATA XREF: .text:$LN51o
		mov	eax, [ebp+arg_10] ; jumptable 0000C480 case 131
		mov	dword ptr [eax], offset	_iDotGrave
		mov	eax, 3
		jmp	loc_C728
; ---------------------------------------------------------------------------

$LN22:					; CODE XREF: _ucase_toFullLower_56+23Cj
					; DATA XREF: .text:$LN51o
		mov	eax, [ebp+arg_10] ; jumptable 0000C480 case 132
		mov	dword ptr [eax], offset	_iDotAcute
		mov	eax, 3
		jmp	loc_C728
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _ucase_toFullLower_56+23Cj
					; DATA XREF: .text:$LN51o
		mov	eax, [ebp+arg_10] ; jumptable 0000C480 case 223
		mov	dword ptr [eax], offset	_iDotTilde
		mov	eax, 3
		jmp	loc_C728
; ---------------------------------------------------------------------------

$LN20:					; CODE XREF: _ucase_toFullLower_56+229j
					; _ucase_toFullLower_56+23Cj
					; DATA XREF: ...
		xor	eax, eax	; jumptable 0000C480 default case
		jmp	loc_C728
; ---------------------------------------------------------------------------
		jmp	loc_C5F7
; ---------------------------------------------------------------------------

loc_C505:				; CODE XREF: _ucase_toFullLower_56+1B2j
					; _ucase_toFullLower_56+201j
		cmp	[ebp+var_50], 2
		jnz	short loc_C523
		cmp	[ebp+arg_4], 130h
		jnz	short loc_C523
		mov	eax, 69h ; 'i'
		jmp	loc_C728
; ---------------------------------------------------------------------------
		jmp	loc_C5F7
; ---------------------------------------------------------------------------

loc_C523:				; CODE XREF: _ucase_toFullLower_56+2C5j
					; _ucase_toFullLower_56+2CEj
		cmp	[ebp+var_50], 2
		jnz	short loc_C559
		cmp	[ebp+arg_4], 307h
		jnz	short loc_C559
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?isPrecededBy_I@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z ; isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void *)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_C559
		xor	eax, eax
		jmp	loc_C728
; ---------------------------------------------------------------------------
		jmp	loc_C5F7
; ---------------------------------------------------------------------------

loc_C559:				; CODE XREF: _ucase_toFullLower_56+2E3j
					; _ucase_toFullLower_56+2ECj ...
		cmp	[ebp+var_50], 2
		jnz	short loc_C58C
		cmp	[ebp+arg_4], 49h ; 'I'
		jnz	short loc_C58C
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?isFollowedByDotAbove@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z ; isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jnz	short loc_C58C
		mov	eax, 131h
		jmp	loc_C728
; ---------------------------------------------------------------------------
		jmp	short loc_C5F7
; ---------------------------------------------------------------------------

loc_C58C:				; CODE XREF: _ucase_toFullLower_56+319j
					; _ucase_toFullLower_56+31Fj ...
		cmp	[ebp+arg_4], 130h
		jnz	short loc_C5AA
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], offset	_iDot
		mov	eax, 2
		jmp	loc_C728
; ---------------------------------------------------------------------------
		jmp	short loc_C5F7
; ---------------------------------------------------------------------------

loc_C5AA:				; CODE XREF: _ucase_toFullLower_56+34Fj
		cmp	[ebp+arg_4], 3A3h
		jnz	short loc_C5F7
		push	1
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?isFollowedByCasedLetter@@YACPBUUCaseProps@@P6AHPAXC@Z1C@Z ; isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)
		add	esp, 10h
		movsx	eax, al
		test	eax, eax
		jnz	short loc_C5F7
		push	0FFFFFFFFh
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?isFollowedByCasedLetter@@YACPBUUCaseProps@@P6AHPAXC@Z1C@Z ; isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)
		add	esp, 10h
		movsx	eax, al
		test	eax, eax
		jz	short loc_C5F7
		mov	eax, 3C2h
		jmp	loc_C728
; ---------------------------------------------------------------------------

loc_C5F7:				; CODE XREF: _ucase_toFullLower_56+2BCj
					; _ucase_toFullLower_56+2DAj ...
		jmp	loc_C692
; ---------------------------------------------------------------------------

loc_C5FC:				; CODE XREF: _ucase_toFullLower_56+195j
		movzx	eax, [ebp+var_38]
		and	eax, 80h
		jz	loc_C692
		movzx	eax, [ebp+var_38]
		and	eax, 100h
		jnz	short loc_C638
		movzx	eax, [ebp+var_38]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		jmp	short loc_C674
; ---------------------------------------------------------------------------

loc_C638:				; CODE XREF: _ucase_toFullLower_56+3D0j
		movzx	eax, [ebp+var_38]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		shl	eax, 10h
		mov	ecx, [ebp+var_20]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_44], eax

loc_C674:				; CODE XREF: _ucase_toFullLower_56+3F2j
		mov	eax, [ebp+var_44]
		and	eax, 0Fh
		mov	[ebp+var_44], eax
		jz	short loc_C692
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	ecx, [ebp+arg_10]
		mov	[ecx], eax
		mov	eax, [ebp+var_44]
		jmp	loc_C728
; ---------------------------------------------------------------------------

loc_C692:				; CODE XREF: _ucase_toFullLower_56:loc_C5F7j
					; _ucase_toFullLower_56+3C1j ...
		movzx	eax, [ebp+var_38]
		and	eax, 1
		jz	short loc_C704
		movzx	eax, [ebp+var_38]
		and	eax, 100h
		jnz	short loc_C6C8
		movzx	eax, [ebp+var_38]
		and	eax, 0
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_2C]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		jmp	short loc_C704
; ---------------------------------------------------------------------------

loc_C6C8:				; CODE XREF: _ucase_toFullLower_56+460j
		movzx	eax, [ebp+var_38]
		and	eax, 0
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_2C]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_8]
		shl	eax, 10h
		mov	ecx, [ebp+var_2C]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_8], eax

loc_C704:				; CODE XREF: _ucase_toFullLower_56:loc_C39Fj
					; _ucase_toFullLower_56+455j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_C719
		mov	ecx, [ebp+var_8]
		not	ecx
		mov	[ebp+var_118], ecx
		jmp	short loc_C722
; ---------------------------------------------------------------------------

loc_C719:				; CODE XREF: _ucase_toFullLower_56+4C6j
		mov	edx, [ebp+var_8]
		mov	[ebp+var_118], edx

loc_C722:				; CODE XREF: _ucase_toFullLower_56+4D3j
		mov	eax, [ebp+var_118]

loc_C728:				; CODE XREF: _ucase_toFullLower_56+251j
					; _ucase_toFullLower_56+264j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 124h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_toFullLower_56 endp

; ---------------------------------------------------------------------------
$LN51		dd offset $LN26_0, offset $LN25_0, offset $LN23_0, offset $LN22
					; DATA XREF: _ucase_toFullLower_56+23Cr
		dd offset $LN21, offset	$LN24_0, offset	$LN20 ;	jump table for switch statement
$LN50		db 0, 1, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
					; DATA XREF: _ucase_toFullLower_56+235r
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6	; indirect table for switch statement
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 2, 3,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6, 6, 6
		db 6, 6, 6, 6, 6, 6, 6,	4, 6, 6, 6, 6, 6, 5
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C840h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isFollowedByCasedLetter(struct UCaseProps	const *, int (__cdecl *)(void *, signed	char), void *, signed char)
?isFollowedByCasedLetter@@YACPBUUCaseProps@@P6AHPAXC@Z1C@Z proc	near
					; CODE XREF: _ucase_toFullLower_56+37Dp
					; _ucase_toFullLower_56+39Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jnz	short loc_C868
		xor	al, al
		jmp	short loc_C8C0
; ---------------------------------------------------------------------------

loc_C868:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+22j
		jmp	short loc_C86E
; ---------------------------------------------------------------------------

loc_C86A:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char):loc_C8BCj
		mov	[ebp+arg_C], 0

loc_C86E:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char):loc_C868j
		mov	esi, esp
		movzx	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_C8BE
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_ucase_getTypeOrIgnorable_56
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 4
		jz	short loc_C8AC
		jmp	short loc_C8BC
; ---------------------------------------------------------------------------

loc_C8AC:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+68j
		cmp	[ebp+var_14], 0
		jz	short loc_C8B8
		mov	al, 1
		jmp	short loc_C8C0
; ---------------------------------------------------------------------------
		jmp	short loc_C8BC
; ---------------------------------------------------------------------------

loc_C8B8:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+70j
		xor	al, al
		jmp	short loc_C8C0
; ---------------------------------------------------------------------------

loc_C8BC:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+6Aj
					; isFollowedByCasedLetter(UCaseProps const *,int (*)(void *,signed char),void *,signed char)+76j
		jmp	short loc_C86A
; ---------------------------------------------------------------------------

loc_C8BE:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+4Dj
		xor	al, al

loc_C8C0:				; CODE XREF: isFollowedByCasedLetter(UCaseProps	const *,int (*)(void *,signed char),void *,signed char)+26j
					; isFollowedByCasedLetter(UCaseProps const *,int (*)(void *,signed char),void *,signed char)+74j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isFollowedByCasedLetter@@YACPBUUCaseProps@@P6AHPAXC@Z1C@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isPrecededBy_I(struct UCaseProps const *,	int (__cdecl *)(void *,	signed char), void *)
?isPrecededBy_I@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z proc near
					; CODE XREF: _ucase_toFullLower_56+2FAp

var_E4		= byte ptr -0E4h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jnz	short loc_C8FC
		xor	al, al
		jmp	short loc_C952
; ---------------------------------------------------------------------------

loc_C8FC:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*)+22j
		mov	[ebp+var_1D], 0FFh
		jmp	short loc_C906
; ---------------------------------------------------------------------------

loc_C902:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*):loc_C94Ej
		mov	[ebp+var_1D], 0

loc_C906:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*)+2Cj
		mov	esi, esp
		movzx	eax, [ebp+var_1D]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_C950
		cmp	[ebp+var_8], 49h ; 'I'
		jnz	short loc_C931
		mov	al, 1
		jmp	short loc_C952
; ---------------------------------------------------------------------------

loc_C931:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*)+57j
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getDotType@@YAHPBUUCaseProps@@H@Z ; getDotType(UCaseProps const *,int)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 60h ; '`'
		jz	short loc_C94E
		xor	al, al
		jmp	short loc_C952
; ---------------------------------------------------------------------------

loc_C94E:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*)+74j
		jmp	short loc_C902
; ---------------------------------------------------------------------------

loc_C950:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*)+51j
		xor	al, al

loc_C952:				; CODE XREF: isPrecededBy_I(UCaseProps const *,int (*)(void *,signed char),void	*)+26j
					; isPrecededBy_I(UCaseProps const *,int	(*)(void *,signed char),void *)+5Bj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isPrecededBy_I@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C968h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isFollowedByMoreAbove(struct UCaseProps const *, int (__cdecl *)(void *, signed char), void *)
?isFollowedByMoreAbove@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z	proc near
					; CODE XREF: _ucase_toFullLower_56+1D9p

var_E4		= byte ptr -0E4h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jnz	short loc_C990
		xor	al, al
		jmp	short loc_C9E8
; ---------------------------------------------------------------------------

loc_C990:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *)+22j
		mov	[ebp+var_1D], 1
		jmp	short loc_C99A
; ---------------------------------------------------------------------------

loc_C996:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *):loc_C9E4j
		mov	[ebp+var_1D], 0

loc_C99A:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *)+2Cj
		mov	esi, esp
		movzx	eax, [ebp+var_1D]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_C9E6
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getDotType@@YAHPBUUCaseProps@@H@Z ; getDotType(UCaseProps const *,int)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 40h ; '@'
		jnz	short loc_C9DA
		mov	al, 1
		jmp	short loc_C9E8
; ---------------------------------------------------------------------------
		jmp	short loc_C9E4
; ---------------------------------------------------------------------------

loc_C9DA:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *)+6Aj
		cmp	[ebp+var_14], 60h ; '`'
		jz	short loc_C9E4
		xor	al, al
		jmp	short loc_C9E8
; ---------------------------------------------------------------------------

loc_C9E4:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *)+70j
					; isFollowedByMoreAbove(UCaseProps const *,int (*)(void	*,signed char),void *)+76j
		jmp	short loc_C996
; ---------------------------------------------------------------------------

loc_C9E6:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *)+51j
		xor	al, al

loc_C9E8:				; CODE XREF: isFollowedByMoreAbove(UCaseProps const *,int (*)(void *,signed char),void *)+26j
					; isFollowedByMoreAbove(UCaseProps const *,int (*)(void	*,signed char),void *)+6Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isFollowedByMoreAbove@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C9FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isFollowedByDotAbove(struct UCaseProps const *, int (__cdecl *)(void *, signed char), void *)
?isFollowedByDotAbove@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z proc near
					; CODE XREF: _ucase_toFullLower_56+32Dp

var_E4		= byte ptr -0E4h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jnz	short loc_CA24
		xor	al, al
		jmp	short loc_CA7D
; ---------------------------------------------------------------------------

loc_CA24:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)+22j
		mov	[ebp+var_1D], 1
		jmp	short loc_CA2E
; ---------------------------------------------------------------------------

loc_CA2A:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *):loc_CA79j
		mov	[ebp+var_1D], 0

loc_CA2E:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)+2Cj
		mov	esi, esp
		movzx	eax, [ebp+var_1D]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_CA7B
		cmp	[ebp+var_8], 307h
		jnz	short loc_CA5C
		mov	al, 1
		jmp	short loc_CA7D
; ---------------------------------------------------------------------------

loc_CA5C:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)+5Aj
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getDotType@@YAHPBUUCaseProps@@H@Z ; getDotType(UCaseProps const *,int)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 60h ; '`'
		jz	short loc_CA79
		xor	al, al
		jmp	short loc_CA7D
; ---------------------------------------------------------------------------

loc_CA79:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)+77j
		jmp	short loc_CA2A
; ---------------------------------------------------------------------------

loc_CA7B:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)+51j
		xor	al, al

loc_CA7D:				; CODE XREF: isFollowedByDotAbove(UCaseProps const *,int (*)(void *,signed char),void *)+26j
					; isFollowedByDotAbove(UCaseProps const	*,int (*)(void *,signed	char),void *)+5Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isFollowedByDotAbove@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CA94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_toFullUpper_56
_ucase_toFullUpper_56 proc near		; CODE XREF: _ucase_hasBinaryProperty_56+164p
					; _ucase_hasBinaryProperty_56+1F3p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	1
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?toUpperOrTitle@@YAHPBUUCaseProps@@HP6AHPAXC@Z1PAPB_WPBDPAHC@Z ; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void	*,wchar_t const	* *,char const *,int *,signed char)
		add	esp, 20h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_toFullUpper_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CAECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl toUpperOrTitle(struct UCaseProps const *,	int, int (__cdecl *)(void *, signed char), void	*, wchar_t const * *, char const *, int	*, signed char)
?toUpperOrTitle@@YAHPBUUCaseProps@@HP6AHPAXC@Z1PAPB_WPBDPAHC@Z proc near
					; CODE XREF: _ucase_toFullUpper_56+3Cp
					; _ucase_toFullTitle_56+3Cp

var_130		= dword	ptr -130h
var_12C		= dword	ptr -12Ch
var_128		= dword	ptr -128h
var_124		= dword	ptr -124h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= byte ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 130h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_130]
		mov	ecx, 4Ch ; 'L'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_CB3D
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_124], edx
		jmp	loc_CC11
; ---------------------------------------------------------------------------

loc_CB3D:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+2Bj
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_CB80
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_128], ecx
		jmp	loc_CC05
; ---------------------------------------------------------------------------

loc_CB80:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+58j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_CB9C
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_12C], eax
		jmp	short loc_CBF9
; ---------------------------------------------------------------------------

loc_CB9C:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+9Bj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_CBB5
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_130], ecx
		jmp	short loc_CBED
; ---------------------------------------------------------------------------

loc_CBB5:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+B9j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_130], eax

loc_CBED:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+C7j
		mov	ecx, [ebp+var_130]
		mov	[ebp+var_12C], ecx

loc_CBF9:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+AEj
		mov	edx, [ebp+var_12C]
		mov	[ebp+var_128], edx

loc_CC05:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+8Fj
		mov	eax, [ebp+var_128]
		mov	[ebp+var_124], eax

loc_CC11:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+4Cj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_124]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_14], cx
		movzx	eax, [ebp+var_14]
		and	eax, 10h
		jnz	short loc_CC4C
		movzx	eax, [ebp+var_14]
		and	eax, 3
		cmp	eax, 1
		jnz	short loc_CC47
		movsx	eax, [ebp+var_14]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax

loc_CC47:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+14Cj
		jmp	loc_CE90
; ---------------------------------------------------------------------------

loc_CC4C:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+140j
		movzx	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	cx, [eax]
		mov	[ebp+var_38], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		movzx	eax, [ebp+var_38]
		and	eax, 4000h
		jz	short loc_CCE4
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		call	_ucase_getCaseLocale_56
		add	esp, 8
		mov	[ebp+var_5C], eax
		cmp	[ebp+var_5C], 2
		jnz	short loc_CCAE
		cmp	[ebp+arg_4], 69h ; 'i'
		jnz	short loc_CCAE
		mov	eax, 130h
		jmp	loc_CEB4
; ---------------------------------------------------------------------------
		jmp	short loc_CCDF
; ---------------------------------------------------------------------------

loc_CCAE:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+1AEj
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+1B4j
		cmp	[ebp+var_5C], 3
		jnz	short loc_CCDF
		cmp	[ebp+arg_4], 307h
		jnz	short loc_CCDF
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?isPrecededBySoftDotted@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z ; isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void *)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_CCDF
		xor	eax, eax
		jmp	loc_CEB4
; ---------------------------------------------------------------------------

loc_CCDF:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+1C0j
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+1C6j ...
		jmp	loc_CDD9
; ---------------------------------------------------------------------------

loc_CCE4:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+195j
		movzx	eax, [ebp+var_38]
		and	eax, 80h
		jz	loc_CDD9
		movzx	eax, [ebp+var_38]
		and	eax, 100h
		jnz	short loc_CD20
		movzx	eax, [ebp+var_38]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		jmp	short loc_CD5C
; ---------------------------------------------------------------------------

loc_CD20:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+210j
		movzx	eax, [ebp+var_38]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		shl	eax, 10h
		mov	ecx, [ebp+var_20]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_44], eax

loc_CD5C:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+232j
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_44]
		and	eax, 0Fh
		mov	ecx, [ebp+var_20]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		sar	eax, 4
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		and	eax, 0Fh
		mov	ecx, [ebp+var_20]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		sar	eax, 4
		mov	[ebp+var_44], eax
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_CDA8
		mov	eax, [ebp+var_44]
		and	eax, 0Fh
		mov	[ebp+var_44], eax
		jmp	short loc_CDC3
; ---------------------------------------------------------------------------

loc_CDA8:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+2AFj
		mov	eax, [ebp+var_44]
		and	eax, 0Fh
		mov	ecx, [ebp+var_20]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		sar	eax, 4
		and	eax, 0Fh
		mov	[ebp+var_44], eax

loc_CDC3:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+2BAj
		cmp	[ebp+var_44], 0
		jz	short loc_CDD9
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		mov	eax, [ebp+var_44]
		jmp	loc_CEB4
; ---------------------------------------------------------------------------

loc_CDD9:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char):loc_CCDFj
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+201j ...
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jnz	short loc_CDF3
		movzx	eax, [ebp+var_38]
		and	eax, 8
		jz	short loc_CDF3
		mov	[ebp+var_50], 3
		jmp	short loc_CE0F
; ---------------------------------------------------------------------------

loc_CDF3:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+2F3j
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+2FCj
		movzx	eax, [ebp+var_38]
		and	eax, 4
		jz	short loc_CE05
		mov	[ebp+var_50], 2
		jmp	short loc_CE0F
; ---------------------------------------------------------------------------

loc_CE05:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+30Ej
		mov	eax, [ebp+arg_4]
		not	eax
		jmp	loc_CEB4
; ---------------------------------------------------------------------------

loc_CE0F:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+305j
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+317j
		movzx	eax, [ebp+var_38]
		and	eax, 100h
		jnz	short loc_CE48
		movzx	eax, [ebp+var_38]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		jmp	short loc_CE90
; ---------------------------------------------------------------------------

loc_CE48:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+32Cj
		movzx	eax, [ebp+var_38]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		shl	eax, 1
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_8]
		shl	eax, 10h
		mov	ecx, [ebp+var_2C]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_8], eax

loc_CE90:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char):loc_CC47j
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+35Aj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_CEA5
		mov	ecx, [ebp+var_8]
		not	ecx
		mov	[ebp+var_124], ecx
		jmp	short loc_CEAE
; ---------------------------------------------------------------------------

loc_CEA5:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+3AAj
		mov	edx, [ebp+var_8]
		mov	[ebp+var_124], edx

loc_CEAE:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+3B7j
		mov	eax, [ebp+var_124]

loc_CEB4:				; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+1BBj
					; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void *,wchar_t const * *,char const	*,int *,signed char)+1EEj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 130h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?toUpperOrTitle@@YAHPBUUCaseProps@@HP6AHPAXC@Z1PAPB_WPBDPAHC@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CEC8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isPrecededBySoftDotted(struct UCaseProps const *,	int (__cdecl *)(void *,	signed char), void *)
?isPrecededBySoftDotted@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z proc near
					; CODE XREF: toUpperOrTitle(UCaseProps const *,int,int (*)(void	*,signed char),void *,wchar_t const * *,char const *,int *,signed char)+1DDp

var_E4		= byte ptr -0E4h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jnz	short loc_CEF0
		xor	al, al
		jmp	short loc_CF48
; ---------------------------------------------------------------------------

loc_CEF0:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*)+22j
		mov	[ebp+var_1D], 0FFh
		jmp	short loc_CEFA
; ---------------------------------------------------------------------------

loc_CEF6:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*):loc_CF44j
		mov	[ebp+var_1D], 0

loc_CEFA:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*)+2Cj
		mov	esi, esp
		movzx	eax, [ebp+var_1D]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_CF46
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?getDotType@@YAHPBUUCaseProps@@H@Z ; getDotType(UCaseProps const *,int)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 20h ; ' '
		jnz	short loc_CF3A
		mov	al, 1
		jmp	short loc_CF48
; ---------------------------------------------------------------------------
		jmp	short loc_CF44
; ---------------------------------------------------------------------------

loc_CF3A:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*)+6Aj
		cmp	[ebp+var_14], 60h ; '`'
		jz	short loc_CF44
		xor	al, al
		jmp	short loc_CF48
; ---------------------------------------------------------------------------

loc_CF44:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*)+70j
					; isPrecededBySoftDotted(UCaseProps const *,int	(*)(void *,signed char),void *)+76j
		jmp	short loc_CEF6
; ---------------------------------------------------------------------------

loc_CF46:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*)+51j
		xor	al, al

loc_CF48:				; CODE XREF: isPrecededBySoftDotted(UCaseProps const *,int (*)(void *,signed char),void	*)+26j
					; isPrecededBySoftDotted(UCaseProps const *,int	(*)(void *,signed char),void *)+6Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isPrecededBySoftDotted@@YACPBUUCaseProps@@P6AHPAXC@Z1@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CF5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_toFullTitle_56
_ucase_toFullTitle_56 proc near		; CODE XREF: _ucase_hasBinaryProperty_56+199p
					; _ucase_hasBinaryProperty_56+218p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	0
		mov	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?toUpperOrTitle@@YAHPBUUCaseProps@@HP6AHPAXC@Z1PAPB_WPBDPAHC@Z ; toUpperOrTitle(UCaseProps const *,int,int (*)(void *,signed char),void	*,wchar_t const	* *,char const *,int *,signed char)
		add	esp, 20h
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_toFullTitle_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CFB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_fold_56
_ucase_fold_56	proc near		; CODE XREF: _u_foldCase_56+2Bp

var_100		= dword	ptr -100h
var_FC		= dword	ptr -0FCh
var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_CFFF
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_F4], edx
		jmp	loc_D0D3
; ---------------------------------------------------------------------------

loc_CFFF:				; CODE XREF: _ucase_fold_56+25j
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_D042
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_F8], ecx
		jmp	loc_D0C7
; ---------------------------------------------------------------------------

loc_D042:				; CODE XREF: _ucase_fold_56+52j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_D05E
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_FC], eax
		jmp	short loc_D0BB
; ---------------------------------------------------------------------------

loc_D05E:				; CODE XREF: _ucase_fold_56+95j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_D077
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_100], ecx
		jmp	short loc_D0AF
; ---------------------------------------------------------------------------

loc_D077:				; CODE XREF: _ucase_fold_56+B3j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_100], eax

loc_D0AF:				; CODE XREF: _ucase_fold_56+C1j
		mov	ecx, [ebp+var_100]
		mov	[ebp+var_FC], ecx

loc_D0BB:				; CODE XREF: _ucase_fold_56+A8j
		mov	edx, [ebp+var_FC]
		mov	[ebp+var_F8], edx

loc_D0C7:				; CODE XREF: _ucase_fold_56+89j
		mov	eax, [ebp+var_F8]
		mov	[ebp+var_F4], eax

loc_D0D3:				; CODE XREF: _ucase_fold_56+46j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_F4]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 10h
		jnz	short loc_D10E
		movzx	eax, [ebp+var_8]
		and	eax, 3
		cmp	eax, 2
		jl	short loc_D109
		movsx	eax, [ebp+var_8]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+arg_4], eax

loc_D109:				; CODE XREF: _ucase_fold_56+146j
		jmp	loc_D240
; ---------------------------------------------------------------------------

loc_D10E:				; CODE XREF: _ucase_fold_56+13Aj
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	cx, [eax]
		mov	[ebp+var_20], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		movzx	eax, [ebp+var_20]
		and	eax, 8000h
		jz	short loc_D193
		mov	eax, [ebp+arg_8]
		and	eax, 0FFh
		jnz	short loc_D16E
		cmp	[ebp+arg_4], 49h ; 'I'
		jnz	short loc_D15B
		mov	eax, 69h ; 'i'
		jmp	loc_D243
; ---------------------------------------------------------------------------
		jmp	short loc_D16C
; ---------------------------------------------------------------------------

loc_D15B:				; CODE XREF: _ucase_fold_56+199j
		cmp	[ebp+arg_4], 130h
		jnz	short loc_D16C
		mov	eax, [ebp+arg_4]
		jmp	loc_D243
; ---------------------------------------------------------------------------

loc_D16C:				; CODE XREF: _ucase_fold_56+1A5j
					; _ucase_fold_56+1AEj
		jmp	short loc_D193
; ---------------------------------------------------------------------------

loc_D16E:				; CODE XREF: _ucase_fold_56+193j
		cmp	[ebp+arg_4], 49h ; 'I'
		jnz	short loc_D180
		mov	eax, 131h
		jmp	loc_D243
; ---------------------------------------------------------------------------
		jmp	short loc_D193
; ---------------------------------------------------------------------------

loc_D180:				; CODE XREF: _ucase_fold_56+1BEj
		cmp	[ebp+arg_4], 130h
		jnz	short loc_D193
		mov	eax, 69h ; 'i'
		jmp	loc_D243
; ---------------------------------------------------------------------------

loc_D193:				; CODE XREF: _ucase_fold_56+189j
					; _ucase_fold_56:loc_D16Cj ...
		movzx	eax, [ebp+var_20]
		and	eax, 2
		jz	short loc_D1A5
		mov	[ebp+var_2C], 1
		jmp	short loc_D1BF
; ---------------------------------------------------------------------------

loc_D1A5:				; CODE XREF: _ucase_fold_56+1E6j
		movzx	eax, [ebp+var_20]
		and	eax, 1
		jz	short loc_D1B7
		mov	[ebp+var_2C], 0
		jmp	short loc_D1BF
; ---------------------------------------------------------------------------

loc_D1B7:				; CODE XREF: _ucase_fold_56+1F8j
		mov	eax, [ebp+arg_4]
		jmp	loc_D243
; ---------------------------------------------------------------------------

loc_D1BF:				; CODE XREF: _ucase_fold_56+1EFj
					; _ucase_fold_56+201j
		movzx	eax, [ebp+var_20]
		and	eax, 100h
		jnz	short loc_D1F8
		movzx	eax, [ebp+var_20]
		mov	edx, 1
		mov	ecx, [ebp+var_2C]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		jmp	short loc_D240
; ---------------------------------------------------------------------------

loc_D1F8:				; CODE XREF: _ucase_fold_56+214j
		movzx	eax, [ebp+var_20]
		mov	edx, 1
		mov	ecx, [ebp+var_2C]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		shl	eax, 1
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		movzx	ecx, word ptr [eax]
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_4]
		shl	eax, 10h
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+arg_4], eax

loc_D240:				; CODE XREF: _ucase_fold_56:loc_D109j
					; _ucase_fold_56+242j
		mov	eax, [ebp+arg_4]

loc_D243:				; CODE XREF: _ucase_fold_56+1A0j
					; _ucase_fold_56+1B3j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_fold_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D24Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_toFullFolding_56
_ucase_toFullFolding_56	proc near

var_124		= dword	ptr -124h
var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 124h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_124]
		mov	ecx, 49h ; 'I'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_4], 0D800h
		jnb	short loc_D29D
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		movzx	eax, word ptr [edx+eax*2]
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_118], edx
		jmp	loc_D371
; ---------------------------------------------------------------------------

loc_D29D:				; CODE XREF: _ucase_toFullFolding_56+2Bj
		cmp	[ebp+arg_4], 0FFFFh
		ja	short loc_D2E0
		xor	eax, eax
		cmp	[ebp+arg_4], 0DBFFh
		setnle	al
		sub	eax, 1
		and	eax, 140h
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		add	eax, ecx
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+10h]
		movzx	edx, word ptr [ecx+eax*2]
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		lea	ecx, [eax+edx*4]
		mov	[ebp+var_11C], ecx
		jmp	loc_D365
; ---------------------------------------------------------------------------

loc_D2E0:				; CODE XREF: _ucase_toFullFolding_56+58j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_D2FC
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		add	eax, 80h ; '€'
		mov	[ebp+var_120], eax
		jmp	short loc_D359
; ---------------------------------------------------------------------------

loc_D2FC:				; CODE XREF: _ucase_toFullFolding_56+9Bj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+30h]
		jl	short loc_D315
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_124], ecx
		jmp	short loc_D34D
; ---------------------------------------------------------------------------

loc_D315:				; CODE XREF: _ucase_toFullFolding_56+B9j
		mov	edx, [ebp+arg_4]
		sar	edx, 0Bh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		movzx	edx, word ptr [ecx+edx*2+1040h]
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	edx, eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+10h]
		movzx	ecx, word ptr [eax+edx*2]
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_124], eax

loc_D34D:				; CODE XREF: _ucase_toFullFolding_56+C7j
		mov	ecx, [ebp+var_124]
		mov	[ebp+var_120], ecx

loc_D359:				; CODE XREF: _ucase_toFullFolding_56+AEj
		mov	edx, [ebp+var_120]
		mov	[ebp+var_11C], edx

loc_D365:				; CODE XREF: _ucase_toFullFolding_56+8Fj
		mov	eax, [ebp+var_11C]
		mov	[ebp+var_118], eax

loc_D371:				; CODE XREF: _ucase_toFullFolding_56+4Cj
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	eax, [ebp+var_118]
		mov	cx, [edx+eax*2]
		mov	[ebp+var_14], cx
		movzx	eax, [ebp+var_14]
		and	eax, 10h
		jnz	short loc_D3AC
		movzx	eax, [ebp+var_14]
		and	eax, 3
		cmp	eax, 2
		jl	short loc_D3A7
		movsx	eax, [ebp+var_14]
		sar	eax, 7
		add	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax

loc_D3A7:				; CODE XREF: _ucase_toFullFolding_56+14Cj
		jmp	loc_D5A4
; ---------------------------------------------------------------------------

loc_D3AC:				; CODE XREF: _ucase_toFullFolding_56+140j
		movzx	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		lea	eax, [edx+eax*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	cx, [eax]
		mov	[ebp+var_38], cx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		movzx	eax, [ebp+var_38]
		and	eax, 8000h
		jz	short loc_D447
		mov	eax, [ebp+arg_C]
		and	eax, 0FFh
		jnz	short loc_D41D
		cmp	[ebp+arg_4], 49h ; 'I'
		jnz	short loc_D3FF
		mov	eax, 69h ; 'i'
		jmp	loc_D5C8
; ---------------------------------------------------------------------------
		jmp	short loc_D41B
; ---------------------------------------------------------------------------

loc_D3FF:				; CODE XREF: _ucase_toFullFolding_56+1A5j
		cmp	[ebp+arg_4], 130h
		jnz	short loc_D41B
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], offset	_iDot
		mov	eax, 2
		jmp	loc_D5C8
; ---------------------------------------------------------------------------

loc_D41B:				; CODE XREF: _ucase_toFullFolding_56+1B1j
					; _ucase_toFullFolding_56+1BAj
		jmp	short loc_D442
; ---------------------------------------------------------------------------

loc_D41D:				; CODE XREF: _ucase_toFullFolding_56+19Fj
		cmp	[ebp+arg_4], 49h ; 'I'
		jnz	short loc_D42F
		mov	eax, 131h
		jmp	loc_D5C8
; ---------------------------------------------------------------------------
		jmp	short loc_D442
; ---------------------------------------------------------------------------

loc_D42F:				; CODE XREF: _ucase_toFullFolding_56+1D5j
		cmp	[ebp+arg_4], 130h
		jnz	short loc_D442
		mov	eax, 69h ; 'i'
		jmp	loc_D5C8
; ---------------------------------------------------------------------------

loc_D442:				; CODE XREF: _ucase_toFullFolding_56:loc_D41Bj
					; _ucase_toFullFolding_56+1E1j	...
		jmp	loc_D4F5
; ---------------------------------------------------------------------------

loc_D447:				; CODE XREF: _ucase_toFullFolding_56+195j
		movzx	eax, [ebp+var_38]
		and	eax, 80h
		jz	loc_D4F5
		movzx	eax, [ebp+var_38]
		and	eax, 100h
		jnz	short loc_D483
		movzx	eax, [ebp+var_38]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		jmp	short loc_D4BF
; ---------------------------------------------------------------------------

loc_D483:				; CODE XREF: _ucase_toFullFolding_56+213j
		movzx	eax, [ebp+var_38]
		and	eax, 7Fh
		movzx	ecx, ds:_flagsOffset[eax]
		shl	ecx, 1
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_20]
		add	edx, 2
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		shl	eax, 10h
		mov	ecx, [ebp+var_20]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_44], eax

loc_D4BF:				; CODE XREF: _ucase_toFullFolding_56+235j
		mov	eax, [ebp+var_20]
		add	eax, 2
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_44]
		and	eax, 0Fh
		mov	ecx, [ebp+var_20]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_44]
		sar	eax, 4
		and	eax, 0Fh
		mov	[ebp+var_44], eax
		jz	short loc_D4F5
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_20]
		mov	[eax], ecx
		mov	eax, [ebp+var_44]
		jmp	loc_D5C8
; ---------------------------------------------------------------------------

loc_D4F5:				; CODE XREF: _ucase_toFullFolding_56:loc_D442j
					; _ucase_toFullFolding_56+204j	...
		movzx	eax, [ebp+var_38]
		and	eax, 2
		jz	short loc_D507
		mov	[ebp+var_50], 1
		jmp	short loc_D523
; ---------------------------------------------------------------------------

loc_D507:				; CODE XREF: _ucase_toFullFolding_56+2B0j
		movzx	eax, [ebp+var_38]
		and	eax, 1
		jz	short loc_D519
		mov	[ebp+var_50], 0
		jmp	short loc_D523
; ---------------------------------------------------------------------------

loc_D519:				; CODE XREF: _ucase_toFullFolding_56+2C2j
		mov	eax, [ebp+arg_4]
		not	eax
		jmp	loc_D5C8
; ---------------------------------------------------------------------------

loc_D523:				; CODE XREF: _ucase_toFullFolding_56+2B9j
					; _ucase_toFullFolding_56+2CBj
		movzx	eax, [ebp+var_38]
		and	eax, 100h
		jnz	short loc_D55C
		movzx	eax, [ebp+var_38]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		jmp	short loc_D5A4
; ---------------------------------------------------------------------------

loc_D55C:				; CODE XREF: _ucase_toFullFolding_56+2E0j
		movzx	eax, [ebp+var_38]
		mov	edx, 1
		mov	ecx, [ebp+var_50]
		shl	edx, cl
		sub	edx, 1
		and	eax, edx
		movzx	eax, ds:_flagsOffset[eax]
		shl	eax, 1
		mov	ecx, [ebp+var_2C]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 2
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_8]
		shl	eax, 10h
		mov	ecx, [ebp+var_2C]
		movzx	edx, word ptr [ecx]
		or	eax, edx
		mov	[ebp+var_8], eax

loc_D5A4:				; CODE XREF: _ucase_toFullFolding_56:loc_D3A7j
					; _ucase_toFullFolding_56+30Ej
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_D5B9
		mov	ecx, [ebp+var_8]
		not	ecx
		mov	[ebp+var_118], ecx
		jmp	short loc_D5C2
; ---------------------------------------------------------------------------

loc_D5B9:				; CODE XREF: _ucase_toFullFolding_56+35Ej
		mov	edx, [ebp+var_8]
		mov	[ebp+var_118], edx

loc_D5C2:				; CODE XREF: _ucase_toFullFolding_56+36Bj
		mov	eax, [ebp+var_118]

loc_D5C8:				; CODE XREF: _ucase_toFullFolding_56+1ACj
					; _ucase_toFullFolding_56+1CAj	...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_ucase_toFullFolding_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D5D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_isULowercase_56
_u_isULowercase_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset _ucase_props_singleton
		call	_ucase_getType_56
		add	esp, 8
		cmp	eax, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_isULowercase_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D61Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_isUUppercase_56
_u_isUUppercase_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset _ucase_props_singleton
		call	_ucase_getType_56
		add	esp, 8
		cmp	eax, 2
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_isUUppercase_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D668h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_tolower_56
_u_tolower_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset _ucase_props_singleton
		call	_ucase_tolower_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_tolower_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D6ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_toupper_56
_u_toupper_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset _ucase_props_singleton
		call	_ucase_toupper_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_toupper_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D6F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_totitle_56
_u_totitle_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		push	eax
		push	offset _ucase_props_singleton
		call	_ucase_totitle_56
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_totitle_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D734h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_foldCase_56
_u_foldCase_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	offset _ucase_props_singleton
		call	_ucase_fold_56
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_foldCase_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D77Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _ucase_hasBinaryProperty_56
_ucase_hasBinaryProperty_56 proc near

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= byte ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_20], offset _ucase_props_singleton
		cmp	[ebp+var_20], 0
		jnz	short loc_D7AE
		xor	eax, eax
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

loc_D7AE:				; CODE XREF: _ucase_hasBinaryProperty_56+29j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+var_E8]
		sub	ecx, 16h
		mov	[ebp+var_E8], ecx
		cmp	[ebp+var_E8], 21h ; '!' ; switch 34 cases
		ja	$LN1		; jumptable 0000D7E0 default case
		mov	edx, [ebp+var_E8]
		movzx	eax, ds:$LN19[edx]
		jmp	ds:$LN24_1[eax*4] ; switch jump
; ---------------------------------------------------------------------------

$LN11:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	eax, [ebp+arg_0] ; jumptable 0000D7E0 case 0
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_getType_56
		add	esp, 8
		cmp	eax, 1
		setz	dl
		movsx	eax, dl
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	eax, [ebp+arg_0] ; jumptable 0000D7E0 case 8
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_getType_56
		add	esp, 8
		cmp	eax, 2
		setz	dl
		movsx	eax, dl
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	eax, [ebp+arg_0] ; jumptable 0000D7E0 case 5
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_isSoftDotted_56
		add	esp, 8
		movsx	eax, al
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	eax, [ebp+arg_0] ; jumptable 0000D7E0 case 12
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_isCaseSensitive_56
		add	esp, 8
		movsx	eax, al
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	eax, [ebp+arg_0] ; jumptable 0000D7E0 case 27
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_getType_56
		add	esp, 8
		test	eax, eax
		setnz	dl
		movsx	eax, dl
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	eax, [ebp+arg_0] ; jumptable 0000D7E0 case 28
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_getTypeOrIgnorable_56
		add	esp, 8
		sar	eax, 2
		movsx	eax, al
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	[ebp+var_14], 1	; jumptable 0000D7E0 case 29
		lea	eax, [ebp+var_14]
		push	eax
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		lea	ecx, [ebp+var_8]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_20]
		push	eax
		call	_ucase_toFullLower_56
		add	esp, 1Ch
		test	eax, eax
		setnl	cl
		movsx	eax, cl
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	[ebp+var_14], 1	; jumptable 0000D7E0 case 30
		lea	eax, [ebp+var_14]
		push	eax
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		lea	ecx, [ebp+var_8]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_20]
		push	eax
		call	_ucase_toFullUpper_56
		add	esp, 1Ch
		test	eax, eax
		setnl	cl
		movsx	eax, cl
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN3:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	[ebp+var_14], 1	; jumptable 0000D7E0 case 31
		lea	eax, [ebp+var_14]
		push	eax
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		lea	ecx, [ebp+var_8]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_20]
		push	eax
		call	_ucase_toFullTitle_56
		add	esp, 1Ch
		test	eax, eax
		setnl	cl
		movsx	eax, cl
		jmp	loc_D9BB
; ---------------------------------------------------------------------------

$LN2:					; CODE XREF: _ucase_hasBinaryProperty_56+64j
					; DATA XREF: .text:$LN24_1o
		mov	[ebp+var_14], 1	; jumptable 0000D7E0 case 33
		lea	eax, [ebp+var_14]
		push	eax
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		lea	ecx, [ebp+var_8]
		push	ecx
		push	0
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+var_20]
		push	eax
		call	_ucase_toFullLower_56
		add	esp, 1Ch
		test	eax, eax
		jge	short loc_D9A9
		lea	ecx, [ebp+var_14]
		push	ecx
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		lea	edx, [ebp+var_8]
		push	edx
		push	0
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		call	_ucase_toFullUpper_56
		add	esp, 1Ch
		test	eax, eax
		jge	short loc_D9A9
		lea	edx, [ebp+var_14]
		push	edx
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		lea	eax, [ebp+var_8]
		push	eax
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_20]
		push	edx
		call	_ucase_toFullTitle_56
		add	esp, 1Ch
		test	eax, eax
		jge	short loc_D9A9
		mov	byte ptr [ebp+var_E8+3], 0
		jmp	short loc_D9B0
; ---------------------------------------------------------------------------

loc_D9A9:				; CODE XREF: _ucase_hasBinaryProperty_56+1D8j
					; _ucase_hasBinaryProperty_56+1FDj ...
		mov	byte ptr [ebp+var_E8+3], 1

loc_D9B0:				; CODE XREF: _ucase_hasBinaryProperty_56+22Bj
		movsx	eax, byte ptr [ebp+var_E8+3]
		jmp	short loc_D9BB
; ---------------------------------------------------------------------------

$LN1:					; CODE XREF: _ucase_hasBinaryProperty_56+51j
					; _ucase_hasBinaryProperty_56+64j
					; DATA XREF: ...
		xor	eax, eax	; jumptable 0000D7E0 default case

loc_D9BB:				; CODE XREF: _ucase_hasBinaryProperty_56+2Dj
					; _ucase_hasBinaryProperty_56+84j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucase_hasBinaryProperty_56 endp

; ---------------------------------------------------------------------------
$LN23_1		dd 2			; DATA XREF: _ucase_hasBinaryProperty_56+243o
		dd offset $LN22_0
$LN22_0		dd 0FFFFFFF8h, 4	; DATA XREF: .text:0000D9E4o
		dd offset $LN20_0	; "resultString"
		dd 0FFFFFFECh, 4
		dd offset $LN21_0	; "locCache"
$LN21_0		db 'locCache',0         ; DATA XREF: .text:0000D9FCo
$LN20_0		db 'resultString',0     ; DATA XREF: .text:0000D9F0o
		align 4
$LN24_1		dd offset $LN11		; DATA XREF: _ucase_hasBinaryProperty_56+64r
		dd offset $LN9		; jump table for switch	statement
		dd offset $LN10
		dd offset $LN8
		dd offset $LN7
		dd offset $LN6
		dd offset $LN5
		dd offset $LN4
		dd offset $LN3
		dd offset $LN2
		dd offset $LN1
$LN19		db	0,   0Ah,   0Ah,   0Ah ; DATA XREF: _ucase_hasBinaryProperty_56+5Dr
		db    0Ah,     1,   0Ah,   0Ah ; indirect table	for switch statement
		db	2,   0Ah,   0Ah,   0Ah
		db	3,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,     4
		db	5,     6,     7,     8
		db    0Ah,     9
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 0DA68h
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: _ucase_hasBinaryProperty_56+11Ao
					; _ucase_hasBinaryProperty_56+14Fo ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DAACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DAECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DB1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_DB56
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_DB62
; ---------------------------------------------------------------------------

loc_DB56:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_DB62:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00006B7Co
					; .rdata:00006E30o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:00006E34o
					; .rdata:00006E38o ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00006E40o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00006E44o
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:000074F0o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:000074F4o
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00007A6Co
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00007A70o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:00007A74o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:00007A78o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00007A7Co
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00007A80o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:00007A84o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:00007A88o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00007A8Co
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
		extrn _umtx_lock_56:near ; CODE	XREF: icu_56::Mutex::Mutex(UMutex *)+31p
		extrn _umtx_unlock_56:near ; CODE XREF:	icu_56::Mutex::~Mutex(void)+29p
		extrn _utrie2_enum_56:near ; CODE XREF:	_ucase_addPropertyStarts_56+47p
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *__hidden	this, signed __int8, const wchar_t *, int)
		extrn ?setTo@UnicodeString@icu_56@@QAEAAV12@CPB_WH@Z:near
					; CODE XREF: icu_56::FullCaseFoldingIterator::next(icu_56::UnicodeString &)+D0p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: _ucase_hasBinaryProperty_56+249p


		end
