;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F93299C14C7DFC49425D985AF561208E
; Input	CRC32 :	E390BE65

; File Name   :	D:\compspace\objfiles\firefox\common\utrie.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 38h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 3Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 74h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_open_56
_utrie_open_56	proc near		; CODE XREF: _utrie_clone_56+C1p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= byte ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 20h ; ' '
		jl	short loc_A9
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	short loc_B0
		cmp	[ebp+arg_8], 400h
		jge	short loc_B0

loc_A9:					; CODE XREF: _utrie_open_56+22j
		xor	eax, eax
		jmp	loc_204
; ---------------------------------------------------------------------------

loc_B0:					; CODE XREF: _utrie_open_56+2Aj
					; _utrie_open_56+33j
		cmp	[ebp+arg_0], 0
		jz	short loc_BE
		mov	eax, [ebp+arg_0]
		mov	[ebp+Dst], eax
		jmp	short loc_DB
; ---------------------------------------------------------------------------

loc_BE:					; CODE XREF: _utrie_open_56+40j
		push	4409Ch
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_DB
		xor	eax, eax
		jmp	loc_204
; ---------------------------------------------------------------------------

loc_DB:					; CODE XREF: _utrie_open_56+48j
					; _utrie_open_56+5Ej
		push	4409Ch		; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		cmp	[ebp+arg_0], 0
		setz	al
		mov	ecx, [ebp+Dst]
		mov	[ecx+22014h], al
		cmp	[ebp+arg_4], 0
		jz	short loc_11C
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_4]
		mov	[eax+22000h], ecx
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+22015h], 0
		jmp	short loc_15D
; ---------------------------------------------------------------------------

loc_11C:				; CODE XREF: _utrie_open_56+8Ej
		mov	eax, [ebp+arg_8]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+Dst]
		mov	[ecx+22000h], eax
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+22000h],	0
		jnz	short loc_153
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_204
; ---------------------------------------------------------------------------

loc_153:				; CODE XREF: _utrie_open_56+CAj
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+22015h], 1

loc_15D:				; CODE XREF: _utrie_open_56+A6j
		mov	[ebp+var_20], 20h ; ' '
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	short loc_197
		mov	[ebp+var_14], 0

loc_173:				; CODE XREF: _utrie_open_56+121j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+Dst]
		mov	edx, [ebp+var_20]
		mov	[ecx+eax*4], edx
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		add	eax, 20h ; ' '
		mov	[ebp+var_20], eax
		cmp	[ebp+var_14], 8
		jl	short loc_173

loc_197:				; CODE XREF: _utrie_open_56+F6j
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_20]
		mov	[eax+22010h], ecx

loc_1A3:				; CODE XREF: _utrie_open_56+150j
		cmp	[ebp+var_20], 0
		jle	short loc_1C6
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+Dst]
		mov	edx, [ecx+22000h]
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_C]
		mov	[edx+eax*4], ecx
		jmp	short loc_1A3
; ---------------------------------------------------------------------------

loc_1C6:				; CODE XREF: _utrie_open_56+133j
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_10]
		mov	[eax+22004h], ecx
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+22008h],	8800h
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_8]
		mov	[eax+2200Ch], ecx
		mov	eax, [ebp+Dst]
		mov	cl, [ebp+arg_14]
		mov	[eax+22016h], cl
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+22017h], 0
		mov	eax, [ebp+Dst]

loc_204:				; CODE XREF: _utrie_open_56+37j
					; _utrie_open_56+62j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_open_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utrie_clone_56(int, void *Src, int, int)
		public _utrie_clone_56
_utrie_clone_56	proc near

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+Src], 0
		jz	short loc_256
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+22000h],	0
		jz	short loc_256
		mov	eax, [ebp+Src]
		movsx	ecx, byte ptr [eax+22017h]
		test	ecx, ecx
		jz	short loc_25D

loc_256:				; CODE XREF: _utrie_clone_56+22j
					; _utrie_clone_56+2Ej
		xor	eax, eax
		jmp	loc_379
; ---------------------------------------------------------------------------

loc_25D:				; CODE XREF: _utrie_clone_56+3Cj
		cmp	[ebp+arg_8], 0
		jz	short loc_277
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+arg_C]
		cmp	ecx, [eax+2200Ch]
		jl	short loc_277
		mov	[ebp+var_11], 0
		jmp	short loc_2AC
; ---------------------------------------------------------------------------

loc_277:				; CODE XREF: _utrie_clone_56+49j
					; _utrie_clone_56+57j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+2200Ch]
		mov	[ebp+arg_C], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+2200Ch]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+arg_8], eax
		cmp	[ebp+arg_8], 0
		jnz	short loc_2A8
		xor	eax, eax
		jmp	loc_379
; ---------------------------------------------------------------------------

loc_2A8:				; CODE XREF: _utrie_clone_56+87j
		mov	[ebp+var_11], 1

loc_2AC:				; CODE XREF: _utrie_clone_56+5Dj
		mov	eax, [ebp+Src]
		movzx	ecx, byte ptr [eax+22016h]
		push	ecx
		mov	edx, [ebp+Src]
		mov	eax, [edx+22004h]
		push	eax
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+22000h]
		mov	eax, [edx]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utrie_open_56
		add	esp, 18h
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_2F8
		mov	eax, [ebp+arg_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		jmp	short loc_376
; ---------------------------------------------------------------------------

loc_2F8:				; CODE XREF: _utrie_clone_56+D0j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	22000h		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		push	1
		mov	eax, [ebp+Src]
		mov	ecx, [eax+22000h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Src]
		mov	eax, [edx+22010h]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+22000h]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+22000h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+22010h]
		mov	[eax+22010h], edx
		mov	eax, [ebp+Dst]
		mov	cl, [ebp+var_11]
		mov	[eax+22015h], cl

loc_376:				; CODE XREF: _utrie_clone_56+DEj
		mov	eax, [ebp+Dst]

loc_379:				; CODE XREF: _utrie_clone_56+40j
					; _utrie_clone_56+8Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_clone_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 390h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_close_56
_utrie_close_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_3FB
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22015h]
		test	ecx, ecx
		jz	short loc_3E1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+22000h],	0

loc_3E1:				; CODE XREF: _utrie_close_56+30j
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22014h]
		test	ecx, ecx
		jz	short loc_3FB
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4

loc_3FB:				; CODE XREF: _utrie_close_56+22j
					; _utrie_close_56+5Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_close_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 410h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_getData_56
_utrie_getData_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_43A
		cmp	[ebp+arg_4], 0
		jnz	short loc_43E

loc_43A:				; CODE XREF: _utrie_getData_56+22j
		xor	eax, eax
		jmp	short loc_455
; ---------------------------------------------------------------------------

loc_43E:				; CODE XREF: _utrie_getData_56+28j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22010h]
		mov	[eax], edx
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+22000h]

loc_455:				; CODE XREF: _utrie_getData_56+2Cj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utrie_getData_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_set32_56
_utrie_set32_56	proc near		; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+21Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_497
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22017h]
		test	ecx, ecx
		jnz	short loc_497
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_49B

loc_497:				; CODE XREF: _utrie_set32_56+22j
					; _utrie_set32_56+30j
		xor	al, al
		jmp	short loc_4D2
; ---------------------------------------------------------------------------

loc_49B:				; CODE XREF: _utrie_set32_56+39j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?utrie_getDataBlock@@YAHPAUUNewTrie@@H@Z ; utrie_getDataBlock(UNewTrie *,int)
		add	esp, 8
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jge	short loc_4B8
		xor	al, al
		jmp	short loc_4D2
; ---------------------------------------------------------------------------

loc_4B8:				; CODE XREF: _utrie_set32_56+56j
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		add	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		mov	ecx, [ebp+arg_8]
		mov	[edx+eax*4], ecx
		mov	al, 1

loc_4D2:				; CODE XREF: _utrie_set32_56+3Dj
					; _utrie_set32_56+5Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_set32_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utrie_getDataBlock(struct	UNewTrie *, int)
?utrie_getDataBlock@@YAHPAUUNewTrie@@H@Z proc near ; CODE XREF:	_utrie_set32_56+47p
					; _utrie_setRange32_56+84p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		cmp	[ebp+var_8], 0
		jle	short loc_526
		mov	eax, [ebp+var_8]
		jmp	short loc_59A
; ---------------------------------------------------------------------------

loc_526:				; CODE XREF: utrie_getDataBlock(UNewTrie *,int)+37j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?utrie_allocDataBlock@@YAHPAUUNewTrie@@@Z ; utrie_allocDataBlock(UNewTrie *)
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_540
		or	eax, 0FFFFFFFFh
		jmp	short loc_59A
; ---------------------------------------------------------------------------

loc_540:				; CODE XREF: utrie_getDataBlock(UNewTrie *,int)+51j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		mov	[ecx+eax*4], edx
		push	1
		mov	eax, [ebp+var_8]
		shl	eax, 2
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		sub	edx, eax
		push	edx
		call	_uprv_checkValidMemory
		add	esp, 8
		push	80h ; '€'       ; Size
		mov	eax, [ebp+var_8]
		shl	eax, 2
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		sub	edx, eax
		push	edx		; Src
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_14]

loc_59A:				; CODE XREF: utrie_getDataBlock(UNewTrie *,int)+3Cj
					; utrie_getDataBlock(UNewTrie *,int)+56j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?utrie_getDataBlock@@YAHPAUUNewTrie@@H@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utrie_allocDataBlock(struct UNewTrie *)
?utrie_allocDataBlock@@YAHPAUUNewTrie@@@Z proc near
					; CODE XREF: utrie_getDataBlock(UNewTrie *,int)+42p
					; utrie_fold(UNewTrie *,uint (*)(UNewTrie *,int,int),UErrorCode	*)+8Ep

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22010h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 20h ; ' '
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+2200Ch]
		jle	short loc_5F6
		or	eax, 0FFFFFFFFh
		jmp	short loc_605
; ---------------------------------------------------------------------------

loc_5F6:				; CODE XREF: utrie_allocDataBlock(UNewTrie *)+3Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+22010h], ecx
		mov	eax, [ebp+var_8]

loc_605:				; CODE XREF: utrie_allocDataBlock(UNewTrie *)+44j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?utrie_allocDataBlock@@YAHPAUUNewTrie@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_get32_56
_utrie_get32_56	proc near		; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+1E9p
					; defaultGetFoldedValue(UNewTrie *,int,int)+4Bp

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_647
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22017h]
		test	ecx, ecx
		jnz	short loc_647
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_657

loc_647:				; CODE XREF: _utrie_get32_56+22j
					; _utrie_get32_56+30j
		cmp	[ebp+arg_8], 0
		jz	short loc_653
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax],	1

loc_653:				; CODE XREF: _utrie_get32_56+3Fj
		xor	eax, eax
		jmp	short loc_6AC
; ---------------------------------------------------------------------------

loc_657:				; CODE XREF: _utrie_get32_56+39j
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		cmp	[ebp+arg_8], 0
		jz	short loc_678
		cmp	[ebp+var_8], 0
		setz	al
		mov	ecx, [ebp+arg_8]
		mov	[ecx], al

loc_678:				; CODE XREF: _utrie_get32_56+5Ej
		cmp	[ebp+var_8], 0
		jl	short loc_689
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D0], eax
		jmp	short loc_694
; ---------------------------------------------------------------------------

loc_689:				; CODE XREF: _utrie_get32_56+70j
		mov	ecx, [ebp+var_8]
		neg	ecx
		mov	[ebp+var_D0], ecx

loc_694:				; CODE XREF: _utrie_get32_56+7Bj
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		add	edx, [ebp+var_D0]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	eax, [ecx+edx*4]

loc_6AC:				; CODE XREF: _utrie_get32_56+49j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utrie_get32_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_setRange32_56
_utrie_setRange32_56 proc near

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_700
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22017h]
		test	ecx, ecx
		jnz	short loc_700
		cmp	[ebp+arg_4], 10FFFFh
		ja	short loc_700
		cmp	[ebp+arg_8], 110000h
		ja	short loc_700
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jle	short loc_707

loc_700:				; CODE XREF: _utrie_setRange32_56+22j
					; _utrie_setRange32_56+30j ...
		xor	al, al
		jmp	loc_93F
; ---------------------------------------------------------------------------

loc_707:				; CODE XREF: _utrie_setRange32_56+4Aj
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jnz	short loc_716
		mov	al, 1
		jmp	loc_93F
; ---------------------------------------------------------------------------

loc_716:				; CODE XREF: _utrie_setRange32_56+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ecx]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		jz	loc_7D4
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?utrie_getDataBlock@@YAHPAUUNewTrie@@H@Z ; utrie_getDataBlock(UNewTrie *,int)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_750
		xor	al, al
		jmp	loc_93F
; ---------------------------------------------------------------------------

loc_750:				; CODE XREF: _utrie_setRange32_56+93j
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		and	eax, 0FFFFFFE0h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_8]
		jg	short loc_79A
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		push	20h ; ' '
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*4]
		push	ecx
		call	?utrie_fillBlock@@YAXPAIHHIIC@Z	; utrie_fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h
		mov	eax, [ebp+var_38]
		mov	[ebp+arg_4], eax
		jmp	short loc_7D4
; ---------------------------------------------------------------------------

loc_79A:				; CODE XREF: _utrie_setRange32_56+AEj
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		and	eax, 1Fh
		push	eax
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22000h]
		mov	ecx, [ebp+var_14]
		lea	edx, [eax+ecx*4]
		push	edx
		call	?utrie_fillBlock@@YAXPAIHHIIC@Z	; utrie_fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h
		mov	al, 1
		jmp	loc_93F
; ---------------------------------------------------------------------------

loc_7D4:				; CODE XREF: _utrie_setRange32_56+76j
					; _utrie_setRange32_56+E4j
		mov	eax, [ebp+arg_8]
		and	eax, 1Fh
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_8]
		and	eax, 0FFFFFFE0h
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+arg_C]
		cmp	eax, [ebp+var_8]
		jnz	short loc_7F7
		mov	[ebp+var_2C], 0
		jmp	short loc_7FE
; ---------------------------------------------------------------------------

loc_7F7:				; CODE XREF: _utrie_setRange32_56+138j
		mov	[ebp+var_2C], 0FFFFFFFFh

loc_7FE:				; CODE XREF: _utrie_setRange32_56+141j
					; _utrie_setRange32_56+236j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jge	loc_8EF
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_14], edx
		cmp	[ebp+var_14], 0
		jle	short loc_84D
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		push	20h ; ' '
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4]
		push	eax
		call	?utrie_fillBlock@@YAXPAIHHIIC@Z	; utrie_fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h
		jmp	loc_8E1
; ---------------------------------------------------------------------------

loc_84D:				; CODE XREF: _utrie_setRange32_56+169j
		mov	eax, [ebp+var_14]
		neg	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		mov	eax, [edx+eax*4]
		cmp	eax, [ebp+arg_C]
		jz	short loc_8E1
		cmp	[ebp+var_14], 0
		jz	short loc_871
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_8E1

loc_871:				; CODE XREF: _utrie_setRange32_56+1B3j
		cmp	[ebp+var_2C], 0
		jl	short loc_88A
		mov	eax, [ebp+var_2C]
		neg	eax
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx*4], eax
		jmp	short loc_8E1
; ---------------------------------------------------------------------------

loc_88A:				; CODE XREF: _utrie_setRange32_56+1C1j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?utrie_getDataBlock@@YAHPAUUNewTrie@@H@Z ; utrie_getDataBlock(UNewTrie *,int)
		add	esp, 8
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jge	short loc_8AA
		xor	al, al
		jmp	loc_93F
; ---------------------------------------------------------------------------

loc_8AA:				; CODE XREF: _utrie_setRange32_56+1EDj
		mov	eax, [ebp+var_2C]
		neg	eax
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx*4], eax
		push	1
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		push	20h ; ' '
		push	0
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22000h]
		mov	ecx, [ebp+var_2C]
		lea	edx, [eax+ecx*4]
		push	edx
		call	?utrie_fillBlock@@YAXPAIHHIIC@Z	; utrie_fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h

loc_8E1:				; CODE XREF: _utrie_setRange32_56+194j
					; _utrie_setRange32_56+1ADj ...
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	[ebp+arg_4], eax
		jmp	loc_7FE
; ---------------------------------------------------------------------------

loc_8EF:				; CODE XREF: _utrie_setRange32_56+150j
		cmp	[ebp+var_20], 0
		jle	short loc_93D
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?utrie_getDataBlock@@YAHPAUUNewTrie@@H@Z ; utrie_getDataBlock(UNewTrie *,int)
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_912
		xor	al, al
		jmp	short loc_93F
; ---------------------------------------------------------------------------

loc_912:				; CODE XREF: _utrie_setRange32_56+258j
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+var_20]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*4]
		push	ecx
		call	?utrie_fillBlock@@YAXPAIHHIIC@Z	; utrie_fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h

loc_93D:				; CODE XREF: _utrie_setRange32_56+23Fj
		mov	al, 1

loc_93F:				; CODE XREF: _utrie_setRange32_56+4Ej
					; _utrie_setRange32_56+5Dj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_setRange32_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 954h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl utrie_fillBlock(unsigned	int *, int, int, unsigned int, unsigned	int, signed char)
?utrie_fillBlock@@YAXPAIHHIIC@Z	proc near ; CODE XREF: _utrie_setRange32_56+D6p
					; _utrie_setRange32_56+111p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= byte ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	short loc_9AF

loc_992:				; CODE XREF: utrie_fillBlock(uint *,int,int,uint,uint,signed char)+57j
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_8]
		jnb	short loc_9AD
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		mov	[eax], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 4
		mov	[ebp+arg_0], edx
		jmp	short loc_992
; ---------------------------------------------------------------------------

loc_9AD:				; CODE XREF: utrie_fillBlock(uint *,int,int,uint,uint,signed char)+44j
		jmp	short loc_9D4
; ---------------------------------------------------------------------------

loc_9AF:				; CODE XREF: utrie_fillBlock(uint *,int,int,uint,uint,signed char)+3Cj
					; utrie_fillBlock(uint *,int,int,uint,uint,signed char)+7Ej
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_8]
		jnb	short loc_9D4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_10]
		jnz	short loc_9C9
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		mov	[eax], ecx

loc_9C9:				; CODE XREF: utrie_fillBlock(uint *,int,int,uint,uint,signed char)+6Bj
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+arg_0], eax
		jmp	short loc_9AF
; ---------------------------------------------------------------------------

loc_9D4:				; CODE XREF: utrie_fillBlock(uint *,int,int,uint,uint,signed char):loc_9ADj
					; utrie_fillBlock(uint *,int,int,uint,uint,signed char)+61j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?utrie_fillBlock@@YAXPAIHHIIC@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9DCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_serialize_56
_utrie_serialize_56 proc near

var_10C		= dword	ptr -10Ch
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
Dst		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_44], 0
		cmp	[ebp+arg_14], 0
		jz	short loc_A1C
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A23

loc_A1C:				; CODE XREF: _utrie_serialize_56+29j
		xor	eax, eax
		jmp	loc_D0B
; ---------------------------------------------------------------------------

loc_A23:				; CODE XREF: _utrie_serialize_56+3Ej
		cmp	[ebp+arg_0], 0
		jz	short loc_A3B
		cmp	[ebp+arg_8], 0
		jl	short loc_A3B
		cmp	[ebp+arg_8], 0
		jle	short loc_A4B
		cmp	[ebp+arg_4], 0
		jnz	short loc_A4B

loc_A3B:				; CODE XREF: _utrie_serialize_56+4Bj
					; _utrie_serialize_56+51j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_D0B
; ---------------------------------------------------------------------------

loc_A4B:				; CODE XREF: _utrie_serialize_56+57j
					; _utrie_serialize_56+5Dj
		cmp	[ebp+arg_C], 0
		jnz	short loc_A58
		mov	[ebp+arg_C], offset ?defaultGetFoldedValue@@YAIPAUUNewTrie@@HH@Z ; defaultGetFoldedValue(UNewTrie *,int,int)

loc_A58:				; CODE XREF: _utrie_serialize_56+73j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22017h]
		test	ecx, ecx
		jnz	short loc_ACA
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?utrie_compact@@YAXPAUUNewTrie@@CPAW4UErrorCode@@@Z ; utrie_compact(UNewTrie *,signed char,UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?utrie_fold@@YAXPAUUNewTrie@@P6AI0HH@ZPAW4UErrorCode@@@Z ; utrie_fold(UNewTrie *,uint (*)(UNewTrie *,int,int),UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+arg_14]
		push	eax
		push	1
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?utrie_compact@@YAXPAUUNewTrie@@CPAW4UErrorCode@@@Z ; utrie_compact(UNewTrie *,signed char,UErrorCode *)
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+22017h], 1
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_ACA
		xor	eax, eax
		jmp	loc_D0B
; ---------------------------------------------------------------------------

loc_ACA:				; CODE XREF: _utrie_serialize_56+8Ej
					; _utrie_serialize_56+E5j
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_AEC
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22010h]
		mov	eax, [ebp+arg_0]
		add	edx, [eax+22008h]
		mov	[ebp+var_10C], edx
		jmp	short loc_AFB
; ---------------------------------------------------------------------------

loc_AEC:				; CODE XREF: _utrie_serialize_56+F4j
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22010h]
		mov	[ebp+var_10C], edx

loc_AFB:				; CODE XREF: _utrie_serialize_56+10Ej
		cmp	[ebp+var_10C], 40000h
		jl	short loc_B10
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 8

loc_B10:				; CODE XREF: _utrie_serialize_56+129j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22008h]
		lea	edx, [ecx+ecx+10h]
		mov	[ebp+var_38], edx
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_B3C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22010h]
		mov	edx, [ebp+var_38]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_38], eax
		jmp	short loc_B4E
; ---------------------------------------------------------------------------

loc_B3C:				; CODE XREF: _utrie_serialize_56+14Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22010h]
		mov	edx, [ebp+var_38]
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_38], eax

loc_B4E:				; CODE XREF: _utrie_serialize_56+15Ej
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_8]
		jle	short loc_B5E
		mov	eax, [ebp+var_38]
		jmp	loc_D0B
; ---------------------------------------------------------------------------

loc_B5E:				; CODE XREF: _utrie_serialize_56+178j
		mov	eax, [ebp+var_44]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_44]
		add	eax, 10h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 54726965h
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 25h ; '%'
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_B9A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		or	ecx, 100h
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_B9A:				; CODE XREF: _utrie_serialize_56+1AAj
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22016h]
		test	ecx, ecx
		jz	short loc_BBA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		or	ecx, 200h
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_BBA:				; CODE XREF: _utrie_serialize_56+1CAj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22008h]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22010h]
		mov	[eax+0Ch], edx
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	loc_C86
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22008h]
		mov	[ebp+var_2C], ecx
		jmp	short loc_C07
; ---------------------------------------------------------------------------

loc_BFE:				; CODE XREF: _utrie_serialize_56+25Aj
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax

loc_C07:				; CODE XREF: _utrie_serialize_56+220j
		cmp	[ebp+var_2C], 0
		jle	short loc_C38
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		add	ecx, [edx+22008h]
		shr	ecx, 2
		mov	eax, [ebp+Dst]
		mov	[eax], cx
		mov	ecx, [ebp+Dst]
		add	ecx, 2
		mov	[ebp+Dst], ecx
		mov	edx, [ebp+var_14]
		add	edx, 4
		mov	[ebp+var_14], edx
		jmp	short loc_BFE
; ---------------------------------------------------------------------------

loc_C38:				; CODE XREF: _utrie_serialize_56+22Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22010h]
		mov	[ebp+var_2C], ecx
		jmp	short loc_C5B
; ---------------------------------------------------------------------------

loc_C52:				; CODE XREF: _utrie_serialize_56+2A3j
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax

loc_C5B:				; CODE XREF: _utrie_serialize_56+274j
		cmp	[ebp+var_2C], 0
		jle	short loc_C81
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_14]
		mov	dx, [ecx]
		mov	[eax], dx
		mov	eax, [ebp+Dst]
		add	eax, 2
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		mov	[ebp+var_14], ecx
		jmp	short loc_C52
; ---------------------------------------------------------------------------

loc_C81:				; CODE XREF: _utrie_serialize_56+283j
		jmp	loc_D08
; ---------------------------------------------------------------------------

loc_C86:				; CODE XREF: _utrie_serialize_56+202j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22008h]
		mov	[ebp+var_2C], ecx
		jmp	short loc_CA9
; ---------------------------------------------------------------------------

loc_CA0:				; CODE XREF: _utrie_serialize_56+2F3j
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax

loc_CA9:				; CODE XREF: _utrie_serialize_56+2C2j
		cmp	[ebp+var_2C], 0
		jle	short loc_CD1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		shr	ecx, 2
		mov	edx, [ebp+Dst]
		mov	[edx], cx
		mov	eax, [ebp+Dst]
		add	eax, 2
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 4
		mov	[ebp+var_14], ecx
		jmp	short loc_CA0
; ---------------------------------------------------------------------------

loc_CD1:				; CODE XREF: _utrie_serialize_56+2D1j
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22010h]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_D08:				; CODE XREF: _utrie_serialize_56:loc_C81j
		mov	eax, [ebp+var_38]

loc_D0B:				; CODE XREF: _utrie_serialize_56+42j
					; _utrie_serialize_56+6Aj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_serialize_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D20h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _utrie_serialize_56+31p
					; _utrie_serialize_56+D8p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D4Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl utrie_fold(struct UNewTrie *, unsigned int (__cdecl *)(struct UNewTrie *, int, int), enum  UErrorCode *)
?utrie_fold@@YAXPAUUNewTrie@@P6AI0HH@ZPAW4UErrorCode@@@Z proc near
					; CODE XREF: _utrie_serialize_56+AEp

var_188		= byte ptr -188h
var_C4		= dword	ptr -0C4h
var_B8		= dword	ptr -0B8h
var_AC		= dword	ptr -0ACh
var_A0		= dword	ptr -0A0h
var_94		= dword	ptr -94h
Dst		= byte ptr -88h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 188h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_188]
		mov	ecx, 62h ; 'b'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_94], eax
		push	1
		mov	eax, [ebp+var_94]
		add	eax, 1B00h
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	80h ; '€'       ; Size
		mov	ecx, [ebp+var_94]
		add	ecx, 1B00h
		push	ecx		; Src
		lea	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22004h]
		cmp	eax, [ecx]
		jnz	short loc_DD6
		mov	[ebp+var_C4], 0
		jmp	short loc_E44
; ---------------------------------------------------------------------------

loc_DD6:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+7Cj
		mov	eax, [ebp+arg_0]
		push	eax
		call	?utrie_allocDataBlock@@YAHPAUUNewTrie@@@Z ; utrie_allocDataBlock(UNewTrie *)
		add	esp, 4
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 0
		jge	short loc_DFF
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	loc_10D8
; ---------------------------------------------------------------------------

loc_DFF:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+A3j
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ecx]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22004h]
		push	ecx
		push	20h ; ' '
		push	0
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22000h]
		mov	ecx, [ebp+var_C4]
		lea	edx, [eax+ecx*4]
		push	edx
		call	?utrie_fillBlock@@YAXPAIHHIIC@Z	; utrie_fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h
		mov	eax, [ebp+var_C4]
		neg	eax
		mov	[ebp+var_C4], eax

loc_E44:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+88j
		mov	[ebp+var_AC], 6C0h
		jmp	short loc_E5F
; ---------------------------------------------------------------------------

loc_E50:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+131j
		mov	eax, [ebp+var_AC]
		add	eax, 1
		mov	[ebp+var_AC], eax

loc_E5F:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+102j
		cmp	[ebp+var_AC], 6E0h
		jge	short loc_E7F
		mov	eax, [ebp+var_AC]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_C4]
		mov	[ecx+eax*4], edx
		jmp	short loc_E50
; ---------------------------------------------------------------------------

loc_E7F:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+11Dj
		mov	[ebp+var_B8], 800h
		mov	[ebp+var_AC], 10000h

loc_E93:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *):loc_101Aj
		cmp	[ebp+var_AC], 110000h
		jge	loc_101F
		mov	eax, [ebp+var_AC]
		sar	eax, 5
		mov	ecx, [ebp+var_94]
		cmp	dword ptr [ecx+eax*4], 0
		jz	loc_100B
		mov	eax, [ebp+var_AC]
		and	eax, 0FFFFFC00h
		mov	[ebp+var_AC], eax
		mov	eax, [ebp+var_AC]
		sar	eax, 5
		push	eax
		mov	ecx, [ebp+var_B8]
		push	ecx
		mov	edx, [ebp+var_94]
		push	edx
		call	?_findSameIndexBlock@@YAHPBHHH@Z ; _findSameIndexBlock(int const *,int,int)
		add	esp, 0Ch
		mov	[ebp+var_C4], eax
		mov	eax, [ebp+var_C4]
		add	eax, 20h ; ' '
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_AC]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	[ebp+arg_4]
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A0], eax
		push	0
		mov	eax, [ebp+var_AC]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		movzx	ecx, ax
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utrie_get32_56
		add	esp, 0Ch
		cmp	[ebp+var_A0], eax
		jz	loc_FF8
		mov	eax, [ebp+var_A0]
		push	eax
		mov	ecx, [ebp+var_AC]
		sar	ecx, 0Ah
		add	ecx, 0D7C0h
		movzx	edx, cx
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utrie_set32_56
		add	esp, 0Ch
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_F84
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	loc_10D8
; ---------------------------------------------------------------------------

loc_F84:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+228j
		mov	eax, [ebp+var_C4]
		cmp	eax, [ebp+var_B8]
		jnz	short loc_FF8
		push	1
		mov	eax, [ebp+var_AC]
		sar	eax, 5
		mov	ecx, [ebp+var_94]
		lea	edx, [ecx+eax*4]
		push	edx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	esi, esp
		push	80h ; '€'       ; Size
		mov	eax, [ebp+var_AC]
		sar	eax, 5
		mov	ecx, [ebp+var_94]
		lea	edx, [ecx+eax*4]
		push	edx		; Src
		mov	eax, [ebp+var_B8]
		mov	ecx, [ebp+var_94]
		lea	edx, [ecx+eax*4]
		push	edx		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_B8]
		add	eax, 20h ; ' '
		mov	[ebp+var_B8], eax

loc_FF8:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+1F7j
					; utrie_fold(UNewTrie *,uint (*)(UNewTrie *,int,int),UErrorCode	*)+244j
		mov	eax, [ebp+var_AC]
		add	eax, 400h
		mov	[ebp+var_AC], eax
		jmp	short loc_101A
; ---------------------------------------------------------------------------

loc_100B:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+16Aj
		mov	eax, [ebp+var_AC]
		add	eax, 20h ; ' '
		mov	[ebp+var_AC], eax

loc_101A:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+2BDj
		jmp	loc_E93
; ---------------------------------------------------------------------------

loc_101F:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+151j
		cmp	[ebp+var_B8], 8800h
		jl	short loc_1039
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 8
		jmp	loc_10D8
; ---------------------------------------------------------------------------

loc_1039:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+2DDj
		push	1
		mov	eax, [ebp+var_94]
		add	eax, 2000h
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+var_B8]
		lea	edx, ds:0FFFFE000h[ecx*4]
		mov	esi, esp
		push	edx		; Size
		mov	eax, [ebp+var_94]
		add	eax, 2000h
		push	eax		; Src
		mov	ecx, [ebp+var_94]
		add	ecx, 2080h
		push	ecx		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	1
		lea	eax, [ebp+Dst]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	80h ; '€'       ; Size
		lea	ecx, [ebp+Dst]
		push	ecx		; Src
		mov	edx, [ebp+var_94]
		add	edx, 2000h
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_B8]
		add	eax, 20h ; ' '
		mov	[ebp+var_B8], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_B8]
		mov	[eax+22008h], ecx

loc_10D8:				; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+AEj
					; utrie_fold(UNewTrie *,uint (*)(UNewTrie *,int,int),UErrorCode	*)+233j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN19
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 188h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?utrie_fold@@YAXPAUUNewTrie@@P6AI0HH@ZPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN19		dd 1			; DATA XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+390o
		dd offset $LN18
$LN18		dd 0FFFFFF78h, 80h	; DATA XREF: .text:0000110Co
		dd offset $LN17		; "leadIndexes"
$LN17		db 'leadIndexes',0      ; DATA XREF: .text:00001118o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1128h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl _findSameIndexBlock(int const *, int, int)
?_findSameIndexBlock@@YAHPBHHH@Z proc near
					; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+199p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 800h
		jmp	short loc_1158
; ---------------------------------------------------------------------------

loc_114F:				; CODE XREF: _findSameIndexBlock(int const *,int,int):loc_11A1j
		mov	eax, [ebp+var_8]
		add	eax, 20h ; ' '
		mov	[ebp+var_8], eax

loc_1158:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+25j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jge	short loc_11A3
		mov	[ebp+var_14], 0
		jmp	short loc_1172
; ---------------------------------------------------------------------------

loc_1169:				; CODE XREF: _findSameIndexBlock(int const *,int,int):loc_1194j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1172:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+3Fj
		cmp	[ebp+var_14], 20h ; ' '
		jge	short loc_1196
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_8]
		add	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	eax, [edx+eax*4]
		cmp	eax, [esi+ecx*4]
		jz	short loc_1194
		jmp	short loc_1196
; ---------------------------------------------------------------------------

loc_1194:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+68j
		jmp	short loc_1169
; ---------------------------------------------------------------------------

loc_1196:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+4Ej
					; _findSameIndexBlock(int const	*,int,int)+6Aj
		cmp	[ebp+var_14], 20h ; ' '
		jnz	short loc_11A1
		mov	eax, [ebp+var_8]
		jmp	short loc_11A6
; ---------------------------------------------------------------------------

loc_11A1:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+72j
		jmp	short loc_114F
; ---------------------------------------------------------------------------

loc_11A3:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+36j
		mov	eax, [ebp+arg_4]

loc_11A6:				; CODE XREF: _findSameIndexBlock(int const *,int,int)+77j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_findSameIndexBlock@@YAHPBHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl utrie_compact(struct UNewTrie *,	signed char, enum  UErrorCode *)
?utrie_compact@@YAXPAUUNewTrie@@CPAW4UErrorCode@@@Z proc near
					; CODE XREF: _utrie_serialize_56+9Ap
					; _utrie_serialize_56+C0p

var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jz	short loc_11E9
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_11EE

loc_11E9:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+22j
		jmp	loc_14C7
; ---------------------------------------------------------------------------

loc_11EE:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+37j
		cmp	[ebp+arg_0], 0
		jnz	short loc_1202
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_14C7
; ---------------------------------------------------------------------------

loc_1202:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+42j
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22017h]
		test	ecx, ecx
		jz	short loc_1215
		jmp	loc_14C7
; ---------------------------------------------------------------------------

loc_1215:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+5Ej
		mov	eax, [ebp+arg_0]
		push	eax
		call	?_findUnusedBlocks@@YAXPAUUNewTrie@@@Z ; _findUnusedBlocks(UNewTrie *)
		add	esp, 4
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+22016h]
		test	ecx, ecx
		jz	short loc_1241
		mov	eax, 1
		test	eax, eax
		jz	short loc_1241
		mov	[ebp+var_2C], 120h
		jmp	short loc_1248
; ---------------------------------------------------------------------------

loc_1241:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+7Dj
					; utrie_compact(UNewTrie *,signed char,UErrorCode *)+86j
		mov	[ebp+var_2C], 20h ; ' '

loc_1248:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+8Fj
		mov	[ebp+var_20], 20h ; ' '
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax

loc_1255:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+D3j
					; utrie_compact(UNewTrie *,signed char,UErrorCode *)+12Bj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+22010h]
		jge	loc_144F
		mov	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4+22018h], 0
		jge	short loc_1285
		mov	eax, [ebp+var_14]
		add	eax, 20h ; ' '
		mov	[ebp+var_14], eax
		jmp	short loc_1255
; ---------------------------------------------------------------------------

loc_1285:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+C8j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jl	short loc_12E0
		movsx	eax, [ebp+arg_4]
		neg	eax
		sbb	eax, eax
		and	eax, 0FFFFFFE4h
		add	eax, 20h ; ' '
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+var_20]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		push	ecx
		call	?_findSameDataBlock@@YAHPBIHHH@Z ; _findSameDataBlock(uint const *,int,int,int)
		add	esp, 10h
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jl	short loc_12E0
		mov	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[ecx+eax*4+22018h], edx
		mov	eax, [ebp+var_14]
		add	eax, 20h ; ' '
		mov	[ebp+var_14], eax
		jmp	loc_1255
; ---------------------------------------------------------------------------

loc_12E0:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+DBj
					; utrie_compact(UNewTrie *,signed char,UErrorCode *)+10Dj
		movsx	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1342
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jl	short loc_1342
		mov	[ebp+var_8], 1Ch
		jmp	short loc_1302
; ---------------------------------------------------------------------------

loc_12F9:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+18Ej
		mov	eax, [ebp+var_8]
		sub	eax, 4
		mov	[ebp+var_8], eax

loc_1302:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+147j
		cmp	[ebp+var_8], 0
		jle	short loc_1340
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+22000h]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*4]
		push	ecx
		mov	edx, [ebp+var_20]
		sub	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		lea	edx, [ecx+edx*4]
		push	edx
		call	?equal_uint32@@YACPBI0H@Z ; equal_uint32(uint const *,uint const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1340
		jmp	short loc_12F9
; ---------------------------------------------------------------------------

loc_1340:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+156j
					; utrie_compact(UNewTrie *,signed char,UErrorCode *)+18Cj
		jmp	short loc_1349
; ---------------------------------------------------------------------------

loc_1342:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+136j
					; utrie_compact(UNewTrie *,signed char,UErrorCode *)+13Ej
		mov	[ebp+var_8], 0

loc_1349:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *):loc_1340j
		cmp	[ebp+var_8], 0
		jle	short loc_13C1
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		sar	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx*4+22018h], eax
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_8]
		mov	[ebp+var_14], eax
		mov	eax, 20h ; ' '
		sub	eax, [ebp+var_8]
		mov	[ebp+var_8], eax
		jmp	short loc_1384
; ---------------------------------------------------------------------------

loc_137B:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+20Aj
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax

loc_1384:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+1C9j
		cmp	[ebp+var_8], 0
		jle	short loc_13BC
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22000h]
		mov	edx, [ebp+var_20]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+esi*4]
		mov	[eax+edx*4], ecx
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_137B
; ---------------------------------------------------------------------------

loc_13BC:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+1D8j
		jmp	loc_144A
; ---------------------------------------------------------------------------

loc_13C1:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+19Dj
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_1428
		mov	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_20]
		mov	[ecx+eax*4+22018h], edx
		mov	[ebp+var_8], 20h ; ' '
		jmp	short loc_13EE
; ---------------------------------------------------------------------------

loc_13E5:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+274j
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax

loc_13EE:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+233j
		cmp	[ebp+var_8], 0
		jle	short loc_1426
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+22000h]
		mov	edx, [ebp+var_20]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+esi*4]
		mov	[eax+edx*4], ecx
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_13E5
; ---------------------------------------------------------------------------

loc_1426:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+242j
		jmp	short loc_144A
; ---------------------------------------------------------------------------

loc_1428:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+217j
		mov	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		mov	[ecx+eax*4+22018h], edx
		mov	eax, [ebp+var_20]
		add	eax, 20h ; ' '
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		mov	[ebp+var_14], eax

loc_144A:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *):loc_13BCj
					; utrie_compact(UNewTrie *,signed char,UErrorCode *):loc_1426j
		jmp	loc_1255
; ---------------------------------------------------------------------------

loc_144F:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+B1j
		mov	[ebp+var_8], 0
		jmp	short loc_1461
; ---------------------------------------------------------------------------

loc_1458:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+309j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_1461:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+2A6j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+22008h]
		jge	short loc_14BB
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4], 0
		jl	short loc_148C
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+edx*4]
		mov	[ebp+var_F4], ecx
		jmp	short loc_149D
; ---------------------------------------------------------------------------

loc_148C:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+2C9j
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+edx*4]
		neg	ecx
		mov	[ebp+var_F4], ecx

loc_149D:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+2DAj
		mov	edx, [ebp+var_F4]
		sar	edx, 5
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	edx, [esi+edx*4+22018h]
		mov	[ecx+eax*4], edx
		jmp	short loc_1458
; ---------------------------------------------------------------------------

loc_14BB:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+2BDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+22010h], ecx

loc_14C7:				; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *):loc_11E9j
					; utrie_compact(UNewTrie *,signed char,UErrorCode *)+4Dj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?utrie_compact@@YAXPAUUNewTrie@@CPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14DCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl equal_uint32(unsigned int	const *, unsigned int const *, int)
?equal_uint32@@YACPBI0H@Z proc near	; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+17Fp
					; _findSameDataBlock(uint const	*,int,int,int)+57p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_14FA:				; CODE XREF: equal_uint32(uint const *,uint const *,int)+4Bj
		cmp	[ebp+arg_8], 0
		jle	short loc_1529
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_1529
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_4]
		add	eax, 4
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_14FA
; ---------------------------------------------------------------------------

loc_1529:				; CODE XREF: equal_uint32(uint const *,uint const *,int)+22j
					; equal_uint32(uint const *,uint const *,int)+2Ej
		cmp	[ebp+arg_8], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?equal_uint32@@YACPBI0H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1538h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl _findUnusedBlocks(struct	UNewTrie *)
?_findUnusedBlocks@@YAXPAUUNewTrie@@@Z proc near
					; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+69p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	22084h		; Size
		push	0FFh		; Val
		mov	eax, [ebp+arg_0]
		add	eax, 22018h
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	[ebp+var_8], 0
		jmp	short loc_1583
; ---------------------------------------------------------------------------

loc_157A:				; CODE XREF: _findUnusedBlocks(UNewTrie	*)+9Ej
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_1583:				; CODE XREF: _findUnusedBlocks(UNewTrie	*)+40j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+22008h]
		jge	short loc_15D8
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4], 0
		jl	short loc_15AE
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+edx*4]
		mov	[ebp+var_D0], ecx
		jmp	short loc_15BF
; ---------------------------------------------------------------------------

loc_15AE:				; CODE XREF: _findUnusedBlocks(UNewTrie	*)+63j
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+edx*4]
		neg	ecx
		mov	[ebp+var_D0], ecx

loc_15BF:				; CODE XREF: _findUnusedBlocks(UNewTrie	*)+74j
		mov	edx, [ebp+var_D0]
		sar	edx, 5
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+edx*4+22018h], 0
		jmp	short loc_157A
; ---------------------------------------------------------------------------

loc_15D8:				; CODE XREF: _findUnusedBlocks(UNewTrie	*)+57j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+22018h],	0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_findUnusedBlocks@@YAXPAUUNewTrie@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15FCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl _findSameDataBlock(unsigned int const *, int, int, int)
?_findSameDataBlock@@YAHPBIHHH@Z proc near
					; CODE XREF: utrie_compact(UNewTrie *,signed char,UErrorCode *)+FEp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		sub	eax, 20h ; ' '
		mov	[ebp+arg_4], eax
		mov	[ebp+var_8], 0
		jmp	short loc_1635
; ---------------------------------------------------------------------------

loc_162C:				; CODE XREF: _findSameDataBlock(uint const *,int,int,int):loc_1667j
		mov	eax, [ebp+var_8]
		add	eax, [ebp+arg_C]
		mov	[ebp+var_8], eax

loc_1635:				; CODE XREF: _findSameDataBlock(uint const *,int,int,int)+2Ej
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jg	short loc_1669
		push	20h ; ' '
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		push	edx
		call	?equal_uint32@@YACPBI0H@Z ; equal_uint32(uint const *,uint const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_1667
		mov	eax, [ebp+var_8]
		jmp	short loc_166C
; ---------------------------------------------------------------------------

loc_1667:				; CODE XREF: _findSameDataBlock(uint const *,int,int,int)+64j
		jmp	short loc_162C
; ---------------------------------------------------------------------------

loc_1669:				; CODE XREF: _findSameDataBlock(uint const *,int,int,int)+3Fj
		or	eax, 0FFFFFFFFh

loc_166C:				; CODE XREF: _findSameDataBlock(uint const *,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?_findSameDataBlock@@YAHPBIHHH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1680h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl defaultGetFoldedValue(struct UNewTrie *,	int, int)
?defaultGetFoldedValue@@YAIPAUUNewTrie@@HH@Z proc near ; DATA XREF: _utrie_serialize_56+75o

var_F0		= byte ptr -0F0h
var_29		= byte ptr -29h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+22000h]
		mov	edx, [ecx]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_4]
		add	eax, 400h
		mov	[ebp+var_20], eax

loc_16B7:				; CODE XREF: defaultGetFoldedValue(UNewTrie *,int,int):loc_1701j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_20]
		jge	short loc_1703
		lea	eax, [ebp+var_29]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utrie_get32_56
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		movsx	eax, [ebp+var_29]
		test	eax, eax
		jz	short loc_16E9
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	[ebp+arg_4], eax
		jmp	short loc_1701
; ---------------------------------------------------------------------------

loc_16E9:				; CODE XREF: defaultGetFoldedValue(UNewTrie *,int,int)+5Cj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jz	short loc_16F8
		mov	eax, [ebp+arg_8]
		jmp	short loc_1705
; ---------------------------------------------------------------------------
		jmp	short loc_1701
; ---------------------------------------------------------------------------

loc_16F8:				; CODE XREF: defaultGetFoldedValue(UNewTrie *,int,int)+6Fj
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+arg_4], eax

loc_1701:				; CODE XREF: defaultGetFoldedValue(UNewTrie *,int,int)+67j
					; defaultGetFoldedValue(UNewTrie *,int,int)+76j
		jmp	short loc_16B7
; ---------------------------------------------------------------------------

loc_1703:				; CODE XREF: defaultGetFoldedValue(UNewTrie *,int,int)+3Dj
		xor	eax, eax

loc_1705:				; CODE XREF: defaultGetFoldedValue(UNewTrie *,int,int)+74j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?defaultGetFoldedValue@@YAIPAUUNewTrie@@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN11		dd 1			; DATA XREF: defaultGetFoldedValue(UNewTrie *,int,int)+89o
		dd offset $LN10
$LN10		dd 0FFFFFFD7h, 1	; DATA XREF: .text:00001730o
		dd offset $LN9		; "inBlockZero"
$LN9		db 'inBlockZero',0      ; DATA XREF: .text:0000173Co
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 174Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_defaultGetFoldingOffset_56
_utrie_defaultGetFoldingOffset_56 proc near ; DATA XREF: _utrie_unserialize_56+1D7o
					; _utrie_unserializeDummy_56+2BFo

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utrie_defaultGetFoldingOffset_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1774h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_unserialize_56
_utrie_unserialize_56 proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_C], 0
		jz	short loc_17AD
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_17B5

loc_17AD:				; CODE XREF: _utrie_unserialize_56+22j
		or	eax, 0FFFFFFFFh
		jmp	loc_1955
; ---------------------------------------------------------------------------

loc_17B5:				; CODE XREF: _utrie_unserialize_56+37j
		cmp	[ebp+arg_8], 10h
		jge	short loc_17CC
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		or	eax, 0FFFFFFFFh
		jmp	loc_1955
; ---------------------------------------------------------------------------

loc_17CC:				; CODE XREF: _utrie_unserialize_56+45j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax], 54726965h
		jz	short loc_17EE
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		or	eax, 0FFFFFFFFh
		jmp	loc_1955
; ---------------------------------------------------------------------------

loc_17EE:				; CODE XREF: _utrie_unserialize_56+67j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_20]
		and	eax, 0Fh
		cmp	eax, 5
		jnz	short loc_1810
		mov	eax, [ebp+var_20]
		shr	eax, 4
		and	eax, 0Fh
		cmp	eax, 2
		jz	short loc_1821

loc_1810:				; CODE XREF: _utrie_unserialize_56+8Cj
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		or	eax, 0FFFFFFFFh
		jmp	loc_1955
; ---------------------------------------------------------------------------

loc_1821:				; CODE XREF: _utrie_unserialize_56+9Aj
		mov	eax, [ebp+var_20]
		and	eax, 200h
		setnz	cl
		mov	edx, [ebp+arg_0]
		mov	[edx+18h], cl
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax+10h], edx
		mov	eax, [ebp+arg_8]
		sub	eax, 10h
		mov	[ebp+arg_8], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		shl	ecx, 1
		cmp	[ebp+arg_8], ecx
		jge	short loc_1871
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		or	eax, 0FFFFFFFFh
		jmp	loc_1955
; ---------------------------------------------------------------------------

loc_1871:				; CODE XREF: _utrie_unserialize_56+EAj
		mov	eax, [ebp+var_8]
		add	eax, 10h
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		shl	ecx, 1
		mov	edx, [ebp+arg_8]
		sub	edx, ecx
		mov	[ebp+arg_8], edx
		mov	eax, [ebp+var_20]
		and	eax, 100h
		jz	short loc_18F9
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		shl	ecx, 2
		cmp	[ebp+arg_8], ecx
		jge	short loc_18CA
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		or	eax, 0FFFFFFFFh
		jmp	loc_1955
; ---------------------------------------------------------------------------

loc_18CA:				; CODE XREF: _utrie_unserialize_56+143j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+4], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx]
		mov	[edx+14h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		shl	eax, 2
		lea	ecx, [eax+ecx*2+10h]
		mov	[ebp+arg_8], ecx
		jmp	short loc_1948
; ---------------------------------------------------------------------------

loc_18F9:				; CODE XREF: _utrie_unserialize_56+135j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		shl	ecx, 1
		cmp	[ebp+arg_8], ecx
		jge	short loc_1914
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 3
		or	eax, 0FFFFFFFFh
		jmp	short loc_1955
; ---------------------------------------------------------------------------

loc_1914:				; CODE XREF: _utrie_unserialize_56+190j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	edx, [ebp+arg_0]
		mov	[edx+14h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		shl	eax, 1
		lea	ecx, [eax+ecx*2+10h]
		mov	[ebp+arg_8], ecx

loc_1948:				; CODE XREF: _utrie_unserialize_56+183j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], offset _utrie_defaultGetFoldingOffset_56
		mov	eax, [ebp+arg_8]

loc_1955:				; CODE XREF: _utrie_unserialize_56+3Cj
					; _utrie_unserialize_56+53j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_unserialize_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 196Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_unserializeDummy_56
_utrie_unserializeDummy_56 proc	near

var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= word ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= byte ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_18], 0
		jz	short loc_19A5
		mov	eax, [ebp+arg_18]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_19AD

loc_19A5:				; CODE XREF: _utrie_unserializeDummy_56+22j
		or	eax, 0FFFFFFFFh
		jmp	loc_1C35
; ---------------------------------------------------------------------------

loc_19AD:				; CODE XREF: _utrie_unserializeDummy_56+37j
		mov	[ebp+var_20], 100h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+0Ch], 820h
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_10]
		cmp	eax, [ebp+arg_C]
		jz	short loc_19DE
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		add	ecx, 20h ; ' '
		mov	edx, [ebp+arg_0]
		mov	[edx+10h], ecx

loc_19DE:				; CODE XREF: _utrie_unserializeDummy_56+61j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		shl	ecx, 1
		mov	[ebp+var_14], ecx
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	short loc_1A02
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_14], eax
		jmp	short loc_1A11
; ---------------------------------------------------------------------------

loc_1A02:				; CODE XREF: _utrie_unserializeDummy_56+83j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_14], eax

loc_1A11:				; CODE XREF: _utrie_unserializeDummy_56+94j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_14]
		jge	short loc_1A2A
		mov	eax, [ebp+arg_18]
		mov	dword ptr [eax], 0Fh
		mov	eax, [ebp+var_14]
		jmp	loc_1C35
; ---------------------------------------------------------------------------

loc_1A2A:				; CODE XREF: _utrie_unserializeDummy_56+ABj
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+18h], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		mov	[eax+14h], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	loc_1B5C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		sar	ecx, 2
		mov	[ebp+var_44], cx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_38], ecx
		mov	[ebp+var_2C], 0
		jmp	short loc_1A7C
; ---------------------------------------------------------------------------

loc_1A73:				; CODE XREF: _utrie_unserializeDummy_56+126j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1A7C:				; CODE XREF: _utrie_unserializeDummy_56+105j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_1A94
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+Dst]
		mov	dx, [ebp+var_44]
		mov	[ecx+eax*2], dx
		jmp	short loc_1A73
; ---------------------------------------------------------------------------

loc_1A94:				; CODE XREF: _utrie_unserializeDummy_56+116j
		mov	eax, [ebp+arg_10]
		cmp	eax, [ebp+arg_C]
		jz	short loc_1AE0
		mov	eax, [ebp+var_20]
		sar	eax, 2
		movzx	ecx, ax
		movzx	edx, [ebp+var_44]
		add	edx, ecx
		mov	[ebp+var_44], dx
		mov	[ebp+var_2C], 6C0h
		mov	[ebp+var_38], 6E0h
		jmp	short loc_1AC8
; ---------------------------------------------------------------------------

loc_1ABF:				; CODE XREF: _utrie_unserializeDummy_56+172j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1AC8:				; CODE XREF: _utrie_unserializeDummy_56+151j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_1AE0
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+Dst]
		mov	dx, [ebp+var_44]
		mov	[ecx+eax*2], dx
		jmp	short loc_1ABF
; ---------------------------------------------------------------------------

loc_1AE0:				; CODE XREF: _utrie_unserializeDummy_56+12Ej
					; _utrie_unserializeDummy_56+162j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+Dst]
		lea	eax, [edx+ecx*2]
		mov	[ebp+Dst], eax
		mov	[ebp+var_2C], 0
		jmp	short loc_1B0B
; ---------------------------------------------------------------------------

loc_1B02:				; CODE XREF: _utrie_unserializeDummy_56+1B5j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1B0B:				; CODE XREF: _utrie_unserializeDummy_56+194j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	short loc_1B23
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+Dst]
		mov	dx, word ptr [ebp+arg_C]
		mov	[ecx+eax*2], dx
		jmp	short loc_1B02
; ---------------------------------------------------------------------------

loc_1B23:				; CODE XREF: _utrie_unserializeDummy_56+1A5j
		mov	eax, [ebp+arg_10]
		cmp	eax, [ebp+arg_C]
		jz	short loc_1B57
		mov	eax, [ebp+var_20]
		add	eax, 20h ; ' '
		mov	[ebp+var_38], eax
		jmp	short loc_1B3F
; ---------------------------------------------------------------------------

loc_1B36:				; CODE XREF: _utrie_unserializeDummy_56+1E9j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1B3F:				; CODE XREF: _utrie_unserializeDummy_56+1C8j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_1B57
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+Dst]
		mov	dx, word ptr [ebp+arg_10]
		mov	[ecx+eax*2], dx
		jmp	short loc_1B36
; ---------------------------------------------------------------------------

loc_1B57:				; CODE XREF: _utrie_unserializeDummy_56+1BDj
					; _utrie_unserializeDummy_56+1D9j
		jmp	loc_1C28
; ---------------------------------------------------------------------------

loc_1B5C:				; CODE XREF: _utrie_unserializeDummy_56+E2j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		shl	ecx, 1
		push	ecx		; Size
		push	0		; Val
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+arg_10]
		cmp	eax, [ebp+arg_C]
		jz	short loc_1BB6
		mov	eax, [ebp+var_20]
		sar	eax, 2
		mov	[ebp+var_44], ax
		mov	[ebp+var_2C], 6C0h
		mov	[ebp+var_38], 6E0h
		jmp	short loc_1B9E
; ---------------------------------------------------------------------------

loc_1B95:				; CODE XREF: _utrie_unserializeDummy_56+248j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1B9E:				; CODE XREF: _utrie_unserializeDummy_56+227j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_1BB6
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+Dst]
		mov	dx, [ebp+var_44]
		mov	[ecx+eax*2], dx
		jmp	short loc_1B95
; ---------------------------------------------------------------------------

loc_1BB6:				; CODE XREF: _utrie_unserializeDummy_56+20Dj
					; _utrie_unserializeDummy_56+238j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+Dst]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_50]
		mov	[ecx+4], edx
		mov	[ebp+var_2C], 0
		jmp	short loc_1BE0
; ---------------------------------------------------------------------------

loc_1BD7:				; CODE XREF: _utrie_unserializeDummy_56+288j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1BE0:				; CODE XREF: _utrie_unserializeDummy_56+269j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jge	short loc_1BF6
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_50]
		mov	edx, [ebp+arg_C]
		mov	[ecx+eax*4], edx
		jmp	short loc_1BD7
; ---------------------------------------------------------------------------

loc_1BF6:				; CODE XREF: _utrie_unserializeDummy_56+27Aj
		mov	eax, [ebp+arg_10]
		cmp	eax, [ebp+arg_C]
		jz	short loc_1C28
		mov	eax, [ebp+var_20]
		add	eax, 20h ; ' '
		mov	[ebp+var_38], eax
		jmp	short loc_1C12
; ---------------------------------------------------------------------------

loc_1C09:				; CODE XREF: _utrie_unserializeDummy_56+2BAj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_1C12:				; CODE XREF: _utrie_unserializeDummy_56+29Bj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jge	short loc_1C28
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_50]
		mov	edx, [ebp+arg_10]
		mov	[ecx+eax*4], edx
		jmp	short loc_1C09
; ---------------------------------------------------------------------------

loc_1C28:				; CODE XREF: _utrie_unserializeDummy_56:loc_1B57j
					; _utrie_unserializeDummy_56+290j ...
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], offset _utrie_defaultGetFoldingOffset_56
		mov	eax, [ebp+var_14]

loc_1C35:				; CODE XREF: _utrie_unserializeDummy_56+3Cj
					; _utrie_unserializeDummy_56+B9j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_unserializeDummy_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C4Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie_enum_56
_utrie_enum_56	proc near

var_16C		= dword	ptr -16Ch
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 16Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_16C]
		mov	ecx, 5Bh ; '['
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1C7E
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jz	short loc_1C7E
		cmp	[ebp+arg_8], 0
		jnz	short loc_1C83

loc_1C7E:				; CODE XREF: _utrie_enum_56+22j
					; _utrie_enum_56+2Aj
		jmp	loc_21E0
; ---------------------------------------------------------------------------

loc_1C83:				; CODE XREF: _utrie_enum_56+30j
		cmp	[ebp+arg_4], 0
		jnz	short loc_1C90
		mov	[ebp+arg_4], offset ?enumSameValue@@YAIPBXI@Z ;	enumSameValue(void const *,uint)

loc_1C90:				; CODE XREF: _utrie_enum_56+3Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_38], eax
		cmp	[ebp+var_8], 0
		jnz	short loc_1CD2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_98], ecx
		jmp	short loc_1CDC
; ---------------------------------------------------------------------------

loc_1CD2:				; CODE XREF: _utrie_enum_56+76j
		mov	[ebp+var_98], 0

loc_1CDC:				; CODE XREF: _utrie_enum_56+84j
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax
		mov	[ebp+var_50], 0
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax
		mov	[ebp+var_68], 0
		mov	[ebp+var_44], 0
		jmp	short loc_1D0E
; ---------------------------------------------------------------------------

loc_1D05:				; CODE XREF: _utrie_enum_56:loc_1EA8j
		mov	eax, [ebp+var_68]
		add	eax, 1
		mov	[ebp+var_68], eax

loc_1D0E:				; CODE XREF: _utrie_enum_56+B7j
		cmp	[ebp+var_44], 0FFFFh
		jg	loc_1EAD
		cmp	[ebp+var_44], 0D800h
		jnz	short loc_1D2D
		mov	[ebp+var_68], 800h
		jmp	short loc_1D3F
; ---------------------------------------------------------------------------

loc_1D2D:				; CODE XREF: _utrie_enum_56+D6j
		cmp	[ebp+var_44], 0DC00h
		jnz	short loc_1D3F
		mov	eax, [ebp+var_44]
		sar	eax, 5
		mov	[ebp+var_68], eax

loc_1D3F:				; CODE XREF: _utrie_enum_56+DFj
					; _utrie_enum_56+E8j
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		shl	edx, 2
		mov	[ebp+var_80], edx
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_8C]
		jnz	short loc_1D68
		mov	eax, [ebp+var_44]
		add	eax, 20h ; ' '
		mov	[ebp+var_44], eax
		jmp	loc_1EA8
; ---------------------------------------------------------------------------

loc_1D68:				; CODE XREF: _utrie_enum_56+10Cj
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_98]
		jnz	short loc_1DD4
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jz	short loc_1DC6
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_1DAE
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1DAE
		jmp	loc_21E0
; ---------------------------------------------------------------------------

loc_1DAE:				; CODE XREF: _utrie_enum_56+135j
					; _utrie_enum_56+15Bj
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax

loc_1DC6:				; CODE XREF: _utrie_enum_56+12Dj
		mov	eax, [ebp+var_44]
		add	eax, 20h ; ' '
		mov	[ebp+var_44], eax
		jmp	loc_1EA8
; ---------------------------------------------------------------------------

loc_1DD4:				; CODE XREF: _utrie_enum_56+125j
		mov	eax, [ebp+var_80]
		mov	[ebp+var_8C], eax
		mov	[ebp+var_74], 0
		jmp	short loc_1DEF
; ---------------------------------------------------------------------------

loc_1DE6:				; CODE XREF: _utrie_enum_56+257j
		mov	eax, [ebp+var_74]
		add	eax, 1
		mov	[ebp+var_74], eax

loc_1DEF:				; CODE XREF: _utrie_enum_56+198j
		cmp	[ebp+var_74], 20h ; ' '
		jge	loc_1EA8
		cmp	[ebp+var_8], 0
		jz	short loc_1E13
		mov	eax, [ebp+var_80]
		add	eax, [ebp+var_74]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_16C], edx
		jmp	short loc_1E26
; ---------------------------------------------------------------------------

loc_1E13:				; CODE XREF: _utrie_enum_56+1B1j
		mov	eax, [ebp+var_80]
		add	eax, [ebp+var_74]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_16C], edx

loc_1E26:				; CODE XREF: _utrie_enum_56+1C5j
		mov	esi, esp
		mov	eax, [ebp+var_16C]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jz	short loc_1E9A
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_1E7E
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1E7E
		jmp	loc_21E0
; ---------------------------------------------------------------------------

loc_1E7E:				; CODE XREF: _utrie_enum_56+205j
					; _utrie_enum_56+22Bj
		cmp	[ebp+var_74], 0
		jle	short loc_1E8E
		mov	[ebp+var_8C], 0FFFFFFFFh

loc_1E8E:				; CODE XREF: _utrie_enum_56+236j
		mov	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax

loc_1E9A:				; CODE XREF: _utrie_enum_56+1FDj
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax
		jmp	loc_1DE6
; ---------------------------------------------------------------------------

loc_1EA8:				; CODE XREF: _utrie_enum_56+117j
					; _utrie_enum_56+183j ...
		jmp	loc_1D05
; ---------------------------------------------------------------------------

loc_1EAD:				; CODE XREF: _utrie_enum_56+C9j
		mov	[ebp+var_5C], 0D800h

loc_1EB4:				; CODE XREF: _utrie_enum_56+300j
					; _utrie_enum_56+570j
		cmp	[ebp+var_5C], 0DC00h
		jge	loc_21C1
		mov	eax, [ebp+var_5C]
		sar	eax, 5
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		shl	edx, 2
		mov	[ebp+var_A4], edx
		mov	eax, [ebp+var_A4]
		cmp	eax, [ebp+var_98]
		jnz	short loc_1F51
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jz	short loc_1F38
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_1F20
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1F20
		jmp	loc_21E0
; ---------------------------------------------------------------------------

loc_1F20:				; CODE XREF: _utrie_enum_56+2A7j
					; _utrie_enum_56+2CDj
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax

loc_1F38:				; CODE XREF: _utrie_enum_56+29Fj
		mov	eax, [ebp+var_5C]
		add	eax, 20h ; ' '
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_44]
		add	eax, 8000h
		mov	[ebp+var_44], eax
		jmp	loc_1EB4
; ---------------------------------------------------------------------------

loc_1F51:				; CODE XREF: _utrie_enum_56+297j
		cmp	[ebp+var_8], 0
		jz	short loc_1F71
		mov	eax, [ebp+var_5C]
		and	eax, 1Fh
		add	eax, [ebp+var_A4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_16C], edx
		jmp	short loc_1F8A
; ---------------------------------------------------------------------------

loc_1F71:				; CODE XREF: _utrie_enum_56+309j
		mov	eax, [ebp+var_5C]
		and	eax, 1Fh
		add	eax, [ebp+var_A4]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_16C], edx

loc_1F8A:				; CODE XREF: _utrie_enum_56+323j
		mov	eax, [ebp+var_16C]
		mov	[ebp+var_20], eax
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+8]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_A4], eax
		cmp	[ebp+var_A4], 0
		jg	short loc_201D
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jz	short loc_200D
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_1FF5
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1FF5
		jmp	loc_21E0
; ---------------------------------------------------------------------------

loc_1FF5:				; CODE XREF: _utrie_enum_56+37Cj
					; _utrie_enum_56+3A2j
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax

loc_200D:				; CODE XREF: _utrie_enum_56+374j
		mov	eax, [ebp+var_44]
		add	eax, 400h
		mov	[ebp+var_44], eax
		jmp	loc_21B3
; ---------------------------------------------------------------------------

loc_201D:				; CODE XREF: _utrie_enum_56+36Cj
		mov	eax, [ebp+var_A4]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_A4]
		add	eax, 20h ; ' '
		mov	[ebp+var_A4], eax

loc_2035:				; CODE XREF: _utrie_enum_56+561j
		mov	eax, [ebp+var_68]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		shl	edx, 2
		mov	[ebp+var_80], edx
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_8C]
		jnz	short loc_205E
		mov	eax, [ebp+var_44]
		add	eax, 20h ; ' '
		mov	[ebp+var_44], eax
		jmp	loc_219B
; ---------------------------------------------------------------------------

loc_205E:				; CODE XREF: _utrie_enum_56+402j
		mov	eax, [ebp+var_80]
		cmp	eax, [ebp+var_98]
		jnz	short loc_20CA
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_38]
		jz	short loc_20BC
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_20A4
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_20A4
		jmp	loc_21E0
; ---------------------------------------------------------------------------

loc_20A4:				; CODE XREF: _utrie_enum_56+42Bj
					; _utrie_enum_56+451j
		mov	eax, [ebp+var_98]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax

loc_20BC:				; CODE XREF: _utrie_enum_56+423j
		mov	eax, [ebp+var_44]
		add	eax, 20h ; ' '
		mov	[ebp+var_44], eax
		jmp	loc_219B
; ---------------------------------------------------------------------------

loc_20CA:				; CODE XREF: _utrie_enum_56+41Bj
		mov	eax, [ebp+var_80]
		mov	[ebp+var_8C], eax
		mov	[ebp+var_74], 0
		jmp	short loc_20E5
; ---------------------------------------------------------------------------

loc_20DC:				; CODE XREF: _utrie_enum_56+54Aj
		mov	eax, [ebp+var_74]
		add	eax, 1
		mov	[ebp+var_74], eax

loc_20E5:				; CODE XREF: _utrie_enum_56+48Ej
		cmp	[ebp+var_74], 20h ; ' '
		jge	loc_219B
		cmp	[ebp+var_8], 0
		jz	short loc_2109
		mov	eax, [ebp+var_80]
		add	eax, [ebp+var_74]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_16C], edx
		jmp	short loc_211C
; ---------------------------------------------------------------------------

loc_2109:				; CODE XREF: _utrie_enum_56+4A7j
		mov	eax, [ebp+var_80]
		add	eax, [ebp+var_74]
		mov	ecx, [ebp+var_14]
		movzx	edx, word ptr [ecx+eax*2]
		mov	[ebp+var_16C], edx

loc_211C:				; CODE XREF: _utrie_enum_56+4BBj
		mov	esi, esp
		mov	eax, [ebp+var_16C]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jz	short loc_218D
		mov	eax, [ebp+var_50]
		cmp	eax, [ebp+var_44]
		jge	short loc_2171
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_2171
		jmp	short loc_21E0
; ---------------------------------------------------------------------------

loc_2171:				; CODE XREF: _utrie_enum_56+4FBj
					; _utrie_enum_56+521j
		cmp	[ebp+var_74], 0
		jle	short loc_2181
		mov	[ebp+var_8C], 0FFFFFFFFh

loc_2181:				; CODE XREF: _utrie_enum_56+529j
		mov	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax

loc_218D:				; CODE XREF: _utrie_enum_56+4F3j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax
		jmp	loc_20DC
; ---------------------------------------------------------------------------

loc_219B:				; CODE XREF: _utrie_enum_56+40Dj
					; _utrie_enum_56+479j ...
		mov	eax, [ebp+var_68]
		add	eax, 1
		mov	[ebp+var_68], eax
		mov	ecx, [ebp+var_68]
		cmp	ecx, [ebp+var_A4]
		jl	loc_2035

loc_21B3:				; CODE XREF: _utrie_enum_56+3CCj
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		jmp	loc_1EB4
; ---------------------------------------------------------------------------

loc_21C1:				; CODE XREF: _utrie_enum_56+26Fj
		mov	esi, esp
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+var_50]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		call	[ebp+arg_8]
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_21E0:				; CODE XREF: _utrie_enum_56:loc_1C7Ej
					; _utrie_enum_56+15Dj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 16Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie_enum_56	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21F4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; unsigned int __cdecl enumSameValue(void const	*, unsigned int)
?enumSameValue@@YAIPBXI@Z proc near	; DATA XREF: _utrie_enum_56+3Do

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?enumSameValue@@YAIPBXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _uprv_free_56:near ; CODE	XREF: _utrie_open_56+D0p
					; _utrie_clone_56+D6p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _utrie_open_56+72p
					; _findUnusedBlocks(UNewTrie *)+31p ...
		extrn _uprv_malloc_56:near ; CODE XREF:	_utrie_open_56+4Fp
					; _utrie_open_56+AFp ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _utrie_open_56+19Bp
					; _utrie_clone_56+16Cp	...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _utrie_clone_56+FBp
					; _utrie_clone_56+138p	...
		extrn _uprv_checkValidMemory:near ; CODE XREF: _utrie_clone_56+E6p
					; _utrie_clone_56+10Fp	...
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near
					; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+28Dp
					; utrie_fold(UNewTrie *,uint (*)(UNewTrie *,int,int),UErrorCode	*)+32Cp
					; DATA XREF: ...
		extrn ___security_cookie:near
					; DATA XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+1Er
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+3A5p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: utrie_fold(UNewTrie *,uint	(*)(UNewTrie *,int,int),UErrorCode *)+396p
					; defaultGetFoldedValue(UNewTrie *,int,int)+8Fp


		end
