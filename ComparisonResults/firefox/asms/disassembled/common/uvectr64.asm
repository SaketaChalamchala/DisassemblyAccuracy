;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8A6A49B09F40F09C6BC69FDF6D411835
; Input	CRC32 :	A3449B17

; File Name   :	D:\compspace\objfiles\firefox\common\uvectr64.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing
; char `public:	static void * __cdecl icu_56::UVector64::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@UVector64@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::UVector64::getStaticClassID(void)+1Eo
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 3Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 40h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase	; DATA XREF: .rdata$r:000001A0o
					; .rdata$r:000001BCo ...
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UVector64::UVector64(UErrorCode &)+45p
					; icu_56::UVector64::UVector64(int,UErrorCode &)+45p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 130h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13Ch
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000130o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 150h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000148o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 170h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000014Co
					; .rdata$r:000001A4o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 180h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:0000017Co
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 18Ch
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000B3Co
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A8h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000184o
					; .rdata$r:00000B40o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1C4h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E4h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000001C0o
					; .rdata$r:00000214o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1F4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000001F0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1FCh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_24F
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_259
; ---------------------------------------------------------------------------

loc_24F:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_259:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 270h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2DF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_2DF:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_359
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_351
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_351:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_378
; ---------------------------------------------------------------------------

loc_359:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_375
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_375:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_378:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 390h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector64::isEmpty(icu_56::UVector64	*__hidden this)
		public ?isEmpty@UVector64@icu_56@@QBECXZ
?isEmpty@UVector64@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UVector64@icu_56@@QBECXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector64::`scalar deleting	destructor'(unsigned int)
		public ??_GUVector64@icu_56@@UAEPAXI@Z
??_GUVector64@icu_56@@UAEPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UVector64@icu_56@@UAE@XZ ; icu_56::UVector64::~UVector64(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_403
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_403:				; CODE XREF: icu_56::UVector64::`scalar	deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUVector64@icu_56@@UAEPAXI@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector64::`vector deleting	destructor'(unsigned int)
		public ??_EUVector64@icu_56@@UAEPAXI@Z
??_EUVector64@icu_56@@UAEPAXI@Z	proc near
					; DATA XREF: .rdata:const icu_56::UVector64::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_47D
		push	offset ??1UVector64@icu_56@@UAE@XZ ; icu_56::UVector64::~UVector64(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	14h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_475
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_475:				; CODE XREF: icu_56::UVector64::`vector	deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_49C
; ---------------------------------------------------------------------------

loc_47D:				; CODE XREF: icu_56::UVector64::`vector	deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UVector64@icu_56@@UAE@XZ ; icu_56::UVector64::~UVector64(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_499
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_499:				; CODE XREF: icu_56::UVector64::`vector	deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_49C:				; CODE XREF: icu_56::UVector64::`vector	deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUVector64@icu_56@@UAEPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector64::ensureCapacity(icu_56::UVector64 *this, int, enum	UErrorCode *)
		public ?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z
?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector64::addElement(__int64,UErrorCode &)+34p
					; icu_56::UVector64::reserveBlock(int,UErrorCode &)+34p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_4EE
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_0]
		jl	short loc_4EE
		mov	al, 1
		jmp	short loc_4FE
; ---------------------------------------------------------------------------
		jmp	short loc_4FE
; ---------------------------------------------------------------------------

loc_4EE:				; CODE XREF: icu_56::UVector64::ensureCapacity(int,UErrorCode &)+27j
					; icu_56::UVector64::ensureCapacity(int,UErrorCode &)+32j
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?expandCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector64::expandCapacity(int,UErrorCode &)

loc_4FE:				; CODE XREF: icu_56::UVector64::ensureCapacity(int,UErrorCode &)+36j
					; icu_56::UVector64::ensureCapacity(int,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 514h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::UVector64::elementAti(icu_56::UVector64 *this, int)
		public ?elementAti@UVector64@icu_56@@QBE_JH@Z
?elementAti@UVector64@icu_56@@QBE_JH@Z proc near
					; CODE XREF: icu_56::UVector64::lastElementi(void)+30p

var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D4]
		mov	ecx, 35h ; '5'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_566
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jge	short loc_566
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+ecx*8]
		mov	[ebp+var_D4], edx
		mov	eax, [eax+ecx*8+4]
		mov	[ebp+var_D0], eax
		jmp	short loc_57A
; ---------------------------------------------------------------------------

loc_566:				; CODE XREF: icu_56::UVector64::elementAti(int)+27j
					; icu_56::UVector64::elementAti(int)+32j
		mov	[ebp+var_D4], 0
		mov	[ebp+var_D0], 0

loc_57A:				; CODE XREF: icu_56::UVector64::elementAti(int)+50j
		mov	eax, [ebp+var_D4]
		mov	edx, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?elementAti@UVector64@icu_56@@QBE_JH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 590h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::addElement(icu_56::UVector64 *this, __int64, enum UErrorCode *)
		public ?addElement@UVector64@icu_56@@QAEX_JAAW4UErrorCode@@@Z
?addElement@UVector64@icu_56@@QAEX_JAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector64::push(__int64,UErrorCode	&)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector64::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_5F8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, dword ptr [ebp+arg_0]
		mov	[eax+ecx*8], edx
		mov	edx, dword ptr [ebp+arg_0+4]
		mov	[eax+ecx*8+4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_5F8:				; CODE XREF: icu_56::UVector64::addElement(__int64,UErrorCode &)+3Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?addElement@UVector64@icu_56@@QAEX_JAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 610h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 *__thiscall icu_56::UVector64::reserveBlock(icu_56::UVector64	*this, int, enum UErrorCode *)
		public ?reserveBlock@UVector64@icu_56@@QAEPA_JHAAW4UErrorCode@@@Z
?reserveBlock@UVector64@icu_56@@QAEPA_JHAAW4UErrorCode@@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector64::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_654
		xor	eax, eax
		jmp	short loc_678
; ---------------------------------------------------------------------------

loc_654:				; CODE XREF: icu_56::UVector64::reserveBlock(int,UErrorCode &)+3Ej
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		lea	ecx, [eax+ecx*8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_14]

loc_678:				; CODE XREF: icu_56::UVector64::reserveBlock(int,UErrorCode &)+42j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reserveBlock@UVector64@icu_56@@QAEPA_JHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 690h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 *__thiscall icu_56::UVector64::popFrame(icu_56::UVector64 *this, int)
		public ?popFrame@UVector64@icu_56@@QAEPA_JH@Z
?popFrame@UVector64@icu_56@@QAEPA_JH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		cmp	ecx, [ebp+arg_0]
		jge	short loc_6E4
		mov	edx, ds:?__LINE__Var@?1??popFrame@UVector64@icu_56@@QAEPA_JH@Z@4JA ; long `icu_56::UVector64::popFrame(int)'::`2'::__LINE__Var
		add	edx, 1
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@CCAJPJF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BM@FLCAFPEE@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; "count >= size"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6E4:				; CODE XREF: icu_56::UVector64::popFrame(int)+2Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jge	short loc_706
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_706:				; CODE XREF: icu_56::UVector64::popFrame(int)+6Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		lea	eax, [eax+ecx*8]
		mov	ecx, [ebp+arg_0]
		shl	ecx, 3
		sub	eax, ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?popFrame@UVector64@icu_56@@QAEPA_JH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 734h
		public ??_C@_1BM@FLCAFPEE@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
; wchar_t `string'
??_C@_1BM@FLCAFPEE@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AA?$AA@:
					; DATA XREF: icu_56::UVector64::popFrame(int)+3Fo
		unicode	0, <count >
		dw 3Eh
		unicode	0, <= size>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 750h
		public ??_C@_1FK@CCAJPJF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FK@CCAJPJF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: icu_56::UVector64::popFrame(int)+3Ao
		unicode	0, <d:\mozilla\intl\icu\source\common\uvectr64.h>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7ACh
		public ?__LINE__Var@?1??popFrame@UVector64@icu_56@@QAEPA_JH@Z@4JA
; long `public:	__int64	* __thiscall icu_56::UVector64::popFrame(int)'::`2'::__LINE__Var
?__LINE__Var@?1??popFrame@UVector64@icu_56@@QAEPA_JH@Z@4JA dd 0E7h
					; DATA XREF: icu_56::UVector64::popFrame(int)+2Er
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector64::size(icu_56::UVector64 *__hidden this)
		public ?size@UVector64@icu_56@@QBEHXZ
?size@UVector64@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@UVector64@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::UVector64::lastElementi(icu_56::UVector64 *__hidden this)
		public ?lastElementi@UVector64@icu_56@@QBE_JXZ
?lastElementi@UVector64@icu_56@@QBE_JXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAti@UVector64@icu_56@@QBE_JH@Z ; icu_56::UVector64::elementAti(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElementi@UVector64@icu_56@@QBE_JXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 82Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector64::operator!=(class icu_56::UVector64 const &)
		public ??9UVector64@icu_56@@QAECABV01@@Z
??9UVector64@icu_56@@QAECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8UVector64@icu_56@@QAECABV01@@Z ; icu_56::UVector64::operator==(icu_56::UVector64 const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UVector64@icu_56@@QAECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 *__thiscall icu_56::UVector64::getBuffer(icu_56::UVector64 *__hidden this)
		public ?getBuffer@UVector64@icu_56@@QBEPA_JXZ
?getBuffer@UVector64@icu_56@@QBEPA_JXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UVector64@icu_56@@QBEPA_JXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8ACh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::UVector64::push(icu_56::UVector64 *this, __int64, enum UErrorCode *)
		public ?push@UVector64@icu_56@@QAE_J_JAAW4UErrorCode@@@Z
?push@UVector64@icu_56@@QAE_J_JAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, dword ptr [ebp+arg_0+4]
		push	ecx
		mov	edx, dword ptr [ebp+arg_0]
		push	edx		; __int64
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector64@icu_56@@QAEX_JAAW4UErrorCode@@@Z ; icu_56::UVector64::addElement(__int64,UErrorCode &)
		mov	eax, dword ptr [ebp+arg_0]
		mov	edx, dword ptr [ebp+arg_0+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?push@UVector64@icu_56@@QAE_J_JAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 900h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; __int64 __thiscall icu_56::UVector64::popi(icu_56::UVector64 *__hidden this)
		public ?popi@UVector64@icu_56@@QAE_JXZ
?popi@UVector64@icu_56@@QAE_JXZ	proc near

var_DC		= byte ptr -0DCh
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_18], 0
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		jle	short loc_962
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [eax+ecx*8]
		mov	[ebp+var_18], edx
		mov	eax, [eax+ecx*8+4]
		mov	[ebp+var_14], eax

loc_962:				; CODE XREF: icu_56::UVector64::popi(void)+38j
		mov	eax, [ebp+var_18]
		mov	edx, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?popi@UVector64@icu_56@@QAE_JXZ	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 970h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UVector64::getStaticClassID()
		public ?getStaticClassID@UVector64@icu_56@@SAPAXXZ
?getStaticClassID@UVector64@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::UVector64::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@UVector64@icu_56@@SAPAXXZ@4DA	; char `icu_56::UVector64::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@UVector64@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 99Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector64::getDynamicClassID(icu_56::UVector64 *__hidden this)
		public ?getDynamicClassID@UVector64@icu_56@@UBEPAXXZ
?getDynamicClassID@UVector64@icu_56@@UBEPAXXZ proc near	; DATA XREF: .rdata:00000AC4o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@UVector64@icu_56@@SAPAXXZ ; icu_56::UVector64::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@UVector64@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector64::UVector64(icu_56::UVector64 *this, enum UErrorCode *)
		public ??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z
??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector64@icu_56@@6B@ ; const icu_56::UVector64::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	8		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector64@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector64::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0A94h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000ACCo
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::UVector64::UVector64(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ABCh
		dd offset ??_R4UVector64@icu_56@@6B@ ; const icu_56::UVector64::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UVector64@icu_56@@6B@
; const	icu_56::UVector64::`vftable'
??_7UVector64@icu_56@@6B@ dd offset ??_EUVector64@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UVector64::UVector64(UErrorCode &)+54o
					; icu_56::UVector64::UVector64(int,UErrorCode &)+54o ...
					; icu_56::UVector64::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UVector64@icu_56@@UBEPAXXZ	; icu_56::UVector64::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0AC8h
__unwindtable$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000AD8o
		dd offset __unwindfunclet$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0AF4h
		public ??_R4UVector64@icu_56@@6B@
; const	icu_56::UVector64::`RTTI Complete Object Locator'
??_R4UVector64@icu_56@@6B@ dd 3	dup(0)	; DATA XREF: .rdata:00000ABCo
		dd offset ??_R0?AVUVector64@icu_56@@@8 ; icu_56::UVector64 `RTTI Type Descriptor'
		dd offset ??_R3UVector64@icu_56@@8 ; icu_56::UVector64::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0B08h
		public ??_R0?AVUVector64@icu_56@@@8
; class	icu_56::UVector64 `RTTI	Type Descriptor'
??_R0?AVUVector64@icu_56@@@8 dd	offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000B00o
					; .rdata$r:icu_56::UVector64::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avuvector64@	db '.?AVUVector64@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B28h
		public ??_R3UVector64@icu_56@@8
; icu_56::UVector64::`RTTI Class Hierarchy Descriptor'
??_R3UVector64@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000B04o
					; .rdata$r:00000B60o
		dd 3
		dd offset ??_R2UVector64@icu_56@@8 ; icu_56::UVector64::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B38h
		public ??_R2UVector64@icu_56@@8
; icu_56::UVector64::`RTTI Base	Class Array'
??_R2UVector64@icu_56@@8 dd offset ??_R1A@?0A@EA@UVector64@icu_56@@8
					; DATA XREF: .rdata$r:00000B34o
					; icu_56::UVector64::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0B48h
		public ??_R1A@?0A@EA@UVector64@icu_56@@8
; icu_56::UVector64::`RTTI Base	Class Descriptor at (0,	-1, 0, 64)'
??_R1A@?0A@EA@UVector64@icu_56@@8 dd offset ??_R0?AVUVector64@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UVector64::`RTTI Base Class Array'o
					; icu_56::UVector64 `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UVector64@icu_56@@8 ; icu_56::UVector64::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B64h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector64::UVector64(icu_56::UVector64 *this, int, enum UErrorCode *)
		public ??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z
??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector64@icu_56@@6B@ ; const icu_56::UVector64::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector64@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector64::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C24h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000C50o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UVector64::UVector64(int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C4Ch
__unwindtable$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000C5Co
		dd offset __unwindfunclet$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C78h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::_init(icu_56::UVector64 *this, int, enum UErrorCode *)
		public ?_init@UVector64@icu_56@@AAEXHAAW4UErrorCode@@@Z
?_init@UVector64@icu_56@@AAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector64::UVector64(UErrorCode &)+8Bp
					; icu_56::UVector64::UVector64(int,UErrorCode &)+8Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1
		jge	short loc_CA8
		mov	[ebp+arg_0], 8

loc_CA8:				; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+27j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jle	short loc_CC5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		cmp	ecx, [ebp+arg_0]
		jge	short loc_CC5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+arg_0], ecx

loc_CC5:				; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+37j
					; icu_56::UVector64::_init(int,UErrorCode &)+42j
		cmp	[ebp+arg_0], 0FFFFFFFh
		jle	short loc_CE2
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		push	8
		call	_uprv_min_56
		add	esp, 8
		mov	[ebp+arg_0], eax

loc_CE2:				; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+54j
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+10h], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jnz	short loc_D0B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_D14
; ---------------------------------------------------------------------------

loc_D0B:				; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+86j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_D14:				; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+91j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_init@UVector64@icu_56@@AAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D2Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector64::~UVector64(icu_56::UVector64 *__hidden this)
		public ??1UVector64@icu_56@@UAE@XZ
??1UVector64@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::UVector64::`scalar	deleting destructor'(uint)+26p
					; icu_56::UVector64::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UVector64@icu_56@@6B@ ; const icu_56::UVector64::`vftable'
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+10h], 0
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UVector64@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D90h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::assign(icu_56::UVector64 *this, const struct icu_56::UVector64 *, enum UErrorCode *)
		public ?assign@UVector64@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z
?assign@UVector64@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector64::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_E1B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setSize@UVector64@icu_56@@QAEXH@Z ; icu_56::UVector64::setSize(int)
		mov	[ebp+var_14], 0
		jmp	short loc_DEE
; ---------------------------------------------------------------------------

loc_DE5:				; CODE XREF: icu_56::UVector64::assign(icu_56::UVector64 const &,UErrorCode &)+89j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_DEE:				; CODE XREF: icu_56::UVector64::assign(icu_56::UVector64 const &,UErrorCode &)+53j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_E1B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	edi, [ecx+esi*8]
		mov	[eax+edx*8], edi
		mov	ecx, [ecx+esi*8+4]
		mov	[eax+edx*8+4], ecx
		jmp	short loc_DE5
; ---------------------------------------------------------------------------

loc_E1B:				; CODE XREF: icu_56::UVector64::assign(icu_56::UVector64 const &,UErrorCode &)+3Bj
					; icu_56::UVector64::assign(icu_56::UVector64 const &,UErrorCode &)+67j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?assign@UVector64@icu_56@@QAEXABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E34h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector64::operator==(class icu_56::UVector64 const &)
		public ??8UVector64@icu_56@@QAECABV01@@Z
??8UVector64@icu_56@@QAECABV01@@Z proc near
					; CODE XREF: icu_56::UVector64::operator!=(icu_56::UVector64 const &)+2Ap

var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jz	short loc_E6C
		xor	al, al
		jmp	loc_F00
; ---------------------------------------------------------------------------

loc_E6C:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &)+2Fj
		mov	[ebp+var_14], 0
		jmp	short loc_E7E
; ---------------------------------------------------------------------------

loc_E75:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &):loc_EF9j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_E7E:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &)+3Fj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_EFE
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	[ebp+var_DC], ecx
		mov	[ebp+var_E0], edx
		mov	[ebp+var_E4], eax
		mov	[ebp+var_E8], esi
		mov	eax, [ebp+var_E0]
		mov	ecx, [ebp+var_DC]
		mov	edx, [ebp+var_E8]
		mov	esi, [ebp+var_E4]
		mov	eax, [ecx+eax*8]
		cmp	eax, [esi+edx*8]
		jnz	short loc_EF5
		mov	ecx, [ebp+var_E0]
		mov	edx, [ebp+var_DC]
		mov	eax, [ebp+var_E8]
		mov	esi, [ebp+var_E4]
		mov	ecx, [edx+ecx*8+4]
		cmp	ecx, [esi+eax*8+4]
		jz	short loc_EF9

loc_EF5:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &)+9Dj
		xor	al, al
		jmp	short loc_F00
; ---------------------------------------------------------------------------

loc_EF9:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &)+BFj
		jmp	loc_E75
; ---------------------------------------------------------------------------

loc_EFE:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &)+53j
		mov	al, 1

loc_F00:				; CODE XREF: icu_56::UVector64::operator==(icu_56::UVector64 const &)+33j
					; icu_56::UVector64::operator==(icu_56::UVector64 const	&)+C3j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8UVector64@icu_56@@QAECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F0Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::setElementAt(icu_56::UVector64 *this, __int64, int)
		public ?setElementAt@UVector64@icu_56@@QAEX_JH@Z
?setElementAt@UVector64@icu_56@@QAEX_JH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jl	short loc_F56
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		cmp	ecx, [eax+4]
		jge	short loc_F56
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_8]
		mov	eax, dword ptr [ebp+arg_0]
		mov	[ecx+edx*8], eax
		mov	eax, dword ptr [ebp+arg_0+4]
		mov	[ecx+edx*8+4], eax

loc_F56:				; CODE XREF: icu_56::UVector64::setElementAt(__int64,int)+27j
					; icu_56::UVector64::setElementAt(__int64,int)+32j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setElementAt@UVector64@icu_56@@QAEX_JH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F60h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::insertElementAt(icu_56::UVector64 *this, __int64, int, enum UErrorCode *)
		public ?insertElementAt@UVector64@icu_56@@QAEX_JHAAW4UErrorCode@@@Z
?insertElementAt@UVector64@icu_56@@QAEX_JHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jl	loc_101D
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		cmp	ecx, [eax+4]
		jg	loc_101D
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector64::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_101D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_FCD
; ---------------------------------------------------------------------------

loc_FC4:				; CODE XREF: icu_56::UVector64::insertElementAt(__int64,int,UErrorCode &)+96j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_FCD:				; CODE XREF: icu_56::UVector64::insertElementAt(__int64,int,UErrorCode &)+62j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_8]
		jle	short loc_FF8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	edi, [ecx+esi*8-8]
		mov	[eax+edx*8], edi
		mov	ecx, [ecx+esi*8-4]
		mov	[eax+edx*8+4], ecx
		jmp	short loc_FC4
; ---------------------------------------------------------------------------

loc_FF8:				; CODE XREF: icu_56::UVector64::insertElementAt(__int64,int,UErrorCode &)+73j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_8]
		mov	eax, dword ptr [ebp+arg_0]
		mov	[ecx+edx*8], eax
		mov	eax, dword ptr [ebp+arg_0+4]
		mov	[ecx+edx*8+4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_101D:				; CODE XREF: icu_56::UVector64::insertElementAt(__int64,int,UErrorCode &)+27j
					; icu_56::UVector64::insertElementAt(__int64,int,UErrorCode &)+36j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insertElementAt@UVector64@icu_56@@QAEX_JHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1034h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::removeAllElements(icu_56::UVector64 *__hidden this)
		public ?removeAllElements@UVector64@icu_56@@QAEXXZ
?removeAllElements@UVector64@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?removeAllElements@UVector64@icu_56@@QAEXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1068h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector64::expandCapacity(icu_56::UVector64 *this, int, enum	UErrorCode *)
		public ?expandCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z
?expandCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector64::ensureCapacity(int,UErrorCode &)+45p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_10A7
		xor	al, al
		jmp	loc_119B
; ---------------------------------------------------------------------------

loc_10A7:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+36j
		cmp	[ebp+arg_0], 0
		jge	short loc_10BD
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_119B
; ---------------------------------------------------------------------------

loc_10BD:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+43j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_0]
		jl	short loc_10CF
		mov	al, 1
		jmp	loc_119B
; ---------------------------------------------------------------------------

loc_10CF:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+5Ej
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jle	short loc_10F3
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+0Ch]
		jle	short loc_10F3
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		xor	al, al
		jmp	loc_119B
; ---------------------------------------------------------------------------

loc_10F3:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+6Ej
					; icu_56::UVector64::expandCapacity(int,UErrorCode &)+79j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 3FFFFFFFh
		jle	short loc_110F
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_119B
; ---------------------------------------------------------------------------

loc_110F:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+95j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		shl	ecx, 1
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_1128
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax

loc_1128:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+B8j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jle	short loc_1145
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+0Ch]
		jle	short loc_1145
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx

loc_1145:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+C7j
					; icu_56::UVector64::expandCapacity(int,UErrorCode &)+D2j
		cmp	[ebp+var_14], 0FFFFFFFh
		jle	short loc_115B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	short loc_119B
; ---------------------------------------------------------------------------

loc_115B:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+E4j
		mov	eax, [ebp+var_14]
		shl	eax, 3
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		push	edx
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_1187
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_119B
; ---------------------------------------------------------------------------

loc_1187:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+110j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		mov	al, 1

loc_119B:				; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+3Aj
					; icu_56::UVector64::expandCapacity(int,UErrorCode &)+50j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?expandCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11B4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+29p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11E0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::setMaxCapacity(icu_56::UVector64 *this, int)
		public ?setMaxCapacity@UVector64@icu_56@@QAEXH@Z
?setMaxCapacity@UVector64@icu_56@@QAEXH@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jge	short loc_122E
		mov	eax, ds:?__LINE__Var@?1??setMaxCapacity@UVector64@icu_56@@QAEXH@Z@4JA ;	long `icu_56::UVector64::setMaxCapacity(int)'::`2'::__LINE__Var
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FO@DKCMBKNO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BG@KDIADNAG@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ;	"limit >= 0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_122E:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+27j
		cmp	[ebp+arg_0], 0
		jge	short loc_123B
		mov	[ebp+arg_0], 0

loc_123B:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+52j
		cmp	[ebp+arg_0], 0FFFFFFFh
		jle	short loc_1246
		jmp	short loc_12BB
; ---------------------------------------------------------------------------

loc_1246:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+62j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+8]
		cmp	edx, [ecx+0Ch]
		jle	short loc_1266
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_1268

loc_1266:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+7Bj
		jmp	short loc_12BB
; ---------------------------------------------------------------------------

loc_1268:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+84j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		shl	ecx, 3
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+10h]
		push	eax
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jnz	short loc_128C
		jmp	short loc_12BB
; ---------------------------------------------------------------------------

loc_128C:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+A8j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	[eax+8], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [eax+4]
		cmp	edx, [ecx+8]
		jle	short loc_12BB
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[eax+4], edx

loc_12BB:				; CODE XREF: icu_56::UVector64::setMaxCapacity(int)+64j
					; icu_56::UVector64::setMaxCapacity(int):loc_1266j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setMaxCapacity@UVector64@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12D4h
		public ??_C@_1BG@KDIADNAG@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BG@KDIADNAG@?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@:
					; DATA XREF: icu_56::UVector64::setMaxCapacity(int)+39o
		unicode	0, <limit >
		dw 3Eh
		unicode	0, <= 0>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 12ECh
		public ??_C@_1FO@DKCMBKNO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FO@DKCMBKNO@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: icu_56::UVector64::setMaxCapacity(int)+34o
		unicode	0, <d:\mozilla\intl\icu\source\common\uvectr64.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 134Ch
		public ?__LINE__Var@?1??setMaxCapacity@UVector64@icu_56@@QAEXH@Z@4JA
; long `public:	void __thiscall	icu_56::UVector64::setMaxCapacity(int)'::`2'::__LINE__Var
?__LINE__Var@?1??setMaxCapacity@UVector64@icu_56@@QAEXH@Z@4JA dd 9Eh
					; DATA XREF: icu_56::UVector64::setMaxCapacity(int)+29r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1350h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector64::setSize(icu_56::UVector64 *this, int)
		public ?setSize@UVector64@icu_56@@QAEXH@Z
?setSize@UVector64@icu_56@@QAEXH@Z proc	near
					; CODE XREF: icu_56::UVector64::assign(icu_56::UVector64 const &,UErrorCode &)+47p

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jge	short loc_137B
		jmp	short loc_13E5
; ---------------------------------------------------------------------------

loc_137B:				; CODE XREF: icu_56::UVector64::setSize(int)+27j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_13DC
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector64@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::UVector64::ensureCapacity(int,UErrorCode &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_13A6
		jmp	short loc_13E5
; ---------------------------------------------------------------------------

loc_13A6:				; CODE XREF: icu_56::UVector64::setSize(int)+52j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_13BA
; ---------------------------------------------------------------------------

loc_13B1:				; CODE XREF: icu_56::UVector64::setSize(int)+8Aj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_13BA:				; CODE XREF: icu_56::UVector64::setSize(int)+5Fj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_13DC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_14]
		mov	dword ptr [ecx+edx*8], 0
		mov	dword ptr [ecx+edx*8+4], 0
		jmp	short loc_13B1
; ---------------------------------------------------------------------------

loc_13DC:				; CODE XREF: icu_56::UVector64::setSize(int)+34j
					; icu_56::UVector64::setSize(int)+70j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx

loc_13E5:				; CODE XREF: icu_56::UVector64::setSize(int)+29j
					; icu_56::UVector64::setSize(int)+54j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN11
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setSize@UVector64@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
$LN11		dd 1			; DATA XREF: icu_56::UVector64::setSize(int)+99o
		dd offset $LN10
$LN10		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001410o
		dd offset $LN9
$LN9		db 65h,	63h, 0		; DATA XREF: .text:0000141Co
_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000138o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::UVector64::`vector deleting destructor'(uint)+51p
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::UVector64::`vector deleting destructor'(uint)+3Dp
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	icu_56::UVector64::popFrame(int)+44p
					; icu_56::UVector64::setMaxCapacity(int)+3Ep
					; DATA XREF: ...
		extrn ___security_cookie:near
					; DATA XREF: icu_56::UVector64::UVector64(UErrorCode &)+2Er
					; icu_56::UVector64::UVector64(int,UErrorCode &)+2Er
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z+19j
					; __ehhandler$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z+19j
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0UVector64@icu_56@@QAE@AAW4UErrorCode@@@Z+Fp
					; __ehhandler$??0UVector64@icu_56@@QAE@HAAW4UErrorCode@@@Z+Fp
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+71p
		extrn _uprv_min_56:near	; CODE XREF: icu_56::UVector64::_init(int,UErrorCode &)+5Fp
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::UVector64::~UVector64(void)+33p
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::UVector64::expandCapacity(int,UErrorCode &)+101p
					; icu_56::UVector64::setMaxCapacity(int)+99p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::UVector64::setSize(int)+9Fp


		end
