;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	A18CCE953C845A12162AA13E744F6D18
; Input	CRC32 :	67A41C9D

; File Name   :	D:\compspace\objfiles\firefox\common\messagepattern.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset _kOffsetColon ; "offset:"
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_3FD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_2000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_3FFC+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_8000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_1BB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z ;	icu_56::swap(icu_56::UnicodeString &,icu_56::UnicodeString &)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_3000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
		public ?MAX_LENGTH@Part@MessagePattern@icu_56@@0HB
; private: static int const icu_56::MessagePattern::Part::MAX_LENGTH
?MAX_LENGTH@Part@MessagePattern@icu_56@@0HB dd 0FFFFh
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
		public ?MAX_VALUE@Part@MessagePattern@icu_56@@0HB
; private: static int const icu_56::MessagePattern::Part::MAX_VALUE
?MAX_VALUE@Part@MessagePattern@icu_56@@0HB dd offset loc_7FFB+4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 100h
; wchar_t kOffsetColon
_kOffsetColon:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+235o
		unicode	0, <offset:>,0
; wchar_t kOther
_kOther:				; DATA XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+37Ao
		unicode	0, <other>
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 154h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 158h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 190h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp

loc_1BB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx

loc_200:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 210h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p
					; icu_56::MessagePattern::MessagePattern(UErrorCode &)+45p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 248h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 254h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000248o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 268h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000260o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 288h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000264o
					; .rdata$r:000002BCo
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 298h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000294o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2A4h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000574o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2C0h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:0000029Co
					; .rdata$r:00000578o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 8
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 2DCh
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 2FCh
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000002D8o
					; .rdata$r:0000032Co
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 30Ch
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:00000308o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 314h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 330h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap
					; icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern	const &)+49p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_367
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_371
; ---------------------------------------------------------------------------

loc_367:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_371:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 388h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3F7
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_3F7:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx

loc_3FD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 410h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_471
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_469
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_469:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_490
; ---------------------------------------------------------------------------

loc_471:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_48D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_48D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_490:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FCh
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 528h
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:000004FCo
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 53Ch
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:00000534o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 560h
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:00000538o
					; .rdata$r:00000598o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 570h
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:0000056Co
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 580h
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:000011B0o
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_623
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_623:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 63Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_69D
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_695
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_695:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_6BC
; ---------------------------------------------------------------------------

loc_69D:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_6B9
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_6B9:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_6BC:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 720h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 770h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp

loc_7FC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 818h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 920h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 950h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 980h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_A8D
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_A71
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_A71:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_A8D:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_AE7
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_ADD
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_AE7
; ---------------------------------------------------------------------------

loc_ADD:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_AE7:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BB8h
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0BCCh
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000BB8o
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0BE0h
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000BD8o
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C00h
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00000BDCo
					; .rdata$r:00000C34o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C10h
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00000C0Co
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0C1Ch
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_C77
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_C77:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_CF1
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_CE9
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_CE9:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_D10
; ---------------------------------------------------------------------------

loc_CF1:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_D0D
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_D0D:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_D10:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E7F
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_E7F:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_EF9
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EF1
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_EF1:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_F18
; ---------------------------------------------------------------------------

loc_EF9:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_F15
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_F15:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_F18:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_F66
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_F82
; ---------------------------------------------------------------------------

loc_F66:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_F82
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_F82:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_FD9
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_FEB
; ---------------------------------------------------------------------------

loc_FD9:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_FEB
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_FEB:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_FFE
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_101A
; ---------------------------------------------------------------------------

loc_FFE:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_101A
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_101A:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1030h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_106D
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1079
; ---------------------------------------------------------------------------

loc_106D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1079:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1088h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_10C5
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_10D1
; ---------------------------------------------------------------------------

loc_10C5:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_10D1:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near
					; CODE XREF: icu_56::MessagePattern::MessagePattern(UErrorCode &)+6Ap
					; icu_56::MessagePattern::MessagePattern(UMessagePatternApostropheMode,UErrorCode &)+69p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1138h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1164h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:00001138o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1178h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00001170o
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 119Ch
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001174o
					; .rdata$r:000011D8o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11ACh
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:000011A8o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 11C0h
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1214h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1248h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_128A
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_1296
; ---------------------------------------------------------------------------

loc_128A:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_1296:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_12EB
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_12F7
; ---------------------------------------------------------------------------

loc_12EB:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_12F7:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1304h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::MessagePattern::hashCode(void)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1344h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1378h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_1401
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_13F8
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_1401

loc_13F8:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_1408
; ---------------------------------------------------------------------------

loc_1401:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_1408:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1424h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near
					; CODE XREF: icu_56::MessagePattern::validateArgumentName(icu_56::UnicodeString	const &)+2Ap
					; icu_56::MessagePattern::skipWhiteSpace(int)+29p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_1459
		xor	eax, eax
		jmp	short loc_1475
; ---------------------------------------------------------------------------
		jmp	short loc_1475
; ---------------------------------------------------------------------------

loc_1459:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_146F
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_1475
; ---------------------------------------------------------------------------
		jmp	short loc_1475
; ---------------------------------------------------------------------------

loc_146F:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_1475:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 147Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_14C2
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_14F3
; ---------------------------------------------------------------------------
		jmp	short loc_14F3
; ---------------------------------------------------------------------------

loc_14C2:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_14F3:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 150Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap
					; icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+4Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_154A
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_15A4
; ---------------------------------------------------------------------------
		jmp	short loc_15A4
; ---------------------------------------------------------------------------

loc_154A:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1597
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_1597
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1597
		mov	[ebp+var_E5], 1
		jmp	short loc_159E
; ---------------------------------------------------------------------------

loc_1597:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_159E:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_15A4:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 160Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1670h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1738h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 179Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near
					; CODE XREF: icu_56::MessagePattern::partSubstringMatches(icu_56::MessagePattern::Part const &,icu_56::UnicodeString const &)+3Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1850h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1900h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1954h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+246p
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+38Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1A4E
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1A7F
; ---------------------------------------------------------------------------
		jmp	short loc_1A7F
; ---------------------------------------------------------------------------

loc_1A4E:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_1A7F:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BFCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1D4A
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1D7F
; ---------------------------------------------------------------------------
		jmp	short loc_1D7F
; ---------------------------------------------------------------------------

loc_1D4A:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_1D7F:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EB0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]

loc_2000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2020h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_208B
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_208B
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_208E
; ---------------------------------------------------------------------------

loc_208B:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_208E:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 216Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 222Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2280h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2320h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2374h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+1D7p
					; icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode	&)+9Dp	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2428h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 248Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2548h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_25B3
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_25B3
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_25B6
; ---------------------------------------------------------------------------

loc_25B3:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_25B6:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2624h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2690h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 273Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 278Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2830h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 295Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_29F0
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_29F0:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2A60
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2A60:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2BC0
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2BC0:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2C3E
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2C3E:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CD8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2DDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2EE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi

loc_3000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3014h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near
					; CODE XREF: icu_56::MessagePattern::setParseError(UParseError *,int)+96p
					; icu_56::MessagePattern::setParseError(UParseError *,int)+111p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3068h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3114h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_322F
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_3234
; ---------------------------------------------------------------------------
		jmp	short loc_3234
; ---------------------------------------------------------------------------

loc_322F:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_3234:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 324Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+D4p
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+126p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3294h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near
					; CODE XREF: icu_56::MessagePattern::setParseError(UParseError *,int)+5Dp
					; icu_56::MessagePattern::setParseError(UParseError *,int)+DDp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3318h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3354h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 339Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_33D6
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_33F3
; ---------------------------------------------------------------------------

loc_33D6:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_33F3:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 340Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3444h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 349Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3540h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3614h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 365Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3770h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near
					; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+56p
					; icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+93p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3810h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3860h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near
					; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+6Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 398Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ADCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near
					; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+F7p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p
					; icu_56::MessagePattern::clear(void)+29p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3C08
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_3C10
; ---------------------------------------------------------------------------

loc_3C08:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_3C10:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_3C64
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_3C64
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_3C7A
; ---------------------------------------------------------------------------

loc_3C64:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_3C7A:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3D86
		cmp	[ebp+arg_0], 0
		jnz	short loc_3D86
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_3DA7
; ---------------------------------------------------------------------------
		jmp	short loc_3DA7
; ---------------------------------------------------------------------------

loc_3D86:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3DA5
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_3DA7
; ---------------------------------------------------------------------------
		jmp	short loc_3DA7
; ---------------------------------------------------------------------------

loc_3DA5:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_3DA7:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E0Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MessagePattern::clearPatternAndSetApostropheMode(enum	 UMessagePatternApostropheMode)
		public ?clearPatternAndSetApostropheMode@MessagePattern@icu_56@@QAEXW4UMessagePatternApostropheMode@@@Z
?clearPatternAndSetApostropheMode@MessagePattern@icu_56@@QAEXW4UMessagePatternApostropheMode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?clear@MessagePattern@icu_56@@QAEXXZ ; icu_56::MessagePattern::clear(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?clearPatternAndSetApostropheMode@MessagePattern@icu_56@@QAEXW4UMessagePatternApostropheMode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePattern::operator!=(class icu_56::MessagePattern const &)const
		public ??9MessagePattern@icu_56@@QBECABV01@@Z
??9MessagePattern@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8MessagePattern@icu_56@@QBECABV01@@Z ; icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9MessagePattern@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: enum	UMessagePatternApostropheMode __thiscall icu_56::MessagePattern::getApostropheMode(void)const
		public ?getApostropheMode@MessagePattern@icu_56@@QBE?AW4UMessagePatternApostropheMode@@XZ
?getApostropheMode@MessagePattern@icu_56@@QBE?AW4UMessagePatternApostropheMode@@XZ proc	near
					; CODE XREF: icu_56::MessageImpl::jdkAposMode(icu_56::MessagePattern const &)+21p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getApostropheMode@MessagePattern@icu_56@@QBE?AW4UMessagePatternApostropheMode@@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::UnicodeString *__thiscall icu_56::MessagePattern::getPatternString(icu_56::MessagePattern *__hidden this)
		public ?getPatternString@MessagePattern@icu_56@@QBEABVUnicodeString@2@XZ
?getPatternString@MessagePattern@icu_56@@QBEABVUnicodeString@2@XZ proc near
					; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+21p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 8
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getPatternString@MessagePattern@icu_56@@QBEABVUnicodeString@2@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::hasNamedArguments(icu_56::MessagePattern *__hidden this)
		public ?hasNamedArguments@MessagePattern@icu_56@@QBECXZ
?hasNamedArguments@MessagePattern@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+60h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasNamedArguments@MessagePattern@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::hasNumberedArguments(icu_56::MessagePattern *__hidden this)
		public ?hasNumberedArguments@MessagePattern@icu_56@@QBECXZ
?hasNumberedArguments@MessagePattern@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+61h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasNumberedArguments@MessagePattern@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FB4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::countParts(icu_56::MessagePattern *__hidden this)
		public ?countParts@MessagePattern@icu_56@@QBEHXZ
?countParts@MessagePattern@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+A0p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+50h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?countParts@MessagePattern@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	struct icu_56::MessagePattern::Part *__thiscall	icu_56::MessagePattern::getPart(icu_56::MessagePattern *this, int)
		public ?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z
?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z proc near
					; CODE XREF: icu_56::MessagePattern::getPartType(int)+2Ap
					; icu_56::MessagePattern::getPatternIndex(int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'

loc_3FFC:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 401Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: enum	UMessagePatternPartType	__thiscall icu_56::MessagePattern::getPartType(int)const
		public ?getPartType@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@H@Z
?getPartType@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getPartType@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@H@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4064h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::getPatternIndex(icu_56::MessagePattern	*this, int)
		public ?getPatternIndex@MessagePattern@icu_56@@QBEHH@Z
?getPatternIndex@MessagePattern@icu_56@@QBEHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getPatternIndex@MessagePattern@icu_56@@QBEHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::MessagePattern::getSubstring(class icu_56::MessagePattern::Part const &)const
		public ?getSubstring@MessagePattern@icu_56@@QBE?AVUnicodeString@2@ABVPart@12@@Z
?getSubstring@MessagePattern@icu_56@@QBE?AVUnicodeString@2@ABVPart@12@@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_4]
		movzx	ecx, word ptr [eax+8]
		push	ecx
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	edx, [ebp+var_D4]
		or	edx, 1
		mov	[ebp+var_D4], edx
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?getSubstring@MessagePattern@icu_56@@QBE?AVUnicodeString@2@ABVPart@12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4120h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::partSubstringMatches(icu_56::MessagePattern *this, const struct icu_56::MessagePattern::Part	*, const struct	icu_56::UnicodeString *)
		public ?partSubstringMatches@MessagePattern@icu_56@@QBECABVPart@12@ABVUnicodeString@2@@Z
?partSubstringMatches@MessagePattern@icu_56@@QBECABVPart@12@ABVUnicodeString@2@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0]
		movzx	edx, word ptr [ecx+8]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@@Z ;	icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &)
		movsx	edx, al
		test	edx, edx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?partSubstringMatches@MessagePattern@icu_56@@QBECABVPart@12@ABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4180h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::getLimitPartIndex(icu_56::MessagePattern *this, int)
		public ?getLimitPartIndex@MessagePattern@icu_56@@QBEHH@Z
?getLimitPartIndex@MessagePattern@icu_56@@QBEHH@Z proc near
					; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+EEp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_41C2
		mov	eax, [ebp+arg_0]
		jmp	short loc_41C5
; ---------------------------------------------------------------------------

loc_41C2:				; CODE XREF: icu_56::MessagePattern::getLimitPartIndex(int)+3Bj
		mov	eax, [ebp+var_14]

loc_41C5:				; CODE XREF: icu_56::MessagePattern::getLimitPartIndex(int)+40j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getLimitPartIndex@MessagePattern@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::parseArgNumber(icu_56::MessagePattern *this, int, int)
		public ?parseArgNumber@MessagePattern@icu_56@@AAEHHH@Z
?parseArgNumber@MessagePattern@icu_56@@AAEHHH@Z	proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+C9p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		add	edx, 8
		push	edx		; struct icu_56::UnicodeString *
		call	?parseArgNumber@MessagePattern@icu_56@@CAHABVUnicodeString@2@HH@Z ; icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const &,int,int)
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?parseArgNumber@MessagePattern@icu_56@@AAEHHH@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 422Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MessagePattern::`scalar deleting destructor'(unsigned int)
		public ??_GMessagePattern@icu_56@@UAEPAXI@Z
??_GMessagePattern@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MessagePattern@icu_56@@UAE@XZ ; icu_56::MessagePattern::~MessagePattern(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_426B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_426B:				; CODE XREF: icu_56::MessagePattern::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMessagePattern@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4284h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::MessagePattern::`vector deleting destructor'(unsigned int)
		public ??_EMessagePattern@icu_56@@UAEPAXI@Z
??_EMessagePattern@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::MessagePattern::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_42E5
		push	offset ??1MessagePattern@icu_56@@UAE@XZ	; icu_56::MessagePattern::~MessagePattern(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	64h ; 'd'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_42DD
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_42DD:				; CODE XREF: icu_56::MessagePattern::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_4304
; ---------------------------------------------------------------------------

loc_42E5:				; CODE XREF: icu_56::MessagePattern::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1MessagePattern@icu_56@@UAE@XZ ; icu_56::MessagePattern::~MessagePattern(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_4301
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_4301:				; CODE XREF: icu_56::MessagePattern::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_4304:				; CODE XREF: icu_56::MessagePattern::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EMessagePattern@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 431Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::MessageImpl::jdkAposMode(const struct icu_56::MessagePattern *)
		public ?jdkAposMode@MessageImpl@icu_56@@SACABVMessagePattern@2@@Z
?jdkAposMode@MessageImpl@icu_56@@SACABVMessagePattern@2@@Z proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_0]
		call	?getApostropheMode@MessagePattern@icu_56@@QBE?AW4UMessagePatternApostropheMode@@XZ ; icu_56::MessagePattern::getApostropheMode(void)
		cmp	eax, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?jdkAposMode@MessageImpl@icu_56@@SACABVMessagePattern@2@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 435Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::MessageImpl & __thiscall icu_56::MessageImpl::operator=(class icu_56::MessageImpl const	&)
		public ??4MessageImpl@icu_56@@QAEAAV01@ABV01@@Z
??4MessageImpl@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4MessageImpl@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 438Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::PatternProps & __thiscall icu_56::PatternProps::operator=(class	icu_56::PatternProps const &)
		public ??4PatternProps@icu_56@@QAEAAV01@ABV01@@Z
??4PatternProps@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4PatternProps@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern *this, enum UErrorCode *)
		public ??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z
??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7MessagePattern@icu_56@@6B@ ; const icu_56::MessagePattern::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+54h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+60h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+61h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+62h], 0
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::MessagePattern::init(UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 44B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:000044FCo
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z$1 proc	near
					; DATA XREF: .xdata$x:00004504o
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::MessagePattern::MessagePattern(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44ECh
		dd offset ??_R4MessagePattern@icu_56@@6B@ ; const icu_56::MessagePattern::`RTTI	Complete Object	Locator'
;
; Exported entry
;
		public ??_7MessagePattern@icu_56@@6B@
; const	icu_56::MessagePattern::`vftable'
??_7MessagePattern@icu_56@@6B@ dd offset ??_EMessagePattern@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::MessagePattern::MessagePattern(UErrorCode &)+54o
					; icu_56::MessagePattern::MessagePattern(UMessagePatternApostropheMode,UErrorCode &)+54o ...
					; icu_56::MessagePattern::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 44F8h
__unwindtable$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004510o
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 452Ch
		public ??_R4MessagePattern@icu_56@@6B@
; const	icu_56::MessagePattern::`RTTI Complete Object Locator'
??_R4MessagePattern@icu_56@@6B@	dd 3 dup(0) ; DATA XREF: .rdata:000044ECo
		dd offset ??_R0?AVMessagePattern@icu_56@@@8 ; icu_56::MessagePattern `RTTI Type	Descriptor'
		dd offset ??_R3MessagePattern@icu_56@@8	; icu_56::MessagePattern::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4540h
		public ??_R0?AVMessagePattern@icu_56@@@8
; class	icu_56::MessagePattern `RTTI Type Descriptor'
??_R0?AVMessagePattern@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:00004538o
					; .rdata$r:icu_56::MessagePattern::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avmessagepat	db '.?AVMessagePattern@icu_56@@',0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4564h
		public ??_R3MessagePattern@icu_56@@8
; icu_56::MessagePattern::`RTTI	Class Hierarchy	Descriptor'
??_R3MessagePattern@icu_56@@8 dd 2 dup(0) ; DATA XREF: .rdata$r:0000453Co
					; .rdata$r:0000459Co
		dd 3
		dd offset ??_R2MessagePattern@icu_56@@8	; icu_56::MessagePattern::`RTTI	Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4574h
		public ??_R2MessagePattern@icu_56@@8
; icu_56::MessagePattern::`RTTI	Base Class Array'
??_R2MessagePattern@icu_56@@8 dd offset	??_R1A@?0A@EA@MessagePattern@icu_56@@8
					; DATA XREF: .rdata$r:00004570o
					; icu_56::MessagePattern::`RTTI	Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4584h
		public ??_R1A@?0A@EA@MessagePattern@icu_56@@8
; icu_56::MessagePattern::`RTTI	Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@MessagePattern@icu_56@@8 dd offset ??_R0?AVMessagePattern@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::MessagePattern::`RTTI Base Class Array'o
					; icu_56::MessagePattern `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3MessagePattern@icu_56@@8	; icu_56::MessagePattern::`RTTI	Class Hierarchy	Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 45A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MessagePattern::MessagePattern(enum  UMessagePatternApostropheMode, enum  UErrorCode &)
		public ??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z
??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7MessagePattern@icu_56@@6B@ ; const icu_56::MessagePattern::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+54h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+60h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+61h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+62h], 0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::MessagePattern::init(UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 469Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000046D4o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:000046DCo
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::MessagePattern::MessagePattern(UMessagePatternApostropheMode,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 46D0h
__unwindtable$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000046E8o
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4704h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern *this, const struct icu_56::UnicodeString *, struct UParseError *, enum UErrorCode *)
		public ??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z
??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7MessagePattern@icu_56@@6B@ ; const icu_56::MessagePattern::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+54h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+60h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+61h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+62h], 0
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_14] ; this
		call	?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z ; icu_56::MessagePattern::init(UErrorCode &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_47EF
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14] ; this
		call	?parse@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parse(icu_56::UnicodeString const &,UParseError *,UErrorCode &)

loc_47EF:				; CODE XREF: icu_56::MessagePattern::MessagePattern(icu_56::UnicodeString const	&,UParseError *,UErrorCode &)+D5j
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 481Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00004854o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z$1 proc near
					; DATA XREF: .xdata$x:0000485Co
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::MessagePattern::MessagePattern(icu_56::UnicodeString const	&,UParseError *,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4850h
__unwindtable$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004868o
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z$0
		dd 0
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z$1
__ehfuncinfo$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0MessagePattern@icu_56@@QAE@ABVUnicodeString@1@PAUUParseError@@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4884h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::init(icu_56::MessagePattern *this, enum UErrorCode *)
		public ?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z
?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::MessagePattern(UErrorCode &)+CBp
					; icu_56::MessagePattern::MessagePattern(UMessagePatternApostropheMode,UErrorCode &)+CAp ...

var_F4		= dword	ptr -0F4h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_48E2
		xor	al, al
		jmp	loc_496A
; ---------------------------------------------------------------------------

loc_48E2:				; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+55j
		push	20Ch		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_E0], 0
		jz	short loc_4918
		mov	ecx, [ebp+var_E0] ; this
		call	??0MessagePatternPartsList@icu_56@@QAE@XZ ; icu_56::MessagePatternPartsList::MessagePatternPartsList(void)
		mov	[ebp+var_F4], eax
		jmp	short loc_4922
; ---------------------------------------------------------------------------

loc_4918:				; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+7Fj
		mov	[ebp+var_F4], 0

loc_4922:				; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+92j
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_EC]
		mov	[ecx+48h], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+48h], 0
		jnz	short loc_4957
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_496A
; ---------------------------------------------------------------------------

loc_4957:				; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+C4j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+4Ch], eax
		mov	al, 1

loc_496A:				; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+59j
					; icu_56::MessagePattern::init(UErrorCode &)+D1j
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 498Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000049BCo
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z	proc near
					; DATA XREF: icu_56::MessagePattern::init(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0F8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z	endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 49B8h
__unwindtable$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000049C8o
		dd offset __unwindfunclet$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z$0
__ehfuncinfo$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?init@MessagePattern@icu_56@@AAECAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 49E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+48p
					; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode	&)+48p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A10h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePatternPartsList::MessagePatternPartsList(icu_56::MessagePatternPartsList *__hidden this)
		public ??0MessagePatternPartsList@icu_56@@QAE@XZ
??0MessagePatternPartsList@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+87p
					; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode	&)+BCp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??0?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ ; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::MessagePatternList<icu_56::MessagePattern::Part,32>(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MessagePatternPartsList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern *this, const struct icu_56::MessagePattern *)
		public ??0MessagePattern@icu_56@@QAE@ABV01@@Z
??0MessagePattern@icu_56@@QAE@ABV01@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0MessagePattern@icu_56@@QAE@ABV01@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7MessagePattern@icu_56@@6B@ ; const icu_56::MessagePattern::`vftable'
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+arg_0]
		add	eax, 8
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	byte ptr [ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+54h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+60h]
		mov	[eax+60h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+61h]
		mov	[eax+61h], dl
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+62h]
		mov	[eax+62h], dl
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::MessagePattern	*
		mov	ecx, [ebp+var_14] ; this
		call	?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4B5A
		mov	ecx, [ebp+var_14] ; this
		call	?clear@MessagePattern@icu_56@@QAEXXZ ; icu_56::MessagePattern::clear(void)

loc_4B5A:				; CODE XREF: icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern const &)+FCj
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN9
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0MessagePattern@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN9		dd 1			; DATA XREF: icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern const &)+114o
		dd offset $LN8
$LN8		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00004B9Co
		dd offset $LN6		; "errorCode"
$LN6		db 'errorCode',0        ; DATA XREF: .text:00004BA8o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4BB8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABV01@@Z$0 proc near
					; DATA XREF: .xdata$x:00004BF0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABV01@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABV01@@Z$1 proc near
					; DATA XREF: .xdata$x:00004BF8o
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??0MessagePattern@icu_56@@QAE@ABV01@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0MessagePattern@icu_56@@QAE@ABV01@@Z proc	near
					; DATA XREF: icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern const &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0E8h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0MessagePattern@icu_56@@QAE@ABV01@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0MessagePattern@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4BECh
__unwindtable$??0MessagePattern@icu_56@@QAE@ABV01@@Z dd	0FFFFFFFFh
					; DATA XREF: .xdata$x:00004C04o
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@ABV01@@Z$0
		align 8
		dd offset __unwindfunclet$??0MessagePattern@icu_56@@QAE@ABV01@@Z$1
__ehfuncinfo$??0MessagePattern@icu_56@@QAE@ABV01@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$??0MessagePattern@icu_56@@QAE@ABV01@@Z+14o
		dd offset __unwindtable$??0MessagePattern@icu_56@@QAE@ABV01@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4C20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::MessagePattern::operator=(struct icu_56::MessagePattern	*)
		public ??4MessagePattern@icu_56@@QAEAAV01@ABV01@@Z
??4MessagePattern@icu_56@@QAEAAV01@ABV01@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_4C50
		mov	eax, [ebp+var_8]
		jmp	short loc_4CBB
; ---------------------------------------------------------------------------

loc_4C50:				; CODE XREF: icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+29j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	eax, [ebp+arg_0]
		add	eax, 8
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+60h]
		mov	[eax+60h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+61h]
		mov	[eax+61h], dl
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	dl, [ecx+62h]
		mov	[eax+62h], dl
		mov	[ebp+var_14], 0
		lea	eax, [ebp+var_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::MessagePattern	*
		mov	ecx, [ebp+var_8] ; this
		call	?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_4CB8
		mov	ecx, [ebp+var_8] ; this
		call	?clear@MessagePattern@icu_56@@QAEXXZ ; icu_56::MessagePattern::clear(void)

loc_4CB8:				; CODE XREF: icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+8Ej
		mov	eax, [ebp+var_8]

loc_4CBB:				; CODE XREF: icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+2Ej
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN7
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4MessagePattern@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN7		dd 1			; DATA XREF: icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+9Fo
		dd offset $LN6_0
$LN6_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:00004CE8o
		dd offset $LN5		; "errorCode"
$LN5		db 'errorCode',0        ; DATA XREF: .text:00004CF4o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::copyStorage(icu_56::MessagePattern *this, const struct icu_56::MessagePattern *, enum UErrorCode *)
		public ?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z
?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern const &)+F2p
					; icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+84p

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4D62
		xor	al, al
		jmp	loc_4F71
; ---------------------------------------------------------------------------

loc_4D62:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+55j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+48h], 0
		jnz	loc_4E20
		push	20Ch		; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_F8], 0
		jz	short loc_4DCD
		mov	ecx, [ebp+var_F8] ; this
		call	??0MessagePatternPartsList@icu_56@@QAE@XZ ; icu_56::MessagePatternPartsList::MessagePatternPartsList(void)
		mov	[ebp+var_10C], eax
		jmp	short loc_4DD7
; ---------------------------------------------------------------------------

loc_4DCD:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+B4j
		mov	[ebp+var_10C], 0

loc_4DD7:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+C7j
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_104], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_104]
		mov	[ecx+48h], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+48h], 0
		jnz	short loc_4E0F
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	loc_4F71
; ---------------------------------------------------------------------------

loc_4E0F:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+F9j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+4Ch], eax

loc_4E20:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+8Dj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+50h], 0
		jle	short loc_4E7F
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+48h]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+48h]
		call	?copyFrom@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z	; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4E62
		xor	al, al
		jmp	loc_4F71
; ---------------------------------------------------------------------------

loc_4E62:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+155j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+4Ch], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+50h], edx

loc_4E7F:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+123j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+5Ch], 0
		jle	loc_4F6F
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+54h], 0
		jnz	loc_4F1C
		push	50h ; 'P'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_E0], eax
		mov	[ebp+var_4], 1
		cmp	[ebp+var_E0], 0
		jz	short loc_4ECC
		mov	ecx, [ebp+var_E0] ; this
		call	??0MessagePatternDoubleList@icu_56@@QAE@XZ ; icu_56::MessagePatternDoubleList::MessagePatternDoubleList(void)
		mov	[ebp+var_10C], eax
		jmp	short loc_4ED6
; ---------------------------------------------------------------------------

loc_4ECC:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+1B3j
		mov	[ebp+var_10C], 0

loc_4ED6:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+1C6j
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_EC]
		mov	[ecx+54h], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_4F0B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_4F71
; ---------------------------------------------------------------------------

loc_4F0B:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+1F8j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		call	?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ ; icu_56::MaybeStackArray<double,8>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+58h], eax

loc_4F1C:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+18Fj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+5Ch]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+54h]
		push	ecx
		mov	edx, [ebp+var_14]
		mov	ecx, [edx+54h]
		call	?copyFrom@?$MessagePatternList@N$07@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z ; icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8>	const &,int,UErrorCode &)
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4F52
		xor	al, al
		jmp	short loc_4F71
; ---------------------------------------------------------------------------

loc_4F52:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+248j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		call	?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ ; icu_56::MaybeStackArray<double,8>::getAlias(void)
		mov	ecx, [ebp+var_14]
		mov	[ecx+58h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+5Ch]
		mov	[eax+5Ch], edx

loc_4F6F:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+182j
		mov	al, 1

loc_4F71:				; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+59j
					; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode	&)+106j ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 4F94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z$0 proc	near
					; DATA XREF: .xdata$x:00004FD4o
		mov	eax, [ebp-0F8h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z$1 proc	near
					; DATA XREF: .xdata$x:00004FDCo
		mov	eax, [ebp-0E0h]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 4FD0h
__unwindtable$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00004FE8o
		dd offset __unwindfunclet$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z$0
		dd 0FFFFFFFFh
		dd offset __unwindfunclet$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z$1
__ehfuncinfo$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z dd 19930522h, 2
					; DATA XREF: __ehhandler$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?copyStorage@MessagePattern@icu_56@@AAECABV12@AAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5004h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePatternDoubleList::MessagePatternDoubleList(icu_56::MessagePatternDoubleList	*__hidden this)
		public ??0MessagePatternDoubleList@icu_56@@QAE@XZ
??0MessagePatternDoubleList@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+1BBp
					; icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode &)+94p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??0?$MessagePatternList@N$07@icu_56@@QAE@XZ ; icu_56::MessagePatternList<double,8>::MessagePatternList<double,8>(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0MessagePatternDoubleList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5048h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePattern::~MessagePattern(icu_56::MessagePattern *__hidden this)
		public ??1MessagePattern@icu_56@@UAE@XZ
??1MessagePattern@icu_56@@UAE@XZ proc near
					; CODE XREF: icu_56::MessagePattern::`scalar deleting destructor'(uint)+26p
					; icu_56::MessagePattern::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_10C		= dword	ptr -10Ch
var_104		= dword	ptr -104h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1MessagePattern@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_10C]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7MessagePattern@icu_56@@6B@ ; const icu_56::MessagePattern::`vftable'
		mov	[ebp+var_4], 1
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+48h]
		mov	[ebp+var_F8], ecx
		mov	edx, [ebp+var_F8]
		mov	[ebp+var_104], edx
		cmp	[ebp+var_104], 0
		jz	short loc_50D0
		push	1
		mov	ecx, [ebp+var_104]
		call	??_GMessagePatternPartsList@icu_56@@QAEPAXI@Z ;	icu_56::MessagePatternPartsList::`scalar deleting destructor'(uint)
		mov	[ebp+var_10C], eax
		jmp	short loc_50DA
; ---------------------------------------------------------------------------

loc_50D0:				; CODE XREF: icu_56::MessagePattern::~MessagePattern(void)+71j
		mov	[ebp+var_10C], 0

loc_50DA:				; CODE XREF: icu_56::MessagePattern::~MessagePattern(void)+86j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+var_E0]
		mov	[ebp+var_EC], edx
		cmp	[ebp+var_EC], 0
		jz	short loc_5110
		push	1
		mov	ecx, [ebp+var_EC]
		call	??_GMessagePatternDoubleList@icu_56@@QAEPAXI@Z ; icu_56::MessagePatternDoubleList::`scalar deleting destructor'(uint)
		mov	[ebp+var_10C], eax
		jmp	short loc_511A
; ---------------------------------------------------------------------------

loc_5110:				; CODE XREF: icu_56::MessagePattern::~MessagePattern(void)+B1j
		mov	[ebp+var_10C], 0

loc_511A:				; CODE XREF: icu_56::MessagePattern::~MessagePattern(void)+C6j
		mov	byte ptr [ebp+var_4], 0
		mov	ecx, [ebp+var_14]
		add	ecx, 8		; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1MessagePattern@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5158h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1MessagePattern@icu_56@@UAE@XZ$0 proc	near ; DATA XREF: .xdata$x:00005190o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??1MessagePattern@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1MessagePattern@icu_56@@UAE@XZ$1 proc	near ; DATA XREF: .xdata$x:00005198o
		mov	ecx, [ebp-14h]
		add	ecx, 8		; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$??1MessagePattern@icu_56@@UAE@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1MessagePattern@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::MessagePattern::~MessagePattern(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-110h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1MessagePattern@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1MessagePattern@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 518Ch
__unwindtable$??1MessagePattern@icu_56@@UAE@XZ dd 0FFFFFFFFh ; DATA XREF: .xdata$x:000051A4o
		dd offset __unwindfunclet$??1MessagePattern@icu_56@@UAE@XZ$0
		align 8
		dd offset __unwindfunclet$??1MessagePattern@icu_56@@UAE@XZ$1
__ehfuncinfo$??1MessagePattern@icu_56@@UAE@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$??1MessagePattern@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1MessagePattern@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::MessagePatternPartsList::`scalar deleting destructor'(unsigned int)
		public ??_GMessagePatternPartsList@icu_56@@QAEPAXI@Z
??_GMessagePatternPartsList@icu_56@@QAEPAXI@Z proc near
					; CODE XREF: icu_56::MessagePattern::~MessagePattern(void)+7Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MessagePatternPartsList@icu_56@@QAE@XZ ; icu_56::MessagePatternPartsList::~MessagePatternPartsList(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_51FF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_51FF:				; CODE XREF: icu_56::MessagePatternPartsList::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMessagePatternPartsList@icu_56@@QAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5218h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::MessagePatternDoubleList::`scalar deleting destructor'(unsigned int)
		public ??_GMessagePatternDoubleList@icu_56@@QAEPAXI@Z
??_GMessagePatternDoubleList@icu_56@@QAEPAXI@Z proc near
					; CODE XREF: icu_56::MessagePattern::~MessagePattern(void)+BBp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1MessagePatternDoubleList@icu_56@@QAE@XZ ; icu_56::MessagePatternDoubleList::~MessagePatternDoubleList(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_5257
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_5257:				; CODE XREF: icu_56::MessagePatternDoubleList::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GMessagePatternDoubleList@icu_56@@QAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5270h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePatternPartsList::~MessagePatternPartsList(icu_56::MessagePatternPartsList *__hidden	this)
		public ??1MessagePatternPartsList@icu_56@@QAE@XZ
??1MessagePatternPartsList@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternPartsList::`scalar deleting destructor'(uint)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ ; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::~MessagePatternList<icu_56::MessagePattern::Part,32>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1MessagePatternPartsList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MessagePatternList<class icu_56::MessagePattern::Part, 32>::~MessagePatternList<class icu_56::MessagePattern::Part, 32>(void)
		public ??1?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ
??1?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternPartsList::~MessagePatternPartsList(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::~MaybeStackArray<icu_56::MessagePattern::Part,32>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePatternDoubleList::~MessagePatternDoubleList(icu_56::MessagePatternDoubleList *__hidden this)
		public ??1MessagePatternDoubleList@icu_56@@QAE@XZ
??1MessagePatternDoubleList@icu_56@@QAE@XZ proc	near
					; CODE XREF: icu_56::MessagePatternDoubleList::`scalar deleting	destructor'(uint)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$MessagePatternList@N$07@icu_56@@QAE@XZ ; icu_56::MessagePatternList<double,8>::~MessagePatternList<double,8>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1MessagePatternDoubleList@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5330h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MessagePatternList<double,	8>::~MessagePatternList<double,	8>(void)
		public ??1?$MessagePatternList@N$07@icu_56@@QAE@XZ
??1?$MessagePatternList@N$07@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternDoubleList::~MessagePatternDoubleList(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??1?$MaybeStackArray@N$07@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<double,8>::~MaybeStackArray<double,8>(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MessagePatternList@N$07@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5370h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::MessagePattern	*__thiscall icu_56::MessagePattern::parse(icu_56::MessagePattern *this,	const struct icu_56::UnicodeString *, struct UParseError *, enum UErrorCode *)
		public ?parse@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z
?parse@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::MessagePattern(icu_56::UnicodeString const	&,UParseError *,UErrorCode &)+E6p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		push	0
		push	0
		push	0
		mov	ecx, [ebp+var_8]
		call	?parseMessage@MessagePattern@icu_56@@AAEHHHHW4UMessagePatternArgType@@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)
		mov	ecx, [ebp+var_8] ; this
		call	?postParse@MessagePattern@icu_56@@AAEXXZ ; icu_56::MessagePattern::postParse(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parse@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::MessagePattern	*__thiscall icu_56::MessagePattern::parseChoiceStyle(icu_56::MessagePattern *this, const struct	icu_56::UnicodeString *, struct	UParseError *, enum UErrorCode *)
		public ?parseChoiceStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z
?parseChoiceStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		push	0		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseChoiceStyle@MessagePattern@icu_56@@AAEHHHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)
		mov	ecx, [ebp+var_8] ; this
		call	?postParse@MessagePattern@icu_56@@AAEXXZ ; icu_56::MessagePattern::postParse(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parseChoiceStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 544Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::MessagePattern	*__thiscall icu_56::MessagePattern::parsePluralStyle(icu_56::MessagePattern *this, const struct	icu_56::UnicodeString *, struct	UParseError *, enum UErrorCode *)
		public ?parsePluralStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z
?parsePluralStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		push	0
		push	3
		mov	ecx, [ebp+var_8]
		call	?parsePluralOrSelectStyle@MessagePattern@icu_56@@AAEHW4UMessagePatternArgType@@HHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)
		mov	ecx, [ebp+var_8] ; this
		call	?postParse@MessagePattern@icu_56@@AAEXXZ ; icu_56::MessagePattern::postParse(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parsePluralStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::MessagePattern	*__thiscall icu_56::MessagePattern::parseSelectStyle(icu_56::MessagePattern *this, const struct	icu_56::UnicodeString *, struct	UParseError *, enum UErrorCode *)
		public ?parseSelectStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z
?parseSelectStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		push	0
		push	0
		push	4
		mov	ecx, [ebp+var_8]
		call	?parsePluralOrSelectStyle@MessagePattern@icu_56@@AAEHW4UMessagePatternArgType@@HHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)
		mov	ecx, [ebp+var_8] ; this
		call	?postParse@MessagePattern@icu_56@@AAEXXZ ; icu_56::MessagePattern::postParse(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parseSelectStyle@MessagePattern@icu_56@@QAEAAV12@ABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 552Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::MessagePattern::clear(icu_56::MessagePattern *__hidden this)
		public ?clear@MessagePattern@icu_56@@QAEXXZ
?clear@MessagePattern@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::MessagePattern::clearPatternAndSetApostropheMode(UMessagePatternApostropheMode)+26p
					; icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern	const &)+101p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+61h], 0
		mov	ecx, [ebp+var_8]
		mov	byte ptr [ecx+60h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+62h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+5Ch], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?clear@MessagePattern@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5598h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePattern::operator==(class icu_56::MessagePattern const &)const
		public ??8MessagePattern@icu_56@@QBECABV01@@Z
??8MessagePattern@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::MessagePattern::operator!=(icu_56::MessagePattern const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_55C7
		mov	al, 1
		jmp	short loc_563B
; ---------------------------------------------------------------------------

loc_55C7:				; CODE XREF: icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+29j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_562E
		mov	eax, [ebp+arg_0]
		add	eax, 8
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_562E
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+50h]
		cmp	ecx, [eax+50h]
		jnz	short loc_562E
		mov	edx, [ebp+var_8]
		cmp	dword ptr [edx+50h], 0
		jz	short loc_5625
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+48h]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+48h]
		call	?equals@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBECABV12@H@Z ;	icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>	const &,int)
		movsx	edx, al
		test	edx, edx
		jz	short loc_562E

loc_5625:				; CODE XREF: icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+6Bj
		mov	[ebp+var_CD], 1
		jmp	short loc_5635
; ---------------------------------------------------------------------------

loc_562E:				; CODE XREF: icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+3Bj
					; icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+54j ...
		mov	[ebp+var_CD], 0

loc_5635:				; CODE XREF: icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+94j
		mov	al, [ebp+var_CD]

loc_563B:				; CODE XREF: icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8MessagePattern@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5654h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::hashCode(icu_56::MessagePattern *__hidden this)
		public ?hashCode@MessagePattern@icu_56@@QBEHXZ
?hashCode@MessagePattern@icu_56@@QBEHXZ	proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	esi, [eax+4]
		imul	esi, 25h
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?hashCode@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::hashCode(void)
		add	esi, eax
		imul	esi, 25h
		mov	ecx, [ebp+var_8]
		add	esi, [ecx+50h]
		mov	[ebp+var_14], esi
		mov	[ebp+var_20], 0
		jmp	short loc_56AB
; ---------------------------------------------------------------------------

loc_56A2:				; CODE XREF: icu_56::MessagePattern::hashCode(void)+7Ej
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_56AB:				; CODE XREF: icu_56::MessagePattern::hashCode(void)+4Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+50h]
		jge	short loc_56D4
		mov	esi, [ebp+var_14]
		imul	esi, 25h
		mov	ecx, [ebp+var_20]
		shl	ecx, 4
		mov	eax, [ebp+var_8]
		add	ecx, [eax+4Ch]	; this
		call	?hashCode@Part@MessagePattern@icu_56@@QBEHXZ ; icu_56::MessagePattern::Part::hashCode(void)
		add	esi, eax
		mov	[ebp+var_14], esi
		jmp	short loc_56A2
; ---------------------------------------------------------------------------

loc_56D4:				; CODE XREF: icu_56::MessagePattern::hashCode(void)+60j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@MessagePattern@icu_56@@QBEHXZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 56ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::Part::hashCode(icu_56::MessagePattern::Part *__hidden this)
		public ?hashCode@Part@MessagePattern@icu_56@@QBEHXZ
?hashCode@Part@MessagePattern@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::MessagePattern::hashCode(void)+74p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		imul	eax, 25h
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		imul	eax, 25h
		mov	edx, [ebp+var_8]
		movzx	ecx, word ptr [edx+8]
		add	eax, ecx
		imul	eax, 25h
		mov	edx, [ebp+var_8]
		movsx	ecx, word ptr [edx+0Ah]
		add	eax, ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@Part@MessagePattern@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 573Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::MessagePattern::validateArgumentName(const struct	icu_56::UnicodeString *)
		public ?validateArgumentName@MessagePattern@icu_56@@SAHABVUnicodeString@2@@Z
?validateArgumentName@MessagePattern@icu_56@@SAHABVUnicodeString@2@@Z proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		push	eax		; wchar_t *
		call	?isIdentifier@PatternProps@icu_56@@SACPB_WH@Z ;	icu_56::PatternProps::isIdentifier(wchar_t const *,int)
		add	esp, 8
		movsx	eax, al
		test	eax, eax
		jnz	short loc_5782
		mov	eax, 0FFFFFFFEh
		jmp	short loc_5799
; ---------------------------------------------------------------------------

loc_5782:				; CODE XREF: icu_56::MessagePattern::validateArgumentName(icu_56::UnicodeString	const &)+3Dj
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		call	?parseArgNumber@MessagePattern@icu_56@@CAHABVUnicodeString@2@HH@Z ; icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const &,int,int)
		add	esp, 0Ch

loc_5799:				; CODE XREF: icu_56::MessagePattern::validateArgumentName(icu_56::UnicodeString	const &)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?validateArgumentName@MessagePattern@icu_56@@SAHABVUnicodeString@2@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::MessagePattern::autoQuoteApostropheDeep(void)const
		public ?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ
?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ proc near

var_154		= byte ptr -154h
var_150		= dword	ptr -150h
var_84		= dword	ptr -84h
var_78		= dword	ptr -78h
var_6C		= dword	ptr -6Ch
var_60		= byte ptr -60h
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 148h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_154]
		mov	ecx, 52h ; 'R'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_10], eax
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_18], ecx
		mov	[ebp+var_150], 0
		mov	eax, [ebp+var_18]
		movsx	ecx, byte ptr [eax+62h]
		test	ecx, ecx
		jnz	short loc_5837
		mov	eax, [ebp+var_18]
		add	eax, 8
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_150]
		or	ecx, 1
		mov	[ebp+var_150], ecx
		mov	eax, [ebp+arg_0]
		jmp	loc_58D8
; ---------------------------------------------------------------------------

loc_5837:				; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+58j
		mov	eax, [ebp+var_18]
		add	eax, 8
		push	eax		; struct icu_56::UnicodeString *
		lea	ecx, [ebp+var_60] ; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	[ebp+var_4], 1
		mov	ecx, [ebp+var_18] ; this
		call	?countParts@MessagePattern@icu_56@@QBEHXZ ; icu_56::MessagePattern::countParts(void)
		mov	[ebp+var_6C], eax
		mov	eax, [ebp+var_6C]
		mov	[ebp+var_78], eax

loc_585E:				; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void):loc_58ACj
		cmp	[ebp+var_78], 0
		jle	short loc_58AE
		mov	eax, [ebp+var_78]
		sub	eax, 1
		mov	[ebp+var_78], eax
		mov	ecx, [ebp+var_78]
		push	ecx		; int
		mov	ecx, [ebp+var_18] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	[ebp+var_84], eax
		mov	ecx, [ebp+var_84]
		call	?getType@Part@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@XZ	; icu_56::MessagePattern::Part::getType(void)
		cmp	eax, 3
		jnz	short loc_58AC
		mov	eax, [ebp+var_84]
		movzx	ecx, word ptr [eax+0Ah]
		push	ecx		; wchar_t
		mov	edx, [ebp+var_84]
		mov	eax, [edx+4]
		push	eax		; int
		lea	ecx, [ebp+var_60] ; this
		call	?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z ; icu_56::UnicodeString::insert(int,wchar_t)

loc_58AC:				; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+DDj
		jmp	short loc_585E
; ---------------------------------------------------------------------------

loc_58AE:				; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+B2j
		lea	eax, [ebp+var_60]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??0UnicodeString@icu_56@@QAE@$$QAV01@@Z	; icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString &&)
		mov	ecx, [ebp+var_150]
		or	ecx, 1
		mov	[ebp+var_150], ecx
		mov	byte ptr [ebp+var_4], 0
		lea	ecx, [ebp+var_60] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]

loc_58D8:				; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+82j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_10]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 154h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
$LN13		dd 1			; DATA XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+12Co
		dd offset $LN12
$LN12		dd 0FFFFFFA0h, 40h	; DATA XREF: .text:00005918o
		dd offset $LN10		; "modified"
$LN10		db 'modified',0         ; DATA XREF: .text:00005924o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 5934h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$0 proc	near
					; DATA XREF: .xdata$x:00005988o
		mov	eax, [ebp-150h]
		and	eax, 1
		jz	$LN8_0
		and	dword ptr [ebp-150h], 0FFFFFFFEh
		mov	ecx, [ebp+8]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
; ---------------------------------------------------------------------------

$LN8_0:					; CODE XREF: __unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$0+9j
		retn
__unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$1 proc	near
					; DATA XREF: .xdata$x:00005990o
		lea	ecx, [ebp-60h]	; this
		jmp	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
__unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$1 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ proc near
					; DATA XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-158h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	ecx, [edx-4]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ
		jmp	___CxxFrameHandler3
__ehhandler$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 5984h
__unwindtable$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:0000599Co
		dd offset __unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$0
		align 10h
		dd offset __unwindfunclet$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ$1
__ehfuncinfo$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ dd 19930522h, 2
					; DATA XREF: __ehhandler$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ+1Eo
		dd offset __unwindtable$?autoQuoteApostropheDeep@MessagePattern@icu_56@@QBE?AVUnicodeString@2@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: enum	UMessagePatternPartType	__thiscall icu_56::MessagePattern::Part::getType(void)const
		public ?getType@Part@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@XZ
?getType@Part@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@XZ	proc near
					; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+D5p
					; icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern	const &,int,icu_56::UnicodeString &)+60p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getType@Part@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern *this, const	struct icu_56::MessagePattern::Part *)
		public ?getNumericValue@MessagePattern@icu_56@@QBENABVPart@12@@Z
?getNumericValue@MessagePattern@icu_56@@QBENABVPart@12@@Z proc near
					; CODE XREF: icu_56::MessagePattern::getPluralOffset(int)+4Ep

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0Ch
		jnz	short loc_5A30
		mov	eax, [ebp+arg_0]
		movsx	ecx, word ptr [eax+0Ah]
		mov	[ebp+var_DC], ecx
		fild	[ebp+var_DC]
		jmp	short loc_5A50
; ---------------------------------------------------------------------------
		jmp	short loc_5A50
; ---------------------------------------------------------------------------

loc_5A30:				; CODE XREF: icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern::Part const	&)+2Fj
		cmp	[ebp+var_14], 0Dh
		jnz	short loc_5A4A
		mov	eax, [ebp+arg_0]
		movsx	ecx, word ptr [eax+0Ah]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+58h]
		fld	qword ptr [eax+ecx*8]
		jmp	short loc_5A50
; ---------------------------------------------------------------------------
		jmp	short loc_5A50
; ---------------------------------------------------------------------------

loc_5A4A:				; CODE XREF: icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern::Part const	&)+4Cj
		fld	ds:__real@c19d6f3454000000

loc_5A50:				; CODE XREF: icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern::Part const	&)+44j
					; icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern::Part const &)+46j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?getNumericValue@MessagePattern@icu_56@@QBENABVPart@12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5A5Ch
		public __real@c19d6f3454000000
__real@c19d6f3454000000	dq -1.23456789e8
					; DATA XREF: icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern::Part const	&):loc_5A4Ar
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5A64h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; double __thiscall icu_56::MessagePattern::getPluralOffset(icu_56::MessagePattern *this, int)
		public ?getPluralOffset@MessagePattern@icu_56@@QBENH@Z
?getPluralOffset@MessagePattern@icu_56@@QBENH@Z	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [eax]
		push	ecx
		call	?hasNumericValue@Part@MessagePattern@icu_56@@SACW4UMessagePatternPartType@@@Z ;	icu_56::MessagePattern::Part::hasNumericValue(UMessagePatternPartType)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5ABB
		mov	eax, [ebp+var_14]
		push	eax		; struct icu_56::MessagePattern::Part *
		mov	ecx, [ebp+var_8] ; this
		call	?getNumericValue@MessagePattern@icu_56@@QBENABVPart@12@@Z ; icu_56::MessagePattern::getNumericValue(icu_56::MessagePattern::Part const &)
		jmp	short loc_5ABD
; ---------------------------------------------------------------------------
		jmp	short loc_5ABD
; ---------------------------------------------------------------------------

loc_5ABB:				; CODE XREF: icu_56::MessagePattern::getPluralOffset(int)+45j
		fldz

loc_5ABD:				; CODE XREF: icu_56::MessagePattern::getPluralOffset(int)+53j
					; icu_56::MessagePattern::getPluralOffset(int)+55j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?getPluralOffset@MessagePattern@icu_56@@QBENH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 5AD4h
		public __real@0000000000000000
__real@0000000000000000	dd 2 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5ADCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: static signed	char __cdecl icu_56::MessagePattern::Part::hasNumericValue(enum	 UMessagePatternPartType)
		public ?hasNumericValue@Part@MessagePattern@icu_56@@SACW4UMessagePatternPartType@@@Z
?hasNumericValue@Part@MessagePattern@icu_56@@SACW4UMessagePatternPartType@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::getPluralOffset(int)+38p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0Ch
		jz	short loc_5B0F
		cmp	[ebp+arg_0], 0Dh
		jz	short loc_5B0F
		mov	[ebp+var_C1], 0
		jmp	short loc_5B16
; ---------------------------------------------------------------------------

loc_5B0F:				; CODE XREF: icu_56::MessagePattern::Part::hasNumericValue(UMessagePatternPartType)+22j
					; icu_56::MessagePattern::Part::hasNumericValue(UMessagePatternPartType)+28j
		mov	[ebp+var_C1], 1

loc_5B16:				; CODE XREF: icu_56::MessagePattern::Part::hasNumericValue(UMessagePatternPartType)+31j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasNumericValue@Part@MessagePattern@icu_56@@SACW4UMessagePatternPartType@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePattern::Part::operator==(class	icu_56::MessagePattern::Part const &)const
		public ??8Part@MessagePattern@icu_56@@QBECABV012@@Z
??8Part@MessagePattern@icu_56@@QBECABV012@@Z proc near
					; CODE XREF: icu_56::MessagePattern::Part::operator!=(icu_56::MessagePattern::Part const &)+2Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_0]
		jnz	short loc_5B53
		mov	al, 1
		jmp	short loc_5BB5
; ---------------------------------------------------------------------------

loc_5B53:				; CODE XREF: icu_56::MessagePattern::Part::operator==(icu_56::MessagePattern::Part const &)+29j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_5BA8
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jnz	short loc_5BA8
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax+8]
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [edx+8]
		cmp	ecx, eax
		jnz	short loc_5BA8
		mov	ecx, [ebp+var_8]
		movsx	edx, word ptr [ecx+0Ah]
		mov	eax, [ebp+arg_0]
		movsx	ecx, word ptr [eax+0Ah]
		cmp	edx, ecx
		jnz	short loc_5BA8
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		mov	ecx, [edx+0Ch]
		cmp	ecx, [eax+0Ch]
		jnz	short loc_5BA8
		mov	[ebp+var_CD], 1
		jmp	short loc_5BAF
; ---------------------------------------------------------------------------

loc_5BA8:				; CODE XREF: icu_56::MessagePattern::Part::operator==(icu_56::MessagePattern::Part const &)+39j
					; icu_56::MessagePattern::Part::operator==(icu_56::MessagePattern::Part	const &)+47j ...
		mov	[ebp+var_CD], 0

loc_5BAF:				; CODE XREF: icu_56::MessagePattern::Part::operator==(icu_56::MessagePattern::Part const &)+82j
		mov	al, [ebp+var_CD]

loc_5BB5:				; CODE XREF: icu_56::MessagePattern::Part::operator==(icu_56::MessagePattern::Part const &)+2Dj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??8Part@MessagePattern@icu_56@@QBECABV012@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5BC0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::MessagePattern::preParse(icu_56::MessagePattern *this, const struct icu_56::UnicodeString *, struct UParseError *, enum UErrorCode *)
		public ?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z
?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::MessagePattern::parse(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+32p
					; icu_56::MessagePattern::parseChoiceStyle(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+32p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5BFA
		jmp	short loc_5C5D
; ---------------------------------------------------------------------------

loc_5BFA:				; CODE XREF: icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)+36j
		cmp	[ebp+arg_4], 0
		jz	short loc_5C25
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax+4], 0
		xor	eax, eax
		mov	ecx, [ebp+arg_4]
		mov	[ecx+8], ax
		xor	eax, eax
		mov	ecx, [ebp+arg_4]
		mov	[ecx+28h], ax

loc_5C25:				; CODE XREF: icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)+3Ej
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UnicodeString::operator=(icu_56::UnicodeString const &)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+61h], 0
		mov	ecx, [ebp+var_8]
		mov	byte ptr [ecx+60h], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+62h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+50h], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+5Ch], 0

loc_5C5D:				; CODE XREF: icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?preParse@MessagePattern@icu_56@@AAEXABVUnicodeString@2@PAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::MessagePattern::postParse(icu_56::MessagePattern *__hidden this)
		public ?postParse@MessagePattern@icu_56@@AAEXXZ
?postParse@MessagePattern@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MessagePattern::parse(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+52p
					; icu_56::MessagePattern::parseChoiceStyle(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+4Ep ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+48h], 0
		jz	short loc_5CB1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4Ch], eax

loc_5CB1:				; CODE XREF: icu_56::MessagePattern::postParse(void)+2Aj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+54h], 0
		jz	short loc_5CCB
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+54h]
		call	?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ ; icu_56::MaybeStackArray<double,8>::getAlias(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+58h], eax

loc_5CCB:				; CODE XREF: icu_56::MessagePattern::postParse(void)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?postParse@MessagePattern@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5CE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: int __thiscall icu_56::MessagePattern::parseMessage(int, int, int, enum  UMessagePatternArgType, struct UParseError *, enum	UErrorCode &)
		public ?parseMessage@MessagePattern@icu_56@@AAEHHHHW4UMessagePatternArgType@@PAUUParseError@@AAW4UErrorCode@@@Z
?parseMessage@MessagePattern@icu_56@@AAEHHHHW4UMessagePatternArgType@@PAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parse(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+4Ap
					; icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+200p ...

var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5D1F
		xor	eax, eax
		jmp	loc_60C4
; ---------------------------------------------------------------------------

loc_5D1F:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+36j
		cmp	[ebp+arg_8], 7FFFh
		jle	short loc_5D38
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_60C4
; ---------------------------------------------------------------------------

loc_5D38:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+46j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+arg_4]
		mov	[ebp+arg_0], eax

loc_5D64:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &):loc_6068j
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5D80
		xor	eax, eax
		jmp	loc_60C4
; ---------------------------------------------------------------------------

loc_5D80:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+97j
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jl	short loc_5D95
		jmp	loc_606D
; ---------------------------------------------------------------------------

loc_5D95:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+AEj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_F4]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_20]
		cmp	eax, 27h ; '''
		jnz	loc_5F85
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnz	short loc_5DFC
		mov	eax, [ebp+arg_14]
		push	eax
		push	27h ; '''
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	3
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+62h], 1
		jmp	loc_5F80
; ---------------------------------------------------------------------------

loc_5DFC:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+F8j
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_20]
		cmp	eax, 27h ; '''
		jnz	short loc_5E48
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+arg_14]
		push	edx
		push	0
		push	1
		mov	eax, [ebp+var_F4]
		push	eax
		push	2
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	loc_5F80
; ---------------------------------------------------------------------------

loc_5E48:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+136j
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 1
		jz	short loc_5E8F
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Bh ; '{'
		jz	short loc_5E8F
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Dh ; '}'
		jz	short loc_5E8F
		cmp	[ebp+arg_C], 2
		jnz	short loc_5E72
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Ch ; '|'
		jz	short loc_5E8F

loc_5E72:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+187j
		cmp	[ebp+arg_C], 3
		jz	short loc_5E82
		cmp	[ebp+arg_C], 5
		jnz	loc_5F63

loc_5E82:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+196j
		movzx	eax, [ebp+var_20]
		cmp	eax, 23h ; '#'
		jnz	loc_5F63

loc_5E8F:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+16Fj
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+178j ...
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		push	1
		mov	ecx, [ebp+arg_0]
		sub	ecx, 1
		push	ecx
		push	2
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)

loc_5EA8:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &):loc_5F5Cj
		mov	eax, [ebp+arg_0]
		add	eax, 1
		push	eax		; int
		push	27h ; '''       ; wchar_t
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?indexOf@UnicodeString@icu_56@@QBEH_WH@Z ; icu_56::UnicodeString::indexOf(wchar_t,int)
		mov	[ebp+arg_0], eax
		cmp	[ebp+arg_0], 0
		jl	short loc_5F2F
		mov	eax, [ebp+arg_0]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		cmp	ecx, 27h ; '''
		jnz	short loc_5F00
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_14]
		push	ecx
		push	0
		push	1
		mov	edx, [ebp+arg_0]
		push	edx
		push	2
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	short loc_5F2D
; ---------------------------------------------------------------------------

loc_5F00:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+1FDj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+arg_14]
		push	edx
		push	0
		push	1
		mov	eax, [ebp+var_F4]
		push	eax
		push	2
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	short loc_5F61
; ---------------------------------------------------------------------------

loc_5F2D:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+21Ej
		jmp	short loc_5F5C
; ---------------------------------------------------------------------------

loc_5F2F:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+1E3j
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_14]
		push	eax
		push	27h ; '''
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	3
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+62h], 1
		jmp	short loc_5F61
; ---------------------------------------------------------------------------

loc_5F5C:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &):loc_5F2Dj
		jmp	loc_5EA8
; ---------------------------------------------------------------------------

loc_5F61:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+24Bj
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+27Aj
		jmp	short loc_5F80
; ---------------------------------------------------------------------------

loc_5F63:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+19Cj
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+1A9j
		mov	eax, [ebp+arg_14]
		push	eax
		push	27h ; '''
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	3
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+62h], 1

loc_5F80:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+117j
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+163j ...
		jmp	loc_6068
; ---------------------------------------------------------------------------

loc_5F85:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+E4j
		cmp	[ebp+arg_C], 3
		jz	short loc_5F91
		cmp	[ebp+arg_C], 5
		jnz	short loc_5FB8

loc_5F91:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+2A9j
		movzx	eax, [ebp+var_20]
		cmp	eax, 23h ; '#'
		jnz	short loc_5FB8
		mov	eax, [ebp+arg_14]
		push	eax
		push	0
		push	1
		mov	ecx, [ebp+arg_0]
		sub	ecx, 1
		push	ecx
		push	4
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	loc_6068
; ---------------------------------------------------------------------------

loc_5FB8:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+2AFj
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+2B8j
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Bh ; '{'
		jnz	short loc_5FE6
		mov	eax, [ebp+arg_14]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_10]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_8]
		push	edx		; int
		push	1		; int
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseArg@MessagePattern@icu_56@@AAEHHHHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)
		mov	[ebp+arg_0], eax
		jmp	loc_6068
; ---------------------------------------------------------------------------

loc_5FE6:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+2DFj
		cmp	[ebp+arg_8], 0
		jle	short loc_5FF5
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Dh ; '}'
		jz	short loc_6004

loc_5FF5:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+30Aj
		cmp	[ebp+arg_C], 2
		jnz	short loc_6068
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Ch ; '|'
		jnz	short loc_6068

loc_6004:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+313j
		cmp	[ebp+arg_C], 2
		jnz	short loc_601F
		movzx	eax, [ebp+var_20]
		cmp	eax, 7Dh ; '}'
		jnz	short loc_601F
		mov	[ebp+var_F4], 0
		jmp	short loc_6029
; ---------------------------------------------------------------------------

loc_601F:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+328j
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+331j
		mov	[ebp+var_F4], 1

loc_6029:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+33Dj
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+var_2C]
		push	edx
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		push	eax
		push	1
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?addLimitPart@MessagePattern@icu_56@@AAEXHW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addLimitPart(int,UMessagePatternPartType,int,int,int,UErrorCode &)
		cmp	[ebp+arg_C], 2
		jnz	short loc_6063
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		jmp	short loc_60C4
; ---------------------------------------------------------------------------
		jmp	short loc_6068
; ---------------------------------------------------------------------------

loc_6063:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+377j
		mov	eax, [ebp+arg_0]
		jmp	short loc_60C4
; ---------------------------------------------------------------------------

loc_6068:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &):loc_5F80j
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+2D3j ...
		jmp	loc_5D64
; ---------------------------------------------------------------------------

loc_606D:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+B0j
		cmp	[ebp+arg_8], 0
		jle	short loc_60A5
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?inTopLevelChoiceMessage@MessagePattern@icu_56@@AAECHW4UMessagePatternArgType@@@Z ; icu_56::MessagePattern::inTopLevelChoiceMessage(int,UMessagePatternArgType)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_60A5
		push	0		; int
		mov	eax, [ebp+arg_10]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 10109h
		xor	eax, eax
		jmp	short loc_60C4
; ---------------------------------------------------------------------------

loc_60A5:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+391j
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+3A8j
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	0
		mov	edx, [ebp+arg_0]
		push	edx
		push	1
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?addLimitPart@MessagePattern@icu_56@@AAEXHW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addLimitPart(int,UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_0]

loc_60C4:				; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+3Aj
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+53j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?parseMessage@MessagePattern@icu_56@@AAEHHHHW4UMessagePatternArgType@@PAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::parseArg(icu_56::MessagePattern *this,	int, int, int, struct UParseError *, enum UErrorCode *)
		public ?parseArg@MessagePattern@icu_56@@AAEHHHHPAUUParseError@@AAW4UErrorCode@@@Z
?parseArg@MessagePattern@icu_56@@AAEHHHHPAUUParseError@@AAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+2F9p

var_138		= byte ptr -138h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= word ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_20], 0
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		push	5
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6145
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_6145:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+60j
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_2C], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnz	short loc_618B
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10109h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_618B:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+8Fj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipIdentifier@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipIdentifier(int)
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_2C]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseArgNumber@MessagePattern@icu_56@@AAEHHH@Z	; icu_56::MessagePattern::parseArgNumber(int,int)
		mov	[ebp+var_38], eax
		cmp	[ebp+var_38], 0
		jl	short loc_6211
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_2C]
		mov	[ebp+var_44], eax
		cmp	[ebp+var_44], 0FFFFh
		jg	short loc_61CE
		cmp	[ebp+var_38], 7FFFh
		jle	short loc_61EE

loc_61CE:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+E7j
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_61EE:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+F0j
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+61h], 1
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		mov	eax, [ebp+var_2C]
		push	eax
		push	7
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	short loc_628A
; ---------------------------------------------------------------------------

loc_6211:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+D5j
		cmp	[ebp+var_38], 0FFFFFFFFh
		jnz	short loc_626A
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_2C]
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0FFFFh
		jle	short loc_6249
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_6249:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+14Bj
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+60h], 1
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_2C]
		push	edx
		push	8
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	short loc_628A
; ---------------------------------------------------------------------------

loc_626A:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+139j
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_628A:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+133j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+18Cj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnz	short loc_62C7
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10109h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_62C7:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+1CBj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_5C], ax
		movzx	eax, [ebp+var_5C]
		cmp	eax, 7Dh ; '}'
		jnz	short loc_62E8
		jmp	loc_658C
; ---------------------------------------------------------------------------

loc_62E8:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+205j
		movzx	eax, [ebp+var_5C]
		cmp	eax, 2Ch ; ','
		jz	short loc_6316
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------
		jmp	loc_658C
; ---------------------------------------------------------------------------

loc_6316:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+213j
		mov	eax, [ebp+arg_0]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_68], ecx

loc_632E:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+28Dj
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jge	short loc_636B
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		push	ecx		; int
		call	?isArgTypeChar@MessagePattern@icu_56@@CACH@Z ; icu_56::MessagePattern::isArgTypeChar(int)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_636B
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		jmp	short loc_632E
; ---------------------------------------------------------------------------

loc_636B:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+260j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+282j
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_68]
		mov	[ebp+var_74], eax
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnz	short loc_63B1
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10109h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_63B1:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+2B5j
		cmp	[ebp+var_74], 0
		jz	short loc_63DC
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_5C], ax
		movzx	ecx, [ebp+var_5C]
		cmp	ecx, 2Ch ; ','
		jz	short loc_63FC
		movzx	eax, [ebp+var_5C]
		cmp	eax, 7Dh ; '}'
		jz	short loc_63FC

loc_63DC:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+2D9j
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_63FC:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+2F5j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+2FEj
		cmp	[ebp+var_74], 0FFFFh
		jle	short loc_6425
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_6425:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+327j
		mov	[ebp+var_20], 1
		cmp	[ebp+var_74], 6
		jnz	short loc_6486
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?isChoice@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::isChoice(int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_644E
		mov	[ebp+var_20], 2
		jmp	short loc_6484
; ---------------------------------------------------------------------------

loc_644E:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+367j
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?isPlural@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::isPlural(int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_646A
		mov	[ebp+var_20], 3
		jmp	short loc_6484
; ---------------------------------------------------------------------------

loc_646A:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+383j
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?isSelect@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::isSelect(int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_6484
		mov	[ebp+var_20], 4

loc_6484:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+370j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+38Cj ...
		jmp	short loc_64BC
; ---------------------------------------------------------------------------

loc_6486:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+354j
		cmp	[ebp+var_74], 0Dh
		jnz	short loc_64BC
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?isSelect@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::isSelect(int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_64BC
		mov	eax, [ebp+var_68]
		add	eax, 6
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?isOrdinal@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::isOrdinal(int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_64BC
		mov	[ebp+var_20], 5

loc_64BC:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &):loc_6484j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+3AEj ...
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+48h]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		mov	dx, word ptr [ebp+var_20]
		mov	[eax+0Ah], dx
		cmp	[ebp+var_20], 1
		jnz	short loc_64F1
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_74]
		push	ecx
		mov	edx, [ebp+var_68]
		push	edx
		push	9
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)

loc_64F1:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+3FBj
		movzx	eax, [ebp+var_5C]
		cmp	eax, 7Dh ; '}'
		jnz	short loc_6522
		cmp	[ebp+var_20], 1
		jz	short loc_6520
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_65AE
; ---------------------------------------------------------------------------

loc_6520:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+422j
		jmp	short loc_658C
; ---------------------------------------------------------------------------

loc_6522:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+41Cj
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		cmp	[ebp+var_20], 1
		jnz	short loc_654A
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseSimpleStyle@MessagePattern@icu_56@@AAEHHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)
		mov	[ebp+arg_0], eax
		jmp	short loc_658C
; ---------------------------------------------------------------------------

loc_654A:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+453j
		cmp	[ebp+var_20], 2
		jnz	short loc_656D
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseChoiceStyle@MessagePattern@icu_56@@AAEHHHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)
		mov	[ebp+arg_0], eax
		jmp	short loc_658C
; ---------------------------------------------------------------------------

loc_656D:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+472j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?parsePluralOrSelectStyle@MessagePattern@icu_56@@AAEHW4UMessagePatternArgType@@HHPAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)
		mov	[ebp+arg_0], eax

loc_658C:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+207j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+235j ...
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		push	1
		mov	edx, [ebp+arg_0]
		push	edx
		push	6
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?addLimitPart@MessagePattern@icu_56@@AAEXHW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addLimitPart(int,UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		add	eax, 1

loc_65AE:				; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+64j
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+AAj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?parseArg@MessagePattern@icu_56@@AAEHHHHPAUUParseError@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 65C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::parseSimpleStyle(icu_56::MessagePattern *this,	int, struct UParseError	*, enum	UErrorCode *)
		public ?parseSimpleStyle@MessagePattern@icu_56@@AAEHHPAUUParseError@@AAW4UErrorCode@@@Z
?parseSimpleStyle@MessagePattern@icu_56@@AAEHHPAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+464p

var_100		= dword	ptr -100h
var_38		= dword	ptr -38h
var_2C		= word ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6603
		xor	eax, eax
		jmp	loc_673E
; ---------------------------------------------------------------------------

loc_6603:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0

loc_6610:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &):loc_6720j
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jge	loc_6725
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_100], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_100]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_2C], ax
		movzx	eax, [ebp+var_2C]
		cmp	eax, 27h ; '''
		jnz	short loc_669D
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	27h ; '''       ; wchar_t
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?indexOf@UnicodeString@icu_56@@QBEH_WH@Z ; icu_56::UnicodeString::indexOf(wchar_t,int)
		mov	[ebp+arg_0], eax
		cmp	[ebp+arg_0], 0
		jge	short loc_668F
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_673E
; ---------------------------------------------------------------------------

loc_668F:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+A9j
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		jmp	loc_6720
; ---------------------------------------------------------------------------

loc_669D:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+8Fj
		movzx	eax, [ebp+var_2C]
		cmp	eax, 7Bh ; '{'
		jnz	short loc_66B1
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_6720
; ---------------------------------------------------------------------------

loc_66B1:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+E0j
		movzx	eax, [ebp+var_2C]
		cmp	eax, 7Dh ; '}'
		jnz	short loc_6720
		cmp	[ebp+var_20], 0
		jle	short loc_66CB
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_6720
; ---------------------------------------------------------------------------

loc_66CB:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+FAj
		mov	eax, [ebp+arg_0]
		sub	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_0]
		sub	ecx, [ebp+var_14]
		mov	[ebp+var_38], ecx
		cmp	[ebp+var_38], 0FFFFh
		jle	short loc_6703
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	short loc_673E
; ---------------------------------------------------------------------------

loc_6703:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+120j
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		push	0Ah
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		jmp	short loc_673E
; ---------------------------------------------------------------------------

loc_6720:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+D4j
					; icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode	&)+EBj	...
		jmp	loc_6610
; ---------------------------------------------------------------------------

loc_6725:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+5Aj
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10109h
		xor	eax, eax

loc_673E:				; CODE XREF: icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode &)+3Aj
					; icu_56::MessagePattern::parseSimpleStyle(int,UParseError *,UErrorCode	&)+C6j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?parseSimpleStyle@MessagePattern@icu_56@@AAEHHPAUUParseError@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6754h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::parseChoiceStyle(icu_56::MessagePattern *this,	int, int, struct UParseError *,	enum UErrorCode	*)
		public ?parseChoiceStyle@MessagePattern@icu_56@@AAEHHHPAUUParseError@@AAW4UErrorCode@@@Z
?parseChoiceStyle@MessagePattern@icu_56@@AAEHHHPAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)+46p
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+487p

var_FC		= byte ptr -0FCh
var_38		= word ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6793
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_6793:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+36j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jz	short loc_67CF
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		cmp	ecx, 7Dh ; '}'
		jnz	short loc_67ED

loc_67CF:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+62j
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_67ED:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+79j
					; icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+294j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipDouble@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipDouble(int)
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_0]
		sub	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		jnz	short loc_682D
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_682D:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+B7j
		cmp	[ebp+var_2C], 0FFFFh
		jle	short loc_6856
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_6856:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+E0j
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		push	1		; char
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z ;	icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_688C
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_688C:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+12Fj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnz	short loc_68CB
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_68CB:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+155j
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_38], ax
		movzx	eax, [ebp+var_38]
		cmp	eax, 23h ; '#'
		jz	short loc_691B
		movzx	eax, [ebp+var_38]
		cmp	eax, 3Ch ; '<'
		jz	short loc_691B
		movzx	eax, [ebp+var_38]
		cmp	eax, 2264h
		jz	short loc_691B
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_69ED
; ---------------------------------------------------------------------------

loc_691B:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+191j
					; icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+19Aj ...
		mov	eax, [ebp+arg_C]
		push	eax
		push	0
		push	1
		mov	ecx, [ebp+arg_0]
		push	ecx
		push	0Bh
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		push	2
		mov	eax, [ebp+arg_4]
		add	eax, 1
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?parseMessage@MessagePattern@icu_56@@AAEHHHHW4UMessagePatternArgType@@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6975
		xor	eax, eax
		jmp	short loc_69ED
; ---------------------------------------------------------------------------

loc_6975:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+21Bj
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnz	short loc_698A
		mov	eax, [ebp+arg_0]
		jmp	short loc_69ED
; ---------------------------------------------------------------------------

loc_698A:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+22Fj
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		cmp	ecx, 7Dh ; '}'
		jnz	short loc_69D6
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?inMessageFormatPattern@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::inMessageFormatPattern(int)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_69D1
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	short loc_69ED
; ---------------------------------------------------------------------------

loc_69D1:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+25Ej
		mov	eax, [ebp+arg_0]
		jmp	short loc_69ED
; ---------------------------------------------------------------------------

loc_69D6:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+24Bj
		mov	eax, [ebp+arg_0]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_0], eax
		jmp	loc_67ED
; ---------------------------------------------------------------------------

loc_69ED:				; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+3Aj
					; icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+94j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?parseChoiceStyle@MessagePattern@icu_56@@AAEHHHPAUUParseError@@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6A04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: int __thiscall icu_56::MessagePattern::parsePluralOrSelectStyle(enum	 UMessagePatternArgType, int, int, struct UParseError *, enum  UErrorCode &)
		public ?parsePluralOrSelectStyle@MessagePattern@icu_56@@AAEHW4UMessagePatternArgType@@HHPAUUParseError@@AAW4UErrorCode@@@Z
?parsePluralOrSelectStyle@MessagePattern@icu_56@@AAEHW4UMessagePatternArgType@@HHPAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parsePluralStyle(icu_56::UnicodeString const &,UParseError	*,UErrorCode &)+48p
					; icu_56::MessagePattern::parseSelectStyle(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+48p ...

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_29		= byte ptr -29h
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6A43
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6A43:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+36j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		mov	[ebp+var_1D], 1
		mov	[ebp+var_29], 0

loc_6A51:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+32Ej
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+44Dj
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_4], eax
		setz	al
		mov	[ebp+var_35], al
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jnz	short loc_6A93
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		cmp	ecx, 7Dh ; '}'
		jnz	short loc_6AF8

loc_6A93:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+76j
		movsx	esi, [ebp+var_35]
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?inMessageFormatPattern@MessagePattern@icu_56@@AAECH@Z ; icu_56::MessagePattern::inMessageFormatPattern(int)
		movsx	ecx, al
		cmp	esi, ecx
		jnz	short loc_6ACA
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6ACA:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+A4j
		movsx	eax, [ebp+var_29]
		test	eax, eax
		jnz	short loc_6AF0
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1010Fh
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6AF0:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+CCj
		mov	eax, [ebp+arg_4]
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6AF8:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+8Dj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_44], eax
		cmp	[ebp+arg_0], 3
		jz	short loc_6B0E
		cmp	[ebp+arg_0], 5
		jnz	loc_6BCD

loc_6B0E:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+FEj
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		cmp	ecx, 3Dh ; '='
		jnz	loc_6BCD
		mov	eax, [ebp+arg_4]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipDouble@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipDouble(int)
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_44]
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 1
		jnz	short loc_6B6A
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6B6A:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+144j
		cmp	[ebp+var_50], 0FFFFh
		jle	short loc_6B93
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6B93:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+16Dj
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		push	0Bh
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+var_44]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z ;	icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)
		jmp	loc_6DA1
; ---------------------------------------------------------------------------

loc_6BCD:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+104j
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+11Fj
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipIdentifier@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipIdentifier(int)
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_44]
		mov	[ebp+var_5C], eax
		jnz	short loc_6C07
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6C07:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+1E1j
		cmp	[ebp+arg_0], 3
		jz	short loc_6C17
		cmp	[ebp+arg_0], 5
		jnz	loc_6D39

loc_6C17:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+207j
		cmp	[ebp+var_5C], 6
		jnz	loc_6D39
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_4], eax
		jge	loc_6D39
		push	7		; int
		push	0		; int
		push	offset _kOffsetColon ; "offset:"
		push	7		; int
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z ;	icu_56::UnicodeString::compare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		jnz	loc_6D39
		movsx	eax, [ebp+var_1D]
		test	eax, eax
		jnz	short loc_6C82
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6C82:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+25Cj
		mov	eax, [ebp+arg_4]
		add	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipDouble@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipDouble(int)
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_68]
		jnz	short loc_6CCB
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6CCB:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+2A5j
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_68]
		cmp	eax, 0FFFFh
		jle	short loc_6CF8
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6CF8:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+2D2j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		push	0		; char
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+var_68]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z ;	icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6D2E
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6D2E:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+321j
		mov	[ebp+var_1D], 0
		jmp	loc_6A51
; ---------------------------------------------------------------------------
		jmp	short loc_6DA1
; ---------------------------------------------------------------------------

loc_6D39:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+20Dj
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+217j ...
		cmp	[ebp+var_5C], 0FFFFh
		jle	short loc_6D62
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6D62:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+33Cj
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+var_5C]
		push	ecx
		mov	edx, [ebp+var_44]
		push	edx
		push	0Bh
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		push	5		; int
		push	0		; int
		push	offset _kOther	; "other"
		mov	eax, [ebp+var_5C]
		push	eax		; int
		mov	ecx, [ebp+var_44]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z ;	icu_56::UnicodeString::compare(int,int,wchar_t const *,int,int)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_6DA1
		mov	[ebp+var_29], 1

loc_6DA1:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+1C4j
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+333j ...
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6DBD
		xor	eax, eax
		jmp	loc_6E56
; ---------------------------------------------------------------------------

loc_6DBD:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+3B0j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z ; icu_56::MessagePattern::skipWhiteSpace(int)
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_4], eax
		jz	short loc_6DF3
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		movzx	ecx, ax
		cmp	ecx, 7Bh ; '{'
		jz	short loc_6E10

loc_6DF3:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+3D6j
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_8] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h
		xor	eax, eax
		jmp	short loc_6E56
; ---------------------------------------------------------------------------

loc_6E10:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+3EDj
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_8]
		add	eax, 1
		push	eax
		push	1
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?parseMessage@MessagePattern@icu_56@@AAEHHHHW4UMessagePatternArgType@@PAUUParseError@@AAW4UErrorCode@@@Z ; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6E4D
		xor	eax, eax
		jmp	short loc_6E56
; ---------------------------------------------------------------------------

loc_6E4D:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+443j
		mov	[ebp+var_1D], 0
		jmp	loc_6A51
; ---------------------------------------------------------------------------

loc_6E56:				; CODE XREF: icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+3Aj
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+C1j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?parsePluralOrSelectStyle@MessagePattern@icu_56@@AAEHW4UMessagePatternArgType@@HHPAUUParseError@@AAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6E6Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::MessagePattern::parseArgNumber(const struct icu_56::UnicodeString	*, int,	int)
		public ?parseArgNumber@MessagePattern@icu_56@@CAHABVUnicodeString@2@HH@Z
?parseArgNumber@MessagePattern@icu_56@@CAHABVUnicodeString@2@HH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArgNumber(int,int)+32p
					; icu_56::MessagePattern::validateArgumentName(icu_56::UnicodeString const &)+55p

var_E8		= dword	ptr -0E8h
var_20		= word ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jl	short loc_6E9C
		mov	eax, 0FFFFFFFEh
		jmp	loc_6F89
; ---------------------------------------------------------------------------

loc_6E9C:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+24j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+arg_4]
		add	ecx, 1
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_E8]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_20]
		cmp	eax, 30h ; '0'
		jnz	short loc_6EE8
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jnz	short loc_6EDB
		xor	eax, eax
		jmp	loc_6F89
; ---------------------------------------------------------------------------
		jmp	short loc_6EE6
; ---------------------------------------------------------------------------

loc_6EDB:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+64j
		mov	[ebp+var_8], 0
		mov	[ebp+var_11], 1

loc_6EE6:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+6Dj
		jmp	short loc_6F0F
; ---------------------------------------------------------------------------

loc_6EE8:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+5Cj
		movzx	eax, [ebp+var_20]
		cmp	eax, 31h ; '1'
		jl	short loc_6F0A
		movzx	eax, [ebp+var_20]
		cmp	eax, 39h ; '9'
		jg	short loc_6F0A
		movzx	eax, [ebp+var_20]
		sub	eax, 30h ; '0'
		mov	[ebp+var_8], eax
		mov	[ebp+var_11], 0
		jmp	short loc_6F0F
; ---------------------------------------------------------------------------

loc_6F0A:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+83j
					; icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const &,int,int)+8Cj
		or	eax, 0FFFFFFFFh
		jmp	short loc_6F89
; ---------------------------------------------------------------------------

loc_6F0F:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int):loc_6EE6j
					; icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const &,int,int)+9Cj ...
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jge	short loc_6F75
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+arg_4]
		add	ecx, 1
		mov	[ebp+arg_4], ecx
		mov	edx, [ebp+var_E8]
		push	edx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_20]
		cmp	eax, 30h ; '0'
		jl	short loc_6F6E
		movzx	eax, [ebp+var_20]
		cmp	eax, 39h ; '9'
		jg	short loc_6F6E
		cmp	[ebp+var_8], 0CCCCCCCh
		jl	short loc_6F5B
		mov	[ebp+var_11], 1

loc_6F5B:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+E9j
		mov	eax, [ebp+var_8]
		imul	eax, 0Ah
		movzx	ecx, [ebp+var_20]
		lea	edx, [eax+ecx-30h]
		mov	[ebp+var_8], edx
		jmp	short loc_6F73
; ---------------------------------------------------------------------------

loc_6F6E:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+D7j
					; icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const &,int,int)+E0j
		or	eax, 0FFFFFFFFh
		jmp	short loc_6F89
; ---------------------------------------------------------------------------

loc_6F73:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+100j
		jmp	short loc_6F0F
; ---------------------------------------------------------------------------

loc_6F75:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+A9j
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_6F86
		mov	eax, 0FFFFFFFEh
		jmp	short loc_6F89
; ---------------------------------------------------------------------------
		jmp	short loc_6F89
; ---------------------------------------------------------------------------

loc_6F86:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+10Fj
		mov	eax, [ebp+var_8]

loc_6F89:				; CODE XREF: icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const	&,int,int)+2Bj
					; icu_56::MessagePattern::parseArgNumber(icu_56::UnicodeString const &,int,int)+68j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?parseArgNumber@MessagePattern@icu_56@@CAHABVUnicodeString@2@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6FA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::MessagePattern::parseDouble(icu_56::MessagePattern *this, int, int, char, struct UParseError *, enum UErrorCode *)
		public ?parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z
?parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+117p
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+1BFp ...

var_1F4		= qword	ptr -1F4h
var_1D4		= dword	ptr -1D4h
var_108		= qword	ptr -108h
EndPtr		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
Str		= byte ptr -0D4h
var_4C		= qword	ptr -4Ch
var_3C		= word ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 1D4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_1D4]
		mov	ecx, 75h ; 'u'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6FE7
		jmp	loc_72DC
; ---------------------------------------------------------------------------

loc_6FE7:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+40j
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+arg_4]
		jl	short loc_7015
		mov	ecx, ds:?__LINE__Var@?1??parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z@4JA ; long `icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)'::`2'::__LINE__Var
		add	ecx, 4
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1GK@CEACJPPF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BI@JIIPEDNH@?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?$DM?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?$AA@ ;	"start<limit"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7015:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+4Dj
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+31Ej
		mov	[ebp+var_18], 0
		mov	[ebp+var_24], 0
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_30]
		mov	[ebp+var_1D4+4], eax
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx
		mov	edx, [ebp+var_1D4+4]
		push	edx		; int
		mov	ecx, [ebp+var_C]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_3C], ax
		movzx	eax, [ebp+var_3C]
		cmp	eax, 2Dh ; '-'
		jnz	short loc_7098
		mov	[ebp+var_24], 1
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_706E
		jmp	loc_72C3
; ---------------------------------------------------------------------------

loc_706E:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+C7j
		mov	eax, [ebp+var_30]
		mov	[ebp+var_1D4+4], eax
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx
		mov	edx, [ebp+var_1D4+4]
		push	edx		; int
		mov	ecx, [ebp+var_C]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_3C], ax
		jmp	short loc_70D6
; ---------------------------------------------------------------------------

loc_7098:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+B8j
		movzx	eax, [ebp+var_3C]
		cmp	eax, 2Bh ; '+'
		jnz	short loc_70D6
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_70AE
		jmp	loc_72C3
; ---------------------------------------------------------------------------

loc_70AE:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+107j
		mov	eax, [ebp+var_30]
		mov	[ebp+var_1D4+4], eax
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx
		mov	edx, [ebp+var_1D4+4]
		push	edx		; int
		mov	ecx, [ebp+var_C]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_3C], ax

loc_70D6:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+F6j
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+FFj
		movzx	eax, [ebp+var_3C]
		cmp	eax, 221Eh
		jnz	short loc_7144
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_713F
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_713F
		call	_uprv_getInfinity_56
		fstp	[ebp+var_4C]
		cmp	[ebp+var_24], 0
		jz	short loc_710C
		fld	[ebp+var_4C]
		fchs
		fstp	qword ptr [ebp+var_1D4]
		jmp	short loc_7115
; ---------------------------------------------------------------------------

loc_710C:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+15Dj
		fld	[ebp+var_4C]
		fstp	qword ptr [ebp+var_1D4]

loc_7115:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+16Aj
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		sub	esp, 8
		fld	qword ptr [ebp+var_1D4]
		fstp	[esp+1F4h+var_1F4] ; double
		mov	ecx, [ebp+var_C] ; this
		call	?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)
		jmp	loc_72DC
; ---------------------------------------------------------------------------
		jmp	short loc_7144
; ---------------------------------------------------------------------------

loc_713F:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+147j
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+14Fj
		jmp	loc_72C3
; ---------------------------------------------------------------------------

loc_7144:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+13Fj
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+19Dj ...
		movzx	eax, [ebp+var_3C]
		cmp	eax, 30h ; '0'
		jl	loc_71F4
		movzx	eax, [ebp+var_3C]
		cmp	eax, 39h ; '9'
		jg	loc_71F4
		mov	eax, [ebp+var_18]
		imul	eax, 0Ah
		movzx	ecx, [ebp+var_3C]
		lea	edx, [eax+ecx-30h]
		mov	[ebp+var_18], edx
		mov	eax, [ebp+var_24]
		add	eax, 7FFFh
		cmp	[ebp+var_18], eax
		jle	short loc_717E
		jmp	short loc_71F4
; ---------------------------------------------------------------------------

loc_717E:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+1DAj
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+arg_4]
		jnz	short loc_71C7
		cmp	[ebp+var_24], 0
		jz	short loc_7199
		mov	eax, [ebp+var_18]
		neg	eax
		mov	[ebp+var_1D4+4], eax
		jmp	short loc_71A2
; ---------------------------------------------------------------------------

loc_7199:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+1EAj
		mov	ecx, [ebp+var_18]
		mov	[ebp+var_1D4+4], ecx

loc_71A2:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+1F7j
		mov	edx, [ebp+arg_10]
		push	edx
		mov	eax, [ebp+var_1D4+4]
		push	eax
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		push	0Ch
		mov	ecx, [ebp+var_C]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		jmp	loc_72DC
; ---------------------------------------------------------------------------

loc_71C7:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+1E4j
		mov	eax, [ebp+var_30]
		mov	[ebp+var_1D4+4], eax
		mov	ecx, [ebp+var_30]
		add	ecx, 1
		mov	[ebp+var_30], ecx
		mov	edx, [ebp+var_1D4+4]
		push	edx		; int
		mov	ecx, [ebp+var_C]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_3C], ax
		jmp	loc_7144
; ---------------------------------------------------------------------------

loc_71F4:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+1ABj
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+1B8j ...
		mov	[ebp+var_E0], 80h ; ''
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		mov	[ebp+var_EC], eax
		mov	eax, [ebp+var_EC]
		cmp	eax, [ebp+var_E0]
		jl	short loc_721D
		jmp	loc_72C3
; ---------------------------------------------------------------------------

loc_721D:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+276j
		push	0
		mov	eax, [ebp+var_E0]
		push	eax
		lea	ecx, [ebp+Str]
		push	ecx
		mov	edx, [ebp+var_EC]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_C]
		add	ecx, 8
		call	?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z ; icu_56::UnicodeString::extract(int,int,char *,int,icu_56::UnicodeString::EInvariant)
		lea	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		cmp	eax, [ebp+var_EC]
		jge	short loc_725C
		jmp	short loc_72C3
; ---------------------------------------------------------------------------

loc_725C:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+2B8j
		mov	esi, esp
		lea	eax, [ebp+EndPtr]
		push	eax		; EndPtr
		lea	ecx, [ebp+Str]
		push	ecx		; Str
		call	dword ptr ds:__imp__strtod
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		fstp	[ebp+var_108]
		mov	eax, [ebp+var_EC]
		lea	ecx, [ebp+eax+Str]
		cmp	[ebp+EndPtr], ecx
		jz	short loc_7299
		jmp	short loc_72C3
; ---------------------------------------------------------------------------

loc_7299:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+2F5j
		mov	eax, [ebp+arg_10]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_EC]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		sub	esp, 8
		fld	[ebp+var_108]
		fstp	qword ptr [esp+0] ; double
		mov	ecx, [ebp+var_C] ; this
		call	?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)
		jmp	short loc_72DC
; ---------------------------------------------------------------------------
		jmp	loc_7015
; ---------------------------------------------------------------------------

loc_72C3:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+C9j
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+109j ...
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; struct UParseError *
		mov	ecx, [ebp+var_C] ; this
		call	?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z ;	icu_56::MessagePattern::setParseError(UParseError *,int)
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 10107h

loc_72DC:				; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+42j
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+198j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN29
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1D4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 10h
$LN29		dd 2			; DATA XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+340o
		dd offset $LN28
$LN28		dd 0FFFFFF2Ch, 80h	; DATA XREF: .text:00007314o
		dd offset $LN26		; "numberChars"
		db 8, 0FFh
		dw 0FFFFh
		dd 4
		dd offset $LN27
$LN27		dd 646E65h		; DATA XREF: .text:0000732Co
$LN26		db 'numberChars',0      ; DATA XREF: .text:00007320o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7340h
		public ??_C@_1BI@JIIPEDNH@?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?$DM?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1BI@JIIPEDNH@?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?$DM?$AAl?$AAi?$AAm?$AAi?$AAt?$AA?$AA@:
					; DATA XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+60o
		unicode	0, <start>
		dw 3Ch
		unicode	0, <limit>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7358h
		public ??_C@_1GK@CEACJPPF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1GK@CEACJPPF@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+5Bo
		unicode	0, <d:\mozilla\intl\icu\source\common\messagepattern.cpp>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 73C4h
		public ?__LINE__Var@?1??parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z@4JA
; long `private: void __thiscall icu_56::MessagePattern::parseDouble(int, int, signed char, struct UParseError *, enum	UErrorCode &)'::`2'::__LINE__Var
?__LINE__Var@?1??parseDouble@MessagePattern@icu_56@@AAEXHHCPAUUParseError@@AAW4UErrorCode@@@Z@4JA dd 3A3h
					; DATA XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+4Fr
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 73C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::skipWhiteSpace(icu_56::MessagePattern *this, int)
		public ?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z
?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+73p
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+1B5p ...

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		push	eax		; wchar_t *
		call	?skipWhiteSpace@PatternProps@icu_56@@SAPB_WPB_WH@Z ; icu_56::PatternProps::skipWhiteSpace(wchar_t const	*,int)
		add	esp, 8
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_14]
		sar	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?skipWhiteSpace@MessagePattern@icu_56@@AAEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7444h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::skipIdentifier(icu_56::MessagePattern *this, int)
		public ?skipIdentifier@MessagePattern@icu_56@@AAEHH@Z
?skipIdentifier@MessagePattern@icu_56@@AAEHH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+B6p
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+1D0p

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2]
		push	eax		; wchar_t *
		call	?skipIdentifier@PatternProps@icu_56@@SAPB_WPB_WH@Z ; icu_56::PatternProps::skipIdentifier(wchar_t const	*,int)
		add	esp, 8
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_14]
		sar	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?skipIdentifier@MessagePattern@icu_56@@AAEHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 74C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::skipDouble(icu_56::MessagePattern *this, int)
		public ?skipDouble@MessagePattern@icu_56@@AAEHH@Z
?skipDouble@MessagePattern@icu_56@@AAEHH@Z proc	near
					; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+A6p
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+12Fp ...

var_E4		= byte ptr -0E4h
var_20		= word ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax

loc_74F1:				; CODE XREF: icu_56::MessagePattern::skipDouble(int)+A1j
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_14]
		jge	short loc_7563
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_20], ax
		movzx	eax, [ebp+var_20]
		cmp	eax, 30h ; '0'
		jge	short loc_7530
		movzx	eax, [ebp+var_20]
		cmp	eax, 2Bh ; '+'
		jz	short loc_7530
		movzx	eax, [ebp+var_20]
		cmp	eax, 2Dh ; '-'
		jz	short loc_7530
		movzx	eax, [ebp+var_20]
		cmp	eax, 2Eh ; '.'
		jnz	short loc_7556

loc_7530:				; CODE XREF: icu_56::MessagePattern::skipDouble(int)+53j
					; icu_56::MessagePattern::skipDouble(int)+5Cj ...
		movzx	eax, [ebp+var_20]
		cmp	eax, 39h ; '9'
		jle	short loc_7558
		movzx	eax, [ebp+var_20]
		cmp	eax, 65h ; 'e'
		jz	short loc_7558
		movzx	eax, [ebp+var_20]
		cmp	eax, 45h ; 'E'
		jz	short loc_7558
		movzx	eax, [ebp+var_20]
		cmp	eax, 221Eh
		jz	short loc_7558

loc_7556:				; CODE XREF: icu_56::MessagePattern::skipDouble(int)+6Ej
		jmp	short loc_7563
; ---------------------------------------------------------------------------

loc_7558:				; CODE XREF: icu_56::MessagePattern::skipDouble(int)+77j
					; icu_56::MessagePattern::skipDouble(int)+80j ...
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		jmp	short loc_74F1
; ---------------------------------------------------------------------------

loc_7563:				; CODE XREF: icu_56::MessagePattern::skipDouble(int)+37j
					; icu_56::MessagePattern::skipDouble(int):loc_7556j
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?skipDouble@MessagePattern@icu_56@@AAEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 757Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__cdecl	icu_56::MessagePattern::isArgTypeChar(int)
		public ?isArgTypeChar@MessagePattern@icu_56@@CACH@Z
?isArgTypeChar@MessagePattern@icu_56@@CACH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+275p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 61h ; 'a'
		jl	short loc_75A6
		cmp	[ebp+arg_0], 7Ah ; 'z'
		jle	short loc_75BB

loc_75A6:				; CODE XREF: icu_56::MessagePattern::isArgTypeChar(int)+22j
		cmp	[ebp+arg_0], 41h ; 'A'
		jl	short loc_75B2
		cmp	[ebp+arg_0], 5Ah ; 'Z'
		jle	short loc_75BB

loc_75B2:				; CODE XREF: icu_56::MessagePattern::isArgTypeChar(int)+2Ej
		mov	[ebp+var_C1], 0
		jmp	short loc_75C2
; ---------------------------------------------------------------------------

loc_75BB:				; CODE XREF: icu_56::MessagePattern::isArgTypeChar(int)+28j
					; icu_56::MessagePattern::isArgTypeChar(int)+34j
		mov	[ebp+var_C1], 1

loc_75C2:				; CODE XREF: icu_56::MessagePattern::isArgTypeChar(int)+3Dj
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isArgTypeChar@MessagePattern@icu_56@@CACH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 75D0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::isChoice(icu_56::MessagePattern *this, int)
		public ?isChoice@MessagePattern@icu_56@@AAECH@Z
?isChoice@MessagePattern@icu_56@@AAECH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+35Dp

var_F0		= byte ptr -0F0h
var_ED		= byte ptr -0EDh
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_DC]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 63h ; 'c'
		jz	short loc_7631
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 43h ; 'C'
		jnz	loc_774F

loc_7631:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+52j
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_E0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 68h ; 'h'
		jz	short loc_766F
		movzx	eax, [ebp+var_14]
		cmp	eax, 48h ; 'H'
		jnz	loc_774F

loc_766F:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+90j
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_E4], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+var_E4]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 6Fh ; 'o'
		jz	short loc_76AD
		movzx	edx, [ebp+var_14]
		cmp	edx, 4Fh ; 'O'
		jnz	loc_774F

loc_76AD:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+CEj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_E8]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 69h ; 'i'
		jz	short loc_76E7
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 49h ; 'I'
		jnz	short loc_774F

loc_76E7:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+10Cj
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_EC], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_EC]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 63h ; 'c'
		jz	short loc_7721
		movzx	eax, [ebp+var_14]
		cmp	eax, 43h ; 'C'
		jnz	short loc_774F

loc_7721:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+146j
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 65h ; 'e'
		jz	short loc_7746
		movzx	eax, [ebp+var_14]
		cmp	eax, 45h ; 'E'
		jnz	short loc_774F

loc_7746:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+16Bj
		mov	[ebp+var_ED], 1
		jmp	short loc_7756
; ---------------------------------------------------------------------------

loc_774F:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+5Bj
					; icu_56::MessagePattern::isChoice(int)+99j ...
		mov	[ebp+var_ED], 0

loc_7756:				; CODE XREF: icu_56::MessagePattern::isChoice(int)+17Dj
		mov	al, [ebp+var_ED]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isChoice@MessagePattern@icu_56@@AAECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7774h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::isPlural(icu_56::MessagePattern *this, int)
		public ?isPlural@MessagePattern@icu_56@@AAECH@Z
?isPlural@MessagePattern@icu_56@@AAECH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+379p

var_F0		= byte ptr -0F0h
var_ED		= byte ptr -0EDh
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_DC]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 70h ; 'p'
		jz	short loc_77D5
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 50h ; 'P'
		jnz	loc_78F3

loc_77D5:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+52j
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_E0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 6Ch ; 'l'
		jz	short loc_7813
		movzx	eax, [ebp+var_14]
		cmp	eax, 4Ch ; 'L'
		jnz	loc_78F3

loc_7813:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+90j
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_E4], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+var_E4]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 75h ; 'u'
		jz	short loc_7851
		movzx	edx, [ebp+var_14]
		cmp	edx, 55h ; 'U'
		jnz	loc_78F3

loc_7851:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+CEj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_E8]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 72h ; 'r'
		jz	short loc_788B
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 52h ; 'R'
		jnz	short loc_78F3

loc_788B:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+10Cj
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_EC], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_EC]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 61h ; 'a'
		jz	short loc_78C5
		movzx	eax, [ebp+var_14]
		cmp	eax, 41h ; 'A'
		jnz	short loc_78F3

loc_78C5:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+146j
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 6Ch ; 'l'
		jz	short loc_78EA
		movzx	eax, [ebp+var_14]
		cmp	eax, 4Ch ; 'L'
		jnz	short loc_78F3

loc_78EA:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+16Bj
		mov	[ebp+var_ED], 1
		jmp	short loc_78FA
; ---------------------------------------------------------------------------

loc_78F3:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+5Bj
					; icu_56::MessagePattern::isPlural(int)+99j ...
		mov	[ebp+var_ED], 0

loc_78FA:				; CODE XREF: icu_56::MessagePattern::isPlural(int)+17Dj
		mov	al, [ebp+var_ED]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isPlural@MessagePattern@icu_56@@AAECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7918h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::isSelect(icu_56::MessagePattern *this, int)
		public ?isSelect@MessagePattern@icu_56@@AAECH@Z
?isSelect@MessagePattern@icu_56@@AAECH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+395p
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+3B7p

var_F0		= byte ptr -0F0h
var_ED		= byte ptr -0EDh
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_DC]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 73h ; 's'
		jz	short loc_7979
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 53h ; 'S'
		jnz	loc_7A97

loc_7979:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+52j
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_E0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 65h ; 'e'
		jz	short loc_79B7
		movzx	eax, [ebp+var_14]
		cmp	eax, 45h ; 'E'
		jnz	loc_7A97

loc_79B7:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+90j
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_E4], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+var_E4]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 6Ch ; 'l'
		jz	short loc_79F5
		movzx	edx, [ebp+var_14]
		cmp	edx, 4Ch ; 'L'
		jnz	loc_7A97

loc_79F5:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+CEj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_E8]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 65h ; 'e'
		jz	short loc_7A2F
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 45h ; 'E'
		jnz	short loc_7A97

loc_7A2F:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+10Cj
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_EC], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_EC]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 63h ; 'c'
		jz	short loc_7A69
		movzx	eax, [ebp+var_14]
		cmp	eax, 43h ; 'C'
		jnz	short loc_7A97

loc_7A69:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+146j
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 74h ; 't'
		jz	short loc_7A8E
		movzx	eax, [ebp+var_14]
		cmp	eax, 54h ; 'T'
		jnz	short loc_7A97

loc_7A8E:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+16Bj
		mov	[ebp+var_ED], 1
		jmp	short loc_7A9E
; ---------------------------------------------------------------------------

loc_7A97:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+5Bj
					; icu_56::MessagePattern::isSelect(int)+99j ...
		mov	[ebp+var_ED], 0

loc_7A9E:				; CODE XREF: icu_56::MessagePattern::isSelect(int)+17Dj
		mov	al, [ebp+var_ED]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isSelect@MessagePattern@icu_56@@AAECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::isOrdinal(icu_56::MessagePattern *this, int)
		public ?isOrdinal@MessagePattern@icu_56@@AAECH@Z
?isOrdinal@MessagePattern@icu_56@@AAECH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+3CDp

var_F4		= byte ptr -0F4h
var_F1		= byte ptr -0F1h
var_F0		= dword	ptr -0F0h
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= word ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_DC]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 6Fh ; 'o'
		jz	short loc_7B1D
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 4Fh ; 'O'
		jnz	loc_7C79

loc_7B1D:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+52j
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_E0]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 72h ; 'r'
		jz	short loc_7B5B
		movzx	eax, [ebp+var_14]
		cmp	eax, 52h ; 'R'
		jnz	loc_7C79

loc_7B5B:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+90j
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_E4], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+var_E4]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 64h ; 'd'
		jz	short loc_7B99
		movzx	edx, [ebp+var_14]
		cmp	edx, 44h ; 'D'
		jnz	loc_7C79

loc_7B99:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+CEj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_E8], eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+var_E8]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	eax, [ebp+var_14]
		cmp	eax, 69h ; 'i'
		jz	short loc_7BD7
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 49h ; 'I'
		jnz	loc_7C79

loc_7BD7:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+10Cj
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_EC], edx
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+var_EC]
		push	ecx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	edx, [ebp+var_14]
		cmp	edx, 6Eh ; 'n'
		jz	short loc_7C11
		movzx	eax, [ebp+var_14]
		cmp	eax, 4Eh ; 'N'
		jnz	short loc_7C79

loc_7C11:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+14Aj
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_F0], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+var_F0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 61h ; 'a'
		jz	short loc_7C4B
		movzx	edx, [ebp+var_14]
		cmp	edx, 41h ; 'A'
		jnz	short loc_7C79

loc_7C4B:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+184j
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?charAt@UnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::charAt(int)
		mov	[ebp+var_14], ax
		movzx	ecx, [ebp+var_14]
		cmp	ecx, 6Ch ; 'l'
		jz	short loc_7C70
		movzx	edx, [ebp+var_14]
		cmp	edx, 4Ch ; 'L'
		jnz	short loc_7C79

loc_7C70:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+1A9j
		mov	[ebp+var_F1], 1
		jmp	short loc_7C80
; ---------------------------------------------------------------------------

loc_7C79:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+5Bj
					; icu_56::MessagePattern::isOrdinal(int)+99j ...
		mov	[ebp+var_F1], 0

loc_7C80:				; CODE XREF: icu_56::MessagePattern::isOrdinal(int)+1BBj
		mov	al, [ebp+var_F1]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?isOrdinal@MessagePattern@icu_56@@AAECH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::MessagePattern::inMessageFormatPattern(icu_56::MessagePattern *this,	int)
		public ?inMessageFormatPattern@MessagePattern@icu_56@@AAECH@Z
?inMessageFormatPattern@MessagePattern@icu_56@@AAECH@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseChoiceStyle(int,int,UParseError *,UErrorCode &)+254p
					; icu_56::MessagePattern::parsePluralOrSelectStyle(UMessagePatternArgType,int,int,UParseError *,UErrorCode &)+9Ap

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_7CE0
		push	0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		cmp	dword ptr [eax], 0
		jz	short loc_7CE0
		mov	[ebp+var_CD], 0
		jmp	short loc_7CE7
; ---------------------------------------------------------------------------

loc_7CE0:				; CODE XREF: icu_56::MessagePattern::inMessageFormatPattern(int)+27j
					; icu_56::MessagePattern::inMessageFormatPattern(int)+39j
		mov	[ebp+var_CD], 1

loc_7CE7:				; CODE XREF: icu_56::MessagePattern::inMessageFormatPattern(int)+42j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?inMessageFormatPattern@MessagePattern@icu_56@@AAECH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: signed char __thiscall icu_56::MessagePattern::inTopLevelChoiceMessage(int, enum  UMessagePatternArgType)
		public ?inTopLevelChoiceMessage@MessagePattern@icu_56@@AAECHW4UMessagePatternArgType@@@Z
?inTopLevelChoiceMessage@MessagePattern@icu_56@@AAECHW4UMessagePatternArgType@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+39Ep

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 1
		jnz	short loc_7D4E
		cmp	[ebp+arg_4], 2
		jnz	short loc_7D4E
		push	0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		cmp	dword ptr [eax], 0
		jz	short loc_7D4E
		mov	[ebp+var_CD], 1
		jmp	short loc_7D55
; ---------------------------------------------------------------------------

loc_7D4E:				; CODE XREF: icu_56::MessagePattern::inTopLevelChoiceMessage(int,UMessagePatternArgType)+27j
					; icu_56::MessagePattern::inTopLevelChoiceMessage(int,UMessagePatternArgType)+2Dj ...
		mov	[ebp+var_CD], 0

loc_7D55:				; CODE XREF: icu_56::MessagePattern::inTopLevelChoiceMessage(int,UMessagePatternArgType)+48j
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?inTopLevelChoiceMessage@MessagePattern@icu_56@@AAECHW4UMessagePatternArgType@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MessagePattern::addPart(enum	 UMessagePatternPartType, int, int, int, enum  UErrorCode &)
		public ?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z
?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+76p
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+10Bp ...

var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= word ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+50h]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		call	?ensureCapacityForOneMore@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_7E15
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+50h]
		mov	[ebp+var_DC], ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+50h]
		add	eax, 1
		mov	ecx, [ebp+var_8]
		mov	[ecx+50h], eax
		mov	edx, [ebp+var_DC]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+48h]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_14]
		mov	cx, [ebp+arg_8]
		mov	[eax+8], cx
		mov	eax, [ebp+var_14]
		mov	cx, [ebp+arg_C]
		mov	[eax+0Ah], cx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0

loc_7E15:				; CODE XREF: icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)+3Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MessagePattern::addLimitPart(int, enum  UMessagePatternPartType, int, int, int, enum	 UErrorCode &)
		public ?addLimitPart@MessagePattern@icu_56@@AAEXHW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z
?addLimitPart@MessagePattern@icu_56@@AAEXHW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+36Ep
					; icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+3DCp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	ecx, [ecx+48h]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		mov	edx, [ebp+var_8]
		mov	ecx, [edx+50h]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?addLimitPart@MessagePattern@icu_56@@AAEXHW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7E9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::MessagePattern::addArgDoublePart(icu_56::MessagePattern *this, double, int, int, enum	UErrorCode *)
		public ?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z
?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z proc	near
					; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+193p
					; icu_56::MessagePattern::parseDouble(int,int,signed char,UParseError *,UErrorCode &)+317p

var_100		= dword	ptr -100h
var_F8		= dword	ptr -0F8h
var_EC		= dword	ptr -0ECh
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= qword	ptr  8
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_100]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7EF8
		jmp	loc_8000
; ---------------------------------------------------------------------------

loc_7EF8:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+55j
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+5Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_7F7F
		push	50h ; 'P'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_EC], eax
		mov	[ebp+var_4], 0
		cmp	[ebp+var_EC], 0
		jz	short loc_7F3D
		mov	ecx, [ebp+var_EC] ; this
		call	??0MessagePatternDoubleList@icu_56@@QAE@XZ ; icu_56::MessagePatternDoubleList::MessagePatternDoubleList(void)
		mov	[ebp+var_100], eax
		jmp	short loc_7F47
; ---------------------------------------------------------------------------

loc_7F3D:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+8Cj
		mov	[ebp+var_100], 0

loc_7F47:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+9Fj
		mov	eax, [ebp+var_100]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_F8]
		mov	[ecx+54h], edx
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax+54h], 0
		jnz	short loc_7F7D
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		jmp	loc_8000
; ---------------------------------------------------------------------------

loc_7F7D:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+D1j
		jmp	short loc_7FB4
; ---------------------------------------------------------------------------

loc_7F7F:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+6Cj
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+5Ch]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		call	?ensureCapacityForOneMore@?$MessagePatternList@N$07@icu_56@@QAECHAAW4UErrorCode@@@Z ; icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode &)
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_7FA0
		jmp	short loc_8000
; ---------------------------------------------------------------------------
		jmp	short loc_7FB4
; ---------------------------------------------------------------------------

loc_7FA0:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+FEj
		cmp	[ebp+var_20], 7FFFh
		jle	short loc_7FB4
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 8
		jmp	short loc_8000
; ---------------------------------------------------------------------------

loc_7FB4:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&):loc_7F7Dj
					; icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode &)+102j ...
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+5Ch]
		mov	[ebp+var_100], ecx
		mov	edx, [ebp+var_14]
		mov	eax, [edx+5Ch]
		add	eax, 1
		mov	ecx, [ebp+var_14]
		mov	[ecx+5Ch], eax
		mov	edx, [ebp+var_100]
		push	edx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+54h]
		call	??A?$MaybeStackArray@N$07@icu_56@@QAEAANH@Z ; icu_56::MaybeStackArray<double,8>::operator[](int)
		fld	[ebp+arg_0]
		fstp	qword ptr [eax]
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		push	0Dh
		mov	ecx, [ebp+var_14]

loc_7FFB:				; DATA XREF: .rdata:int	const icu_56::MessagePattern::Part::MAX_VALUEo
		call	?addPart@MessagePattern@icu_56@@AAEXW4UMessagePatternPartType@@HHHAAW4UErrorCode@@@Z ; icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)

loc_8000:				; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+57j
					; icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode &)+DCj ...
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 8024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00008054o
		mov	eax, [ebp-0ECh]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		pop	ecx
		retn
__unwindfunclet$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-104h]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z endp

_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 8050h
__unwindtable$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00008060o
		dd offset __unwindfunclet$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z$0
__ehfuncinfo$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$?addArgDoublePart@MessagePattern@icu_56@@AAEXNHHAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 807Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::MessagePattern::setParseError(icu_56::MessagePattern *this, struct UParseError *, int)
		public ?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z
?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z proc near
					; CODE XREF: icu_56::MessagePattern::parseMessage(int,int,int,UMessagePatternArgType,UParseError *,UErrorCode &)+3B3p
					; icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode	&)+9Ap	...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jnz	short loc_80AA
		jmp	loc_819F
; ---------------------------------------------------------------------------

loc_80AA:				; CODE XREF: icu_56::MessagePattern::setParseError(UParseError *,int)+27j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 10h
		jl	short loc_80F8
		mov	[ebp+var_14], 0Fh
		cmp	[ebp+var_14], 0
		jle	short loc_80F8
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	??AUnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::operator[](int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_80F8
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_80F8:				; CODE XREF: icu_56::MessagePattern::setParseError(UParseError *,int)+41j
					; icu_56::MessagePattern::setParseError(UParseError *,int)+4Ej	...
		push	0		; int
		mov	eax, [ebp+arg_0]
		add	eax, 8
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+var_14]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z ; icu_56::UnicodeString::extract(int,int,wchar_t *,int)
		xor	eax, eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx*2+8], ax
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 10h
		jl	short loc_8176
		mov	[ebp+var_14], 0Fh
		cmp	[ebp+var_14], 0
		jle	short loc_8176
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		lea	edx, [ecx+eax-1]
		push	edx
		mov	ecx, [ebp+var_8]
		add	ecx, 8
		call	??AUnicodeString@icu_56@@QBE_WH@Z ; icu_56::UnicodeString::operator[](int)
		movzx	eax, ax
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_8176
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_8176:				; CODE XREF: icu_56::MessagePattern::setParseError(UParseError *,int)+BDj
					; icu_56::MessagePattern::setParseError(UParseError *,int)+CAj	...
		push	0		; int
		mov	eax, [ebp+arg_0]
		add	eax, 28h ; '('
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8]
		add	ecx, 8		; this
		call	?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z ; icu_56::UnicodeString::extract(int,int,wchar_t *,int)
		xor	eax, eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx*2+28h], ax

loc_819F:				; CODE XREF: icu_56::MessagePattern::setParseError(UParseError *,int)+29j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setParseError@MessagePattern@icu_56@@AAEXPAUUParseError@@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 81B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::MessageImpl::appendReducedApostrophes(const struct icu_56::UnicodeString	*, int,	int, struct icu_56::UnicodeString *)
		public ?appendReducedApostrophes@MessageImpl@icu_56@@SAXABVUnicodeString@2@HHAAV32@@Z
?appendReducedApostrophes@MessageImpl@icu_56@@SAXABVUnicodeString@2@HHAAV32@@Z proc near
					; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+11Cp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh

loc_81DD:				; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &):loc_825Fj
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	27h ; '''       ; wchar_t
		mov	ecx, [ebp+arg_0] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEH_WH@Z ; icu_56::UnicodeString::indexOf(wchar_t,int)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jl	short loc_81FC
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_8]
		jl	short loc_8215

loc_81FC:				; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+3Aj
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_C] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString	const &,int,int)
		jmp	short loc_8264
; ---------------------------------------------------------------------------

loc_8215:				; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+42j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jnz	short loc_8239
		push	27h ; '''       ; wchar_t
		mov	ecx, [ebp+arg_C] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@_W@Z ; icu_56::UnicodeString::append(wchar_t)
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+arg_4], eax
		mov	[ebp+var_8], 0FFFFFFFFh
		jmp	short loc_825F
; ---------------------------------------------------------------------------

loc_8239:				; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+63j
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_C] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString	const &,int,int)
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+arg_4], eax
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], ecx

loc_825F:				; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+7Fj
		jmp	loc_81DD
; ---------------------------------------------------------------------------

loc_8264:				; CODE XREF: icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)+5Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?appendReducedApostrophes@MessageImpl@icu_56@@SAXABVUnicodeString@2@HHAAV32@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8278h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__cdecl	icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(const struct icu_56::MessagePattern *, int, struct icu_56::UnicodeString	*)
		public ?appendSubMessageWithoutSkipSyntax@MessageImpl@icu_56@@SAAAVUnicodeString@2@ABVMessagePattern@2@HAAV32@@Z
?appendSubMessageWithoutSkipSyntax@MessageImpl@icu_56@@SAAAVUnicodeString@2@ABVMessagePattern@2@HAAV32@@Z proc near

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	ecx, [ebp+arg_0] ; this
		call	?getPatternString@MessagePattern@icu_56@@QBEABVUnicodeString@2@XZ ; icu_56::MessagePattern::getPatternString(void)
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	ecx, eax	; this
		call	?getLimit@Part@MessagePattern@icu_56@@QBEHXZ ; icu_56::MessagePattern::Part::getLimit(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_20], eax

loc_82BD:				; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &):loc_83A2j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_2C]
		call	?getType@Part@MessagePattern@icu_56@@QBE?AW4UMessagePatternPartType@@XZ	; icu_56::MessagePattern::Part::getType(void)
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_2C] ; this
		call	?getIndex@Part@MessagePattern@icu_56@@QBEHXZ ; icu_56::MessagePattern::Part::getIndex(void)
		mov	[ebp+var_44], eax
		cmp	[ebp+var_38], 1
		jnz	short loc_8312
		mov	eax, [ebp+var_44]
		sub	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString	const &,int,int)
		jmp	loc_83A7
; ---------------------------------------------------------------------------
		jmp	loc_83A2
; ---------------------------------------------------------------------------

loc_8312:				; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+77j
		cmp	[ebp+var_38], 2
		jnz	short loc_833C
		mov	eax, [ebp+var_44]
		sub	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString	const &,int,int)
		mov	ecx, [ebp+var_2C] ; this
		call	?getLimit@Part@MessagePattern@icu_56@@QBEHXZ ; icu_56::MessagePattern::Part::getLimit(void)
		mov	[ebp+var_14], eax
		jmp	short loc_83A2
; ---------------------------------------------------------------------------

loc_833C:				; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+9Ej
		cmp	[ebp+var_38], 5
		jnz	short loc_83A2
		mov	eax, [ebp+var_44]
		sub	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_14]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::append(icu_56::UnicodeString	const &,int,int)
		mov	eax, [ebp+var_44]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getLimitPartIndex@MessagePattern@icu_56@@QBEHH@Z ; icu_56::MessagePattern::getLimitPartIndex(int)
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getPart@MessagePattern@icu_56@@QBEABVPart@12@H@Z ; icu_56::MessagePattern::getPart(int)
		mov	ecx, eax	; this
		call	?getLimit@Part@MessagePattern@icu_56@@QBEHXZ ; icu_56::MessagePattern::Part::getLimit(void)
		mov	[ebp+var_44], eax
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_44]
		push	ecx		; int
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+var_8]
		push	eax		; struct icu_56::UnicodeString *
		call	?appendReducedApostrophes@MessageImpl@icu_56@@SAXABVUnicodeString@2@HHAAV32@@Z ; icu_56::MessageImpl::appendReducedApostrophes(icu_56::UnicodeString const &,int,int,icu_56::UnicodeString &)
		add	esp, 10h
		mov	eax, [ebp+var_44]
		mov	[ebp+var_14], eax

loc_83A2:				; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+95j
					; icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern	const &,int,icu_56::UnicodeString &)+C2j ...
		jmp	loc_82BD
; ---------------------------------------------------------------------------

loc_83A7:				; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+90j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?appendSubMessageWithoutSkipSyntax@MessageImpl@icu_56@@SAAAVUnicodeString@2@ABVMessagePattern@2@HAAV32@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::Part::getIndex(icu_56::MessagePattern::Part *__hidden this)
		public ?getIndex@Part@MessagePattern@icu_56@@QBEHXZ
?getIndex@Part@MessagePattern@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+6Bp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIndex@Part@MessagePattern@icu_56@@QBEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::MessagePattern::Part::getLimit(icu_56::MessagePattern::Part *__hidden this)
		public ?getLimit@Part@MessagePattern@icu_56@@QBEHXZ
?getLimit@Part@MessagePattern@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern const &,int,icu_56::UnicodeString &)+37p
					; icu_56::MessageImpl::appendSubMessageWithoutSkipSyntax(icu_56::MessagePattern	const &,int,icu_56::UnicodeString &)+BAp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movzx	eax, word ptr [eax+8]
		mov	ecx, [ebp+var_8]
		add	eax, [ecx+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLimit@Part@MessagePattern@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8424h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8464h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84A4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 84D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MessagePatternList<double,	8>::MessagePatternList<double, 8>(void)
		public ??0?$MessagePatternList@N$07@icu_56@@QAE@XZ
??0?$MessagePatternList@N$07@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternDoubleList::MessagePatternDoubleList(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??0?$MaybeStackArray@N$07@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<double,8>::MaybeStackArray<double,8>(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$MessagePatternList@N$07@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8518h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<double, 8>::~MaybeStackArray<double, 8>(void)
		public ??1?$MaybeStackArray@N$07@icu_56@@QAE@XZ
??1?$MaybeStackArray@N$07@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternList<double,8>::~MessagePatternList<double,8>(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@N$07@icu_56@@AAEXXZ ; icu_56::MaybeStackArray<double,8>::releaseArray(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackArray@N$07@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8558h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: double * __thiscall icu_56::MaybeStackArray<double, 8>::getAlias(void)const
		public ?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ
?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ proc near
					; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+20Dp
					; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode	&)+254p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8588h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: double & __thiscall icu_56::MaybeStackArray<double, 8>::operator[](int)
		public ??A?$MaybeStackArray@N$07@icu_56@@QAEAANH@Z
??A?$MaybeStackArray@N$07@icu_56@@QAEAANH@Z proc near
					; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+140p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_0]
		lea	eax, [ecx+edx*8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@N$07@icu_56@@QAEAANH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 85C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MessagePatternList<class icu_56::MessagePattern::Part, 32>::MessagePatternList<class icu_56::MessagePattern::Part,	32>(void)
		public ??0?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ
??0?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternPartsList::MessagePatternPartsList(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	??0?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ ; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::MaybeStackArray<icu_56::MessagePattern::Part,32>(void)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8604h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePatternList<class icu_56::MessagePattern::Part,	32>::equals(class icu_56::MessagePatternList<class icu_56::MessagePattern::Part, 32> const &, int)const
		public ?equals@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBECABV12@H@Z
?equals@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBECABV12@H@Z proc near
					; CODE XREF: icu_56::MessagePattern::operator==(icu_56::MessagePattern const &)+81p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_8639
; ---------------------------------------------------------------------------

loc_8630:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int):loc_866Cj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_8639:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int)+2Aj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jge	short loc_866E
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEABVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEABVPart@MessagePattern@1@H@Z	; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::operator[](int)
		mov	ecx, eax
		call	??9Part@MessagePattern@icu_56@@QBECABV012@@Z ; icu_56::MessagePattern::Part::operator!=(icu_56::MessagePattern::Part const &)
		movsx	edx, al
		test	edx, edx
		jz	short loc_866C
		xor	al, al
		jmp	short loc_8670
; ---------------------------------------------------------------------------

loc_866C:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int)+62j
		jmp	short loc_8630
; ---------------------------------------------------------------------------

loc_866E:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int)+3Bj
		mov	al, 1

loc_8670:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int)+66j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?equals@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBECABV12@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8688h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePattern::Part::operator!=(class	icu_56::MessagePattern::Part const &)const
		public ??9Part@MessagePattern@icu_56@@QBECABV012@@Z
??9Part@MessagePattern@icu_56@@QBECABV012@@Z proc near
					; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int)+58p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8Part@MessagePattern@icu_56@@QBECABV012@@Z ; icu_56::MessagePattern::Part::operator==(icu_56::MessagePattern::Part const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9Part@MessagePattern@icu_56@@QBECABV012@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 86D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<class icu_56::MessagePattern::Part, 32>::~MaybeStackArray<class icu_56::MessagePattern::Part, 32>(void)
		public ??1?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ
??1?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::~MessagePatternList<icu_56::MessagePattern::Part,32>(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@AAEXXZ ; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::releaseArray(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8718h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::MessagePattern::Part * __thiscall icu_56::MaybeStackArray<class	icu_56::MessagePattern::Part, 32>::getAlias(void)const
		public ?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ
?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ proc near
					; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+D9p
					; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode	&)+111p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8748h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::MessagePattern::Part & __thiscall icu_56::MaybeStackArray<class	icu_56::MessagePattern::Part, 32>::operator[](int)
		public ??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z
??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	proc near
					; CODE XREF: icu_56::MessagePattern::parseArg(int,int,int,UParseError *,UErrorCode &)+3EAp
					; icu_56::MessagePattern::inMessageFormatPattern(int)+31p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEAAVPart@MessagePattern@1@H@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_87BA
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_87C6
; ---------------------------------------------------------------------------

loc_87BA:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_87C6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 87D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<double, 8>::MaybeStackArray<double, 8>(void)
		public ??0?$MaybeStackArray@N$07@icu_56@@QAE@XZ
??0?$MaybeStackArray@N$07@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternList<double,8>::MessagePatternList<double,8>(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 10h
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 8
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackArray@N$07@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8820h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<double, 8>::releaseArray(void)
		public ?releaseArray@?$MaybeStackArray@N$07@icu_56@@AAEXXZ
?releaseArray@?$MaybeStackArray@N$07@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackArray<double,8>::~MaybeStackArray<double,8>(void)+26p
					; icu_56::MaybeStackArray<double,8>::resize(int,int)+99p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_885C
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_885C:				; CODE XREF: icu_56::MaybeStackArray<double,8>::releaseArray(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseArray@?$MaybeStackArray@N$07@icu_56@@AAEXXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::MaybeStackArray<class icu_56::MessagePattern::Part, 32>::MaybeStackArray<class icu_56::MessagePattern::Part, 32>(void)
		public ??0?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ
??0?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ proc near
					; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::MessagePatternList<icu_56::MessagePattern::Part,32>(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 20h ; ' '
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 0
		push	offset ??0Part@MessagePattern@icu_56@@QAE@XZ ; icu_56::MessagePattern::Part::Part(void)
		push	20h ; ' '
		push	10h
		mov	eax, [ebp+var_8]
		add	eax, 0Ch
		push	eax
		call	??_H@YGXPAXIHP6EPAX0@Z@Z ; `vector constructor iterator'(void *,uint,int,void * (*)(void *))
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 88DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::MessagePattern::Part::Part(icu_56::MessagePattern::Part *__hidden this)
		public ??0Part@MessagePattern@icu_56@@QAE@XZ
??0Part@MessagePattern@icu_56@@QAE@XZ proc near
					; DATA XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::MaybeStackArray<icu_56::MessagePattern::Part,32>(void)+3Fo

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0Part@MessagePattern@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 890Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::MessagePattern::Part const & __thiscall	icu_56::MaybeStackArray<class icu_56::MessagePattern::Part, 32>::operator[](int)const
		public ??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEABVPart@MessagePattern@1@H@Z
??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEABVPart@MessagePattern@1@H@Z	proc near
					; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int)+44p
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::equals(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const	&,int)+51p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		shl	eax, 4
		mov	ecx, [ebp+var_8]
		add	eax, [ecx]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??A?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEABVPart@MessagePattern@1@H@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8944h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::MaybeStackArray<class icu_56::MessagePattern::Part, 32>::releaseArray(void)
		public ?releaseArray@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@AAEXXZ
?releaseArray@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::~MaybeStackArray<icu_56::MessagePattern::Part,32>(void)+26p
					; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+99p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_8980
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_free_56
		add	esp, 4

loc_8980:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::releaseArray(void)+2Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?releaseArray@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@AAEXXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8994h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __stdcall `vector constructor iterator'(void *, unsigned int, int, void * (__thiscall *)(void *))
		public ??_H@YGXPAXIHP6EPAX0@Z@Z
??_H@YGXPAXIHP6EPAX0@Z@Z proc near	; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::MaybeStackArray<icu_56::MessagePattern::Part,32>(void)+4Fp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_89B2:				; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+41j
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		js	short loc_89D7
		mov	esi, esp
		mov	ecx, [ebp+arg_0]
		call	[ebp+arg_C]
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		add	eax, [ebp+arg_4]
		mov	[ebp+arg_0], eax
		jmp	short loc_89B2
; ---------------------------------------------------------------------------

loc_89D7:				; CODE XREF: `vector constructor iterator'(void *,uint,int,void * (*)(void *))+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??_H@YGXPAXIHP6EPAX0@Z@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 89F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MessagePatternList<double, 8>::copyFrom(class	icu_56::MessagePatternList<double, 8> const &, int, enum  UErrorCode &)
		public ?copyFrom@?$MessagePatternList@N$07@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z
?copyFrom@?$MessagePatternList@N$07@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+230p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8A8C
		cmp	[ebp+arg_4], 0
		jle	short loc_8A8C
		mov	ecx, [ebp+var_8]
		call	?getCapacity@?$MaybeStackArray@N$07@icu_56@@QBEHXZ ; icu_56::MaybeStackArray<double,8>::getCapacity(void)
		cmp	[ebp+arg_4], eax
		jle	short loc_8A58
		push	0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?resize@?$MaybeStackArray@N$07@icu_56@@QAEPANHH@Z ; icu_56::MaybeStackArray<double,8>::resize(int,int)
		test	eax, eax
		jnz	short loc_8A58
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_8A8C
; ---------------------------------------------------------------------------

loc_8A58:				; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+49j
					; icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode &)+5Bj
		push	1
		mov	ecx, [ebp+arg_0]
		call	?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ ; icu_56::MaybeStackArray<double,8>::getAlias(void)
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	eax, [ebp+arg_4]
		shl	eax, 3
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		call	?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ ; icu_56::MaybeStackArray<double,8>::getAlias(void)
		push	eax		; Src
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@N$07@icu_56@@QBEPANXZ ; icu_56::MaybeStackArray<double,8>::getAlias(void)
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8A8C:				; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+36j
					; icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode &)+3Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?copyFrom@?$MessagePatternList@N$07@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8AA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+29p
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+29p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePatternList<double, 8>::ensureCapacityForOneMore(int, enum  UErrorCode &)
		public ?ensureCapacityForOneMore@?$MessagePatternList@N$07@icu_56@@QAECHAAW4UErrorCode@@@Z
?ensureCapacityForOneMore@?$MessagePatternList@N$07@icu_56@@QAECHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::addArgDoublePart(double,int,int,UErrorCode	&)+F4p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8B0C
		xor	al, al
		jmp	short loc_8B3E
; ---------------------------------------------------------------------------

loc_8B0C:				; CODE XREF: icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode &)+36j
		mov	ecx, [ebp+var_8]
		call	?getCapacity@?$MaybeStackArray@N$07@icu_56@@QBEHXZ ; icu_56::MaybeStackArray<double,8>::getCapacity(void)
		cmp	eax, [ebp+arg_0]
		jg	short loc_8B2F
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 1
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?resize@?$MaybeStackArray@N$07@icu_56@@QAEPANHH@Z ; icu_56::MaybeStackArray<double,8>::resize(int,int)
		test	eax, eax
		jz	short loc_8B33

loc_8B2F:				; CODE XREF: icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode &)+47j
		mov	al, 1
		jmp	short loc_8B3E
; ---------------------------------------------------------------------------

loc_8B33:				; CODE XREF: icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode &)+5Dj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al

loc_8B3E:				; CODE XREF: icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode &)+3Aj
					; icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode	&)+61j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacityForOneMore@?$MessagePatternList@N$07@icu_56@@QAECHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::MessagePatternList<class icu_56::MessagePattern::Part, 32>::copyFrom(class icu_56::MessagePatternList<class icu_56::MessagePattern::Part, 32>	const &, int, enum  UErrorCode &)
		public ?copyFrom@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z
?copyFrom@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::MessagePattern::copyStorage(icu_56::MessagePattern	const &,UErrorCode &)+13Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8BF0
		cmp	[ebp+arg_4], 0
		jle	short loc_8BF0
		mov	ecx, [ebp+var_8]
		call	?getCapacity@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEHXZ ; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getCapacity(void)
		cmp	[ebp+arg_4], eax
		jle	short loc_8BBC
		push	0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?resize@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEPAVPart@MessagePattern@2@HH@Z ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)
		test	eax, eax
		jnz	short loc_8BBC
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_8BF0
; ---------------------------------------------------------------------------

loc_8BBC:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+49j
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+5Bj
		push	1
		mov	ecx, [ebp+arg_0]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	eax, [ebp+arg_4]
		shl	eax, 4
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		push	eax		; Src
		mov	ecx, [ebp+var_8]
		call	?getAlias@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEPAVPart@MessagePattern@2@XZ ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getAlias(void)
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8BF0:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+36j
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+3Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?copyFrom@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEXABV12@HAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C08h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::MessagePatternList<class icu_56::MessagePattern::Part,	32>::ensureCapacityForOneMore(int, enum	 UErrorCode &)
		public ?ensureCapacityForOneMore@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAECHAAW4UErrorCode@@@Z
?ensureCapacityForOneMore@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAECHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::MessagePattern::addPart(UMessagePatternPartType,int,int,int,UErrorCode &)+34p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8C44
		xor	al, al
		jmp	short loc_8C76
; ---------------------------------------------------------------------------

loc_8C44:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+36j
		mov	ecx, [ebp+var_8]
		call	?getCapacity@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEHXZ ; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::getCapacity(void)
		cmp	eax, [ebp+arg_0]
		jg	short loc_8C67
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		shl	ecx, 1
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?resize@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEPAVPart@MessagePattern@2@HH@Z ;	icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)
		test	eax, eax
		jz	short loc_8C6B

loc_8C67:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+47j
		mov	al, 1
		jmp	short loc_8C76
; ---------------------------------------------------------------------------

loc_8C6B:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+5Dj
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al

loc_8C76:				; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+3Aj
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+61j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacityForOneMore@?$MessagePatternList@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAECHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackArray<double, 8>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackArray@N$07@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackArray@N$07@icu_56@@QBEHXZ proc	near
					; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+41p
					; icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode	&)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackArray@N$07@icu_56@@QBEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8CBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: int __thiscall icu_56::MaybeStackArray<class icu_56::MessagePattern::Part, 32>::getCapacity(void)const
		public ?getCapacity@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEHXZ
?getCapacity@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+41p
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QBEHXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8CECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: double * __thiscall icu_56::MaybeStackArray<double, 8>::resize(int, int)
		public ?resize@?$MaybeStackArray@N$07@icu_56@@QAEPANHH@Z
?resize@?$MaybeStackArray@N$07@icu_56@@QAEPANHH@Z proc near
					; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+54p
					; icu_56::MessagePatternList<double,8>::ensureCapacityForOneMore(int,UErrorCode	&)+56p

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jle	loc_8DA9
		mov	eax, [ebp+arg_0]
		shl	eax, 3
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_8DA2
		cmp	[ebp+arg_4], 0
		jle	short loc_8D82
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jle	short loc_8D4B
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_4], ecx

loc_8D4B:				; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+54j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jle	short loc_8D59
		mov	eax, [ebp+arg_0]
		mov	[ebp+arg_4], eax

loc_8D59:				; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+65j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_4]
		shl	edx, 3
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8D82:				; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+49j
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@N$07@icu_56@@AAEXXZ ; icu_56::MaybeStackArray<double,8>::releaseArray(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_8DA2:				; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+43j
		mov	eax, [ebp+Dst]
		jmp	short loc_8DAB
; ---------------------------------------------------------------------------
		jmp	short loc_8DAB
; ---------------------------------------------------------------------------

loc_8DA9:				; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+27j
		xor	eax, eax

loc_8DAB:				; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+B9j
					; icu_56::MaybeStackArray<double,8>::resize(int,int)+BBj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackArray@N$07@icu_56@@QAEPANHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8DC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::MessagePattern::Part * __thiscall icu_56::MaybeStackArray<class	icu_56::MessagePattern::Part, 32>::resize(int, int)
		public ?resize@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEPAVPart@MessagePattern@2@HH@Z
?resize@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEPAVPart@MessagePattern@2@HH@Z proc near
					; CODE XREF: icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+54p
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::ensureCapacityForOneMore(int,UErrorCode &)+56p

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jle	loc_8E81
		mov	eax, [ebp+arg_0]
		shl	eax, 4
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jz	short loc_8E7A
		cmp	[ebp+arg_4], 0
		jle	short loc_8E5A
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jle	short loc_8E23
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_4], ecx

loc_8E23:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+54j
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_0]
		jle	short loc_8E31
		mov	eax, [ebp+arg_0]
		mov	[ebp+arg_4], eax

loc_8E31:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+65j
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_4]
		shl	edx, 4
		push	edx		; Size
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8E5A:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+49j
		mov	ecx, [ebp+var_8]
		call	?releaseArray@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@AAEXXZ ; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::releaseArray(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+8], 1

loc_8E7A:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+43j
		mov	eax, [ebp+Dst]
		jmp	short loc_8E83
; ---------------------------------------------------------------------------
		jmp	short loc_8E83
; ---------------------------------------------------------------------------

loc_8E81:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+27j
		xor	eax, eax

loc_8E83:				; CODE XREF: icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+B9j
					; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+BBj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?resize@?$MaybeStackArray@VPart@MessagePattern@icu_56@@$0CA@@icu_56@@QAEPAVPart@MessagePattern@2@HH@Z endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000250o
					; .rdata:00000504o ...
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:00000508o
					; .rdata:0000050Co ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00000514o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:00000518o
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:00000BC4o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:00000BC8o
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00001140o
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:00001144o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:00001148o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:0000114Co
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:00001150o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:00001154o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:00001158o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:0000115Co
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:00001160o
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
					; icu_56::MessagePattern::getSubstring(icu_56::MessagePattern::Part const &)+46p
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
		extrn ___security_cookie:near
					; DATA XREF: icu_56::MessagePattern::MessagePattern(UErrorCode &)+2Er
					; icu_56::MessagePattern::MessagePattern(UMessagePatternApostropheMode,UErrorCode &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z+19j
					; __ehhandler$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0MessagePattern@icu_56@@QAE@AAW4UErrorCode@@@Z+Fp
					; __ehhandler$??0MessagePattern@icu_56@@QAE@W4UMessagePatternApostropheMode@@AAW4UErrorCode@@@Z+Fp ...
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn ??2UMemory@icu_56@@SAPAXI@Z:near
					; CODE XREF: icu_56::MessagePattern::init(UErrorCode &)+63p
					; icu_56::MessagePattern::copyStorage(icu_56::MessagePattern const &,UErrorCode	&)+98p	...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern const &)+77p
					; icu_56::MessagePattern::autoQuoteApostropheDeep(void)+64p ...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::MessagePattern::MessagePattern(icu_56::MessagePattern const &)+11Ap
					; icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+A5p ...
; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(class icu_56::UnicodeString	const &)
		extrn ??4UnicodeString@icu_56@@QAEAAV01@ABV01@@Z:near
					; CODE XREF: icu_56::MessagePattern::operator=(icu_56::MessagePattern const &)+49p
					; icu_56::MessagePattern::preParse(icu_56::UnicodeString const &,UParseError *,UErrorCode &)+6Fp
; signed __int8	__cdecl	static icu_56::PatternProps::isIdentifier(const	wchar_t	*, int)
		extrn ?isIdentifier@PatternProps@icu_56@@SACPB_WH@Z:near
					; CODE XREF: icu_56::MessagePattern::validateArgumentName(icu_56::UnicodeString	const &)+30p
; public: __thiscall icu_56::UnicodeString::UnicodeString(class	icu_56::UnicodeString &&)
		extrn ??0UnicodeString@icu_56@@QAE@$$QAV01@@Z:near
					; CODE XREF: icu_56::MessagePattern::autoQuoteApostropheDeep(void)+105p
		extrn __fltused:near
; double __cdecl _strtod(const char *Str, char **EndPtr)
		extrn __imp__strtod:near
					; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+2CCp
					; DATA XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+2CCr
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+2AAp
; int __thiscall __high	icu_56::UnicodeString::extract(int, int, char *, int, enum icu_56::UnicodeString::EInvariant)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADHW4EInvariant@12@@Z:near
					; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+29Ep
		extrn _uprv_getInfinity_56:near
					; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+151p
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near
					; CODE XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+65p
					; DATA XREF: icu_56::MessagePattern::parseDouble(int,int,signed	char,UParseError *,UErrorCode &)+65r
; const	wchar_t	*__cdecl static	icu_56::PatternProps::skipWhiteSpace(const wchar_t *, int)
		extrn ?skipWhiteSpace@PatternProps@icu_56@@SAPB_WPB_WH@Z:near
					; CODE XREF: icu_56::MessagePattern::skipWhiteSpace(int)+50p
; const	wchar_t	*__cdecl static	icu_56::PatternProps::skipIdentifier(const wchar_t *, int)
		extrn ?skipIdentifier@PatternProps@icu_56@@SAPB_WPB_WH@Z:near
					; CODE XREF: icu_56::MessagePattern::skipIdentifier(int)+50p
		extrn _uprv_free_56:near
					; CODE XREF: icu_56::MaybeStackArray<double,8>::releaseArray(void)+34p
					; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::releaseArray(void)+34p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+94p
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+94p ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: icu_56::MessagePatternList<double,8>::copyFrom(icu_56::MessagePatternList<double,8> const &,int,UErrorCode	&)+73p
					; icu_56::MessagePatternList<icu_56::MessagePattern::Part,32>::copyFrom(icu_56::MessagePatternList<icu_56::MessagePattern::Part,32> const &,int,UErrorCode &)+73p ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::MaybeStackArray<double,8>::resize(int,int)+34p
					; icu_56::MaybeStackArray<icu_56::MessagePattern::Part,32>::resize(int,int)+34p


		end
