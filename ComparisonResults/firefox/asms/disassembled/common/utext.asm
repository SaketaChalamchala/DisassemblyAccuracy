;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F623562E72EEB6C25F21CF0EB32B42F4
; Input	CRC32 :	F8FB251E

; File Name   :	D:\compspace\objfiles\firefox\common\utext.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		public ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 0>::value
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	db 0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 4
		public ?value@?$integral_constant@_N$00@tr1@std@@2_NB
; public: static bool const std::tr1::integral_constant<bool, 1>::value
?value@?$integral_constant@_N$00@tr1@std@@2_NB db 1
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8
		public ?value@?$integral_constant@I$0A@@tr1@std@@2IB
; public: static unsigned int const std::tr1::integral_constant<unsigned int, 0>::value
?value@?$integral_constant@I$0A@@tr1@std@@2IB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0Ch
		public ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
; public: static int const std::_Arithmetic_traits<bool>::_Rank
?_Rank@?$_Arithmetic_traits@_N@std@@2HB	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
		public ?_Rank@?$_Arithmetic_traits@D@std@@2HB
; public: static int const std::_Arithmetic_traits<char>::_Rank
?_Rank@?$_Arithmetic_traits@D@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 14h
		public ?_Rank@?$_Arithmetic_traits@C@std@@2HB
; public: static int const std::_Arithmetic_traits<signed char>::_Rank
?_Rank@?$_Arithmetic_traits@C@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18h
		public ?_Rank@?$_Arithmetic_traits@E@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned char>::_Rank
?_Rank@?$_Arithmetic_traits@E@std@@2HB dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
		public ?_Rank@?$_Arithmetic_traits@F@std@@2HB
; public: static int const std::_Arithmetic_traits<short>::_Rank
?_Rank@?$_Arithmetic_traits@F@std@@2HB dd 3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
		public ?_Rank@?$_Arithmetic_traits@G@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned short>::_Rank
?_Rank@?$_Arithmetic_traits@G@std@@2HB dd 3
					; DATA XREF: .rdata:int	const std::_Locbase<int>::messageso
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::showposo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 24h
		public ?_Rank@?$_Arithmetic_traits@H@std@@2HB
; public: static int const std::_Arithmetic_traits<int>::_Rank
?_Rank@?$_Arithmetic_traits@H@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 28h
		public ?_Rank@?$_Arithmetic_traits@I@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned int>::_Rank
?_Rank@?$_Arithmetic_traits@I@std@@2HB dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2Ch
		public ?_Rank@?$_Arithmetic_traits@J@std@@2HB
; public: static int const std::_Arithmetic_traits<long>::_Rank
?_Rank@?$_Arithmetic_traits@J@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30h
		public ?_Rank@?$_Arithmetic_traits@K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned long>::_Rank
?_Rank@?$_Arithmetic_traits@K@std@@2HB dd 5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 34h
		public ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
; public: static int const std::_Arithmetic_traits<__int64>::_Rank
?_Rank@?$_Arithmetic_traits@_J@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38h
		public ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
; public: static int const std::_Arithmetic_traits<unsigned __int64>::_Rank
?_Rank@?$_Arithmetic_traits@_K@std@@2HB	dd 6
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3Ch
		public ?_Rank@?$_Arithmetic_traits@M@std@@2HB
; public: static int const std::_Arithmetic_traits<float>::_Rank
?_Rank@?$_Arithmetic_traits@M@std@@2HB dd 7
					; DATA XREF: .rdata:int	const std::_Locbase<int>::allo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
		public ?_Rank@?$_Arithmetic_traits@N@std@@2HB
; public: static int const std::_Arithmetic_traits<double>::_Rank
?_Rank@?$_Arithmetic_traits@N@std@@2HB dd 8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::lefto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Nocreateo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44h
		public ?_Rank@?$_Arithmetic_traits@O@std@@2HB
; public: static int const std::_Arithmetic_traits<long	double>::_Rank
?_Rank@?$_Arithmetic_traits@O@std@@2HB dd 9
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48h
		public ?collate@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::collate
?collate@?$_Locbase@H@std@@2HB dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
		public ?ctype@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::ctype
?ctype@?$_Locbase@H@std@@2HB dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50h
		public ?monetary@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::monetary
?monetary@?$_Locbase@H@std@@2HB	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 54h
		public ?numeric@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::numeric
?numeric@?$_Locbase@H@std@@2HB dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 58h
		public ?time@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::time
?time@?$_Locbase@H@std@@2HB dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5Ch
		public ?messages@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::messages
?messages@?$_Locbase@H@std@@2HB	dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 60h
		public ?all@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::all
?all@?$_Locbase@H@std@@2HB dd offset ?_Rank@?$_Arithmetic_traits@M@std@@2HB+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
		public ?none@?$_Locbase@H@std@@2HB
; public: static int const std::_Locbase<int>::none
?none@?$_Locbase@H@std@@2HB dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 68h
		public ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::skipws
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6Ch
		public ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::unitbuf
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
		public ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::uppercase
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 4 ; DATA	XREF: .rdata:00000104o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74h
		public ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showbase
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 78h
		public ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpoint
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7Ch
		public ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::showpos
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
		public ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::left
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::righto
					; .rdata:std::_Iosb<int>::_Openmode const std::_Iosb<int>::_Noreplaceo
_rdata		ends			; int const std::_Arithmetic_traits<double>::_Rank

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 84h
		public ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::right
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ; std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 88h
		public ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::internal
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset dword_100
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8Ch
		public ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::dec
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	off_200
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 90h
		public ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::oct
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	off_400
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 94h
		public ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hex
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	loc_7FE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 98h
		public ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::scientific
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_FFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
		public ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::fixed
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B	dd offset loc_1FFD+3
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A0h
		public ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::hexfloat
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A4h
		public ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::boolalpha
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_4000
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A8h
		public ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::_Stdio
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_7FFB+5
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
		public ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::adjustfield
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset	off_1C0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B0h
		public ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::basefield
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd offset loc_DFF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B4h
		public ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
; public: static enum  std::_Iosb<int>::_Fmtflags const	std::_Iosb<int>::floatfield
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B dd	offset loc_2FFE+2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8h
		public ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 0
					; DATA XREF: .data:long	`utext_current32_56'::`2'::__LINE__Varo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BCh
		public ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::eofbit
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0h
		public ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::failbit
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4h
		public ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::badbit
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B	dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C8h
		public ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
; public: static enum  std::_Iosb<int>::_Iostate const std::_Iosb<int>::_Hardfail
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CCh
		public ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::in
?in@?$_Iosb@H@std@@2W4_Openmode@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D0h
		public ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::out
?out@?$_Iosb@H@std@@2W4_Openmode@12@B dd 2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D4h
		public ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::ate
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B dd 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D8h
		public ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::app
?app@?$_Iosb@H@std@@2W4_Openmode@12@B dd 8
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::trunc
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B	dd 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E0h
		public ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Nocreate
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
		public ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::_Noreplace
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B dd	offset ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::left
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8h
		public ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
; public: static enum  std::_Iosb<int>::_Openmode const	std::_Iosb<int>::binary
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B dd offset ?_Rank@?$_Arithmetic_traits@G@std@@2HB ; int	const std::_Arithmetic_traits<ushort>::_Rank
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECh
		public ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::beg
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
		public ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::cur
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	1
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
		public ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
; public: static enum  std::_Iosb<int>::_Seekdir const std::_Iosb<int>::end
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B dd	2
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F8h
_emptyText	db ',ØZ4',0             ; DATA XREF: _utext_setup_56+83o
		align 10h
dword_100	dd 0			; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::internalo
		dd offset ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B ;	std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::uppercase
		dd 18h dup(0)
_utf8Funcs	dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: _utext_openUTF8_56+B9o
					; int const std::_Arithmetic_traits<double>::_Rank
		dd 3 dup(0)
		dd offset _utf8TextClone
		dd offset _utf8TextLength
		dd offset _utf8TextAccess
		dd offset _utf8TextExtract
		align 10h
		dd offset _utf8TextMapOffsetToNative
		dd offset _utf8TextMapIndexToUTF16
		dd offset _utf8TextClose
		dd 3 dup(0)
_gEmptyString	dd 2 dup(0)		; DATA XREF: _utext_openUTF8_56+48o
_repFuncs	dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: _utext_openReplaceable_56+B5o
					; int const std::_Arithmetic_traits<double>::_Rank
		align 10h
off_1C0		dd offset _repTextClone	; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::adjustfieldo
		dd offset _repTextLength
		dd offset _repTextAccess
		dd offset _repTextExtract
		dd offset _repTextReplace
		dd offset _repTextCopy
		align 10h
		dd offset _repTextClose
		align 10h
_unistrFuncs	dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: _utext_openConstUnicodeString_56+96o
					; int const std::_Arithmetic_traits<double>::_Rank
		align 10h
off_200		dd offset _unistrTextClone
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::deco
		dd offset _unistrTextLength
		dd offset _unistrTextAccess
		dd offset _unistrTextExtract
		dd offset _unistrTextReplace
		dd offset _unistrTextCopy
		align 10h
		dd offset _unistrTextClose
		align 10h
_ucstrFuncs	dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: _utext_openUChars_56+B5o
					; int const std::_Arithmetic_traits<double>::_Rank
		align 10h
		dd offset _ucstrTextClone
		dd offset _ucstrTextLength
		dd offset _ucstrTextAccess
		dd offset _ucstrTextExtract
		align 20h
		dd offset _ucstrTextClose
		align 10h
_gEmptyUString	dd 2 dup(0)		; DATA XREF: _utext_openUChars_56+48o
_charIterFuncs	dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB
					; DATA XREF: _utext_openCharacterIterator_56+90o
					; int const std::_Arithmetic_traits<double>::_Rank
		dd 3 dup(0)
		dd offset _charIterTextClone
		dd offset _charIterTextLength
		dd offset _charIterTextAccess
		dd offset _charIterTextExtract
		dd 4 dup(0)
		dd offset _charIterTextClose
		dd 3 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 2F0h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 2F4h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 354h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::Replaceable::Replaceable(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3E4h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 3F0h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000003E4o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
off_400		dd offset ??_R3UObject@icu_56@@8
					; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::octo
_rdata$r	ends			; icu_56::UObject::`RTTI Class Hierarchy Descriptor'

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 404h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:000003FCo
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 424h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:off_400o
					; .rdata$r:00000458o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 434h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000430o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 440h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000710o ...
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 45Ch
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000438o
					; .rdata$r:00000714o ...
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 478h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 498h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000474o
					; .rdata$r:000004C8o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4A8h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000004A4o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 10h
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 4B0h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near
					; CODE XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+2Ap

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_503
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_50D
; ---------------------------------------------------------------------------

loc_503:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_50D:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 524h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near
					; CODE XREF: icu_56::Replaceable::operator=(icu_56::Replaceable	const &)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 554h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_593
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_593:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_60D
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_605
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_605:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_62C
; ---------------------------------------------------------------------------

loc_60D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_629
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_629:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_62C:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 644h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *this,	const struct icu_56::Replaceable *)
		public ??0Replaceable@icu_56@@QAE@ABV01@@Z
??0Replaceable@icu_56@@QAE@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UObject *
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@ABV01@@Z	; icu_56::UObject::UObject(icu_56::UObject const &)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Replaceable@icu_56@@QAE@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 698h
		dd offset ??_R4Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`vftable'
??_7Replaceable@icu_56@@6B@ dd offset ??_EReplaceable@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::Replaceable::Replaceable(icu_56::Replaceable const	&)+32o
					; icu_56::Replaceable::Replaceable(void)+2Eo
					; icu_56::Replaceable::`vector deleting	destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
		dd offset __purecall
		dd offset __purecall
		dd offset __purecall
		dd offset ?hasMetaData@Replaceable@icu_56@@UBECXZ ; icu_56::Replaceable::hasMetaData(void)
		dd offset ?clone@Replaceable@icu_56@@UBEPAV12@XZ ; icu_56::Replaceable::clone(void)
		dd offset __purecall
off_6BC		dd offset __purecall	; DATA XREF: .data:?__LINE__Var@?1??repTextAccess@@9@4JA@8d672338o
		dd offset __purecall
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6C4h
		public ??_R4Replaceable@icu_56@@6B@
; const	icu_56::Replaceable::`RTTI Complete Object Locator'
??_R4Replaceable@icu_56@@6B@ dd	3 dup(0) ; DATA	XREF: .rdata:00000698o
		dd offset ??_R0?AVReplaceable@icu_56@@@8 ; icu_56::Replaceable `RTTI Type Descriptor'
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6D8h
		public ??_R0?AVReplaceable@icu_56@@@8
; class	icu_56::Replaceable `RTTI Type Descriptor'
??_R0?AVReplaceable@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA XREF: .rdata$r:000006D0o
					; .rdata$r:icu_56::Replaceable::`RTTI Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 10h
a_?avreplaceabl	db '.?AVReplaceable@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 6FCh
		public ??_R3Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Class Hierarchy Descriptor'
??_R3Replaceable@icu_56@@8 dd 2	dup(0)	; DATA XREF: .rdata$r:000006D4o
					; .rdata$r:00000734o
		dd 3
		dd offset ??_R2Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 70Ch
		public ??_R2Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Array'
??_R2Replaceable@icu_56@@8 dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8
					; DATA XREF: .rdata$r:00000708o
					; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 71Ch
		public ??_R1A@?0A@EA@Replaceable@icu_56@@8
; icu_56::Replaceable::`RTTI Base Class	Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@Replaceable@icu_56@@8 dd offset ??_R0?AVReplaceable@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::Replaceable::`RTTI Base Class Array'o
					; .rdata$r:0000134Co
					; icu_56::Replaceable `RTTI Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3Replaceable@icu_56@@8 ; icu_56::Replaceable::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 738h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::Replaceable & __thiscall icu_56::Replaceable::operator=(class icu_56::Replaceable const	&)
		public ??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??4UObject@icu_56@@QAEAAV01@ABV01@@Z ; icu_56::UObject::operator=(icu_56::UObject const	&)
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4Replaceable@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 780h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`scalar deleting destructor'(unsigned int)
		public ??_GReplaceable@icu_56@@UAEPAXI@Z
??_GReplaceable@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_7BF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_7BF:				; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GReplaceable@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::Replaceable::`vector deleting destructor'(unsigned int)
		public ??_EReplaceable@icu_56@@UAEPAXI@Z
??_EReplaceable@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::Replaceable::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]

loc_7FE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexo
		and	eax, 2
		jz	short loc_839
		push	offset ??1Replaceable@icu_56@@UAE@XZ ; icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_831
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_831:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_858
; ---------------------------------------------------------------------------

loc_839:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1Replaceable@icu_56@@UAE@XZ ;	icu_56::Replaceable::~Replaceable(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_855
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_855:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_858:				; CODE XREF: icu_56::Replaceable::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EReplaceable@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Replaceable::Replaceable(icu_56::Replaceable *__hidden this)
		public ??0Replaceable@icu_56@@IAE@XZ
??0Replaceable@icu_56@@IAE@XZ proc near	; CODE XREF: icu_56::UnicodeString::UnicodeString(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7Replaceable@icu_56@@6B@ ; const icu_56::Replaceable::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0Replaceable@icu_56@@IAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::length(icu_56::Replaceable *__hidden this)
		public ?length@Replaceable@icu_56@@QBEHXZ
?length@Replaceable@icu_56@@QBEHXZ proc	near ; CODE XREF: _repTextLength+2Ap
					; _repTextAccess+34p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@Replaceable@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 90Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::Replaceable::charAt(icu_56::Replaceable *this, int)
		public ?charAt@Replaceable@icu_56@@QBE_WH@Z
?charAt@Replaceable@icu_56@@QBE_WH@Z proc near ; CODE XREF: _repTextExtract+CEp
					; _repTextExtract+114p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+20h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@Replaceable@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 960h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::Replaceable::char32At(icu_56::Replaceable *this, int)
		public ?char32At@Replaceable@icu_56@@QBEHH@Z
?char32At@Replaceable@icu_56@@QBEHH@Z proc near	; CODE XREF: _repTextExtract+EBp
					; _repTextExtract+131p
					; DATA XREF: ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+24h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?char32At@Replaceable@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this)
		public ??0StringPiece@icu_56@@QAE@XZ
??0StringPiece@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0StringPiece@icu_56@@QAE@XZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: __thiscall icu_56::StringPiece::StringPiece(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
		public ??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0]
		call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx], eax
		mov	ecx, [ebp+arg_0]
		call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], eax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0StringPiece@icu_56@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A4Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *this,	const char *, int)
		public ??0StringPiece@icu_56@@QAE@PBDH@Z
??0StringPiece@icu_56@@QAE@PBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
??0StringPiece@icu_56@@QAE@PBDH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	char *__thiscall icu_56::StringPiece::data(icu_56::StringPiece *__hidden this)
		public ?data@StringPiece@icu_56@@QBEPBDXZ
?data@StringPiece@icu_56@@QBEPBDXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?data@StringPiece@icu_56@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::size(icu_56::StringPiece *__hidden this)
		public ?size@StringPiece@icu_56@@QBEHXZ
?size@StringPiece@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0AECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::StringPiece::length(icu_56::StringPiece *__hidden this)
		public ?length@StringPiece@icu_56@@QBEHXZ
?length@StringPiece@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?length@StringPiece@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::StringPiece::empty(icu_56::StringPiece *__hidden this)
		public ?empty@StringPiece@icu_56@@QBECXZ
?empty@StringPiece@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?empty@StringPiece@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B50h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::clear(icu_56::StringPiece *__hidden this)
		public ?clear@StringPiece@icu_56@@QAEXXZ
?clear@StringPiece@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?clear@StringPiece@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::set(icu_56::StringPiece *this, const char *, int)
		public ?set@StringPiece@icu_56@@QAEXPBDH@Z
?set@StringPiece@icu_56@@QAEXPBDH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		mov	[eax+4], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	8
?set@StringPiece@icu_56@@QAEXPBDH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0BD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_prefix(icu_56::StringPiece *this,	int)
		public ?remove_prefix@StringPiece@icu_56@@QAEXH@Z
?remove_prefix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_C29
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_C0D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+arg_0], ecx

loc_C0D:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		add	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_C29:				; CODE XREF: icu_56::StringPiece::remove_prefix(int)+27j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_prefix@StringPiece@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::StringPiece::remove_suffix(icu_56::StringPiece *this,	int)
		public ?remove_suffix@StringPiece@icu_56@@QAEXH@Z
?remove_suffix@StringPiece@icu_56@@QAEXH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_C83
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jg	short loc_C79
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx
		jmp	short loc_C83
; ---------------------------------------------------------------------------

loc_C79:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+32j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0

loc_C83:				; CODE XREF: icu_56::StringPiece::remove_suffix(int)+27j
					; icu_56::StringPiece::remove_suffix(int)+43j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?remove_suffix@StringPiece@icu_56@@QAEXH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece __thiscall icu_56::StringPiece::substr(int,	int)const
		public ?substr@StringPiece@icu_56@@QBE?AV12@HH@Z
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::StringPiece *
		mov	ecx, [ebp+arg_0] ; this
		call	??0StringPiece@icu_56@@QAE@ABV01@HH@Z ;	icu_56::StringPiece::StringPiece(icu_56::StringPiece const &,int,int)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?substr@StringPiece@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0CDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::StringPiece & __thiscall icu_56::StringPiece::operator=(class icu_56::StringPiece const	&)
		public ??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+var_8]
		mov	[eax], ecx
		mov	[eax+4], edx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4StringPiece@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::ByteSink::ByteSink(icu_56::ByteSink	*__hidden this)
		public ??0ByteSink@icu_56@@QAE@XZ
??0ByteSink@icu_56@@QAE@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0ByteSink@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D54h
		dd offset ??_R4ByteSink@icu_56@@6B@ ; const icu_56::ByteSink::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`vftable'
??_7ByteSink@icu_56@@6B@ dd offset ??_EByteSink@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::ByteSink::ByteSink(void)+26o
					; icu_56::ByteSink::`vector deleting destructor'(uint)
		dd offset __purecall
		dd offset ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z ;	icu_56::ByteSink::GetAppendBuffer(int,int,char *,int,int *)
		dd offset ?Flush@ByteSink@icu_56@@UAEXXZ ; icu_56::ByteSink::Flush(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D68h
		public ??_R4ByteSink@icu_56@@6B@
; const	icu_56::ByteSink::`RTTI	Complete Object	Locator'
??_R4ByteSink@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000D54o
		dd offset ??_R0?AVByteSink@icu_56@@@8 ;	icu_56::ByteSink `RTTI Type Descriptor'
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0D7Ch
		public ??_R0?AVByteSink@icu_56@@@8
; class	icu_56::ByteSink `RTTI Type Descriptor'
??_R0?AVByteSink@icu_56@@@8 dd offset ??_7type_info@@6B@ ; DATA	XREF: .rdata$r:00000D74o
					; .rdata$r:icu_56::ByteSink::`RTTI Base	Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avbytesink@i	db '.?AVByteSink@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0D9Ch
		public ??_R3ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Class	Hierarchy Descriptor'
??_R3ByteSink@icu_56@@8	dd 2 dup(0)	; DATA XREF: .rdata$r:00000D78o
					; .rdata$r:00000DD0o
		dd 2
		dd offset ??_R2ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DACh
		public ??_R2ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Array'
??_R2ByteSink@icu_56@@8	dd offset ??_R1A@?0A@EA@ByteSink@icu_56@@8
					; DATA XREF: .rdata$r:00000DA8o
					; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0DB8h
		public ??_R1A@?0A@EA@ByteSink@icu_56@@8
; icu_56::ByteSink::`RTTI Base Class Descriptor	at (0, -1, 0, 64)'
??_R1A@?0A@EA@ByteSink@icu_56@@8 dd offset ??_R0?AVByteSink@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::ByteSink::`RTTI Base Class Array'o
					; icu_56::ByteSink `RTTI Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3ByteSink@icu_56@@8 ; icu_56::ByteSink::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DD4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`scalar deleting destructor'(unsigned int)
		public ??_GByteSink@icu_56@@UAEPAXI@Z
??_GByteSink@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)

loc_DFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::basefieldo
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E13
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_E13:				; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GByteSink@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::ByteSink::`vector deleting destructor'(unsigned int)
		public ??_EByteSink@icu_56@@UAEPAXI@Z
??_EByteSink@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::ByteSink::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_E8D
		push	offset ??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_E85
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_E85:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_EAC
; ---------------------------------------------------------------------------

loc_E8D:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1ByteSink@icu_56@@UAE@XZ ; icu_56::ByteSink::~ByteSink(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_EA9
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_EA9:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_EAC:				; CODE XREF: icu_56::ByteSink::`vector deleting	destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EByteSink@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesWritten(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesWritten@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0EF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::CheckedArrayByteSink::Overflowed(icu_56::CheckedArrayByteSink *__hidden this)
		public ?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	al, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?Overflowed@CheckedArrayByteSink@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CheckedArrayByteSink::NumberOfBytesAppended(icu_56::CheckedArrayByteSink *__hidden this)
		public ?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?NumberOfBytesAppended@CheckedArrayByteSink@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(struct	icu_56::UnicodeString *)
		public ??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z ; icu_56::UnicodeString::moveFrom(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@$$QAV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::swap(icu_56 *this, struct icu_56::UnicodeString *, struct icu_56::UnicodeString *)
		public ?swap@icu_56@@YAXAAVUnicodeString@1@0@Z
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	proc near

var_C0		= byte ptr -0C0h
this		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+this]	; this
		call	?swap@UnicodeString@icu_56@@QAEXAAV12@@Z ; icu_56::UnicodeString::swap(icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?swap@icu_56@@YAXAAVUnicodeString@1@0@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0FDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`scalar deleting destructor'(unsigned int)
		public ??_GUnicodeString@icu_56@@UAEPAXI@Z
??_GUnicodeString@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx

loc_FFF:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::scientifico
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_101B
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_101B:				; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUnicodeString@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1034h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UnicodeString::`vector deleting destructor'(unsigned int)
		public ??_EUnicodeString@icu_56@@UAEPAXI@Z
??_EUnicodeString@icu_56@@UAEPAXI@Z proc near
					; DATA XREF: .rdata:const icu_56::UnicodeString::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_1095
		push	offset ??1UnicodeString@icu_56@@UAE@XZ ; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	40h ; '@'
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_108D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_108D:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_10B4
; ---------------------------------------------------------------------------

loc_1095:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_10B1
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_10B1:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_10B4:				; CODE XREF: icu_56::UnicodeString::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUnicodeString@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndex(icu_56::UnicodeString	*this, int *)
		public ?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int)+2Ap
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+2Ap ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1102
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_111E
; ---------------------------------------------------------------------------

loc_1102:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+29j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		cmp	[ecx], eax
		jle	short loc_111E
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx], eax

loc_111E:				; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+34j
					; icu_56::UnicodeString::pinIndex(int &)+43j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1134h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::pinIndices(icu_56::UnicodeString *this, int *,	int *)
		public ?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+51p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+51p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 0
		jge	short loc_1175
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		jmp	short loc_1187
; ---------------------------------------------------------------------------

loc_1175:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+34j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+var_14]
		jle	short loc_1187
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax], ecx

loc_1187:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+3Fj
					; icu_56::UnicodeString::pinIndices(int	&,int &)+49j
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jge	short loc_119A
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0
		jmp	short loc_11B6
; ---------------------------------------------------------------------------

loc_119A:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		cmp	[edx], ecx
		jle	short loc_11B6
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax]
		mov	edx, [ebp+arg_4]
		mov	[edx], ecx

loc_11B6:				; CODE XREF: icu_56::UnicodeString::pinIndices(int &,int &)+64j
					; icu_56::UnicodeString::pinIndices(int	&,int &)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t *__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1209
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_1215
; ---------------------------------------------------------------------------

loc_1209:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_1215:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@AAEPA_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1224h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getArrayStart(icu_56::UnicodeString *__hidden this)
		public ?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+61p
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+61p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1261
		mov	edx, [ebp+var_8]
		add	edx, 6
		mov	[ebp+var_D0], edx
		jmp	short loc_126D
; ---------------------------------------------------------------------------

loc_1261:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+2Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_D0], ecx

loc_126D:				; CODE XREF: icu_56::UnicodeString::getArrayStart(void)+3Bj
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 127Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this)
		public ??0UnicodeString@icu_56@@QAE@XZ
??0UnicodeString@icu_56@@QAE@XZ	proc near ; CODE XREF: _repTextCopy+12Cp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??0Replaceable@icu_56@@IAE@XZ ;	icu_56::Replaceable::Replaceable(void)
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UnicodeString@icu_56@@6B@ ;	const icu_56::UnicodeString::`vftable'
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??0UnicodeString@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12D4h
		dd offset ??_R4UnicodeString@icu_56@@6B@ ; const icu_56::UnicodeString::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`vftable'
??_7UnicodeString@icu_56@@6B@ dd offset	??_EUnicodeString@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UnicodeString::UnicodeString(void)+2Eo
					; icu_56::UnicodeString::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ ; icu_56::UnicodeString::getDynamicClassID(void)
		dd offset ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z ; icu_56::UnicodeString::extractBetween(int,int,icu_56::UnicodeString &)
		dd offset ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z ; icu_56::UnicodeString::handleReplaceBetween(int,int,icu_56::UnicodeString const &)
		dd offset ?copy@UnicodeString@icu_56@@UAEXHHH@Z	; icu_56::UnicodeString::copy(int,int,int)
		dd offset ?hasMetaData@UnicodeString@icu_56@@UBECXZ ; icu_56::UnicodeString::hasMetaData(void)
		dd offset ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ ;	icu_56::UnicodeString::clone(void)
		dd offset ?getLength@UnicodeString@icu_56@@MBEHXZ ; icu_56::UnicodeString::getLength(void)
		dd offset ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z ; icu_56::UnicodeString::getCharAt(int)
		dd offset ?getChar32At@UnicodeString@icu_56@@MBEHH@Z ; icu_56::UnicodeString::getChar32At(int)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1300h
		public ??_R4UnicodeString@icu_56@@6B@
; const	icu_56::UnicodeString::`RTTI Complete Object Locator'
??_R4UnicodeString@icu_56@@6B@ dd 3 dup(0) ; DATA XREF:	.rdata:000012D4o
		dd offset ??_R0?AVUnicodeString@icu_56@@@8 ; icu_56::UnicodeString `RTTI Type Descriptor'
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1314h
		public ??_R0?AVUnicodeString@icu_56@@@8
; class	icu_56::UnicodeString `RTTI Type Descriptor'
??_R0?AVUnicodeString@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:0000130Co
					; .rdata$r:icu_56::UnicodeString::`RTTI	Base Class Descriptor at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avunicodestr	db '.?AVUnicodeString@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1338h
		public ??_R3UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
??_R3UnicodeString@icu_56@@8 dd	2 dup(0) ; DATA	XREF: .rdata$r:00001310o
					; .rdata$r:00001374o
		dd 4
		dd offset ??_R2UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1348h
		public ??_R2UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Array'
??_R2UnicodeString@icu_56@@8 dd	offset ??_R1A@?0A@EA@UnicodeString@icu_56@@8
					; DATA XREF: .rdata$r:00001344o
					; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@Replaceable@icu_56@@8 ;	icu_56::Replaceable::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 135Ch
		public ??_R1A@?0A@EA@UnicodeString@icu_56@@8
; icu_56::UnicodeString::`RTTI Base Class Descriptor at	(0, -1,	0, 64)'
??_R1A@?0A@EA@UnicodeString@icu_56@@8 dd offset	??_R0?AVUnicodeString@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UnicodeString::`RTTI Base	Class Array'o
					; icu_56::UnicodeString	`RTTI Type Descriptor'
		dd 3, 0
		dd 0FFFFFFFFh, 0
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset ??_R3UnicodeString@icu_56@@8 ; icu_56::UnicodeString::`RTTI Class Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1378h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::hasShortLength(icu_56::UnicodeString *__hidden this)
		public ?hasShortLength@UnicodeString@icu_56@@ABECXZ
?hasShortLength@UnicodeString@icu_56@@ABECXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		test	ecx, ecx
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?hasShortLength@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getShortLength(icu_56::UnicodeString *__hidden this)
		public ?getShortLength@UnicodeString@icu_56@@ABEHXZ
?getShortLength@UnicodeString@icu_56@@ABEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::length(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		sar	eax, 5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getShortLength@UnicodeString@icu_56@@ABEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::length(icu_56::UnicodeString *__hidden this)
		public ?length@UnicodeString@icu_56@@QBEHXZ
?length@UnicodeString@icu_56@@QBEHXZ proc near
					; CODE XREF: icu_56::UnicodeString::pinIndex(int &)+39p
					; icu_56::UnicodeString::pinIndex(int &)+48p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?hasShortLength@UnicodeString@icu_56@@ABECXZ ; icu_56::UnicodeString::hasShortLength(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1426
		mov	ecx, [ebp+var_8] ; this
		call	?getShortLength@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::getShortLength(void)
		mov	[ebp+var_D0], eax
		jmp	short loc_1432
; ---------------------------------------------------------------------------

loc_1426:				; CODE XREF: icu_56::UnicodeString::length(void)+30j
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+8]
		mov	[ebp+var_D0], edx

loc_1432:				; CODE XREF: icu_56::UnicodeString::length(void)+40j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?length@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 144Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::getCapacity(icu_56::UnicodeString *__hidden this)
		public ?getCapacity@UnicodeString@icu_56@@QBEHXZ
?getCapacity@UnicodeString@icu_56@@QBEHXZ proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_1487
		mov	[ebp+var_D0], 1Dh
		jmp	short loc_1493
; ---------------------------------------------------------------------------

loc_1487:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+2Dj
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	[ebp+var_D0], eax

loc_1493:				; CODE XREF: icu_56::UnicodeString::getCapacity(void)+39j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getCapacity@UnicodeString@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14A0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::hashCode(icu_56::UnicodeString *__hidden this)
		public ?hashCode@UnicodeString@icu_56@@QBEHXZ
?hashCode@UnicodeString@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?doHashCode@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::doHashCode(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?hashCode@UnicodeString@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 14E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBogus(icu_56::UnicodeString	*__hidden this)
		public ?isBogus@UnicodeString@icu_56@@QBECXZ
?isBogus@UnicodeString@icu_56@@QBECXZ proc near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+26p
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+35p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	eax, word ptr [eax+4]
		and	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isBogus@UnicodeString@icu_56@@QBECXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1514h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isWritable(icu_56::UnicodeString *__hidden this)
		public ?isWritable@UnicodeString@icu_56@@ABECXZ
?isWritable@UnicodeString@icu_56@@ABECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 154Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isBufferWritable(icu_56::UnicodeString *__hidden this)
		public ?isBufferWritable@UnicodeString@icu_56@@ABECXZ
?isBufferWritable@UnicodeString@icu_56@@ABECXZ proc near

var_D0		= byte ptr -0D0h
var_CD		= byte ptr -0CDh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 19h
		jnz	short loc_159D
		mov	edx, [ebp+var_8]
		movsx	eax, word ptr [edx+4]
		and	eax, 4
		jz	short loc_1594
		mov	ecx, [ebp+var_8] ; this
		call	?refCount@UnicodeString@icu_56@@ABEHXZ ; icu_56::UnicodeString::refCount(void)
		cmp	eax, 1
		jnz	short loc_159D

loc_1594:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+39j
		mov	[ebp+var_CD], 1
		jmp	short loc_15A4
; ---------------------------------------------------------------------------

loc_159D:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+2Dj
					; icu_56::UnicodeString::isBufferWritable(void)+46j
		mov	[ebp+var_CD], 0

loc_15A4:				; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+4Fj
		mov	al, [ebp+var_CD]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?isBufferWritable@UnicodeString@icu_56@@ABECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; const	wchar_t	*__thiscall icu_56::UnicodeString::getBuffer(icu_56::UnicodeString *__hidden this)
		public ?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ proc	near ; CODE XREF: _unistrTextReplace+106p
					; _unistrTextCopy+130p	...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 11h
		jz	short loc_15F5
		xor	eax, eax
		jmp	short loc_1611
; ---------------------------------------------------------------------------
		jmp	short loc_1611
; ---------------------------------------------------------------------------

loc_15F5:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+2Dj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 2
		jz	short loc_160B
		mov	eax, [ebp+var_8]
		add	eax, 6
		jmp	short loc_1611
; ---------------------------------------------------------------------------
		jmp	short loc_1611
; ---------------------------------------------------------------------------

loc_160B:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+3Fj
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]

loc_1611:				; CODE XREF: icu_56::UnicodeString::getBuffer(void)+31j
					; icu_56::UnicodeString::getBuffer(void)+33j ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1618h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *this, int, int, const struct	icu_56::UnicodeString *, int, int)
		public ?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator>(icu_56::UnicodeString const &)+40p
					; icu_56::UnicodeString::operator<(icu_56::UnicodeString const &)+40p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_165E
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_168F
; ---------------------------------------------------------------------------
		jmp	short loc_168F
; ---------------------------------------------------------------------------

loc_165E:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)

loc_168F:				; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+42j
					; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator==(icu_56::UnicodeString	*)
		public ??8UnicodeString@icu_56@@QBECABV01@@Z
??8UnicodeString@icu_56@@QBECABV01@@Z proc near
					; CODE XREF: icu_56::UnicodeString::operator!=(icu_56::UnicodeString const &)+2Ap

var_E8		= byte ptr -0E8h
var_E5		= byte ptr -0E5h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_16E6
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		jmp	short loc_1740
; ---------------------------------------------------------------------------
		jmp	short loc_1740
; ---------------------------------------------------------------------------

loc_16E6:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_1733
		mov	ecx, [ebp+var_14]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_1733
		mov	edx, [ebp+var_14]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z ;	icu_56::UnicodeString::doEquals(icu_56::UnicodeString const &,int)
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1733
		mov	[ebp+var_E5], 1
		jmp	short loc_173A
; ---------------------------------------------------------------------------

loc_1733:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+61j
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+69j	...
		mov	[ebp+var_E5], 0

loc_173A:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+89j
		mov	al, [ebp+var_E5]

loc_1740:				; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+3Aj
					; icu_56::UnicodeString::operator==(icu_56::UnicodeString const	&)+3Cj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1758h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator!=(icu_56::UnicodeString	*)
		public ??9UnicodeString@icu_56@@QBECABV01@@Z
??9UnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; icu_56::UnicodeString	*
		mov	ecx, [ebp+var_8]
		call	??8UnicodeString@icu_56@@QBECABV01@@Z ;	icu_56::UnicodeString::operator==(icu_56::UnicodeString	const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UnicodeString@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>(icu_56::UnicodeString *)
		public ??OUnicodeString@icu_56@@QBECABV01@@Z
??OUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??OUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 180Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<(icu_56::UnicodeString *)
		public ??MUnicodeString@icu_56@@QBECABV01@@Z
??MUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??MUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1870h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator>=(icu_56::UnicodeString	*)
		public ??PUnicodeString@icu_56@@QBECABV01@@Z
??PUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 0FFFFFFFFh
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??PUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator<=(icu_56::UnicodeString	*)
		public ??NUnicodeString@icu_56@@QBECABV01@@Z
??NUnicodeString@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		cmp	ecx, 1
		setnz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??NUnicodeString@icu_56@@QBECABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1938h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECABV12@@Z
?compare@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compare@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1994h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 19ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, const wchar_t *,	int)
		public ?compare@UnicodeString@icu_56@@QBECPB_WH@Z
?compare@UnicodeString@icu_56@@QBECPB_WH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compare@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::startsWith(icu_56::UnicodeString const &)+40p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_W@Z
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compare@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compare(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compare@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BA4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString	const &)+40p
					; icu_56::UnicodeString::compareCodePointOrder(int,int,icu_56::UnicodeString const &)+3Dp ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1BEA
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1C1B
; ---------------------------------------------------------------------------
		jmp	short loc_1C1B
; ---------------------------------------------------------------------------

loc_1BEA:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)

loc_1C1B:				; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+42j
					; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?compareCodePointOrder@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CE8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?compareCodePointOrder@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D40h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1DECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrder(icu_56::UnicodeString *this, int, int, const wchar_t *,	int, int)
		public ?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z ;	icu_56::UnicodeString::doCompareCodePointOrder(int,int,wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrder@UnicodeString@icu_56@@QBECHHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E44h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::compareCodePointOrderBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHABV12@HH@Z	; icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?compareCodePointOrderBetween@UnicodeString@icu_56@@QBECHHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EA0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned	int)
		public ?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z proc near
					; CODE XREF: icu_56::UnicodeString::caseCompare(icu_56::UnicodeString const &,uint)+44p
					; icu_56::UnicodeString::caseCompare(int,int,icu_56::UnicodeString const &,uint)+41p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1EE6
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		setz	al
		jmp	short loc_1F1B
; ---------------------------------------------------------------------------
		jmp	short loc_1F1B
; ---------------------------------------------------------------------------

loc_1EE6:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+30j
		lea	eax, [ebp+arg_10]
		push	eax		; int *
		lea	ecx, [ebp+arg_C]
		push	ecx		; int *
		mov	ecx, [ebp+arg_8] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)

loc_1F1B:				; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+42j
					; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)+44j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const struct	icu_56::UnicodeString *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?caseCompare@UnicodeString@icu_56@@QBECABV12@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@I@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FF0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, const wchar_t *, int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx

loc_1FFD:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::fixedo
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?caseCompare@UnicodeString@icu_56@@QBECPB_WHI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 204Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const struct icu_56::UnicodeString	*, int,	int, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2100h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompare(icu_56::UnicodeString *this, int,	int, const wchar_t *, int, int,	unsigned int)
		public ?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,wchar_t const *,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompare@UnicodeString@icu_56@@QBECHHPB_WHHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 215Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::caseCompareBetween(icu_56::UnicodeString *this, int, int, const struct icu_56::UnicodeString *, int, int, unsigned int)
		public ?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_14]
		push	eax		; unsigned int
		mov	ecx, [ebp+arg_10]
		sub	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCaseCompare@UnicodeString@icu_56@@ABECHHABV12@HHI@Z ; icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString const &,int,int,uint)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	18h
?caseCompareBetween@UnicodeString@icu_56@@QBECHHABV12@HHI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&)+40p
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2227
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_2227
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_222A
; ---------------------------------------------------------------------------

loc_2227:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+30j
					; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_222A:				; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2240h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 229Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2308h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z	; icu_56::UnicodeString::indexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2360h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23C8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, const wchar_t *, int, int,	int)
		public ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ;	icu_56::UnicodeString::indexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?indexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 241Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 246Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::indexOf(int)+35p
					; icu_56::UnicodeString::indexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 24BCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t)
		public ?indexOf@UnicodeString@icu_56@@QBEH_W@Z
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEH_W@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2510h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHH@Z
?indexOf@UnicodeString@icu_56@@QBEHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?indexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2560h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?indexOf@UnicodeString@icu_56@@QBEH_WH@Z
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z ; icu_56::UnicodeString::doIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *this, int, int)
		public ?indexOf@UnicodeString@icu_56@@QBEHHH@Z
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::indexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UnicodeString@icu_56@@QBEHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2628h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 267Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26E4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int)+3Dp
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int)+51p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jnz	short loc_274F
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		cmp	[ebp+arg_8], 0
		jle	short loc_274F
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z ; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int,int,int)
		jmp	short loc_2752
; ---------------------------------------------------------------------------

loc_274F:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+30j
					; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+46j
		or	eax, 0FFFFFFFFh

loc_2752:				; CODE XREF: icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2768h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 27C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 282Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@HHHH@Z ; icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString const &,int,int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2888h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		movzx	edx, [ebp+arg_0]
		push	edx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEH_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 28D8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z proc near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int)+35p
					; icu_56::UnicodeString::lastIndexOf(int,int)+46p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z ; icu_56::UnicodeString::doLastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2928h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		movzx	eax, [ebp+arg_0]
		push	eax		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 297Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?lastIndexOf@UnicodeString@icu_56@@QBEHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, wchar_t, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		movzx	ecx, [ebp+arg_0]
		push	ecx		; wchar_t
		mov	ecx, [ebp+var_8] ; this
		call	?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z	; icu_56::UnicodeString::doLastIndexOf(wchar_t,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEH_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *this, int, int)
		public ?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?lastIndexOf@UnicodeString@icu_56@@QBEHHHH@Z ; icu_56::UnicodeString::lastIndexOf(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?lastIndexOf@UnicodeString@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?compare@UnicodeString@icu_56@@QBECHHABV12@HH@Z	; icu_56::UnicodeString::compare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?startsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2AF8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	struct icu_56::UnicodeString *,	int, int)
		public ?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2B54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2B8C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2B8C:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?startsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2BC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::startsWith(icu_56::UnicodeString *this, const	wchar_t	*, int,	int)
		public ?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2BFC
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2BFC:				; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?startsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	esi, eax
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	esi, eax
		push	esi		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?endsWith@UnicodeString@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const struct icu_56::UnicodeString *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_8]
		push	eax		; int *
		lea	ecx, [ebp+arg_4]
		push	ecx		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndices@UnicodeString@icu_56@@ABEXAAH0@Z ; icu_56::UnicodeString::pinIndices(int &,int &)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHABV12@HH@Z ; icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jge	short loc_2D5C
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_4], eax

loc_2D5C:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int)+27j
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	eax, al
		test	eax, eax
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?endsWith@UnicodeString@icu_56@@QBECPB_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D9Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::endsWith(icu_56::UnicodeString *this,	const wchar_t *, int, int)
		public ?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jge	short loc_2DDA
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		push	edx
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_2DDA:				; CODE XREF: icu_56::UnicodeString::endsWith(wchar_t const *,int,int)+27j
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z	; icu_56::UnicodeString::doCompare(int,int,wchar_t const *,int,int)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?endsWith@UnicodeString@icu_56@@QBECPB_WHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2E74h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const struct icu_56::UnicodeString *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near
					; CODE XREF: icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2ECCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z proc near
					; CODE XREF: _unistrTextReplace+F3p
					; _unistrTextCopy+104p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F20h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, const wchar_t *, int, int)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*this, int, int, wchar_t)
		public ?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_8]
		push	eax		; wchar_t *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replace@UnicodeString@icu_56@@QAEAAV12@HH_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2FCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *

loc_2FFE:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::hexfloato
					; .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::floatfieldo
		mov	ecx, [ebp+arg_4]
		sub	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3028h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replaceBetween(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, int, int)
		public ?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_10]
		sub	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_C]
		push	ecx		; int
		mov	edx, [ebp+arg_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	14h
?replaceBetween@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@ABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 30F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *this, int, int,	const struct icu_56::UnicodeString *, const struct icu_56::UnicodeString *)
		public ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_C] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_C]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; struct icu_56::UnicodeString *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z ; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3158h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *this,	int, int, struct icu_56::UnicodeString *)
		public ?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	proc near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,icu_56::UnicodeString &)+32p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	edx, [ebp+var_8]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 31B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	wchar_t	*, int)
		public ?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near ; CODE XREF: _unistrTextExtract+16Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3204h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int,	struct icu_56::UnicodeString *)
		public ?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHAAV12@@Z	; icu_56::UnicodeString::doExtract(int,int,icu_56::UnicodeString &)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?extract@UnicodeString@icu_56@@QBEXHHAAV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3254h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *this, int, int, char *, const char *)
		public ?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; char *
		mov	ecx, [ebp+arg_8]
		neg	ecx
		sbb	ecx, ecx
		push	ecx		; unsigned int
		mov	edx, [ebp+arg_8]
		push	edx		; char *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z ; icu_56::UnicodeString::extract(int,int,char *,uint,char const *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extract@UnicodeString@icu_56@@QBEHHHPADPBD@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 32B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::extractBetween(icu_56::UnicodeString *this, int, int, wchar_t *, int)
		public ?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		lea	eax, [ebp+arg_0]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+var_8] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; wchar_t *
		mov	edx, [ebp+arg_4]
		sub	edx, [ebp+arg_0]
		push	edx		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z ; icu_56::UnicodeString::doExtract(int,int,wchar_t *,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?extractBetween@UnicodeString@icu_56@@QBEXHHPA_WH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 331Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString __thiscall icu_56::UnicodeString::tempSubStringBetween(int, int)const
		public ?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z proc near

var_D8		= byte ptr -0D8h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_D4], 0
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z ; icu_56::UnicodeString::tempSubString(int,int)
		mov	eax, [ebp+var_D4]
		or	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?tempSubStringBetween@UnicodeString@icu_56@@QBE?AV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3388h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::doCharAt(icu_56::UnicodeString *this, int)
		public ?doCharAt@UnicodeString@icu_56@@ABE_WH@Z
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z proc near
					; CODE XREF: icu_56::UnicodeString::charAt(int)+2Ap
					; icu_56::UnicodeString::operator[](int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_33CB
		mov	ecx, [ebp+var_8] ; this
		call	?getArrayStart@UnicodeString@icu_56@@ABEPB_WXZ ; icu_56::UnicodeString::getArrayStart(void)
		mov	ecx, [ebp+arg_0]
		mov	ax, [eax+ecx*2]
		jmp	short loc_33D0
; ---------------------------------------------------------------------------
		jmp	short loc_33D0
; ---------------------------------------------------------------------------

loc_33CB:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+2Ej
		mov	eax, 0FFFFh

loc_33D0:				; CODE XREF: icu_56::UnicodeString::doCharAt(int)+3Fj
					; icu_56::UnicodeString::doCharAt(int)+41j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?doCharAt@UnicodeString@icu_56@@ABE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 33E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; wchar_t __thiscall icu_56::UnicodeString::charAt(icu_56::UnicodeString *this,	int)
		public ?charAt@UnicodeString@icu_56@@QBE_WH@Z
?charAt@UnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?charAt@UnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3430h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: wchar_t __thiscall icu_56::UnicodeString::operator[](int)const
		public ??AUnicodeString@icu_56@@QBE_WH@Z
??AUnicodeString@icu_56@@QBE_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doCharAt@UnicodeString@icu_56@@ABE_WH@Z ; icu_56::UnicodeString::doCharAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUnicodeString@icu_56@@QBE_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3478h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::isEmpty(icu_56::UnicodeString	*__hidden this)
		public ?isEmpty@UnicodeString@icu_56@@QBECXZ
?isEmpty@UnicodeString@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		sar	ecx, 5
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UnicodeString@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setZeroLength(icu_56::UnicodeString *__hidden this)
		public ?setZeroLength@UnicodeString@icu_56@@AAEXXZ
?setZeroLength@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+3Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setZeroLength@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 34F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setShortLength(icu_56::UnicodeString *this, int)
		public ?setShortLength@UnicodeString@icu_56@@AAEXH@Z
?setShortLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setLength(int)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		and	ecx, 1Fh
		mov	edx, [ebp+arg_0]
		shl	edx, 5
		or	ecx, edx
		mov	eax, [ebp+var_8]
		mov	[eax+4], cx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setShortLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3538h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setLength(icu_56::UnicodeString *this,	int)
		public ?setLength@UnicodeString@icu_56@@AAEXH@Z
?setLength@UnicodeString@icu_56@@AAEXH@Z proc near
					; CODE XREF: icu_56::UnicodeString::setArray(wchar_t *,int,int)+2Ap
					; icu_56::UnicodeString::truncate(int)+5Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 3FFh
		jg	short loc_3572
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setShortLength@UnicodeString@icu_56@@AAEXH@Z ;	icu_56::UnicodeString::setShortLength(int)
		jmp	short loc_358F
; ---------------------------------------------------------------------------

loc_3572:				; CODE XREF: icu_56::UnicodeString::setLength(int)+2Aj
		mov	eax, [ebp+var_8]
		movsx	ecx, word ptr [eax+4]
		or	ecx, 0FFE0h
		mov	edx, [ebp+var_8]
		mov	[edx+4], cx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_358F:				; CODE XREF: icu_56::UnicodeString::setLength(int)+38j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setLength@UnicodeString@icu_56@@AAEXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setToEmpty(icu_56::UnicodeString *__hidden this)
		public ?setToEmpty@UnicodeString@icu_56@@AAEXXZ
?setToEmpty@UnicodeString@icu_56@@AAEXXZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(void)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, 2
		mov	ecx, [ebp+var_8]
		mov	[ecx+4], ax
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?setToEmpty@UnicodeString@icu_56@@AAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 35E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UnicodeString::setArray(icu_56::UnicodeString	*this, wchar_t *, int, int)
		public ?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_8]
		mov	[eax+0Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setArray@UnicodeString@icu_56@@AAEXPA_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3638h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator=(wchar_t)
		public ??4UnicodeString@icu_56@@QAEAAV01@_W@Z
??4UnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 368Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator=(int)
		public ??4UnicodeString@icu_56@@QAEAAV01@H@Z
??4UnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??4UnicodeString@icu_56@@QAEAAV01@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 36DCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int,	int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 373Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		lea	eax, [ebp+arg_4]
		push	eax		; int *
		mov	ecx, [ebp+arg_0] ; this
		call	?pinIndex@UnicodeString@icu_56@@ABEXAAH@Z ; icu_56::UnicodeString::pinIndex(int	&)
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		sub	eax, [ebp+arg_4]
		push	eax		; int
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const struct icu_56::UnicodeString	*)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; signed __int8
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z ; icu_56::UnicodeString::copyFrom(icu_56::UnicodeString const &,signed char)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 37F8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setTo@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3858h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, wchar_t)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::setTo(icu_56::UnicodeString *this, int)
		public ?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?setTo@UnicodeString@icu_56@@QAEAAV12@H@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 390Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 395Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const struct icu_56::UnicodeString *)
		public ?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@ABV12@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; int
		mov	edx, [ebp+arg_0]
		push	edx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?append@UnicodeString@icu_56@@QAEAAV12@PB_WHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 39FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, const wchar_t *, int)
		public ?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?append@UnicodeString@icu_56@@QAEAAV12@PB_WH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A48h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *this, wchar_t)
		public ?append@UnicodeString@icu_56@@QAEAAV12@_W@Z
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?append@UnicodeString@icu_56@@QAEAAV12@_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3A94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(wchar_t)
		public ??YUnicodeString@icu_56@@QAEAAV01@_W@Z
??YUnicodeString@icu_56@@QAEAAV01@_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= word ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_0]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z ; icu_56::UnicodeString::doAppend(wchar_t const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@_W@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3AE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UnicodeString &	__thiscall icu_56::UnicodeString::operator+=(int)
		public ??YUnicodeString@icu_56@@QAEAAV01@H@Z
??YUnicodeString@icu_56@@QAEAAV01@H@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?append@UnicodeString@icu_56@@QAEAAV12@H@Z ; icu_56::UnicodeString::append(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __stdcall	icu_56::UnicodeString::operator+=(struct icu_56::UnicodeString *)
		public ??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_0] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_8] ; this
		call	?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z ; icu_56::UnicodeString::doAppend(icu_56::UnicodeString const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??YUnicodeString@icu_56@@QAEAAV01@ABV01@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3B78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; struct icu_56::UnicodeString *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3BCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const struct	icu_56::UnicodeString *)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	eax, [ebp+arg_4]
		push	eax		; struct icu_56::UnicodeString *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z ; icu_56::UnicodeString::doReplace(int,int,icu_56::UnicodeString	const &,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	edx, [ebp+arg_4]
		push	edx		; wchar_t *
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3C78h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, const wchar_t *, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; wchar_t *
		push	0		; int
		mov	edx, [ebp+arg_0]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insert@UnicodeString@icu_56@@QAEAAV12@HPB_WH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3CCCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, wchar_t)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	1		; int
		push	0		; int
		lea	eax, [ebp+arg_4]
		push	eax		; wchar_t *
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@H_W@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D1Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::insert(icu_56::UnicodeString *this, int, int)
		public ?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z ;	icu_56::UnicodeString::replace(int,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?insert@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D68h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *__hidden this)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@XZ
?remove@UnicodeString@icu_56@@QAEAAV12@XZ proc near
					; CODE XREF: icu_56::UnicodeString::remove(int,int)+35p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3DA4
		mov	ecx, [ebp+var_8] ; this
		call	?setToEmpty@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setToEmpty(void)
		jmp	short loc_3DAC
; ---------------------------------------------------------------------------

loc_3DA4:				; CODE XREF: icu_56::UnicodeString::remove(void)+30j
		mov	ecx, [ebp+var_8] ; this
		call	?setZeroLength@UnicodeString@icu_56@@AAEXXZ ; icu_56::UnicodeString::setZeroLength(void)

loc_3DAC:				; CODE XREF: icu_56::UnicodeString::remove(void)+3Aj
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?remove@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3DC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::remove(icu_56::UnicodeString *this, int, int)
		public ?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jg	short loc_3E00
		cmp	[ebp+arg_4], 7FFFFFFFh
		jnz	short loc_3E00
		mov	ecx, [ebp+var_8] ; this
		call	?remove@UnicodeString@icu_56@@QAEAAV12@XZ ; icu_56::UnicodeString::remove(void)
		jmp	short loc_3E16
; ---------------------------------------------------------------------------

loc_3E00:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+27j
					; icu_56::UnicodeString::remove(int,int)+30j
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)

loc_3E16:				; CODE XREF: icu_56::UnicodeString::remove(int,int)+3Aj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?remove@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::removeBetween(icu_56::UnicodeString *this, int, int)
		public ?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?removeBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E80h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::retainBetween(icu_56::UnicodeString *this, int, int)
		public ?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?truncate@UnicodeString@icu_56@@QAECH@Z	; icu_56::UnicodeString::truncate(int)
		push	0		; int
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+arg_0]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z ; icu_56::UnicodeString::doReplace(int,int,wchar_t	const *,int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?retainBetween@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3EDCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UnicodeString::truncate(icu_56::UnicodeString *this,	int)
		public ?truncate@UnicodeString@icu_56@@QAECH@Z
?truncate@UnicodeString@icu_56@@QAECH@Z	proc near
					; CODE XREF: icu_56::UnicodeString::retainBetween(int,int)+2Ap

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_3F22
		cmp	[ebp+arg_0], 0
		jnz	short loc_3F22
		mov	ecx, [ebp+var_8] ; this
		call	?unBogus@UnicodeString@icu_56@@AAEXXZ ;	icu_56::UnicodeString::unBogus(void)
		xor	al, al
		jmp	short loc_3F43
; ---------------------------------------------------------------------------
		jmp	short loc_3F43
; ---------------------------------------------------------------------------

loc_3F22:				; CODE XREF: icu_56::UnicodeString::truncate(int)+30j
					; icu_56::UnicodeString::truncate(int)+36j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cmp	[ebp+arg_0], eax
		jnb	short loc_3F41
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setLength@UnicodeString@icu_56@@AAEXH@Z ; icu_56::UnicodeString::setLength(int)
		mov	al, 1
		jmp	short loc_3F43
; ---------------------------------------------------------------------------
		jmp	short loc_3F43
; ---------------------------------------------------------------------------

loc_3F41:				; CODE XREF: icu_56::UnicodeString::truncate(int)+51j
		xor	al, al

loc_3F43:				; CODE XREF: icu_56::UnicodeString::truncate(int)+42j
					; icu_56::UnicodeString::truncate(int)+44j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?truncate@UnicodeString@icu_56@@QAECH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3F5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*__hidden this)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@XZ
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?reverse@UnicodeString@icu_56@@QAEAAV12@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::reverse(icu_56::UnicodeString	*this, int, int)
		public ?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z ; icu_56::UnicodeString::doReverse(int,int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?reverse@UnicodeString@icu_56@@QAEAAV12@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3FF4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; protected: class icu_56::ForwardCharacterIterator & __thiscall icu_56::ForwardCharacterIterator::operator=(class icu_56::ForwardCharacterIterator const &)
		public ??4ForwardCharacterIterator@icu_56@@IAEAAV01@ABV01@@Z
??4ForwardCharacterIterator@icu_56@@IAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi

loc_4000:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::boolalphao
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4ForwardCharacterIterator@icu_56@@IAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::ForwardCharacterIterator::operator!=(class icu_56::ForwardCharacterIterator const &)const
		public ??9ForwardCharacterIterator@icu_56@@QBECABV01@@Z
??9ForwardCharacterIterator@icu_56@@QBECABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9ForwardCharacterIterator@icu_56@@QBECABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4080h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::setToStart(icu_56::CharacterIterator *__hidden this)
		public ?setToStart@CharacterIterator@icu_56@@QAEHXZ
?setToStart@CharacterIterator@icu_56@@QAEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	0
		push	0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+5Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToStart@CharacterIterator@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::setToEnd(icu_56::CharacterIterator *__hidden this)
		public ?setToEnd@CharacterIterator@icu_56@@QAEHXZ
?setToEnd@CharacterIterator@icu_56@@QAEHXZ proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	esi, esp
		push	2
		push	0
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+5Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setToEnd@CharacterIterator@icu_56@@QAEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4128h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::startIndex(icu_56::CharacterIterator *__hidden this)
		public ?startIndex@CharacterIterator@icu_56@@QBEHXZ
?startIndex@CharacterIterator@icu_56@@QBEHXZ proc near
					; CODE XREF: _utext_openCharacterIterator_56+3Dp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+0Ch]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?startIndex@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4158h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::endIndex(icu_56::CharacterIterator *__hidden this)
		public ?endIndex@CharacterIterator@icu_56@@QBEHXZ
?endIndex@CharacterIterator@icu_56@@QBEHXZ proc	near
					; CODE XREF: _utext_openCharacterIterator_56+ADp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+10h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?endIndex@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4188h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::getIndex(icu_56::CharacterIterator *__hidden this)
		public ?getIndex@CharacterIterator@icu_56@@QBEHXZ
?getIndex@CharacterIterator@icu_56@@QBEHXZ proc	near ; CODE XREF: _charIterTextExtract+CEp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getIndex@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::CharacterIterator::getLength(icu_56::CharacterIterator	*__hidden this)
		public ?getLength@CharacterIterator@icu_56@@QBEHXZ
?getLength@CharacterIterator@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getLength@CharacterIterator@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 41E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_moveIndex32_56
_utext_moveIndex32_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 0
		jle	loc_42AC

loc_4210:				; CODE XREF: _utext_moveIndex32_56+B9j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jl	short loc_4245
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [eax+10h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?utext_access@@YACPAUUText@@_JC@Z ; utext_access(UText *,__int64,signed	char)
		add	esp, 10h
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4245
		xor	al, al
		jmp	loc_4341
; ---------------------------------------------------------------------------

loc_4245:				; CODE XREF: _utext_moveIndex32_56+34j
					; _utext_moveIndex32_56+54j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	short loc_4285
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFFFFFh
		jnz	short loc_4283
		xor	al, al
		jmp	loc_4341
; ---------------------------------------------------------------------------

loc_4283:				; CODE XREF: _utext_moveIndex32_56+92j
		jmp	short loc_4294
; ---------------------------------------------------------------------------

loc_4285:				; CODE XREF: _utext_moveIndex32_56+7Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx

loc_4294:				; CODE XREF: _utext_moveIndex32_56:loc_4283j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		cmp	[ebp+arg_4], 0
		jg	loc_4210
		jmp	loc_433F
; ---------------------------------------------------------------------------

loc_42AC:				; CODE XREF: _utext_moveIndex32_56+22j
		cmp	[ebp+arg_4], 0
		jge	loc_433F

loc_42B6:				; CODE XREF: _utext_moveIndex32_56+151j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jg	short loc_42E3
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+24h]
		push	ecx
		mov	edx, [eax+20h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	?utext_access@@YACPAUUText@@_JC@Z ; utext_access(UText *,__int64,signed	char)
		add	esp, 10h
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_42E3
		xor	al, al
		jmp	short loc_4341
; ---------------------------------------------------------------------------

loc_42E3:				; CODE XREF: _utext_moveIndex32_56+D5j
					; _utext_moveIndex32_56+F5j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2-2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	short loc_4321
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0FFFFFFFFh
		jnz	short loc_431F
		xor	al, al
		jmp	short loc_4341
; ---------------------------------------------------------------------------

loc_431F:				; CODE XREF: _utext_moveIndex32_56+131j
		jmp	short loc_4330
; ---------------------------------------------------------------------------

loc_4321:				; CODE XREF: _utext_moveIndex32_56+11Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx

loc_4330:				; CODE XREF: _utext_moveIndex32_56:loc_431Fj
		mov	eax, [ebp+arg_4]
		add	eax, 1
		mov	[ebp+arg_4], eax
		js	loc_42B6

loc_433F:				; CODE XREF: _utext_moveIndex32_56+BFj
					; _utext_moveIndex32_56+C8j
		mov	al, 1

loc_4341:				; CODE XREF: _utext_moveIndex32_56+58j
					; _utext_moveIndex32_56+96j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_moveIndex32_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4358h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl utext_access(struct UText	*, __int64, signed char)
?utext_access@@YACPAUUText@@_JC@Z proc near ; CODE XREF: _utext_moveIndex32_56+47p
					; _utext_moveIndex32_56+E8p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		movzx	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?utext_access@@YACPAUUText@@_JC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 43B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_nativeLength_56
_utext_nativeLength_56 proc near	; CODE XREF: _utf8TextClone+5Ap
					; _ucstrTextClone+5Ep ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+14h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_nativeLength_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4404h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_isLengthExpensive_56
_utext_isLengthExpensive_56 proc near

var_CC		= byte ptr -0CCh
var_5		= byte ptr -5
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 2
		setnz	dl
		mov	[ebp+var_5], dl
		mov	al, [ebp+var_5]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utext_isLengthExpensive_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 443Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_getNativeIndex_56
_utext_getNativeIndex_56 proc near	; CODE XREF: _utext_equals_56+6Cp
					; _utext_equals_56+7Cp	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+1Ch]
		jg	short loc_447C
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+28h]
		cdq
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		jmp	short loc_4497
; ---------------------------------------------------------------------------
		jmp	short loc_4497
; ---------------------------------------------------------------------------

loc_447C:				; CODE XREF: _utext_getNativeIndex_56+2Aj
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4497:				; CODE XREF: _utext_getNativeIndex_56+3Cj
					; _utext_getNativeIndex_56+3Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_getNativeIndex_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_setNativeIndex_56
_utext_setNativeIndex_56 proc near	; CODE XREF: _utext_char32At_56+D3p
					; _utext_next32From_56+175p ...

var_DC		= dword	ptr -0DCh
var_14		= word ptr -14h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		mov	ecx, [ebp+var_DC]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+24h]
		jl	short loc_4518
		jg	short loc_44F1
		mov	eax, [ebp+var_DC]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+20h]
		jb	short loc_4518

loc_44F1:				; CODE XREF: _utext_setNativeIndex_56+35j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_DC], eax
		mov	ecx, [ebp+var_DC]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+14h]
		jl	short loc_453F
		jg	short loc_4518
		mov	eax, [ebp+var_DC]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+10h]
		jb	short loc_453F

loc_4518:				; CODE XREF: _utext_setNativeIndex_56+33j
					; _utext_setNativeIndex_56+43j	...
		mov	esi, esp
		push	1
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_4596
; ---------------------------------------------------------------------------

loc_453F:				; CODE XREF: _utext_setNativeIndex_56+5Aj
					; _utext_setNativeIndex_56+6Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	edx, [ebp+arg_8]
		sbb	edx, [eax+24h]
		mov	eax, [ebp+arg_0]
		cmp	ecx, [eax+1Ch]
		jg	short loc_456D
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	edx, [ebp+arg_8]
		sbb	edx, [eax+24h]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		jmp	short loc_4596
; ---------------------------------------------------------------------------

loc_456D:				; CODE XREF: _utext_setNativeIndex_56+A8j
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+2Ch]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax

loc_4596:				; CODE XREF: _utext_setNativeIndex_56+91j
					; _utext_setNativeIndex_56+BFj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jge	loc_463A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		mov	cx, [eax+ecx*2]
		mov	[ebp+var_8], cx
		movzx	eax, [ebp+var_8]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_463A
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_45FD
		mov	esi, esp
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+24h]
		push	ecx
		mov	edx, [eax+20h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_45FD:				; CODE XREF: _utext_setNativeIndex_56+127j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jle	short loc_463A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		mov	cx, [eax+ecx*2-2]
		mov	[ebp+var_14], cx
		movzx	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_463A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx

loc_463A:				; CODE XREF: _utext_setNativeIndex_56+F6j
					; _utext_setNativeIndex_56+11Ej ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_setNativeIndex_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4650h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_getPreviousNativeIndex_56
_utext_getPreviousNativeIndex_56 proc near

var_F0		= dword	ptr -0F0h
var_EC		= dword	ptr -0ECh
var_24		= word ptr -24h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	[ebp+var_8], ecx
		js	loc_470C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+30h]
		mov	edx, [ebp+var_8]
		mov	ax, [ecx+edx*2]
		mov	[ebp+var_24], ax
		movzx	eax, [ebp+var_24]
		and	eax, 0FFFFFC00h
		xor	ecx, ecx
		cmp	eax, 0DC00h
		setz	cl
		test	ecx, ecx
		jnz	short loc_470C
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+1Ch]
		jg	short loc_46C8
		mov	eax, [ebp+var_8]
		cdq
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		jmp	short loc_4701
; ---------------------------------------------------------------------------

loc_46C8:				; CODE XREF: _utext_getPreviousNativeIndex_56+61j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+28h], ecx
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+28h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx

loc_4701:				; CODE XREF: _utext_getPreviousNativeIndex_56+76j
		mov	eax, [ebp+var_18]
		mov	edx, [ebp+var_14]
		jmp	loc_47BE
; ---------------------------------------------------------------------------

loc_470C:				; CODE XREF: _utext_getPreviousNativeIndex_56+2Aj
					; _utext_getPreviousNativeIndex_56+56j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_473B
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_EC], eax
		mov	ecx, [ebp+var_EC]
		mov	edx, [ebp+var_EC]
		mov	eax, [ecx+20h]
		or	eax, [edx+24h]
		jnz	short loc_473B
		xor	eax, eax
		xor	edx, edx
		jmp	loc_47BE
; ---------------------------------------------------------------------------

loc_473B:				; CODE XREF: _utext_getPreviousNativeIndex_56+C3j
					; _utext_getPreviousNativeIndex_56+E0j
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_previous32_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+1Ch]
		jg	short loc_4773
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+28h]
		cdq
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_F0], eax
		mov	[ebp+var_EC], edx
		jmp	short loc_479A
; ---------------------------------------------------------------------------

loc_4773:				; CODE XREF: _utext_getPreviousNativeIndex_56+103j
		mov	esi, esp
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+28h]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_F0], eax
		mov	[ebp+var_EC], edx

loc_479A:				; CODE XREF: _utext_getPreviousNativeIndex_56+121j
		mov	eax, [ebp+var_F0]
		mov	[ebp+var_18], eax
		mov	ecx, [ebp+var_EC]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	eax, [ebp+var_18]
		mov	edx, [ebp+var_14]

loc_47BE:				; CODE XREF: _utext_getPreviousNativeIndex_56+B7j
					; _utext_getPreviousNativeIndex_56+E6j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_getPreviousNativeIndex_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 47D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_current32_56
_utext_current32_56 proc near		; CODE XREF: _utext_char32At_56+136p

var_10C		= byte ptr -10Ch
var_45		= byte ptr -45h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jnz	short loc_4837
		mov	esi, esp
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [eax+10h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4837
		or	eax, 0FFFFFFFFh
		jmp	loc_4988
; ---------------------------------------------------------------------------

loc_4837:				; CODE XREF: _utext_current32_56+2Aj
					; _utext_current32_56+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFFC00h
		xor	ecx, ecx
		cmp	eax, 0D800h
		setz	cl
		test	ecx, ecx
		jnz	short loc_4868
		mov	eax, [ebp+var_8]
		jmp	loc_4988
; ---------------------------------------------------------------------------

loc_4868:				; CODE XREF: _utext_current32_56+8Aj
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		cmp	ecx, [edx+2Ch]
		jge	short loc_489F
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2+2]
		mov	[ebp+var_14], ecx
		jmp	loc_4963
; ---------------------------------------------------------------------------

loc_489F:				; CODE XREF: _utext_current32_56+B0j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_30], ecx
		mov	edx, [eax+14h]
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	[ebp+var_3C], ecx
		mov	esi, esp
		push	1
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jz	short loc_48F6
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_14], ecx

loc_48F6:				; CODE XREF: _utext_current32_56+10Dj
		mov	esi, esp
		push	0
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_45], al
		movsx	eax, [ebp+var_45]
		cmp	eax, 1
		jz	short loc_494D
		mov	ecx, ds:?__LINE__Var@?1??utext_current32_56@@9@4JA ; long `utext_current32_56'::`2'::__LINE__Var
		add	ecx, 26h ; '&'
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_19HCAPDH@?$AAr?$AA?$DN?$AA?$DN?$AA1?$AA?$AA@ ; "r==1"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_494D:				; CODE XREF: _utext_current32_56+151j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_3C]
		mov	[eax+28h], ecx
		movsx	eax, [ebp+var_45]
		test	eax, eax
		jnz	short loc_4963
		or	eax, 0FFFFFFFFh
		jmp	short loc_4988
; ---------------------------------------------------------------------------

loc_4963:				; CODE XREF: _utext_current32_56+C6j
					; _utext_current32_56+188j
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_4985
		mov	eax, [ebp+var_8]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_14]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_20], edx

loc_4985:				; CODE XREF: _utext_current32_56+19Cj
		mov	eax, [ebp+var_20]

loc_4988:				; CODE XREF: _utext_current32_56+5Ej
					; _utext_current32_56+8Fj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_current32_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 499Ch
		public ??_C@_19HCAPDH@?$AAr?$AA?$DN?$AA?$DN?$AA1?$AA?$AA@
; wchar_t `string'
??_C@_19HCAPDH@?$AAr?$AA?$DN?$AA?$DN?$AA1?$AA?$AA@: ; DATA XREF: _utext_current32_56+164o
		unicode	0, <r==1>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 49A8h
		public ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: _utext_current32_56+15Fo
					; _utf8TextAccess+4FFo	...
		unicode	0, <d:\mozilla\intl\icu\source\common\utext.cpp>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4A00h
		public ?__LINE__Var@?1??utext_current32_56@@9@4JA
; long `utext_current32_56'::`2'::__LINE__Var
?__LINE__Var@?1??utext_current32_56@@9@4JA dd offset ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
					; DATA XREF: _utext_current32_56+153r
_data		ends			; std::_Iosb<int>::_Iostate const std::_Iosb<int>::goodbit

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4A04h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_char32At_56
_utext_char32At_56 proc	near

var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D4]
		mov	ecx, 35h ; '5'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+24h]
		jl	loc_4ACB
		jg	short loc_4A54
		mov	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+20h]
		jb	short loc_4ACB

loc_4A54:				; CODE XREF: _utext_char32At_56+40j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+1Ch]
		cdq
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+20h]
		adc	edx, [ecx+24h]
		mov	[ebp+var_D4], eax
		mov	[ebp+var_D0], edx
		mov	edx, [ebp+arg_8]
		cmp	edx, [ebp+var_D0]
		jg	short loc_4ACB
		jl	short loc_4A88
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_D4]
		jnb	short loc_4ACB

loc_4A88:				; CODE XREF: _utext_char32At_56+77j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	edx, [ebp+arg_8]
		sbb	edx, [eax+24h]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFF800h
		xor	ecx, ecx
		cmp	eax, 0D800h
		setz	cl
		test	ecx, ecx
		jnz	short loc_4ACB
		mov	eax, [ebp+var_8]
		jmp	short loc_4B48
; ---------------------------------------------------------------------------

loc_4ACB:				; CODE XREF: _utext_char32At_56+3Aj
					; _utext_char32At_56+4Ej ...
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+24h]
		jl	short loc_4B45
		jg	short loc_4B06
		mov	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+20h]
		jb	short loc_4B45

loc_4B06:				; CODE XREF: _utext_char32At_56+F2j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jge	short loc_4B45
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	short loc_4B45
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_current32_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_4B45:				; CODE XREF: _utext_char32At_56+F0j
					; _utext_char32At_56+100j ...
		mov	eax, [ebp+var_8]

loc_4B48:				; CODE XREF: _utext_char32At_56+C5j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_char32At_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B5Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_next32_56
_utext_next32_56 proc near		; CODE XREF: _utext_moveIndex32_56+83p
					; _utext_getPreviousNativeIndex_56+160p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jl	short loc_4BBF
		mov	esi, esp
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [eax+10h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4BBF
		or	eax, 0FFFFFFFFh
		jmp	loc_4C94
; ---------------------------------------------------------------------------

loc_4BBF:				; CODE XREF: _utext_next32_56+2Aj
					; _utext_next32_56+59j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+28h]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFFC00h
		xor	ecx, ecx
		cmp	eax, 0D800h
		setz	cl
		test	ecx, ecx
		jnz	short loc_4BFF
		mov	eax, [ebp+var_8]
		jmp	loc_4C94
; ---------------------------------------------------------------------------

loc_4BFF:				; CODE XREF: _utext_next32_56+99j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jl	short loc_4C41
		mov	esi, esp
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [eax+10h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4C41
		mov	eax, [ebp+var_8]
		jmp	short loc_4C94
; ---------------------------------------------------------------------------

loc_4C41:				; CODE XREF: _utext_next32_56+AFj
					; _utext_next32_56+DEj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		xor	ecx, ecx
		cmp	eax, 0DC00h
		setz	cl
		test	ecx, ecx
		jnz	short loc_4C6F
		mov	eax, [ebp+var_8]
		jmp	short loc_4C94
; ---------------------------------------------------------------------------

loc_4C6F:				; CODE XREF: _utext_next32_56+10Cj
		mov	eax, [ebp+var_8]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_14]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx
		mov	eax, [ebp+var_20]

loc_4C94:				; CODE XREF: _utext_next32_56+5Ej
					; _utext_next32_56+9Ej	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_next32_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4CA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_previous32_56
_utext_previous32_56 proc near		; CODE XREF: _utext_moveIndex32_56+122p
					; _utext_getPreviousNativeIndex_56+EFp	...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jg	short loc_4D06
		mov	esi, esp
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+24h]
		push	ecx
		mov	edx, [eax+20h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4D06
		or	eax, 0FFFFFFFFh
		jmp	loc_4DD7
; ---------------------------------------------------------------------------

loc_4D06:				; CODE XREF: _utext_previous32_56+25j
					; _utext_previous32_56+54j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFFC00h
		xor	ecx, ecx
		cmp	eax, 0DC00h
		setz	cl
		test	ecx, ecx
		jnz	short loc_4D46
		mov	eax, [ebp+var_8]
		jmp	loc_4DD7
; ---------------------------------------------------------------------------

loc_4D46:				; CODE XREF: _utext_previous32_56+94j
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jg	short loc_4D83
		mov	esi, esp
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+24h]
		push	ecx
		mov	edx, [eax+20h]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+18h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_4D83
		mov	eax, [ebp+var_8]
		jmp	short loc_4DD7
; ---------------------------------------------------------------------------

loc_4D83:				; CODE XREF: _utext_previous32_56+A5j
					; _utext_previous32_56+D4j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2-2]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFFC00h
		xor	ecx, ecx
		cmp	eax, 0D800h
		setz	cl
		test	ecx, ecx
		jnz	short loc_4DB2
		mov	eax, [ebp+var_8]
		jmp	short loc_4DD7
; ---------------------------------------------------------------------------

loc_4DB2:				; CODE XREF: _utext_previous32_56+103j
		mov	eax, [ebp+var_14]
		shl	eax, 0Ah
		mov	ecx, [ebp+var_8]
		lea	edx, [eax+ecx-35FDC00h]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx
		mov	eax, [ebp+var_20]

loc_4DD7:				; CODE XREF: _utext_previous32_56+59j
					; _utext_previous32_56+99j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_previous32_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4DECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_next32From_56
_utext_next32From_56 proc near

var_DC		= dword	ptr -0DCh
var_D8		= dword	ptr -0D8h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+24h]
		jl	short loc_4E5F
		jg	short loc_4E38
		mov	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+20h]
		jb	short loc_4E5F

loc_4E38:				; CODE XREF: _utext_next32From_56+3Cj
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+14h]
		jl	short loc_4E98
		jg	short loc_4E5F
		mov	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+10h]
		jb	short loc_4E98

loc_4E5F:				; CODE XREF: _utext_next32From_56+3Aj
					; _utext_next32From_56+4Aj ...
		mov	esi, esp
		push	1
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_4E93
		or	eax, 0FFFFFFFFh
		jmp	loc_4F7B
; ---------------------------------------------------------------------------

loc_4E93:				; CODE XREF: _utext_next32From_56+9Dj
		jmp	loc_4F24
; ---------------------------------------------------------------------------

loc_4E98:				; CODE XREF: _utext_next32From_56+61j
					; _utext_next32From_56+71j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	esi, [ebp+arg_8]
		sbb	esi, [eax+24h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		cdq
		mov	[ebp+var_D4], ecx
		mov	[ebp+var_D0], esi
		mov	[ebp+var_DC], eax
		mov	[ebp+var_D8], edx
		mov	eax, [ebp+var_D0]
		cmp	eax, [ebp+var_D8]
		jg	short loc_4EFB
		jl	short loc_4EE4
		mov	ecx, [ebp+var_D4]
		cmp	ecx, [ebp+var_DC]
		ja	short loc_4EFB

loc_4EE4:				; CODE XREF: _utext_next32From_56+E8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	edx, [ebp+arg_8]
		sbb	edx, [eax+24h]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		jmp	short loc_4F24
; ---------------------------------------------------------------------------

loc_4EFB:				; CODE XREF: _utext_next32From_56+E6j
					; _utext_next32From_56+F6j
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+2Ch]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax

loc_4F24:				; CODE XREF: _utext_next32From_56:loc_4E93j
					; _utext_next32From_56+10Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+28h]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	short loc_4F78
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_next32_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_4F78:				; CODE XREF: _utext_next32From_56+167j
		mov	eax, [ebp+var_8]

loc_4F7B:				; CODE XREF: _utext_next32From_56+A2j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_next32From_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4F90h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_previous32From_56
_utext_previous32From_56 proc near

var_DC		= dword	ptr -0DCh
var_D8		= dword	ptr -0D8h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+24h]
		jl	short loc_4FFC
		jg	short loc_4FD5
		mov	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+20h]
		jbe	short loc_4FFC

loc_4FD5:				; CODE XREF: _utext_previous32From_56+35j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+14h]
		jl	short loc_5035
		jg	short loc_4FFC
		mov	eax, [ebp+var_D0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+10h]
		jbe	short loc_5035

loc_4FFC:				; CODE XREF: _utext_previous32From_56+33j
					; _utext_previous32From_56+43j	...
		mov	esi, esp
		push	0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_5030
		or	eax, 0FFFFFFFFh
		jmp	loc_5152
; ---------------------------------------------------------------------------

loc_5030:				; CODE XREF: _utext_previous32From_56+96j
		jmp	loc_50FB
; ---------------------------------------------------------------------------

loc_5035:				; CODE XREF: _utext_previous32From_56+5Aj
					; _utext_previous32From_56+6Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	esi, [ebp+arg_8]
		sbb	esi, [eax+24h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		cdq
		mov	[ebp+var_D4], ecx
		mov	[ebp+var_D0], esi
		mov	[ebp+var_DC], eax
		mov	[ebp+var_D8], edx
		mov	eax, [ebp+var_D0]
		cmp	eax, [ebp+var_D8]
		jg	short loc_5098
		jl	short loc_5081
		mov	ecx, [ebp+var_D4]
		cmp	ecx, [ebp+var_DC]
		ja	short loc_5098

loc_5081:				; CODE XREF: _utext_previous32From_56+E1j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	edx, [ebp+arg_8]
		sbb	edx, [eax+24h]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		jmp	short loc_50FB
; ---------------------------------------------------------------------------

loc_5098:				; CODE XREF: _utext_previous32From_56+DFj
					; _utext_previous32From_56+EFj
		mov	esi, esp
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+2Ch]
		call	edx
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_50FB
		mov	esi, esp
		push	0
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+18h]
		call	edx
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	eax, al
		test	eax, eax
		jnz	short loc_50FB
		or	eax, 0FFFFFFFFh
		jmp	short loc_5152
; ---------------------------------------------------------------------------

loc_50FB:				; CODE XREF: _utext_previous32From_56:loc_5030j
					; _utext_previous32From_56+106j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	short loc_514F
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_previous32_56
		add	esp, 4
		mov	[ebp+var_8], eax

loc_514F:				; CODE XREF: _utext_previous32From_56+19Aj
		mov	eax, [ebp+var_8]

loc_5152:				; CODE XREF: _utext_previous32From_56+9Bj
					; _utext_previous32From_56+169j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_previous32From_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5168h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_extract_56
_utext_extract_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	esi, esp
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+34h]
		mov	ecx, [eax+1Ch]
		call	ecx
		add	esp, 20h
		cmp	esi, esp
		call	__RTC_CheckEsp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_extract_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 51D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_equals_56
_utext_equals_56 proc near

var_D0		= dword	ptr -0D0h
var_CC		= dword	ptr -0CCh
var_C8		= dword	ptr -0C8h
var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_5214
		cmp	[ebp+arg_4], 0
		jz	short loc_5214
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 345AD82Ch
		jnz	short loc_5214
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 345AD82Ch
		jz	short loc_5218

loc_5214:				; CODE XREF: _utext_equals_56+22j
					; _utext_equals_56+28j	...
		xor	al, al
		jmp	short loc_5292
; ---------------------------------------------------------------------------

loc_5218:				; CODE XREF: _utext_equals_56+3Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax+34h]
		cmp	edx, [ecx+34h]
		jz	short loc_522A
		xor	al, al
		jmp	short loc_5292
; ---------------------------------------------------------------------------

loc_522A:				; CODE XREF: _utext_equals_56+50j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax+3Ch]
		cmp	edx, [ecx+3Ch]
		jz	short loc_523C
		xor	al, al
		jmp	short loc_5292
; ---------------------------------------------------------------------------

loc_523C:				; CODE XREF: _utext_equals_56+62j
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	esi, eax
		mov	edi, edx
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+var_C8], esi
		mov	[ebp+var_C4], edi
		mov	[ebp+var_D0], eax
		mov	[ebp+var_CC], edx
		mov	edx, [ebp+var_C8]
		cmp	edx, [ebp+var_D0]
		jnz	short loc_528C
		mov	eax, [ebp+var_C4]
		cmp	eax, [ebp+var_CC]
		jz	short loc_5290

loc_528C:				; CODE XREF: _utext_equals_56+A8j
		xor	al, al
		jmp	short loc_5292
; ---------------------------------------------------------------------------

loc_5290:				; CODE XREF: _utext_equals_56+B6j
		mov	al, 1

loc_5292:				; CODE XREF: _utext_equals_56+42j
					; _utext_equals_56+54j	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_equals_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52A8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_isWritable_56
_utext_isWritable_56 proc near

var_CC		= byte ptr -0CCh
var_5		= byte ptr -5
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 8
		setnz	dl
		mov	[ebp+var_5], dl
		mov	al, [ebp+var_5]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utext_isWritable_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 52E0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_freeze_56
_utext_freeze_56 proc near		; CODE XREF: _utext_clone_56+9Dp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFF7h
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utext_freeze_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5314h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_hasMetaData_56
_utext_hasMetaData_56 proc near

var_CC		= byte ptr -0CCh
var_5		= byte ptr -5
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 10h
		setnz	dl
		mov	[ebp+var_5], dl
		mov	al, [ebp+var_5]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utext_hasMetaData_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 534Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_replace_56
_utext_replace_56 proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5383
		xor	eax, eax
		jmp	short loc_53D8
; ---------------------------------------------------------------------------

loc_5383:				; CODE XREF: _utext_replace_56+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 8
		jnz	short loc_539B
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1Eh
		xor	eax, eax
		jmp	short loc_53D8
; ---------------------------------------------------------------------------

loc_539B:				; CODE XREF: _utext_replace_56+40j
		mov	esi, esp
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+arg_18]
		push	ecx
		mov	edx, [ebp+arg_14]
		push	edx
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+34h]
		mov	ecx, [eax+20h]
		call	ecx
		add	esp, 20h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]

loc_53D8:				; CODE XREF: _utext_replace_56+35j
					; _utext_replace_56+4Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_replace_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 53ECh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _utext_replace_56+24p
					; _utext_copy_56+24p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5418h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_copy_56
_utext_copy_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= byte ptr  24h
arg_20		= dword	ptr  28h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_544D
		jmp	short loc_549F
; ---------------------------------------------------------------------------

loc_544D:				; CODE XREF: _utext_copy_56+31j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 8
		jnz	short loc_5463
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 1Eh
		jmp	short loc_549F
; ---------------------------------------------------------------------------

loc_5463:				; CODE XREF: _utext_copy_56+3Ej
		mov	esi, esp
		mov	eax, [ebp+arg_20]
		push	eax
		movzx	ecx, [ebp+arg_1C]
		push	ecx
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		mov	edx, [ebp+arg_C]
		push	edx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	edx, [ecx+24h]
		call	edx
		add	esp, 24h
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_549F:				; CODE XREF: _utext_copy_56+33j
					; _utext_copy_56+49j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_copy_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 54B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_clone_56
_utext_clone_56	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= byte ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_54EC
		mov	eax, [ebp+arg_0]
		jmp	short loc_555C
; ---------------------------------------------------------------------------

loc_54EC:				; CODE XREF: _utext_clone_56+31j
		mov	esi, esp
		mov	eax, [ebp+arg_10]
		push	eax
		movzx	ecx, [ebp+arg_8]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_4]
		mov	edx, [ecx+34h]
		mov	eax, [edx+10h]
		call	eax
		add	esp, 10h
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_5531
		mov	eax, [ebp+var_8]
		jmp	short loc_555C
; ---------------------------------------------------------------------------

loc_5531:				; CODE XREF: _utext_clone_56+76j
		cmp	[ebp+var_8], 0
		jnz	short loc_5545
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		mov	eax, [ebp+var_8]
		jmp	short loc_555C
; ---------------------------------------------------------------------------

loc_5545:				; CODE XREF: _utext_clone_56+81j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_5559
		mov	eax, [ebp+var_8]
		push	eax
		call	_utext_freeze_56
		add	esp, 4

loc_5559:				; CODE XREF: _utext_clone_56+97j
		mov	eax, [ebp+var_8]

loc_555C:				; CODE XREF: _utext_clone_56+36j
					; _utext_clone_56+7Bj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_clone_56	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5570h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_setup_56
_utext_setup_56	proc near		; CODE XREF: _shallowTextClone+4Fp
					; _utext_openUTF8_56+91p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_55AB
		mov	eax, [ebp+arg_0]
		jmp	loc_581B
; ---------------------------------------------------------------------------

loc_55AB:				; CODE XREF: _utext_setup_56+31j
		cmp	[ebp+arg_0], 0
		jnz	short loc_562C
		mov	[ebp+var_8], 70h ; 'p'
		cmp	[ebp+arg_4], 0
		jle	short loc_55C7
		mov	eax, [ebp+arg_4]
		add	eax, 70h ; 'p'
		mov	[ebp+var_8], eax

loc_55C7:				; CODE XREF: _utext_setup_56+4Cj
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+arg_0], eax
		cmp	[ebp+arg_0], 0
		jnz	short loc_55EE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_581B
; ---------------------------------------------------------------------------
		jmp	short loc_5627
; ---------------------------------------------------------------------------

loc_55EE:				; CODE XREF: _utext_setup_56+6Aj
		mov	ecx, 1Ch
		mov	esi, offset _emptyText ; ",ØZ4"
		mov	edi, [ebp+arg_0]
		rep movsd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		or	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+4], ecx
		cmp	[ebp+var_8], 0
		jle	short loc_5627
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+18h], ecx
		mov	eax, [ebp+arg_0]
		add	eax, 70h ; 'p'
		mov	ecx, [ebp+arg_0]
		mov	[ecx+38h], eax

loc_5627:				; CODE XREF: _utext_setup_56+7Cj
					; _utext_setup_56+A0j
		jmp	loc_56F6
; ---------------------------------------------------------------------------

loc_562C:				; CODE XREF: _utext_setup_56+3Fj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 345AD82Ch
		jz	short loc_5648
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+arg_0]
		jmp	loc_581B
; ---------------------------------------------------------------------------

loc_5648:				; CODE XREF: _utext_setup_56+C5j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 4
		jz	short loc_567A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		cmp	dword ptr [ecx+30h], 0
		jz	short loc_567A
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+30h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_567A:				; CODE XREF: _utext_setup_56+E1j
					; _utext_setup_56+EDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFBh
		mov	edx, [ebp+arg_0]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+18h]
		jle	short loc_56F6
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 2
		jz	short loc_56B8
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+38h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+18h], 0

loc_56B8:				; CODE XREF: _utext_setup_56+12Dj
		mov	eax, [ebp+arg_4]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+38h], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+38h], 0
		jnz	short loc_56DE
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	short loc_56F6
; ---------------------------------------------------------------------------

loc_56DE:				; CODE XREF: _utext_setup_56+161j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+18h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		or	ecx, 2
		mov	edx, [ebp+arg_0]
		mov	[edx+4], ecx

loc_56F6:				; CODE XREF: _utext_setup_56:loc_5627j
					; _utext_setup_56+122j	...
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_5818
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		or	ecx, 4
		mov	edx, [ebp+arg_0]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+3Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+40h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+44h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+50h], 0
		mov	dword ptr [eax+54h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+58h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+10h], 0
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+60h], 0
		mov	dword ptr [eax+64h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+68h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+6Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+4Ch], 0
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+38h], 0
		jz	short loc_5818
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+18h], 0
		jle	short loc_5818
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		push	ecx		; Size
		push	0		; Val
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+38h]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch

loc_5818:				; CODE XREF: _utext_setup_56+199j
					; _utext_setup_56+285j	...
		mov	eax, [ebp+arg_0]

loc_581B:				; CODE XREF: _utext_setup_56+36j
					; _utext_setup_56+77j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_setup_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5830h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _utext_setup_56+18Cp
					; _utf8TextClone+47p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 585Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_close_56
_utext_close_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_5896
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax], 345AD82Ch
		jnz	short loc_5896
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 4
		jnz	short loc_589E

loc_5896:				; CODE XREF: _utext_close_56+22j
					; _utext_close_56+2Dj
		mov	eax, [ebp+arg_0]
		jmp	loc_5945
; ---------------------------------------------------------------------------

loc_589E:				; CODE XREF: _utext_close_56+38j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		cmp	dword ptr [ecx+30h], 0
		jz	short loc_58C5
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+34h]
		mov	eax, [edx+30h]
		call	eax
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_58C5:				; CODE XREF: _utext_close_56+4Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFBh
		mov	edx, [ebp+arg_0]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 2
		jz	short loc_5911
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+38h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+38h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+4], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+18h], 0

loc_5911:				; CODE XREF: _utext_close_56+81j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		and	ecx, 1
		jz	short loc_5942
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+arg_0]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	[ebp+arg_0], 0

loc_5942:				; CODE XREF: _utext_close_56+C8j
		mov	eax, [ebp+arg_0]

loc_5945:				; CODE XREF: _utext_close_56+3Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_close_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 595Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utf8TextLength	proc near		; DATA XREF: .rdata:0000017Co

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+58h], 0
		jge	short loc_59E2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	edx, [ebp+arg_0]
		add	ecx, [edx+5Ch]
		mov	[ebp+var_8], ecx

loc_5992:				; CODE XREF: _utf8TextLength+49j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_59A7
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		jmp	short loc_5992
; ---------------------------------------------------------------------------

loc_59A7:				; CODE XREF: _utf8TextLength+3Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+3Ch]
		cmp	ecx, 7FFFFFFFh
		jge	short loc_59C9
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+3Ch]
		mov	edx, [ebp+arg_0]
		mov	[edx+58h], ecx
		jmp	short loc_59D3
; ---------------------------------------------------------------------------

loc_59C9:				; CODE XREF: _utf8TextLength+5Aj
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+58h], 7FFFFFFFh

loc_59D3:				; CODE XREF: _utf8TextLength+6Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_59E2:				; CODE XREF: _utf8TextLength+25j
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+58h]
		cdq
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextLength	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 59F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utf8TextAccess	proc near		; CODE XREF: _utf8TextExtract+20Cp
					; DATA XREF: .rdata:00000180o

var_24C		= dword	ptr -24Ch
var_248		= dword	ptr -248h
var_244		= dword	ptr -244h
var_17C		= dword	ptr -17Ch
var_170		= dword	ptr -170h
var_164		= dword	ptr -164h
var_158		= dword	ptr -158h
var_14C		= dword	ptr -14Ch
var_140		= dword	ptr -140h
var_134		= dword	ptr -134h
var_128		= dword	ptr -128h
var_11C		= dword	ptr -11Ch
var_110		= dword	ptr -110h
var_101		= byte ptr -101h
var_F5		= byte ptr -0F5h
var_EC		= dword	ptr -0ECh
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_C8		= dword	ptr -0C8h
var_B9		= byte ptr -0B9h
var_B0		= dword	ptr -0B0h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_71		= byte ptr -71h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 24Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_24C]
		mov	ecx, 93h ; ''
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+58h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_2C], eax
		mov	[ebp+var_38], 0
		cmp	[ebp+arg_8], 0
		jg	short loc_5A4B
		jl	short loc_5A42
		cmp	[ebp+arg_4], 0
		jnb	short loc_5A4B

loc_5A42:				; CODE XREF: _utf8TextAccess+4Aj
		mov	[ebp+var_2C], 0
		jmp	short loc_5A63
; ---------------------------------------------------------------------------

loc_5A4B:				; CODE XREF: _utf8TextAccess+48j
					; _utf8TextAccess+50j
		cmp	[ebp+arg_8], 0
		jl	short loc_5A63
		jg	short loc_5A5C
		cmp	[ebp+arg_4], 7FFFFFFFh
		jbe	short loc_5A63

loc_5A5C:				; CODE XREF: _utf8TextAccess+61j
		mov	[ebp+var_2C], 7FFFFFFFh

loc_5A63:				; CODE XREF: _utf8TextAccess+59j
					; _utf8TextAccess+5Fj ...
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jle	loc_5AF3
		cmp	[ebp+var_20], 0
		jl	short loc_5A7D
		mov	eax, [ebp+var_20]
		mov	[ebp+var_2C], eax
		jmp	short loc_5AF3
; ---------------------------------------------------------------------------

loc_5A7D:				; CODE XREF: _utf8TextAccess+83j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+5Ch]
		jl	short loc_5AF3

loc_5A88:				; CODE XREF: _utf8TextAccess+C3j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		cmp	ecx, [ebp+var_2C]
		jge	short loc_5AB5
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+ecx]
		test	eax, eax
		jz	short loc_5AB5
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		add	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+5Ch], ecx
		jmp	short loc_5A88
; ---------------------------------------------------------------------------

loc_5AB5:				; CODE XREF: _utf8TextAccess+A1j
					; _utf8TextAccess+B2j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		mov	edx, [ebp+var_8]
		movzx	eax, byte ptr [edx+ecx]
		test	eax, eax
		jnz	short loc_5AF3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+5Ch]
		mov	[eax+58h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_5AF3:				; CODE XREF: _utf8TextAccess+79j
					; _utf8TextAccess+8Bj ...
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	loc_5CD5
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_248]
		cmp	eax, [edx+10h]
		jnz	short loc_5B7F
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_244]
		cmp	edx, [ecx+14h]
		jnz	short loc_5B7F
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jnz	short loc_5B57
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+28h], edx
		xor	al, al
		jmp	loc_69DD
; ---------------------------------------------------------------------------
		jmp	short loc_5B7F
; ---------------------------------------------------------------------------

loc_5B57:				; CODE XREF: _utf8TextAccess+150j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax]
		jl	short loc_5B7F
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jge	short loc_5B7F
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------

loc_5B7F:				; CODE XREF: _utf8TextAccess+137j
					; _utf8TextAccess+148j	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax]
		jl	short loc_5BA7
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jge	short loc_5BA7
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------

loc_5BA7:				; CODE XREF: _utf8TextAccess+1A0j
					; _utf8TextAccess+1ABj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_20]
		jnz	short loc_5C1C
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_248]
		cmp	eax, [edx+10h]
		jnz	short loc_5BFD
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_244]
		cmp	edx, [ecx+14h]
		jnz	short loc_5BFD
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+28h], edx
		xor	al, al
		jmp	loc_69DD
; ---------------------------------------------------------------------------

loc_5BFD:				; CODE XREF: _utf8TextAccess+1E7j
					; _utf8TextAccess+1F8j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jnz	short loc_5C12
		jmp	$swapBuffersAndFail$36894
; ---------------------------------------------------------------------------
		jmp	$swapBuffersAndFail$36894
; ---------------------------------------------------------------------------

loc_5C12:				; CODE XREF: _utf8TextAccess+216j
		jmp	$makeStubBuffer$36896
; ---------------------------------------------------------------------------
		jmp	$makeStubBuffer$36896
; ---------------------------------------------------------------------------

loc_5C1C:				; CODE XREF: _utf8TextAccess+1BDj
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_244]
		cmp	eax, [edx+24h]
		jl	short loc_5C96
		jg	short loc_5C59
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_248]
		cmp	edx, [ecx+20h]
		jb	short loc_5C96

loc_5C59:				; CODE XREF: _utf8TextAccess+256j
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_244]
		cmp	eax, [edx+14h]
		jl	short loc_5CA0
		jg	short loc_5C96
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_248]
		cmp	edx, [ecx+10h]
		jb	short loc_5CA0

loc_5C96:				; CODE XREF: _utf8TextAccess+254j
					; _utf8TextAccess+267j	...
		jmp	$fillForward$36900
; ---------------------------------------------------------------------------
		jmp	$fillForward$36900
; ---------------------------------------------------------------------------

loc_5CA0:				; CODE XREF: _utf8TextAccess+291j
					; _utf8TextAccess+2A4j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		sub	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		movzx	ecx, byte ptr [eax+84h]
		mov	edx, [ebp+var_14]
		sub	ecx, [edx+8]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		mov	al, 1
		jmp	loc_69DD
; ---------------------------------------------------------------------------

loc_5CD5:				; CODE XREF: _utf8TextAccess+109j
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_248]
		cmp	eax, [edx+20h]
		jnz	short loc_5D51
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_244]
		cmp	edx, [ecx+24h]
		jnz	short loc_5D51
		cmp	[ebp+var_2C], 0
		jnz	short loc_5D29
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		xor	al, al
		jmp	loc_69DD
; ---------------------------------------------------------------------------
		jmp	short loc_5D51
; ---------------------------------------------------------------------------

loc_5D29:				; CODE XREF: _utf8TextAccess+324j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax]
		jle	short loc_5D51
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jg	short loc_5D51
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------

loc_5D51:				; CODE XREF: _utf8TextAccess+30Dj
					; _utf8TextAccess+31Ej	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax]
		jle	short loc_5D79
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jg	short loc_5D79
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------
		jmp	$swapBuffers$36886
; ---------------------------------------------------------------------------

loc_5D79:				; CODE XREF: _utf8TextAccess+372j
					; _utf8TextAccess+37Dj
		cmp	[ebp+var_2C], 0
		jnz	short loc_5D9D
		mov	eax, [ebp+var_14]
		cmp	dword ptr [eax], 0
		jnz	short loc_5D93
		jmp	$swapBuffersAndFail$36894
; ---------------------------------------------------------------------------
		jmp	$swapBuffersAndFail$36894
; ---------------------------------------------------------------------------
		jmp	short loc_5D9D
; ---------------------------------------------------------------------------

loc_5D93:				; CODE XREF: _utf8TextAccess+395j
		jmp	$makeStubBuffer$36896
; ---------------------------------------------------------------------------
		jmp	$makeStubBuffer$36896
; ---------------------------------------------------------------------------

loc_5D9D:				; CODE XREF: _utf8TextAccess+38Dj
					; _utf8TextAccess+3A1j
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_244]
		cmp	eax, [edx+24h]
		jl	short loc_5E17
		jg	short loc_5DDA
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_248]
		cmp	edx, [ecx+20h]
		jbe	short loc_5E17

loc_5DDA:				; CODE XREF: _utf8TextAccess+3D7j
		mov	eax, [ebp+var_2C]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_248], eax
		mov	[ebp+var_244], edx
		mov	[ebp+var_24C], ecx
		mov	edx, [ebp+var_24C]
		mov	eax, [ebp+var_244]
		cmp	eax, [edx+14h]
		jl	short loc_5E21
		jg	short loc_5E17
		mov	ecx, [ebp+var_24C]
		mov	edx, [ebp+var_248]
		cmp	edx, [ecx+10h]
		jbe	short loc_5E21

loc_5E17:				; CODE XREF: _utf8TextAccess+3D5j
					; _utf8TextAccess+3E8j	...
		jmp	$fillReverse$36920
; ---------------------------------------------------------------------------
		jmp	$fillReverse$36920
; ---------------------------------------------------------------------------

loc_5E21:				; CODE XREF: _utf8TextAccess+412j
					; _utf8TextAccess+425j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		sub	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		movzx	ecx, byte ptr [eax+84h]
		mov	edx, [ebp+var_14]
		sub	ecx, [edx+8]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_5E61
		xor	al, al
		jmp	loc_69DD
; ---------------------------------------------------------------------------
		jmp	short $swapBuffers$36886
; ---------------------------------------------------------------------------

loc_5E61:				; CODE XREF: _utf8TextAccess+466j
		mov	al, 1
		jmp	loc_69DD
; ---------------------------------------------------------------------------

$swapBuffers$36886:			; CODE XREF: _utf8TextAccess+185j
					; _utf8TextAccess+18Aj	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+40h]
		mov	[eax+44h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+40h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2+18h]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+30h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+8]
		mov	eax, [ebp+arg_0]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_14]
		mov	eax, [eax]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+var_14]
		mov	eax, [eax+4]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+10h]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax]
		jge	short loc_5F09
		mov	edx, ds:?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338
		add	edx, 0C6h ; 'Æ'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1DA@LIDIDCGI@?$AAi?$AAx?$AA?$DO?$AA?$DN?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ ; "ix>=u8b->bufNativeStart"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5F09:				; CODE XREF: _utf8TextAccess+4EEj
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jle	short loc_5F3D
		mov	edx, ds:?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338
		add	edx, 0C7h ; 'Ç'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1DA@HOAKNNGO@?$AAi?$AAx?$AA?$DM?$AA?$DN?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@ ; "ix<=u8b->bufNativeLimit"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5F3D:				; CODE XREF: _utf8TextAccess+522j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		sub	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		jns	short loc_5F72
		mov	eax, ds:?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338
		add	eax, 0C9h ; 'É'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BI@GHPKBIFA@?$AAm?$AAa?$AAp?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; "mapIndex>=0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5F72:				; CODE XREF: _utf8TextAccess+559j
		cmp	[ebp+var_38], 66h ; 'f'
		jl	short loc_5F9F
		mov	eax, ds:?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338
		add	eax, 0CAh ; 'Ê'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1FG@FGNNNOCG@?$AAm?$AAa?$AAp?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$CI?$AAi?$AAn?$AAt?$AA3?$AA2?$AA_?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAm?$AAa@ ; "mapIndex<(int32_t)sizeof(u8b->mapToUCha"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_5F9F:				; CODE XREF: _utf8TextAccess+586j
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		movzx	ecx, byte ptr [eax+84h]
		mov	edx, [ebp+var_14]
		sub	ecx, [edx+8]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		mov	al, 1
		jmp	loc_69DD
; ---------------------------------------------------------------------------

$swapBuffersAndFail$36894:		; CODE XREF: _utf8TextAccess+218j
					; _utf8TextAccess+21Dj	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+40h]
		mov	[eax+44h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+40h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_14]
		lea	eax, [edx+ecx*2+18h]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+30h], eax
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+8]
		mov	eax, [ebp+arg_0]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_14]
		mov	eax, [eax]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+var_14]
		mov	eax, [eax+4]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	edx, [ecx+10h]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+4]
		jnz	short loc_6046
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+28h], edx
		jmp	short loc_6083
; ---------------------------------------------------------------------------

loc_6046:				; CODE XREF: _utf8TextAccess+646j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax]
		jz	short loc_6083
		mov	edx, ds:?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338
		add	edx, 0EAh ; 'ê'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1DE@OCIKOEBK@?$AAi?$AAx?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ ; "ix == u8b->bufNativeStart"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_6083:				; CODE XREF: _utf8TextAccess+654j
					; _utf8TextAccess+668j
		xor	al, al
		jmp	loc_69DD
; ---------------------------------------------------------------------------

$makeStubBuffer$36896:			; CODE XREF: _utf8TextAccess:loc_5C12j
					; _utf8TextAccess+227j	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_2C]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+60h], 0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+84h], 0
		jmp	$swapBuffersAndFail$36894
; ---------------------------------------------------------------------------

$fillForward$36900:			; CODE XREF: _utf8TextAccess:loc_5C96j
					; _utf8TextAccess+2ABj
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_2C]
		movzx	ecx, byte ptr [eax]
		and	ecx, 0C0h
		cmp	ecx, 80h ; ''
		jnz	short loc_610D
		mov	eax, [ebp+var_2C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_utf8_back1SafeBody_56
		add	esp, 0Ch
		mov	[ebp+var_2C], eax

loc_610D:				; CODE XREF: _utf8TextAccess+706j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+40h]
		mov	[eax+44h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_5C]
		mov	[eax+40h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+58h]
		mov	[ebp+var_68], ecx
		mov	[ebp+var_71], 0
		cmp	[ebp+var_68], 0
		jge	short loc_6149
		mov	[ebp+var_68], 7FFFFFFFh
		mov	[ebp+var_71], 1

loc_6149:				; CODE XREF: _utf8TextAccess+74Cj
		mov	eax, [ebp+var_5C]
		add	eax, 18h
		mov	[ebp+var_80], eax
		mov	eax, [ebp+var_5C]
		add	eax, 60h ; '`'
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_5C]
		add	eax, 84h ; ''
		mov	[ebp+var_98], eax
		mov	[ebp+var_A4], 0
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_B0], eax
		mov	[ebp+var_B9], 0
		mov	[ebp+var_C8], 0

loc_6190:				; CODE XREF: _utf8TextAccess:loc_6514j
		cmp	[ebp+var_A4], 20h ; ' '
		jge	loc_6519
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_B0]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_C8], ecx
		cmp	[ebp+var_C8], 0
		jle	short loc_622A
		cmp	[ebp+var_C8], 80h ; ''
		jge	short loc_622A
		mov	eax, [ebp+var_A4]
		mov	ecx, [ebp+var_80]
		mov	dx, word ptr [ebp+var_C8]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8C]
		add	ecx, [ebp+var_A4]
		mov	[ecx], al
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_98]
		mov	dl, byte ptr [ebp+var_A4]
		mov	[ecx+eax], dl
		mov	eax, [ebp+var_B0]
		add	eax, 1
		mov	[ebp+var_B0], eax
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax
		jmp	loc_6507
; ---------------------------------------------------------------------------

loc_622A:				; CODE XREF: _utf8TextAccess+7C6j
					; _utf8TextAccess+7D2j
		movsx	eax, [ebp+var_B9]
		test	eax, eax
		jnz	short loc_6248
		mov	[ebp+var_B9], 1
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_A4]
		mov	[eax+10h], ecx

loc_6248:				; CODE XREF: _utf8TextAccess+843j
		mov	eax, [ebp+var_B0]
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+var_A4]
		mov	[ebp+var_E0], eax
		mov	eax, [ebp+var_A4]
		mov	[ebp+var_EC], eax
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_B0]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_C8], ecx
		mov	edx, [ebp+var_B0]
		add	edx, 1
		mov	[ebp+var_B0], edx
		cmp	[ebp+var_C8], 80h ; ''
		jl	loc_63F2
		cmp	[ebp+var_C8], 0E0h ; 'à'
		jle	loc_6359
		cmp	[ebp+var_C8], 0ECh ; 'ì'
		jg	loc_6359
		mov	eax, [ebp+var_B0]
		add	eax, 1
		cmp	eax, [ebp+var_68]
		jl	short loc_62D5
		cmp	[ebp+var_68], 0
		jge	loc_6359

loc_62D5:				; CODE XREF: _utf8TextAccess+8D9j
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_B0]
		movzx	ecx, byte ptr [eax]
		sub	ecx, 80h ; ''
		mov	[ebp+var_F5], cl
		movzx	edx, [ebp+var_F5]
		cmp	edx, 3Fh ; '?'
		jg	short loc_6359
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_B0]
		movzx	ecx, byte ptr [eax+1]
		sub	ecx, 80h ; ''
		mov	[ebp+var_101], cl
		movzx	edx, [ebp+var_101]
		cmp	edx, 3Fh ; '?'
		jg	short loc_6359
		mov	eax, [ebp+var_C8]
		shl	eax, 0Ch
		movzx	ecx, [ebp+var_F5]
		shl	ecx, 6
		or	eax, ecx
		movzx	edx, [ebp+var_101]
		or	eax, edx
		movzx	eax, ax
		mov	[ebp+var_C8], eax
		mov	eax, [ebp+var_B0]
		add	eax, 2
		mov	[ebp+var_B0], eax
		jmp	loc_63F2
; ---------------------------------------------------------------------------

loc_6359:				; CODE XREF: _utf8TextAccess+8B7j
					; _utf8TextAccess+8C7j	...
		cmp	[ebp+var_C8], 0E0h ; 'à'
		jge	short loc_63CC
		cmp	[ebp+var_C8], 0C2h ; 'Â'
		jl	short loc_63CC
		mov	eax, [ebp+var_B0]
		cmp	eax, [ebp+var_68]
		jz	short loc_63CC
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_B0]
		movzx	ecx, byte ptr [eax]
		sub	ecx, 80h ; ''
		mov	[ebp+var_F5], cl
		movzx	edx, [ebp+var_F5]
		cmp	edx, 3Fh ; '?'
		jg	short loc_63CC
		mov	eax, [ebp+var_C8]
		and	eax, 1Fh
		shl	eax, 6
		movzx	ecx, [ebp+var_F5]
		or	eax, ecx
		mov	[ebp+var_C8], eax
		mov	eax, [ebp+var_B0]
		add	eax, 1
		mov	[ebp+var_B0], eax
		jmp	short loc_63F2
; ---------------------------------------------------------------------------

loc_63CC:				; CODE XREF: _utf8TextAccess+973j
					; _utf8TextAccess+97Fj	...
		push	0FFFFFFFDh
		mov	eax, [ebp+var_C8]
		push	eax
		mov	ecx, [ebp+var_68]
		push	ecx
		lea	edx, [ebp+var_B0]
		push	edx
		mov	eax, [ebp+var_8]
		push	eax
		call	_utf8_nextCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_C8], eax

loc_63F2:				; CODE XREF: _utf8TextAccess+8A7j
					; _utf8TextAccess+964j	...
		cmp	[ebp+var_C8], 0
		jnz	short loc_6417
		movsx	eax, [ebp+var_71]
		test	eax, eax
		jz	short loc_6417
		mov	eax, [ebp+var_B0]
		sub	eax, 1
		mov	[ebp+var_B0], eax
		jmp	loc_6519
; ---------------------------------------------------------------------------

loc_6417:				; CODE XREF: _utf8TextAccess+A09j
					; _utf8TextAccess+A11j
		cmp	[ebp+var_C8], 0FFFFh
		ja	short loc_6448
		mov	eax, [ebp+var_A4]
		mov	ecx, [ebp+var_80]
		mov	dx, word ptr [ebp+var_C8]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax
		jmp	short loc_649E
; ---------------------------------------------------------------------------

loc_6448:				; CODE XREF: _utf8TextAccess+A31j
		mov	eax, [ebp+var_C8]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_A4]
		mov	edx, [ebp+var_80]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax
		mov	eax, [ebp+var_C8]
		and	eax, 3FFh
		or	eax, 0DC00h
		mov	ecx, [ebp+var_A4]
		mov	edx, [ebp+var_80]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_A4]
		add	eax, 1
		mov	[ebp+var_A4], eax

loc_649E:				; CODE XREF: _utf8TextAccess+A56j
					; _utf8TextAccess+AE0j
		mov	eax, [ebp+var_D4]
		sub	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8C]
		add	ecx, [ebp+var_E0]
		mov	[ecx], al
		mov	edx, [ebp+var_E0]
		add	edx, 1
		mov	[ebp+var_E0], edx
		mov	eax, [ebp+var_E0]
		cmp	eax, [ebp+var_A4]
		jl	short loc_649E

loc_64D2:				; CODE XREF: _utf8TextAccess+B15j
		mov	eax, [ebp+var_D4]
		sub	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_98]
		mov	dl, byte ptr [ebp+var_EC]
		mov	[ecx+eax], dl
		mov	eax, [ebp+var_D4]
		add	eax, 1
		mov	[ebp+var_D4], eax
		mov	eax, [ebp+var_D4]
		cmp	eax, [ebp+var_B0]
		jl	short loc_64D2

loc_6507:				; CODE XREF: _utf8TextAccess+835j
		mov	eax, [ebp+var_B0]
		cmp	eax, [ebp+var_68]
		jl	short loc_6514
		jmp	short loc_6519
; ---------------------------------------------------------------------------

loc_6514:				; CODE XREF: _utf8TextAccess+B20j
		jmp	loc_6190
; ---------------------------------------------------------------------------

loc_6519:				; CODE XREF: _utf8TextAccess+7A7j
					; _utf8TextAccess+A22j	...
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_8C]
		add	ecx, [ebp+var_A4]
		mov	[ecx], al
		mov	eax, [ebp+var_B0]
		sub	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_98]
		mov	dl, byte ptr [ebp+var_A4]
		mov	[ecx+eax], dl
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_2C]
		mov	[eax], ecx
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_B0]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_5C]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_A4]
		mov	[eax+0Ch], ecx
		movsx	eax, [ebp+var_B9]
		test	eax, eax
		jnz	short loc_6589
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_A4]
		mov	[eax+10h], ecx

loc_6589:				; CODE XREF: _utf8TextAccess+B8Bj
		mov	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_5C]
		mov	edx, [ecx]
		mov	[eax+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_80]
		mov	[eax+30h], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_5C]
		mov	edx, [ecx+0Ch]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+var_5C]
		mov	eax, [eax]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+var_5C]
		mov	eax, [eax+4]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_5C]
		mov	edx, [ecx+10h]
		mov	[eax+1Ch], edx
		movsx	eax, [ebp+var_71]
		test	eax, eax
		jz	short loc_6624
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_B0]
		cmp	ecx, [eax+5Ch]
		jle	short loc_6624
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_B0]
		mov	[eax+5Ch], ecx
		cmp	[ebp+var_C8], 0
		jnz	short loc_6624
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_B0]
		mov	[eax+58h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_6624:				; CODE XREF: _utf8TextAccess+BF4j
					; _utf8TextAccess+C02j	...
		mov	al, 1
		jmp	loc_69DD
; ---------------------------------------------------------------------------

$fillReverse$36920:			; CODE XREF: _utf8TextAccess:loc_5E17j
					; _utf8TextAccess+42Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+58h]
		jz	short loc_6662
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_2C]
		movzx	ecx, byte ptr [eax]
		and	ecx, 0C0h
		cmp	ecx, 80h ; ''
		jnz	short loc_6662
		mov	eax, [ebp+var_2C]
		push	eax
		push	0
		mov	ecx, [ebp+var_8]
		push	ecx
		call	_utf8_back1SafeBody_56
		add	esp, 0Ch
		mov	[ebp+var_2C], eax

loc_6662:				; CODE XREF: _utf8TextAccess+C44j
					; _utf8TextAccess+C5Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_110], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+40h]
		mov	[eax+44h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_110]
		mov	[eax+40h], ecx
		mov	eax, [ebp+var_110]
		add	eax, 18h
		mov	[ebp+var_11C], eax
		mov	eax, [ebp+var_110]
		add	eax, 60h ; '`'
		mov	[ebp+var_128], eax
		mov	eax, [ebp+var_110]
		add	eax, 84h ; ''
		mov	[ebp+var_134], eax
		mov	eax, [ebp+var_2C]
		sub	eax, 61h ; 'a'
		mov	[ebp+var_140], eax
		mov	[ebp+var_14C], 22h ; '"'
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_158], eax
		mov	eax, [ebp+var_14C]
		mov	[ebp+var_164], eax
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_128]
		add	ecx, [ebp+var_14C]
		mov	[ecx], al
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_134]
		mov	dl, byte ptr [ebp+var_14C]
		mov	[ecx+eax], dl

loc_6715:				; CODE XREF: _utf8TextAccess:loc_6909j
		cmp	[ebp+var_14C], 2
		jle	loc_690E
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		cmp	eax, 5
		jle	loc_690E
		cmp	[ebp+var_158], 0
		jle	loc_690E
		mov	eax, [ebp+var_158]
		sub	eax, 1
		mov	[ebp+var_158], eax
		mov	eax, [ebp+var_14C]
		sub	eax, 1
		mov	[ebp+var_14C], eax
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_158]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_170], ecx
		cmp	[ebp+var_170], 80h ; ''
		jge	short loc_67D1
		mov	eax, [ebp+var_14C]
		mov	ecx, [ebp+var_11C]
		mov	dx, word ptr [ebp+var_170]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_134]
		mov	dl, byte ptr [ebp+var_14C]
		mov	[ecx+eax], dl
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_128]
		add	ecx, [ebp+var_14C]
		mov	[ecx], al
		jmp	loc_6909
; ---------------------------------------------------------------------------

loc_67D1:				; CODE XREF: _utf8TextAccess+D8Ej
		mov	eax, [ebp+var_158]
		mov	[ebp+var_17C], eax
		push	0FFFFFFFDh
		mov	eax, [ebp+var_170]
		push	eax
		lea	ecx, [ebp+var_158]
		push	ecx
		push	0
		mov	edx, [ebp+var_8]
		push	edx
		call	_utf8_prevCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_170], eax
		cmp	[ebp+var_170], 10000h
		jge	short loc_6843
		mov	eax, [ebp+var_14C]
		mov	ecx, [ebp+var_11C]
		mov	dx, word ptr [ebp+var_170]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_128]
		add	ecx, [ebp+var_14C]
		mov	[ecx], al
		jmp	loc_68C5
; ---------------------------------------------------------------------------

loc_6843:				; CODE XREF: _utf8TextAccess+E1Bj
		mov	eax, [ebp+var_170]
		and	eax, 3FFh
		or	eax, 0DC00h
		mov	ecx, [ebp+var_14C]
		mov	edx, [ebp+var_11C]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_128]
		add	ecx, [ebp+var_14C]
		mov	[ecx], al
		mov	eax, [ebp+var_14C]
		sub	eax, 1
		mov	[ebp+var_14C], eax
		mov	ecx, [ebp+var_170]
		sar	ecx, 0Ah
		add	ecx, 0D7C0h
		mov	edx, [ebp+var_14C]
		mov	eax, [ebp+var_11C]
		mov	[eax+edx*2], cx
		mov	eax, [ebp+var_158]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_128]
		add	ecx, [ebp+var_14C]
		mov	[ecx], al

loc_68C5:				; CODE XREF: _utf8TextAccess+E4Ej
					; _utf8TextAccess+F0Bj
		mov	eax, [ebp+var_17C]
		sub	eax, [ebp+var_140]
		mov	ecx, [ebp+var_134]
		mov	dl, byte ptr [ebp+var_14C]
		mov	[ecx+eax], dl
		mov	eax, [ebp+var_17C]
		sub	eax, 1
		mov	[ebp+var_17C], eax
		mov	eax, [ebp+var_17C]
		cmp	eax, [ebp+var_158]
		jge	short loc_68C5
		mov	eax, [ebp+var_14C]
		mov	[ebp+var_164], eax

loc_6909:				; CODE XREF: _utf8TextAccess+DDCj
		jmp	loc_6715
; ---------------------------------------------------------------------------

loc_690E:				; CODE XREF: _utf8TextAccess+D2Cj
					; _utf8TextAccess+D41j	...
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_158]
		mov	[eax], ecx
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_2C]
		mov	[eax+4], ecx
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_14C]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_110]
		mov	dword ptr [eax+0Ch], 22h ; '"'
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_164]
		sub	ecx, [eax+8]
		mov	edx, [ebp+var_110]
		mov	[edx+10h], ecx
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_140]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_110]
		mov	ecx, [eax+8]
		mov	edx, [ebp+var_11C]
		lea	eax, [edx+ecx*2]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+30h], eax
		mov	eax, [ebp+var_110]
		mov	ecx, [ebp+var_110]
		mov	edx, [eax+0Ch]
		sub	edx, [ecx+8]
		mov	eax, [ebp+arg_0]
		mov	[eax+2Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+28h], edx
		mov	eax, [ebp+var_110]
		mov	eax, [eax]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+var_110]
		mov	eax, [eax+4]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_110]
		mov	edx, [ecx+10h]
		mov	[eax+1Ch], edx
		mov	al, 1

loc_69DD:				; CODE XREF: _utf8TextAccess+160j
					; _utf8TextAccess+208j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN99
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 24Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextAccess	endp

; ---------------------------------------------------------------------------
		align 4
$LN99		dd 2			; DATA XREF: _utf8TextAccess+FF1o
		dd offset $LN98
$LN98		dd 0FFFFFF50h, 4	; DATA XREF: .text:00006A08o
		dd offset $LN96		; "srcIx"
		dd 0FFFFFEA8h, 4
		dd offset $LN97		; "srcIx"
$LN97		db 'srcIx',0            ; DATA XREF: .text:00006A20o
$LN96		db 'srcIx',0            ; DATA XREF: .text:00006A14o
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A30h
		public ??_C@_1DE@OCIKOEBK@?$AAi?$AAx?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1DE@OCIKOEBK@?$AAi?$AAx?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@:
					; DATA XREF: _utf8TextAccess+67Eo
		unicode	0, <ix == u8b->
		dw 3Eh
		unicode	0, <bufNativeStart>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 6A64h
		public ??_C@_1FG@FGNNNOCG@?$AAm?$AAa?$AAp?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$CI?$AAi?$AAn?$AAt?$AA3?$AA2?$AA_?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAm?$AAa@
; wchar_t `string'
??_C@_1FG@FGNNNOCG@?$AAm?$AAa?$AAp?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$CI?$AAi?$AAn?$AAt?$AA3?$AA2?$AA_?$AAt?$AA?$CJ?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAm?$AAa@:
					; DATA XREF: _utf8TextAccess+59Ao
		unicode	0, <mapIndex>
		dw 3Ch
		unicode	0, <(int32_t)sizeof(u8b->
		dw 3Eh
		unicode	0, <mapToUChars)>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6ABCh
		public ??_C@_1BI@GHPKBIFA@?$AAm?$AAa?$AAp?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BI@GHPKBIFA@?$AAm?$AAa?$AAp?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@:
					; DATA XREF: _utf8TextAccess+56Do
		unicode	0, <mapIndex>
		dw 3Eh
		unicode	0, <=0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6AD4h
		public ??_C@_1DA@HOAKNNGO@?$AAi?$AAx?$AA?$DM?$AA?$DN?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1DA@HOAKNNGO@?$AAi?$AAx?$AA?$DM?$AA?$DN?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@:
					; DATA XREF: _utf8TextAccess+538o
		unicode	0, <ix>
		dw 3Ch
		unicode	0, <=u8b->
		dw 3Eh
		unicode	0, <bufNativeLimit>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6B04h
		public ??_C@_1DA@LIDIDCGI@?$AAi?$AAx?$AA?$DO?$AA?$DN?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1DA@LIDIDCGI@?$AAi?$AAx?$AA?$DO?$AA?$DN?$AAu?$AA8?$AAb?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@:
					; DATA XREF: _utf8TextAccess+504o
		unicode	0, <ix>
		dw 3Eh
		unicode	0, <=u8b->
		dw 3Eh
		unicode	0, <bufNativeStart>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6B34h
		public ?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338
?__LINE__Var@?1??utf8TextAccess@@9@4JA@8d672338	dd 3A2h	; DATA XREF: _utf8TextAccess+4F0r
					; _utf8TextAccess+524r	...
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6B38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utf8TextExtract proc near		; DATA XREF: .rdata:00000184o

var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_C		= byte ptr  14h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_6B72
		xor	eax, eax
		jmp	loc_6D4F
; ---------------------------------------------------------------------------

loc_6B72:				; CODE XREF: _utf8TextExtract+31j
		cmp	[ebp+arg_18], 0
		jl	short loc_6B84
		cmp	[ebp+arg_14], 0
		jnz	short loc_6B94
		cmp	[ebp+arg_18], 0
		jle	short loc_6B94

loc_6B84:				; CODE XREF: _utf8TextExtract+3Ej
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_6D4F
; ---------------------------------------------------------------------------

loc_6B94:				; CODE XREF: _utf8TextExtract+44j
					; _utf8TextExtract+4Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+58h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jle	short loc_6BDF
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_6D4F
; ---------------------------------------------------------------------------

loc_6BDF:				; CODE XREF: _utf8TextExtract+95j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_14]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	[ebp+var_114], ecx
		mov	edx, [ebp+var_114]
		mov	eax, [ebp+var_10C]
		cmp	eax, [edx+14h]
		jg	short loc_6C78
		jl	short loc_6C25
		mov	ecx, [ebp+var_114]
		mov	edx, [ebp+var_110]
		cmp	edx, [ecx+10h]
		jnb	short loc_6C78

loc_6C25:				; CODE XREF: _utf8TextExtract+DAj
		mov	[ebp+var_38], 0
		jmp	short loc_6C37
; ---------------------------------------------------------------------------

loc_6C2E:				; CODE XREF: _utf8TextExtract+13Ej
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_6C37:				; CODE XREF: _utf8TextExtract+F4j
		cmp	[ebp+var_38], 3
		jge	short loc_6C78
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		and	ecx, 80h
		jz	short loc_6C6B
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_14]
		movzx	ecx, byte ptr [eax]
		sub	ecx, 0C0h ; 'À'
		movzx	edx, cl
		cmp	edx, 3Eh ; '>'
		jl	short loc_6C6B
		cmp	[ebp+var_14], 0
		jnz	short loc_6C6D

loc_6C6B:				; CODE XREF: _utf8TextExtract+114j
					; _utf8TextExtract+12Bj
		jmp	short loc_6C78
; ---------------------------------------------------------------------------

loc_6C6D:				; CODE XREF: _utf8TextExtract+131j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_6C2E
; ---------------------------------------------------------------------------

loc_6C78:				; CODE XREF: _utf8TextExtract+D8j
					; _utf8TextExtract+EBj	...
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	[ebp+var_114], ecx
		mov	edx, [ebp+var_114]
		mov	eax, [ebp+var_10C]
		cmp	eax, [edx+14h]
		jg	short loc_6D08
		jl	short loc_6CB5
		mov	ecx, [ebp+var_114]
		mov	edx, [ebp+var_110]
		cmp	edx, [ecx+10h]
		jnb	short loc_6D08

loc_6CB5:				; CODE XREF: _utf8TextExtract+16Aj
		mov	[ebp+var_38], 0
		jmp	short loc_6CC7
; ---------------------------------------------------------------------------

loc_6CBE:				; CODE XREF: _utf8TextExtract+1CEj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_6CC7:				; CODE XREF: _utf8TextExtract+184j
		cmp	[ebp+var_38], 3
		jge	short loc_6D08
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_20]
		movzx	ecx, byte ptr [eax]
		and	ecx, 80h
		jz	short loc_6CFB
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_20]
		movzx	ecx, byte ptr [eax]
		sub	ecx, 0C0h ; 'À'
		movzx	edx, cl
		cmp	edx, 3Eh ; '>'
		jl	short loc_6CFB
		cmp	[ebp+var_20], 0
		jnz	short loc_6CFD

loc_6CFB:				; CODE XREF: _utf8TextExtract+1A4j
					; _utf8TextExtract+1BBj
		jmp	short loc_6D08
; ---------------------------------------------------------------------------

loc_6CFD:				; CODE XREF: _utf8TextExtract+1C1j
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_6CBE
; ---------------------------------------------------------------------------

loc_6D08:				; CODE XREF: _utf8TextExtract+168j
					; _utf8TextExtract+17Bj ...
		mov	[ebp+var_44], 0
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_20]
		sub	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+3Ch]
		add	eax, [ebp+var_14]
		push	eax
		lea	ecx, [ebp+var_44]
		push	ecx
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_utext_strFromUTF8
		add	esp, 18h
		push	1
		mov	eax, [ebp+var_20]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utf8TextAccess
		add	esp, 10h
		mov	eax, [ebp+var_44]

loc_6D4F:				; CODE XREF: _utf8TextExtract+35j
					; _utf8TextExtract+57j	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN23
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 114h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextExtract endp

; ---------------------------------------------------------------------------
$LN23		dd 1			; DATA XREF: _utf8TextExtract+21Bo
		dd offset $LN22
$LN22		dd 0FFFFFFBCh, 4	; DATA XREF: .text:00006D78o
		dd offset $LN21		; "destLength"
$LN21		db 'destLength',0       ; DATA XREF: .text:00006D84o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6D94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl pinIndex(__int64 &, __int64)
?pinIndex@@YAHAA_J_J@Z proc near	; CODE XREF: _utf8TextExtract+6Fp
					; _utf8TextExtract+84p	...

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C4], eax
		mov	ecx, [ebp+var_C4]
		cmp	dword ptr [ecx+4], 0
		jg	short loc_6DE6
		jl	short loc_6DD4
		mov	edx, [ebp+var_C4]
		cmp	dword ptr [edx], 0
		jnb	short loc_6DE6

loc_6DD4:				; CODE XREF: pinIndex(__int64 &,__int64)+33j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+4], 0
		jmp	short loc_6E1A
; ---------------------------------------------------------------------------

loc_6DE6:				; CODE XREF: pinIndex(__int64 &,__int64)+31j
					; pinIndex(__int64 &,__int64)+3Ej
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C4], eax
		mov	ecx, [ebp+var_C4]
		mov	edx, [ecx+4]
		cmp	edx, [ebp+arg_8]
		jl	short loc_6E1A
		jg	short loc_6E0C
		mov	eax, [ebp+var_C4]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_4]
		jbe	short loc_6E1A

loc_6E0C:				; CODE XREF: pinIndex(__int64 &,__int64)+69j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		mov	edx, [ebp+arg_8]
		mov	[eax+4], edx

loc_6E1A:				; CODE XREF: pinIndex(__int64 &,__int64)+50j
					; pinIndex(__int64 &,__int64)+67j ...
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?pinIndex@@YAHAA_J_J@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6E28h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utext_strFromUTF8 proc	near		; CODE XREF: _utf8TextExtract+1F8p

var_10C		= dword	ptr -10Ch
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_10C]
		mov	ecx, 43h ; 'C'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_0], 0
		jz	short loc_6E63
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*2]
		mov	[ebp+var_10C], edx
		jmp	short loc_6E6D
; ---------------------------------------------------------------------------

loc_6E63:				; CODE XREF: _utext_strFromUTF8+28j
		mov	[ebp+var_10C], 0

loc_6E6D:				; CODE XREF: _utext_strFromUTF8+39j
		mov	eax, [ebp+var_10C]
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_44], eax

loc_6E91:				; CODE XREF: _utext_strFromUTF8:loc_6F62j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_10]
		jge	loc_6F67
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jnb	loc_6F67
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_2C]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_20], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 1
		mov	[ebp+var_2C], edx
		cmp	[ebp+var_20], 7Fh ; ''
		jg	short loc_6EDC
		mov	eax, [ebp+var_8]
		mov	cx, word ptr [ebp+var_20]
		mov	[eax], cx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		jmp	loc_6F62
; ---------------------------------------------------------------------------

loc_6EDC:				; CODE XREF: _utext_strFromUTF8+9Aj
		push	0FFFFFFFDh
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		mov	eax, [ebp+var_44]
		push	eax
		call	_utf8_nextCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0FFFFh
		ja	short loc_6F17
		mov	eax, [ebp+var_8]
		mov	cx, word ptr [ebp+var_20]
		mov	[eax], cx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		jmp	short loc_6F62
; ---------------------------------------------------------------------------

loc_6F17:				; CODE XREF: _utext_strFromUTF8+D8j
		mov	eax, [ebp+var_20]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_8]
		mov	[ecx], ax
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jnb	short loc_6F57
		mov	eax, [ebp+var_20]
		and	eax, 3FFh
		or	eax, 0DC00h
		mov	ecx, [ebp+var_8]
		mov	[ecx], ax
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		jmp	short loc_6F62
; ---------------------------------------------------------------------------

loc_6F57:				; CODE XREF: _utext_strFromUTF8+10Fj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		jmp	short loc_6F67
; ---------------------------------------------------------------------------

loc_6F62:				; CODE XREF: _utext_strFromUTF8+AFj
					; _utext_strFromUTF8+EDj ...
		jmp	loc_6E91
; ---------------------------------------------------------------------------

loc_6F67:				; CODE XREF: _utext_strFromUTF8+6Fj
					; _utext_strFromUTF8+7Bj ...
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_10]
		jge	short loc_6FC9
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_2C]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_20], ecx
		mov	edx, [ebp+var_2C]
		add	edx, 1
		mov	[ebp+var_2C], edx
		cmp	[ebp+var_20], 7Fh ; ''
		jg	short loc_6F95
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		jmp	short loc_6FC7
; ---------------------------------------------------------------------------

loc_6F95:				; CODE XREF: _utext_strFromUTF8+160j
		push	0FFFFFFFDh
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_10]
		push	ecx
		lea	edx, [ebp+var_2C]
		push	edx
		mov	eax, [ebp+var_44]
		push	eax
		call	_utf8_nextCharSafeBody_56
		add	esp, 14h
		mov	[ebp+var_20], eax
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_20]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		add	ecx, [ebp+var_38]
		mov	[ebp+var_38], ecx

loc_6FC7:				; CODE XREF: _utext_strFromUTF8+16Bj
		jmp	short loc_6F67
; ---------------------------------------------------------------------------

loc_6FC9:				; CODE XREF: _utext_strFromUTF8+145j
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+arg_0]
		sar	eax, 1
		add	eax, [ebp+var_38]
		mov	[ebp+var_38], eax
		cmp	[ebp+arg_8], 0
		jz	short loc_6FE5
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_38]
		mov	[eax], ecx

loc_6FE5:				; CODE XREF: _utext_strFromUTF8+1B3j
		mov	eax, [ebp+arg_14]
		push	eax
		mov	ecx, [ebp+var_38]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h
		mov	eax, [ebp+arg_0]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN20
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_strFromUTF8 endp

; ---------------------------------------------------------------------------
		align 4
$LN20		dd 1			; DATA XREF: _utext_strFromUTF8+1DCo
		dd offset $LN19
$LN19		dd 0FFFFFFD4h, 4	; DATA XREF: .text:0000702Co
		dd offset $LN18		; "index"
$LN18		db 'index',0            ; DATA XREF: .text:00007038o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7044h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utf8TextMapOffsetToNative proc	near	; DATA XREF: .rdata:00000190o

var_F0		= dword	ptr -0F0h
var_EC		= dword	ptr -0ECh
var_E8		= dword	ptr -0E8h
var_E4		= dword	ptr -0E4h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+1Ch]
		jle	short loc_7087
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jle	short loc_70AC

loc_7087:				; CODE XREF: _utf8TextMapOffsetToNative+33j
		mov	eax, ds:?__LINE__Var@?1??utf8TextMapOffsetToNative@@9@4JA@8d672338
		add	eax, 3
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1JI@ICBDKHPO@?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AAu?$AAt?$AA?9?$AA?$DO?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AAi@ ; "ut->chunkOffset>ut->nativeIndexingLimit"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_70AC:				; CODE XREF: _utf8TextMapOffsetToNative+41j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+var_8]
		add	ecx, [edx+8]
		mov	eax, [ebp+var_8]
		movzx	ecx, byte ptr [eax+ecx+60h]
		mov	edx, [ebp+var_8]
		add	ecx, [edx+14h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_E0], eax
		mov	[ebp+var_DC], edx
		mov	[ebp+var_E4], ecx
		mov	edx, [ebp+var_E4]
		mov	eax, [ebp+var_DC]
		cmp	eax, [edx+24h]
		jl	short loc_7143
		jg	short loc_7106
		mov	ecx, [ebp+var_E4]
		mov	edx, [ebp+var_E0]
		cmp	edx, [ecx+20h]
		jb	short loc_7143

loc_7106:				; CODE XREF: _utf8TextMapOffsetToNative+AFj
		mov	eax, [ebp+var_14]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_EC], eax
		mov	[ebp+var_E8], edx
		mov	[ebp+var_F0], ecx
		mov	edx, [ebp+var_F0]
		mov	eax, [ebp+var_E8]
		cmp	eax, [edx+14h]
		jl	short loc_7168
		jg	short loc_7143
		mov	ecx, [ebp+var_F0]
		mov	edx, [ebp+var_EC]
		cmp	edx, [ecx+10h]
		jbe	short loc_7168

loc_7143:				; CODE XREF: _utf8TextMapOffsetToNative+ADj
					; _utf8TextMapOffsetToNative+C0j ...
		mov	eax, ds:?__LINE__Var@?1??utf8TextMapOffsetToNative@@9@4JA@8d672338
		add	eax, 5
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1JK@MEHKDALN@?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS@	; "nativeOffset	>= ut->chunkNativeStart	&&"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7168:				; CODE XREF: _utf8TextMapOffsetToNative+EAj
					; _utf8TextMapOffsetToNative+FDj
		mov	eax, [ebp+var_14]
		cdq
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextMapOffsetToNative endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7180h
		public ??_C@_1JK@MEHKDALN@?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS@
; wchar_t `string'
??_C@_1JK@MEHKDALN@?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS@:
					; DATA XREF: _utf8TextMapOffsetToNative+10Fo
		unicode	0, <nativeOffset >
		dw 3Eh
		unicode	0, <= ut->
		dw 3Eh
		unicode	0, <chunkNativeStart &&	nativeOffset >
		dw 3Ch
		unicode	0, <= ut->
		dw 3Eh
		unicode	0, <chunkNativeLimit>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 721Ch
		public ??_C@_1JI@ICBDKHPO@?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AAu?$AAt?$AA?9?$AA?$DO?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AAi@
; wchar_t `string'
??_C@_1JI@ICBDKHPO@?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AAu?$AAt?$AA?9?$AA?$DO?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAI?$AAn?$AAd?$AAe?$AAx?$AAi@:
					; DATA XREF: _utf8TextMapOffsetToNative+53o
		unicode	0, <ut->
		dw 3Eh
		unicode	0, <chunkOffset>
		dw 3Eh
		unicode	0, <ut->
		dw 3Eh
		unicode	0, <nativeIndexingLimit	&& ut->
		dw 3Eh
		unicode	0, <chunkOffset>
		dw 3Ch
		unicode	0, <=ut->
		dw 3Eh
		unicode	0, <chunkLength>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 72B4h
		public ?__LINE__Var@?1??utf8TextMapOffsetToNative@@9@4JA@8d672338
?__LINE__Var@?1??utf8TextMapOffsetToNative@@9@4JA@8d672338 dd 5F2h
					; DATA XREF: _utf8TextMapOffsetToNative:loc_7087r
					; _utf8TextMapOffsetToNative:loc_7143r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 72B8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utf8TextMapIndexToUTF16 proc near	; DATA XREF: .rdata:00000194o

var_100		= dword	ptr -100h
var_FC		= dword	ptr -0FCh
var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 100h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_100]
		mov	ecx, 40h ; '@'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_8], 0
		jl	short loc_730C
		jg	short loc_72E7
		cmp	[ebp+arg_4], 7FFFFFFFh
		jbe	short loc_730C

loc_72E7:				; CODE XREF: _utf8TextMapIndexToUTF16+24j
		mov	eax, ds:?__LINE__Var@?1??utf8TextMapIndexToUTF16@@9@4JA@8d672338
		add	eax, 1
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1CM@LECLFDGF@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA6?$AA4?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@ ; "index64	<= 0x7fffffff"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_730C:				; CODE XREF: _utf8TextMapIndexToUTF16+22j
					; _utf8TextMapIndexToUTF16+2Dj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		cdq
		mov	ecx, eax
		mov	esi, edx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+1Ch]
		cdq
		mov	edi, [ebp+arg_0]
		add	eax, [edi+20h]
		adc	edx, [edi+24h]
		mov	[ebp+var_F8], ecx
		mov	[ebp+var_F4], esi
		mov	[ebp+var_100], eax
		mov	[ebp+var_FC], edx
		mov	eax, [ebp+var_F4]
		cmp	eax, [ebp+var_FC]
		jg	short loc_738F
		jl	short loc_7369
		mov	ecx, [ebp+var_F8]
		cmp	ecx, [ebp+var_100]
		jnb	short loc_738F

loc_7369:				; CODE XREF: _utf8TextMapIndexToUTF16+A1j
		mov	edx, ds:?__LINE__Var@?1??utf8TextMapIndexToUTF16@@9@4JA@8d672338
		add	edx, 4
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1GI@PMDKFDFH@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DO?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$CL?$AAu?$AAt?$AA?9?$AA?$DO@ ; "index>=ut->chunkNativeStart+ut->nativeI"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_738F:				; CODE XREF: _utf8TextMapIndexToUTF16+9Fj
					; _utf8TextMapIndexToUTF16+AFj
		mov	eax, [ebp+var_8]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_F8], eax
		mov	[ebp+var_F4], edx
		mov	[ebp+var_FC], ecx
		mov	edx, [ebp+var_FC]
		mov	eax, [ebp+var_F4]
		cmp	eax, [edx+14h]
		jl	short loc_73F1
		jg	short loc_73CC
		mov	ecx, [ebp+var_FC]
		mov	edx, [ebp+var_F8]
		cmp	edx, [ecx+10h]
		jbe	short loc_73F1

loc_73CC:				; CODE XREF: _utf8TextMapIndexToUTF16+101j
		mov	eax, ds:?__LINE__Var@?1??utf8TextMapIndexToUTF16@@9@4JA@8d672338
		add	eax, 5
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1DI@NEMBKDBO@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@ ; "index<=ut->chunkNativeLimit"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_73F1:				; CODE XREF: _utf8TextMapIndexToUTF16+FFj
					; _utf8TextMapIndexToUTF16+112j
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+14h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]
		movzx	ecx, byte ptr [eax+84h]
		mov	edx, [ebp+var_14]
		sub	ecx, [edx+8]
		mov	[ebp+var_2C], ecx
		js	short loc_7420
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_2C]
		cmp	ecx, [eax+2Ch]
		jle	short loc_7446

loc_7420:				; CODE XREF: _utf8TextMapIndexToUTF16+15Bj
		mov	edx, ds:?__LINE__Var@?1??utf8TextMapIndexToUTF16@@9@4JA@8d672338
		add	edx, 8
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1EK@OJNDMMAI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DM?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAL?$AAe@ ; "offset>=0 && offset<=ut->chunkLength"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7446:				; CODE XREF: _utf8TextMapIndexToUTF16+166j
		mov	eax, [ebp+var_2C]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 100h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextMapIndexToUTF16 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 7460h
		public ??_C@_1EK@OJNDMMAI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DM?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAL?$AAe@
; wchar_t `string'
??_C@_1EK@OJNDMMAI@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DM?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAL?$AAe@:
					; DATA XREF: _utf8TextMapIndexToUTF16+179o
		unicode	0, <offset>
		dw 3Eh
		unicode	0, <=0 && offset>
		dw 3Ch
		unicode	0, <=ut->
		dw 3Eh
		unicode	0, <chunkLength>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 74ACh
		public ??_C@_1DI@NEMBKDBO@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@
; wchar_t `string'
??_C@_1DI@NEMBKDBO@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAi?$AAm?$AAi?$AAt?$AA?$AA@:
					; DATA XREF: _utf8TextMapIndexToUTF16+124o
		unicode	0, <index>
		dw 3Ch
		unicode	0, <=ut->
		dw 3Eh
		unicode	0, <chunkNativeLimit>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 74E4h
		public ??_C@_1GI@PMDKFDFH@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DO?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$CL?$AAu?$AAt?$AA?9?$AA?$DO@
; wchar_t `string'
??_C@_1GI@PMDKFDFH@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DO?$AA?$DN?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAN?$AAa?$AAt?$AAi?$AAv?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$CL?$AAu?$AAt?$AA?9?$AA?$DO@:
					; DATA XREF: _utf8TextMapIndexToUTF16+C2o
		unicode	0, <index>
		dw 3Eh
		unicode	0, <=ut->
		dw 3Eh
		unicode	0, <chunkNativeStart+ut->
		dw 3Eh
		unicode	0, <nativeIndexingLimit>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 754Ch
		public ??_C@_1CM@LECLFDGF@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA6?$AA4?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@
; wchar_t `string'
??_C@_1CM@LECLFDGF@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA6?$AA4?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@:
					; DATA XREF: _utf8TextMapIndexToUTF16+3Fo
		unicode	0, <index64 >
		dw 3Ch
		unicode	0, <= 0x7fffffff>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 7578h
		public ?__LINE__Var@?1??utf8TextMapIndexToUTF16@@9@4JA@8d672338
?__LINE__Var@?1??utf8TextMapIndexToUTF16@@9@4JA@8d672338 dd 5FFh
					; DATA XREF: _utf8TextMapIndexToUTF16:loc_72E7r
					; _utf8TextMapIndexToUTF16:loc_7369r ...
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 757Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utf8TextClone(void *, void *Src, char, int)
_utf8TextClone	proc near		; DATA XREF: .rdata:00000178o

var_D8		= byte ptr -0D8h
Dst		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+arg_0]
		push	edx		; Dst
		call	_shallowTextClone
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_7647
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7647
		mov	eax, [ebp+Src]
		push	eax
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		add	eax, 1
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_7604
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		jmp	short loc_7647
; ---------------------------------------------------------------------------

loc_7604:				; CODE XREF: _utf8TextClone+7Bj
		push	1
		mov	eax, [ebp+Src]
		mov	ecx, [eax+3Ch]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_8]
		add	edx, 1
		push	edx		; Size
		mov	eax, [ebp+Src]
		mov	ecx, [eax+3Ch]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		or	ecx, 20h
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_7647:				; CODE XREF: _utf8TextClone+3Bj
					; _utf8TextClone+54j ...
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextClone	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7660h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl shallowTextClone(void *Dst, void *Src, int)
_shallowTextClone proc near		; CODE XREF: _utf8TextClone+2Ap
					; _repTextClone+2Ap ...

var_F0		= byte ptr -0F0h
Size		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_769A
		xor	eax, eax
		jmp	loc_77F0
; ---------------------------------------------------------------------------

loc_769A:				; CODE XREF: _shallowTextClone+31j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+18h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_utext_setup_56
		add	esp, 0Ch
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_76D7
		mov	eax, [ebp+Dst]
		jmp	loc_77F0
; ---------------------------------------------------------------------------

loc_76D7:				; CODE XREF: _shallowTextClone+6Dj
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+38h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+0Ch]
		mov	[ebp+Size], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Size]
		cmp	ecx, [eax+0Ch]
		jle	short loc_7706
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+0Ch]
		mov	[ebp+Size], ecx

loc_7706:				; CODE XREF: _shallowTextClone+9Bj
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_14]
		mov	[eax+38h], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_20]
		mov	[eax+4], ecx
		cmp	[ebp+var_8], 0
		jle	short loc_776B
		push	1
		mov	eax, [ebp+Src]
		mov	ecx, [eax+38h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_8]
		push	edx		; Size
		mov	eax, [ebp+Src]
		mov	ecx, [eax+38h]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		mov	eax, [edx+38h]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_776B:				; CODE XREF: _shallowTextClone+DEj
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, 3Ch ; '<'
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_adjustPointer
		add	esp, 0Ch
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, 40h ; '@'
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_adjustPointer
		add	esp, 0Ch
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, 44h ; 'D'
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_adjustPointer
		add	esp, 0Ch
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, 48h ; 'H'
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_adjustPointer
		add	esp, 0Ch
		mov	eax, [ebp+Src]
		push	eax
		mov	ecx, [ebp+Dst]
		add	ecx, 30h ; '0'
		push	ecx
		mov	edx, [ebp+Dst]
		push	edx
		call	_adjustPointer
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFDFh
		mov	edx, [ebp+Dst]
		mov	[edx+8], ecx
		mov	eax, [ebp+Dst]

loc_77F0:				; CODE XREF: _shallowTextClone+35j
					; _shallowTextClone+72j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_shallowTextClone endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7804h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_adjustPointer	proc near		; CODE XREF: _shallowTextClone+11Ap
					; _shallowTextClone+131p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+38h]
		jb	short loc_7868
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax+38h]
		mov	edx, [ebp+arg_8]
		add	ecx, [edx+18h]
		cmp	[ebp+var_8], ecx
		jnb	short loc_7868
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_8]
		sub	ecx, [eax+38h]
		mov	edx, [ebp+arg_0]
		add	ecx, [edx+38h]
		mov	eax, [ebp+arg_4]
		mov	[eax], ecx
		jmp	short loc_788C
; ---------------------------------------------------------------------------

loc_7868:				; CODE XREF: _adjustPointer+3Bj
					; _adjustPointer+4Cj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jb	short loc_788C
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_20]
		add	ecx, [eax+0Ch]
		cmp	[ebp+var_8], ecx
		jnb	short loc_788C
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+var_20]
		add	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[ecx], eax

loc_788C:				; CODE XREF: _adjustPointer+62j
					; _adjustPointer+6Aj ...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_adjustPointer	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7894h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_utf8TextClose	proc near		; DATA XREF: .rdata:00000198o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 20h
		jz	short loc_78DC
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+3Ch], 0

loc_78DC:				; CODE XREF: _utf8TextClose+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utf8TextClose	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_openUTF8_56
_utext_openUTF8_56 proc	near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_792A
		xor	eax, eax
		jmp	loc_7A0E
; ---------------------------------------------------------------------------

loc_792A:				; CODE XREF: _utext_openUTF8_56+31j
		cmp	[ebp+arg_4], 0
		jnz	short loc_793F
		mov	eax, [ebp+arg_8]
		or	eax, [ebp+arg_C]
		jnz	short loc_793F
		mov	[ebp+arg_4], offset _gEmptyString

loc_793F:				; CODE XREF: _utext_openUTF8_56+3Ej
					; _utext_openUTF8_56+46j
		cmp	[ebp+arg_4], 0
		jz	short loc_7964
		cmp	[ebp+arg_C], 0FFFFFFFFh
		jl	short loc_7964
		jg	short loc_7953
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jb	short loc_7964

loc_7953:				; CODE XREF: _utext_openUTF8_56+5Bj
		cmp	[ebp+arg_C], 0
		jl	short loc_7974
		jg	short loc_7964
		cmp	[ebp+arg_8], 7FFFFFFFh
		jbe	short loc_7974

loc_7964:				; CODE XREF: _utext_openUTF8_56+53j
					; _utext_openUTF8_56+59j ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_7A0E
; ---------------------------------------------------------------------------

loc_7974:				; CODE XREF: _utext_openUTF8_56+67j
					; _utext_openUTF8_56+72j
		mov	eax, [ebp+arg_10]
		push	eax
		push	1E0h
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utext_setup_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_79A6
		mov	eax, [ebp+arg_0]
		jmp	short loc_7A0E
; ---------------------------------------------------------------------------

loc_79A6:				; CODE XREF: _utext_openUTF8_56+AFj
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], offset _utf8Funcs
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+58h], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+5Ch], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+5Ch], 0
		jge	short loc_79ED
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+5Ch], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		or	ecx, 2
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_79ED:				; CODE XREF: _utext_openUTF8_56+E2j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+38h]
		mov	[eax+40h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+38h]
		add	ecx, 0F0h ; 'ð'
		mov	edx, [ebp+arg_0]
		mov	[edx+44h], ecx
		mov	eax, [ebp+arg_0]

loc_7A0E:				; CODE XREF: _utext_openUTF8_56+35j
					; _utext_openUTF8_56+7Fj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_openUTF8_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7A24h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl repTextClone(void	*Dst, void *Src, char, int)
_repTextClone	proc near		; DATA XREF: .rdata:off_1C0o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_shallowTextClone
		add	esp, 0Ch
		mov	[ebp+Dst], eax
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_7AB9
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_7AB9
		mov	eax, [ebp+Src]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+18h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+Dst]
		mov	[ecx+3Ch], eax
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		or	ecx, 20h
		mov	edx, [ebp+Dst]
		mov	[edx+8], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		or	ecx, 8
		mov	edx, [ebp+Dst]
		mov	[edx+8], ecx

loc_7AB9:				; CODE XREF: _repTextClone+3Bj
					; _repTextClone+50j
		mov	eax, [ebp+Dst]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextClone	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7AD0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_repTextClose	proc near		; DATA XREF: .rdata:000001E0o

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 20h
		jz	short loc_7B59
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_D4]
		mov	[ebp+var_E0], ecx
		cmp	[ebp+var_E0], 0
		jz	short loc_7B45
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_E0]
		mov	eax, [edx]
		mov	ecx, [ebp+var_E0]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_7B4F
; ---------------------------------------------------------------------------

loc_7B45:				; CODE XREF: _repTextClose+4Ej
		mov	[ebp+var_E8], 0

loc_7B4F:				; CODE XREF: _repTextClose+73j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+3Ch], 0

loc_7B59:				; CODE XREF: _repTextClose+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextClose	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B70h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_repTextLength	proc near		; DATA XREF: .rdata:000001C4o

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@Replaceable@icu_56@@QBEHXZ ; icu_56::Replaceable::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cdq
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextLength	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7BBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_repTextAccess	proc near		; CODE XREF: _repTextExtract+1A5p
					; _repTextReplace+223p	...

var_154		= dword	ptr -154h
var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
var_141		= byte ptr -141h
var_78		= byte ptr -78h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 154h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_154]
		mov	ecx, 55h ; 'U'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_C], ecx
		mov	ecx, [ebp+var_C] ; this
		call	?length@Replaceable@icu_56@@QBEHXZ ; icu_56::Replaceable::length(void)
		mov	[ebp+var_18], eax
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		cmp	[ebp+arg_8], 0
		jl	short loc_7C43
		jg	short loc_7C1E
		cmp	[ebp+arg_4], 7FFFFFFFh
		jbe	short loc_7C43

loc_7C1E:				; CODE XREF: _repTextAccess+57j
		mov	eax, ds:?__LINE__Var@?1??repTextAccess@@9@4JA@8d672338
		add	eax, 6
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1CE@DHOOMOBN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@ ; "index<=0x7fffffff"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_7C43:				; CODE XREF: _repTextAccess+55j
					; _repTextAccess+60j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	loc_7DF6
		mov	eax, [ebp+var_24]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_150], eax
		mov	[ebp+var_14C], edx
		mov	[ebp+var_154], ecx
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+var_14C]
		cmp	eax, [edx+24h]
		jl	short loc_7CE5
		jg	short loc_7C8C
		mov	ecx, [ebp+var_154]
		mov	edx, [ebp+var_150]
		cmp	edx, [ecx+20h]
		jb	short loc_7CE5

loc_7C8C:				; CODE XREF: _repTextAccess+BDj
		mov	eax, [ebp+var_24]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_150], eax
		mov	[ebp+var_14C], edx
		mov	[ebp+var_154], ecx
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+var_14C]
		cmp	eax, [edx+14h]
		jg	short loc_7CE5
		jl	short loc_7CC9
		mov	ecx, [ebp+var_154]
		mov	edx, [ebp+var_150]
		cmp	edx, [ecx+10h]
		jnb	short loc_7CE5

loc_7CC9:				; CODE XREF: _repTextAccess+FAj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		sub	ecx, [eax+20h]
		mov	edx, [ebp+arg_8]
		sbb	edx, [eax+24h]
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], ecx
		mov	al, 1
		jmp	loc_8159
; ---------------------------------------------------------------------------

loc_7CE5:				; CODE XREF: _repTextAccess+BBj
					; _repTextAccess+CEj ...
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_18]
		jl	short loc_7D40
		mov	eax, [ebp+var_18]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_14C], ecx
		mov	[ebp+var_154], eax
		mov	[ebp+var_150], edx
		mov	edx, [ebp+var_14C]
		mov	eax, [edx+10h]
		cmp	eax, [ebp+var_154]
		jnz	short loc_7D40
		mov	ecx, [ebp+var_14C]
		mov	edx, [ecx+14h]
		cmp	edx, [ebp+var_150]
		jnz	short loc_7D40
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		mov	edx, [ebp+var_18]
		sub	edx, ecx
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], edx
		xor	al, al
		jmp	loc_8159
; ---------------------------------------------------------------------------

loc_7D40:				; CODE XREF: _repTextAccess+12Fj
					; _repTextAccess+159j ...
		mov	eax, [ebp+arg_4]
		add	eax, 0Ah
		mov	ecx, [ebp+arg_8]
		adc	ecx, 0
		sub	eax, 1
		sbb	ecx, 0
		mov	edx, [ebp+arg_0]
		mov	[edx+10h], eax
		mov	[edx+14h], ecx
		mov	eax, [ebp+var_18]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_14C], ecx
		mov	[ebp+var_154], eax
		mov	[ebp+var_150], edx
		mov	edx, [ebp+var_14C]
		mov	eax, [edx+14h]
		cmp	eax, [ebp+var_150]
		jl	short loc_7DA5
		jg	short loc_7D98
		mov	ecx, [ebp+var_14C]
		mov	edx, [ecx+10h]
		cmp	edx, [ebp+var_154]
		jbe	short loc_7DA5

loc_7D98:				; CODE XREF: _repTextAccess+1C9j
		mov	eax, [ebp+var_18]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx

loc_7DA5:				; CODE XREF: _repTextAccess+1C7j
					; _repTextAccess+1DAj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		sub	ecx, 0Ah
		mov	edx, [eax+14h]
		sbb	edx, 0
		mov	eax, [ebp+arg_0]
		mov	[eax+20h], ecx
		mov	[eax+24h], edx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14C], eax
		mov	ecx, [ebp+var_14C]
		cmp	dword ptr [ecx+24h], 0
		jg	short loc_7DF1
		jl	short loc_7DE0
		mov	edx, [ebp+var_14C]
		cmp	dword ptr [edx+20h], 0
		jnb	short loc_7DF1

loc_7DE0:				; CODE XREF: _repTextAccess+216j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0

loc_7DF1:				; CODE XREF: _repTextAccess+214j
					; _repTextAccess+222j
		jmp	loc_7F5A
; ---------------------------------------------------------------------------

loc_7DF6:				; CODE XREF: _repTextAccess+8Dj
		mov	eax, [ebp+var_24]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_150], eax
		mov	[ebp+var_14C], edx
		mov	[ebp+var_154], ecx
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+var_14C]
		cmp	eax, [edx+24h]
		jl	short loc_7E88
		jg	short loc_7E33
		mov	ecx, [ebp+var_154]
		mov	edx, [ebp+var_150]
		cmp	edx, [ecx+20h]
		jbe	short loc_7E88

loc_7E33:				; CODE XREF: _repTextAccess+264j
		mov	eax, [ebp+var_24]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_150], eax
		mov	[ebp+var_14C], edx
		mov	[ebp+var_154], ecx
		mov	edx, [ebp+var_154]
		mov	eax, [ebp+var_14C]
		cmp	eax, [edx+14h]
		jg	short loc_7E88
		jl	short loc_7E70
		mov	ecx, [ebp+var_154]
		mov	edx, [ebp+var_150]
		cmp	edx, [ecx+10h]
		ja	short loc_7E88

loc_7E70:				; CODE XREF: _repTextAccess+2A1j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		mov	edx, [ebp+var_24]
		sub	edx, ecx
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], edx
		mov	al, 1
		jmp	loc_8159
; ---------------------------------------------------------------------------

loc_7E88:				; CODE XREF: _repTextAccess+262j
					; _repTextAccess+275j ...
		cmp	[ebp+var_24], 0
		jnz	short loc_7EBC
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14C], eax
		mov	ecx, [ebp+var_14C]
		mov	edx, [ebp+var_14C]
		mov	eax, [ecx+20h]
		or	eax, [edx+24h]
		jnz	short loc_7EBC
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		xor	al, al
		jmp	loc_8159
; ---------------------------------------------------------------------------

loc_7EBC:				; CODE XREF: _repTextAccess+2D0j
					; _repTextAccess+2EDj
		mov	eax, [ebp+var_24]
		sub	eax, 9
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14C], eax
		mov	ecx, [ebp+var_14C]
		cmp	dword ptr [ecx+24h], 0
		jg	short loc_7F00
		jl	short loc_7EEF
		mov	edx, [ebp+var_14C]
		cmp	dword ptr [edx+20h], 0
		jnb	short loc_7F00

loc_7EEF:				; CODE XREF: _repTextAccess+325j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0

loc_7F00:				; CODE XREF: _repTextAccess+323j
					; _repTextAccess+331j
		mov	eax, [ebp+var_24]
		add	eax, 1
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+var_18]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_14C], ecx
		mov	[ebp+var_154], eax
		mov	[ebp+var_150], edx
		mov	edx, [ebp+var_14C]
		mov	eax, [edx+14h]
		cmp	eax, [ebp+var_150]
		jl	short loc_7F5A
		jg	short loc_7F4D
		mov	ecx, [ebp+var_14C]
		mov	edx, [ecx+10h]
		cmp	edx, [ebp+var_154]
		jbe	short loc_7F5A

loc_7F4D:				; CODE XREF: _repTextAccess+37Ej
		mov	eax, [ebp+var_18]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx

loc_7F5A:				; CODE XREF: _repTextAccess:loc_7DF1j
					; _repTextAccess+37Cj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+38h]
		mov	[ebp+var_30], ecx
		push	0Ah		; int
		push	0		; int
		mov	eax, [ebp+var_30]
		push	eax		; wchar_t *
		lea	ecx, [ebp+var_78] ; this
		call	??0UnicodeString@icu_56@@QAE@PA_WHH@Z ;	icu_56::UnicodeString::UnicodeString(wchar_t *,int,int)
		mov	esi, esp
		lea	eax, [ebp+var_78]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_C]
		mov	edx, [eax+8]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_30]
		mov	[eax+30h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+10h]
		sub	edx, [ecx+20h]
		mov	eax, [eax+14h]
		sbb	eax, [ecx+24h]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+2Ch], edx
		mov	eax, [ebp+var_24]
		cdq
		mov	ecx, [ebp+arg_0]
		sub	eax, [ecx+20h]
		sbb	edx, [ecx+24h]
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], eax
		mov	eax, [ebp+var_18]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_14C], ecx
		mov	[ebp+var_154], eax
		mov	[ebp+var_150], edx
		mov	edx, [ebp+var_14C]
		mov	eax, [edx+14h]
		cmp	eax, [ebp+var_150]
		jg	short loc_8067
		jl	short loc_800C

loc_7FFB:				; DATA XREF: .rdata:std::_Iosb<int>::_Fmtflags const std::_Iosb<int>::_Stdioo
		mov	ecx, [ebp+var_14C]
		mov	edx, [ecx+10h]
		cmp	edx, [ebp+var_154]
		jnb	short loc_8067

loc_800C:				; CODE XREF: _repTextAccess+43Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2Ch]
		mov	edx, [ebp+var_30]
		movzx	eax, word ptr [edx+ecx*2-2]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_8067
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2Ch]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		sub	ecx, 1
		mov	edx, [eax+14h]
		sbb	edx, 0
		mov	eax, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	[eax+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+28h]
		cmp	edx, [ecx+2Ch]
		jle	short loc_8067
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+28h], edx

loc_8067:				; CODE XREF: _repTextAccess+43Bj
					; _repTextAccess+44Ej ...
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14C], eax
		mov	ecx, [ebp+var_14C]
		cmp	dword ptr [ecx+24h], 0
		jl	short loc_80E3
		jg	short loc_808A
		mov	edx, [ebp+var_14C]
		cmp	dword ptr [edx+20h], 0
		jbe	short loc_80E3

loc_808A:				; CODE XREF: _repTextAccess+4C0j
		mov	eax, [ebp+var_30]
		movzx	ecx, word ptr [eax]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_80E3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+30h]
		add	ecx, 2
		mov	edx, [ebp+arg_0]
		mov	[edx+30h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		add	ecx, 1
		mov	edx, [eax+24h]
		adc	edx, 0
		mov	eax, [ebp+arg_0]
		mov	[eax+20h], ecx
		mov	[eax+24h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2Ch]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx

loc_80E3:				; CODE XREF: _repTextAccess+4BEj
					; _repTextAccess+4CCj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_8138
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jle	short loc_8138
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		movzx	ecx, word ptr [eax+ecx*2-2]
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0D800h
		jnz	short loc_8138
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		sub	ecx, 1
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], ecx

loc_8138:				; CODE XREF: _repTextAccess+543j
					; _repTextAccess+54Cj ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+1Ch], edx
		mov	[ebp+var_141], 1
		lea	ecx, [ebp+var_78] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	al, [ebp+var_141]

loc_8159:				; CODE XREF: _repTextAccess+124j
					; _repTextAccess+17Fj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN31
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 154h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextAccess	endp

; ---------------------------------------------------------------------------
$LN31		dd 1			; DATA XREF: _repTextAccess+5A1o
		dd offset $LN30
$LN30		db 88h,	0FFh		; DATA XREF: .text:0000818Co
		dw 0FFFFh
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset $LN29		; "buffer"
$LN29		db 'buffer',0           ; DATA XREF: .text:00008198o
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 81A4h
		public ??_C@_1CE@DHOOMOBN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@
; wchar_t `string'
??_C@_1CE@DHOOMOBN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@:
					; DATA XREF: _repTextAccess+72o
					; _ucstrTextAccess+3EEo
		unicode	0, <index>
		dw 3Ch
		unicode	0, <=0x7fffffff>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 81C8h
		public ?__LINE__Var@?1??repTextAccess@@9@4JA@8d672338
?__LINE__Var@?1??repTextAccess@@9@4JA@8d672338 dd offset off_6BC
					; DATA XREF: _repTextAccess:loc_7C1Er
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 81CCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl repTextExtract(int, int, int, int, int, wchar_t *, int, int)
_repTextExtract	proc near		; DATA XREF: .rdata:000001CCo

var_148		= byte ptr -148h
var_144		= dword	ptr -144h
var_78		= byte ptr -78h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 148h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_148]
		mov	ecx, 52h ; 'R'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_C], ecx
		mov	ecx, [ebp+var_C] ; this
		call	?length@Replaceable@icu_56@@QBEHXZ ; icu_56::Replaceable::length(void)
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8224
		xor	eax, eax
		jmp	loc_83A5
; ---------------------------------------------------------------------------

loc_8224:				; CODE XREF: _repTextExtract+4Fj
		cmp	[ebp+arg_18], 0
		jl	short loc_8236
		cmp	[ebp+arg_14], 0
		jnz	short loc_823F
		cmp	[ebp+arg_18], 0
		jle	short loc_823F

loc_8236:				; CODE XREF: _repTextExtract+5Cj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1

loc_823F:				; CODE XREF: _repTextExtract+62j
					; _repTextExtract+68j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jl	short loc_8261
		jg	short loc_8251
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jbe	short loc_8261

loc_8251:				; CODE XREF: _repTextExtract+7Bj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_83A5
; ---------------------------------------------------------------------------

loc_8261:				; CODE XREF: _repTextExtract+79j
					; _repTextExtract+83j
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_18]
		jge	short loc_82D1
		mov	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_82D1
		mov	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?char32At@Replaceable@icu_56@@QBEHH@Z ;	icu_56::Replaceable::char32At(int)
		sub	eax, 10000h
		cmp	eax, 0FFFFFh
		ja	short loc_82D1
		mov	eax, [ebp+var_24]
		sub	eax, 1
		mov	[ebp+var_24], eax

loc_82D1:				; CODE XREF: _repTextExtract+C5j
					; _repTextExtract+E2j ...
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_18]
		jge	short loc_8317
		mov	eax, [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_8317
		mov	eax, [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?char32At@Replaceable@icu_56@@QBEHH@Z ;	icu_56::Replaceable::char32At(int)
		sub	eax, 10000h
		cmp	eax, 0FFFFFh
		ja	short loc_8317
		mov	eax, [ebp+var_30]
		sub	eax, 1
		mov	[ebp+var_30], eax

loc_8317:				; CODE XREF: _repTextExtract+10Bj
					; _repTextExtract+128j	...
		mov	eax, [ebp+var_30]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_18], eax
		mov	eax, [ebp+var_18]
		cmp	eax, [ebp+arg_18]
		jle	short loc_8331
		mov	eax, [ebp+var_24]
		add	eax, [ebp+arg_18]
		mov	[ebp+var_30], eax

loc_8331:				; CODE XREF: _repTextExtract+15Aj
		mov	eax, [ebp+arg_18]
		push	eax		; int
		push	0		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; wchar_t *
		lea	ecx, [ebp+var_78] ; this
		call	??0UnicodeString@icu_56@@QAE@PA_WHH@Z ;	icu_56::UnicodeString::UnicodeString(wchar_t *,int,int)
		mov	esi, esp
		lea	eax, [ebp+var_78]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx+8]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		push	1
		mov	eax, [ebp+var_30]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		call	_repTextAccess
		add	esp, 10h
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h
		mov	[ebp+var_144], eax
		lea	ecx, [ebp+var_78] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_144]

loc_83A5:				; CODE XREF: _repTextExtract+53j
					; _repTextExtract+90j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 148h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextExtract	endp

; ---------------------------------------------------------------------------
$LN13		dd 1			; DATA XREF: _repTextExtract+1DDo
		dd offset $LN12
$LN12		db 88h,	0FFh		; DATA XREF: .text:000083D8o
		dw 0FFFFh
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset $LN11		; "buffer"
$LN11		db 'buffer',0           ; DATA XREF: .text:000083E4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 83F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl repTextReplace(int, int, int, int, int, wchar_t *, int, int)
_repTextReplace	proc near		; DATA XREF: .rdata:000001D0o

var_178		= dword	ptr -178h
var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_168		= dword	ptr -168h
var_9C		= dword	ptr -9Ch
var_90		= dword	ptr -90h
var_84		= dword	ptr -84h
var_78		= byte ptr -78h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 178h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_178]
		mov	ecx, 5Eh ; '^'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_C], ecx
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_843D
		xor	eax, eax
		jmp	loc_8635
; ---------------------------------------------------------------------------

loc_843D:				; CODE XREF: _repTextReplace+44j
		cmp	[ebp+arg_14], 0
		jnz	short loc_8459
		cmp	[ebp+arg_18], 0
		jz	short loc_8459
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_8635
; ---------------------------------------------------------------------------

loc_8459:				; CODE XREF: _repTextReplace+51j
					; _repTextReplace+57j
		mov	ecx, [ebp+var_C] ; this
		call	?length@Replaceable@icu_56@@QBEHXZ ; icu_56::Replaceable::length(void)
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jl	short loc_8486
		jg	short loc_8476
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jbe	short loc_8486

loc_8476:				; CODE XREF: _repTextReplace+7Cj
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_8635
; ---------------------------------------------------------------------------

loc_8486:				; CODE XREF: _repTextReplace+7Aj
					; _repTextReplace+84j
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_18]
		jge	short loc_8504
		mov	eax, [ebp+var_24]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_8504
		cmp	[ebp+var_24], 0
		jle	short loc_8504
		mov	eax, [ebp+var_24]
		sub	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0D800h
		jnz	short loc_8504
		mov	eax, [ebp+var_24]
		sub	eax, 1
		mov	[ebp+var_24], eax

loc_8504:				; CODE XREF: _repTextReplace+C6j
					; _repTextReplace+E3j ...
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_18]
		jge	short loc_8552
		mov	eax, [ebp+var_30]
		sub	eax, 1
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0D800h
		jnz	short loc_8552
		mov	eax, [ebp+var_30]
		push	eax		; int
		mov	ecx, [ebp+var_C] ; this
		call	?charAt@Replaceable@icu_56@@QBE_WH@Z ; icu_56::Replaceable::charAt(int)
		movzx	ecx, ax
		and	ecx, 0FFFFFC00h
		cmp	ecx, 0DC00h
		jnz	short loc_8552
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	[ebp+var_30], eax

loc_8552:				; CODE XREF: _repTextReplace+11Aj
					; _repTextReplace+13Aj	...
		mov	eax, [ebp+arg_18]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; wchar_t *
		cmp	[ebp+arg_18], 0
		setl	dl
		movzx	eax, dl
		push	eax		; signed __int8
		lea	ecx, [ebp+var_78] ; this
		call	??0UnicodeString@icu_56@@QAE@CPB_WH@Z ;	icu_56::UnicodeString::UnicodeString(signed char,wchar_t const *,int)
		mov	esi, esp
		lea	eax, [ebp+var_78]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx+0Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_C] ; this
		call	?length@Replaceable@icu_56@@QBEHXZ ; icu_56::Replaceable::length(void)
		mov	[ebp+var_84], eax
		mov	eax, [ebp+var_84]
		sub	eax, [ebp+var_18]
		mov	[ebp+var_90], eax
		mov	eax, [ebp+var_24]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_170], ecx
		mov	[ebp+var_178], eax
		mov	[ebp+var_174], edx
		mov	edx, [ebp+var_170]
		mov	eax, [edx+14h]
		cmp	eax, [ebp+var_174]
		jl	short loc_85F5
		jg	short loc_85E9
		mov	ecx, [ebp+var_170]
		mov	edx, [ecx+10h]
		cmp	edx, [ebp+var_178]
		jbe	short loc_85F5

loc_85E9:				; CODE XREF: _repTextReplace+1E6j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?invalidateChunk@@YAXPAUUText@@@Z ; invalidateChunk(UText *)
		add	esp, 4

loc_85F5:				; CODE XREF: _repTextReplace+1E4j
					; _repTextReplace+1F7j
		mov	eax, [ebp+var_30]
		add	eax, [ebp+var_90]
		mov	[ebp+var_9C], eax
		push	1
		mov	eax, [ebp+var_9C]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		call	_repTextAccess
		add	esp, 10h
		mov	eax, [ebp+var_90]
		mov	[ebp+var_168], eax
		lea	ecx, [ebp+var_78] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		mov	eax, [ebp+var_168]

loc_8635:				; CODE XREF: _repTextReplace+48j
					; _repTextReplace+64j ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN13_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 178h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextReplace	endp

; ---------------------------------------------------------------------------
$LN13_0		dd 1			; DATA XREF: _repTextReplace+249o
		dd offset $LN12_0
$LN12_0		db 88h,	0FFh		; DATA XREF: .text:00008668o
		dw 0FFFFh
		dd offset ?_Rank@?$_Arithmetic_traits@N@std@@2HB ; int const std::_Arithmetic_traits<double>::_Rank
		dd offset $LN11_0	; "replStr"
$LN11_0		db 'replStr',0          ; DATA XREF: .text:00008674o
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8680h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl invalidateChunk(struct UText *)
?invalidateChunk@@YAXPAUUText@@@Z proc near ; CODE XREF: _repTextReplace+1FDp
					; _repTextCopy+1DCp

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+10h], 0
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+1Ch], 0
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?invalidateChunk@@YAXPAUUText@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 86E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_repTextCopy	proc near		; DATA XREF: .rdata:000001D4o

var_178		= dword	ptr -178h
var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_168		= byte ptr -168h
var_60		= dword	ptr -60h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= byte ptr  24h
arg_20		= dword	ptr  28h

		push	ebp
		mov	ebp, esp
		sub	esp, 178h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_178]
		mov	ecx, 5Eh ; '^'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_C], ecx
		mov	ecx, [ebp+var_C] ; this
		call	?length@Replaceable@icu_56@@QBEHXZ ; icu_56::Replaceable::length(void)
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_873E
		jmp	loc_8902
; ---------------------------------------------------------------------------

loc_873E:				; CODE XREF: _repTextCopy+4Fj
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jg	short loc_8774
		jl	short loc_8750
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		ja	short loc_8774

loc_8750:				; CODE XREF: _repTextCopy+5Ej
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_18]
		jg	short loc_8782
		jl	short loc_8762
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_14]
		jnb	short loc_8782

loc_8762:				; CODE XREF: _repTextCopy+70j
		mov	eax, [ebp+arg_18]
		cmp	eax, [ebp+arg_10]
		jg	short loc_8782
		jl	short loc_8774
		mov	ecx, [ebp+arg_14]
		cmp	ecx, [ebp+arg_C]
		jnb	short loc_8782

loc_8774:				; CODE XREF: _repTextCopy+5Cj
					; _repTextCopy+66j ...
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 8
		jmp	loc_8902
; ---------------------------------------------------------------------------

loc_8782:				; CODE XREF: _repTextCopy+6Ej
					; _repTextCopy+78j ...
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_18]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_14]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_3C], eax
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_8845
		mov	eax, [ebp+var_30]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_48], eax
		mov	esi, esp
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_3C]
		cmp	eax, [ebp+var_24]
		jge	short loc_880E
		mov	eax, [ebp+var_24]
		add	eax, [ebp+var_48]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_30]
		add	eax, [ebp+var_48]
		mov	[ebp+var_30], eax

loc_880E:				; CODE XREF: _repTextCopy+112j
		lea	ecx, [ebp+var_168] ; this
		call	??0UnicodeString@icu_56@@QAE@XZ	; icu_56::UnicodeString::UnicodeString(void)
		mov	esi, esp
		push	eax
		mov	eax, [ebp+var_30]
		push	eax
		mov	ecx, [ebp+var_24]
		push	ecx
		mov	edx, [ebp+var_C]
		mov	eax, [edx]
		mov	ecx, [ebp+var_C]
		mov	edx, [eax+0Ch]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		lea	ecx, [ebp+var_168] ; this
		call	??1UnicodeString@icu_56@@UAE@XZ	; icu_56::UnicodeString::~UnicodeString(void)
		jmp	short loc_8867
; ---------------------------------------------------------------------------

loc_8845:				; CODE XREF: _repTextCopy+DFj
		mov	esi, esp
		mov	eax, [ebp+var_3C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		mov	edx, [ebp+var_24]
		push	edx
		mov	eax, [ebp+var_C]
		mov	edx, [eax]
		mov	ecx, [ebp+var_C]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_8867:				; CODE XREF: _repTextCopy+15Bj
		mov	eax, [ebp+var_3C]
		mov	[ebp+var_54], eax
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_8883
		mov	eax, [ebp+var_24]
		cmp	eax, [ebp+var_54]
		jge	short loc_8883
		mov	eax, [ebp+var_24]
		mov	[ebp+var_54], eax

loc_8883:				; CODE XREF: _repTextCopy+18Bj
					; _repTextCopy+193j
		mov	eax, [ebp+var_54]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_174], eax
		mov	[ebp+var_170], edx
		mov	[ebp+var_178], ecx
		mov	edx, [ebp+var_178]
		mov	eax, [ebp+var_170]
		cmp	eax, [edx+14h]
		jg	short loc_88CC
		jl	short loc_88C0
		mov	ecx, [ebp+var_178]
		mov	edx, [ebp+var_174]
		cmp	edx, [ecx+10h]
		jnb	short loc_88CC

loc_88C0:				; CODE XREF: _repTextCopy+1C5j
		mov	eax, [ebp+arg_0]
		push	eax
		call	?invalidateChunk@@YAXPAUUText@@@Z ; invalidateChunk(UText *)
		add	esp, 4

loc_88CC:				; CODE XREF: _repTextCopy+1C3j
					; _repTextCopy+1D6j
		mov	eax, [ebp+var_3C]
		add	eax, [ebp+var_30]
		sub	eax, [ebp+var_24]
		mov	[ebp+var_60], eax
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_88EE
		mov	eax, [ebp+var_3C]
		cmp	eax, [ebp+var_24]
		jle	short loc_88EE
		mov	eax, [ebp+var_3C]
		mov	[ebp+var_60], eax

loc_88EE:				; CODE XREF: _repTextCopy+1F6j
					; _repTextCopy+1FEj
		push	1
		mov	eax, [ebp+var_60]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		call	_repTextAccess
		add	esp, 10h

loc_8902:				; CODE XREF: _repTextCopy+51j
					; _repTextCopy+95j
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 178h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_repTextCopy	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8920h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_openReplaceable_56
_utext_openReplaceable_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_895A
		xor	eax, eax
		jmp	loc_89E8
; ---------------------------------------------------------------------------

loc_895A:				; CODE XREF: _utext_openReplaceable_56+31j
		cmp	[ebp+arg_4], 0
		jnz	short loc_896D
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	short loc_89E8
; ---------------------------------------------------------------------------

loc_896D:				; CODE XREF: _utext_openReplaceable_56+3Ej
		mov	eax, [ebp+arg_8]
		push	eax
		push	16h
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utext_setup_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_899C
		mov	eax, [ebp+arg_0]
		jmp	short loc_89E8
; ---------------------------------------------------------------------------

loc_899C:				; CODE XREF: _utext_openReplaceable_56+75j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 8
		mov	eax, [ebp+arg_4]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+arg_4]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_89D2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		or	ecx, 10h
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_89D2:				; CODE XREF: _utext_openReplaceable_56+A1j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], offset _repFuncs
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+arg_0]

loc_89E8:				; CODE XREF: _utext_openReplaceable_56+35j
					; _utext_openReplaceable_56+4Bj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_openReplaceable_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 89FCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl unistrTextClone(void *Dst, void *Src, char, int)
_unistrTextClone proc near		; DATA XREF: .rdata:off_200o

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_shallowTextClone
		add	esp, 0Ch
		mov	[ebp+Dst], eax
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_8ACB
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8ACB
		mov	eax, [ebp+Src]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		push	40h ; '@'       ; unsigned int
		call	??2UMemory@icu_56@@SAPAXI@Z ; icu_56::UMemory::operator	new(uint)
		add	esp, 4
		mov	[ebp+var_D4], eax
		cmp	[ebp+var_D4], 0
		jz	short loc_8A8B
		mov	eax, [ebp+var_8]
		push	eax		; struct icu_56::UnicodeString *
		mov	ecx, [ebp+var_D4] ; this
		call	??0UnicodeString@icu_56@@QAE@ABV01@@Z ;	icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString const &)
		mov	[ebp+var_E8], eax
		jmp	short loc_8A95
; ---------------------------------------------------------------------------

loc_8A8B:				; CODE XREF: _unistrTextClone+76j
		mov	[ebp+var_E8], 0

loc_8A95:				; CODE XREF: _unistrTextClone+8Dj
		mov	ecx, [ebp+var_E8]
		mov	[ebp+var_E0], ecx
		mov	edx, [ebp+Dst]
		mov	eax, [ebp+var_E0]
		mov	[edx+3Ch], eax
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		or	ecx, 20h
		mov	edx, [ebp+Dst]
		mov	[edx+8], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		or	ecx, 8
		mov	edx, [ebp+Dst]
		mov	[edx+8], ecx

loc_8ACB:				; CODE XREF: _unistrTextClone+3Bj
					; _unistrTextClone+54j
		mov	eax, [ebp+Dst]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextClone endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8AE4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_unistrTextClose proc near		; DATA XREF: .rdata:00000220o

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 20h
		jz	short loc_8B6D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_D4]
		mov	[ebp+var_E0], ecx
		cmp	[ebp+var_E0], 0
		jz	short loc_8B59
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_E0]
		mov	eax, [edx]
		mov	ecx, [ebp+var_E0]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_8B63
; ---------------------------------------------------------------------------

loc_8B59:				; CODE XREF: _unistrTextClose+4Ej
		mov	[ebp+var_E8], 0

loc_8B63:				; CODE XREF: _unistrTextClose+73j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+3Ch], 0

loc_8B6D:				; CODE XREF: _unistrTextClose+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextClose endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B84h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_unistrTextLength proc near		; DATA XREF: .rdata:00000204o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]	; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		cdq
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextLength endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8BC4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_unistrTextAccess proc near		; DATA XREF: .rdata:00000208o

var_E4		= byte ptr -0E4h
var_E1		= byte ptr -0E1h
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_8C33
		mov	eax, [ebp+var_8]
		cdq
		mov	[ebp+var_E0], eax
		mov	[ebp+var_DC], edx
		mov	ecx, [ebp+arg_8]
		cmp	ecx, [ebp+var_DC]
		jl	short loc_8C52
		jg	short loc_8C33
		mov	edx, [ebp+arg_4]
		cmp	edx, [ebp+var_E0]
		jb	short loc_8C52

loc_8C33:				; CODE XREF: _unistrTextAccess+45j
					; _unistrTextAccess+62j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_8C49
		cmp	[ebp+arg_8], 0
		jg	short loc_8C52
		jl	short loc_8C49
		cmp	[ebp+arg_4], 0
		ja	short loc_8C52

loc_8C49:				; CODE XREF: _unistrTextAccess+75j
					; _unistrTextAccess+7Dj
		mov	[ebp+var_E1], 0
		jmp	short loc_8C59
; ---------------------------------------------------------------------------

loc_8C52:				; CODE XREF: _unistrTextAccess+60j
					; _unistrTextAccess+6Dj ...
		mov	[ebp+var_E1], 1

loc_8C59:				; CODE XREF: _unistrTextAccess+8Cj
		mov	cl, [ebp+var_E1]
		mov	[ebp+var_11], cl
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextAccess endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl unistrTextExtract(int, int, int, int, int, wchar_t *, int, int)
_unistrTextExtract proc	near		; DATA XREF: .rdata:0000020Co

var_108		= dword	ptr -108h
var_104		= dword	ptr -104h
var_100		= dword	ptr -100h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8CCA
		xor	eax, eax
		jmp	loc_8E22
; ---------------------------------------------------------------------------

loc_8CCA:				; CODE XREF: _unistrTextExtract+45j
		cmp	[ebp+arg_18], 0
		jl	short loc_8CDC
		cmp	[ebp+arg_14], 0
		jnz	short loc_8CE5
		cmp	[ebp+arg_18], 0
		jle	short loc_8CE5

loc_8CDC:				; CODE XREF: _unistrTextExtract+52j
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1

loc_8CE5:				; CODE XREF: _unistrTextExtract+58j
					; _unistrTextExtract+5Ej
		cmp	[ebp+arg_8], 0
		jl	short loc_8D05
		jg	short loc_8CF3
		cmp	[ebp+arg_4], 0
		jb	short loc_8D05

loc_8CF3:				; CODE XREF: _unistrTextExtract+6Fj
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jl	short loc_8D15
		jg	short loc_8D05
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jbe	short loc_8D15

loc_8D05:				; CODE XREF: _unistrTextExtract+6Dj
					; _unistrTextExtract+75j ...
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_8E22
; ---------------------------------------------------------------------------

loc_8D15:				; CODE XREF: _unistrTextExtract+7Dj
					; _unistrTextExtract+87j
		mov	eax, [ebp+var_14]
		cdq
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_100]
		jg	short loc_8D51
		jl	short loc_8D3D
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_104]
		jnb	short loc_8D51

loc_8D3D:				; CODE XREF: _unistrTextExtract+B4j
		mov	edx, [ebp+arg_4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getChar32Start@UnicodeString@icu_56@@QBEHH@Z ;	icu_56::UnicodeString::getChar32Start(int)
		mov	[ebp+var_108], eax
		jmp	short loc_8D5A
; ---------------------------------------------------------------------------

loc_8D51:				; CODE XREF: _unistrTextExtract+B2j
					; _unistrTextExtract+BFj
		mov	eax, [ebp+var_14]
		mov	[ebp+var_108], eax

loc_8D5A:				; CODE XREF: _unistrTextExtract+D3j
		mov	ecx, [ebp+var_108]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_14]
		cdq
		mov	[ebp+var_104], eax
		mov	[ebp+var_100], edx
		mov	eax, [ebp+arg_10]
		cmp	eax, [ebp+var_100]
		jg	short loc_8D9F
		jl	short loc_8D8B
		mov	ecx, [ebp+arg_C]
		cmp	ecx, [ebp+var_104]
		jnb	short loc_8D9F

loc_8D8B:				; CODE XREF: _unistrTextExtract+102j
		mov	edx, [ebp+arg_C]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getChar32Start@UnicodeString@icu_56@@QBEHH@Z ;	icu_56::UnicodeString::getChar32Start(int)
		mov	[ebp+var_108], eax
		jmp	short loc_8DA8
; ---------------------------------------------------------------------------

loc_8D9F:				; CODE XREF: _unistrTextExtract+100j
					; _unistrTextExtract+10Dj
		mov	eax, [ebp+var_14]
		mov	[ebp+var_108], eax

loc_8DA8:				; CODE XREF: _unistrTextExtract+121j
		mov	ecx, [ebp+var_108]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		cmp	[ebp+arg_18], 0
		jle	short loc_8DFE
		cmp	[ebp+arg_14], 0
		jz	short loc_8DFE
		mov	eax, [ebp+var_14]
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+arg_18]
		jle	short loc_8DDA
		mov	eax, [ebp+arg_18]
		mov	[ebp+var_38], eax

loc_8DDA:				; CODE XREF: _unistrTextExtract+156j
		push	0		; int
		mov	eax, [ebp+arg_14]
		push	eax		; wchar_t *
		mov	ecx, [ebp+var_38]
		push	ecx		; int
		mov	edx, [ebp+var_20]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?extract@UnicodeString@icu_56@@QBEXHHPA_WH@Z ; icu_56::UnicodeString::extract(int,int,wchar_t *,int)
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_38]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		jmp	short loc_8E07
; ---------------------------------------------------------------------------

loc_8DFE:				; CODE XREF: _unistrTextExtract+142j
					; _unistrTextExtract+148j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+28h], ecx

loc_8E07:				; CODE XREF: _unistrTextExtract+180j
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h
		mov	eax, [ebp+var_14]

loc_8E22:				; CODE XREF: _unistrTextExtract+49j
					; _unistrTextExtract+94j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextExtract endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8E38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl unistrTextReplace(int, int, int, int, int, wchar_t *, int, int)
_unistrTextReplace proc	near		; DATA XREF: .rdata:00000210o

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8E7B
		xor	eax, eax
		jmp	loc_8F80
; ---------------------------------------------------------------------------

loc_8E7B:				; CODE XREF: _unistrTextReplace+3Aj
		cmp	[ebp+arg_14], 0
		jnz	short loc_8E90
		cmp	[ebp+arg_18], 0
		jz	short loc_8E90
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1

loc_8E90:				; CODE XREF: _unistrTextReplace+47j
					; _unistrTextReplace+4Dj
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jl	short loc_8EB2
		jg	short loc_8EA2
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jbe	short loc_8EB2

loc_8EA2:				; CODE XREF: _unistrTextReplace+60j
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 8
		xor	eax, eax
		jmp	loc_8F80
; ---------------------------------------------------------------------------

loc_8EB2:				; CODE XREF: _unistrTextReplace+5Ej
					; _unistrTextReplace+68j
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_8EFE
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getChar32Start@UnicodeString@icu_56@@QBEHH@Z ;	icu_56::UnicodeString::getChar32Start(int)
		mov	[ebp+var_20], eax

loc_8EFE:				; CODE XREF: _unistrTextReplace+B5j
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_14]
		jge	short loc_8F15
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?getChar32Start@UnicodeString@icu_56@@QBEHH@Z ;	icu_56::UnicodeString::getChar32Start(int)
		mov	[ebp+var_2C], eax

loc_8F15:				; CODE XREF: _unistrTextReplace+CCj
		mov	eax, [ebp+arg_18]
		push	eax		; int
		mov	ecx, [ebp+arg_14]
		push	ecx		; wchar_t *
		mov	edx, [ebp+var_2C]
		sub	edx, [ebp+var_20]
		push	edx		; int
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z ; icu_56::UnicodeString::replace(int,int,wchar_t const *,int)
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_38], eax
		mov	ecx, [ebp+var_8] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx+30h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	[eax+2Ch], ecx
		mov	eax, [ebp+var_38]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_38]
		sub	eax, [ebp+var_14]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		mov	eax, [ebp+var_44]

loc_8F80:				; CODE XREF: _unistrTextReplace+3Ej
					; _unistrTextReplace+75j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextReplace endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8F94h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_unistrTextCopy	proc near		; DATA XREF: .rdata:00000214o

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch
arg_C		= byte ptr  14h
arg_14		= byte ptr  1Ch
arg_1C		= byte ptr  24h
arg_20		= dword	ptr  28h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_20]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8FE0
		jmp	loc_912D
; ---------------------------------------------------------------------------

loc_8FE0:				; CODE XREF: _unistrTextCopy+45j
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_14]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_14]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_2C]
		jg	short loc_9037
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_38]
		jge	short loc_9045
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_2C]
		jge	short loc_9045

loc_9037:				; CODE XREF: _unistrTextCopy+91j
		mov	eax, [ebp+arg_20]
		mov	dword ptr [eax], 8
		jmp	loc_912D
; ---------------------------------------------------------------------------

loc_9045:				; CODE XREF: _unistrTextCopy+99j
					; _unistrTextCopy+A1j
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_909F
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_20]
		mov	[ebp+var_44], eax
		mov	esi, esp
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_20]
		push	edx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_20]
		jge	short loc_9089
		mov	eax, [ebp+var_20]
		add	eax, [ebp+var_44]
		mov	[ebp+var_20], eax

loc_9089:				; CODE XREF: _unistrTextCopy+EAj
		push	0		; int
		push	0		; wchar_t *
		mov	eax, [ebp+var_44]
		push	eax		; int
		mov	ecx, [ebp+var_20]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?replace@UnicodeString@icu_56@@QAEAAV12@HHPB_WH@Z ; icu_56::UnicodeString::replace(int,int,wchar_t const *,int)
		jmp	short loc_90C1
; ---------------------------------------------------------------------------

loc_909F:				; CODE XREF: _unistrTextCopy+B7j
		mov	esi, esp
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+var_20]
		push	edx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_90C1:				; CODE XREF: _unistrTextCopy+109j
		mov	ecx, [ebp+var_8] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx+30h], eax
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jnz	short loc_9105
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+2Ch]
		mov	edx, [ebp+arg_0]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+2Ch]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+1Ch], edx

loc_9105:				; CODE XREF: _unistrTextCopy+141j
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_2C]
		sub	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		movsx	eax, [ebp+arg_1C]
		test	eax, eax
		jz	short loc_912D
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_20]
		jle	short loc_912D
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_38]
		mov	[eax+28h], ecx

loc_912D:				; CODE XREF: _unistrTextCopy+47j
					; _unistrTextCopy+ACj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_unistrTextCopy	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9144h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utext_openUnicodeString_56(int, icu_56::UnicodeString *, int)
		public _utext_openUnicodeString_56
_utext_openUnicodeString_56 proc near

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		push	eax		; int
		mov	ecx, [ebp+arg_4]
		push	ecx		; icu_56::UnicodeString	*
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	_utext_openConstUnicodeString_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_919D
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		or	ecx, 8
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_919D:				; CODE XREF: _utext_openUnicodeString_56+48j
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_openUnicodeString_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 91B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utext_openConstUnicodeString_56(int, icu_56::UnicodeString *, int)
		public _utext_openConstUnicodeString_56
_utext_openConstUnicodeString_56 proc near ; CODE XREF:	_utext_openUnicodeString_56+2Ap

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_921D
		mov	ecx, [ebp+arg_4] ; this
		call	?isBogus@UnicodeString@icu_56@@QBECXZ ;	icu_56::UnicodeString::isBogus(void)
		movsx	eax, al
		test	eax, eax
		jz	short loc_921D
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		push	0
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utext_openUChars_56
		add	esp, 14h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+arg_0]
		jmp	loc_92B0
; ---------------------------------------------------------------------------

loc_921D:				; CODE XREF: _utext_openConstUnicodeString_56+31j
					; _utext_openConstUnicodeString_56+40j
		mov	eax, [ebp+arg_8]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utext_setup_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_92AD
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], offset _unistrFuncs
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 4
		mov	ecx, [ebp+arg_4] ; this
		call	?getBuffer@UnicodeString@icu_56@@QBEPB_WXZ ; icu_56::UnicodeString::getBuffer(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx+30h], eax
		mov	ecx, [ebp+arg_4] ; this
		call	?length@UnicodeString@icu_56@@QBEHXZ ; icu_56::UnicodeString::length(void)
		mov	ecx, [ebp+arg_0]
		mov	[ecx+2Ch], eax
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+2Ch]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+1Ch], edx

loc_92AD:				; CODE XREF: _utext_openConstUnicodeString_56+91j
		mov	eax, [ebp+arg_0]

loc_92B0:				; CODE XREF: _utext_openConstUnicodeString_56+64j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_openConstUnicodeString_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 92C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ucstrTextClone(void *Dst,	void *Src, char, int)
_ucstrTextClone	proc near		; DATA XREF: .rdata:00000240o

var_FC		= dword	ptr -0FCh
var_F8		= dword	ptr -0F8h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Dst		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_shallowTextClone
		add	esp, 0Ch
		mov	[ebp+Dst], eax
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_9454
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_9454
		mov	eax, [ebp+Dst]
		push	eax
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_FC], eax
		mov	[ebp+var_F8], edx
		cmp	[ebp+var_F8], 0
		jl	short loc_9373
		jg	short loc_934D
		cmp	[ebp+var_FC], 7FFFFFFFh
		jb	short loc_9373

loc_934D:				; CODE XREF: _ucstrTextClone+7Bj
		mov	ecx, ds:?__LINE__Var@?1??ucstrTextClone@@9@4JA@8d672338
		add	ecx, 0Ah
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1FC@DHKAKMO@?$AAu?$AAt?$AAe?$AAx?$AAt?$AA_?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA_?$AA5?$AA6?$AA?$CI?$AAd?$AAe?$AAs?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx@ ;	"utext_nativeLength_56(dest) < 0x7ffffff"...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9373:				; CODE XREF: _ucstrTextClone+79j
					; _ucstrTextClone+87j
		mov	eax, [ebp+Dst]
		push	eax
		call	_utext_nativeLength_56
		add	esp, 4
		mov	[ebp+var_8], eax
		mov	eax, [ebp+Src]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		lea	ecx, [eax+eax+2]
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_93B2
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 7
		jmp	loc_9454
; ---------------------------------------------------------------------------

loc_93B2:				; CODE XREF: _ucstrTextClone+DEj
		mov	[ebp+var_30], 0
		mov	[ebp+var_2C], 0
		jmp	short loc_93D4
; ---------------------------------------------------------------------------

loc_93C2:				; CODE XREF: _ucstrTextClone+16Aj
		mov	eax, [ebp+var_30]
		add	eax, 1
		mov	ecx, [ebp+var_2C]
		adc	ecx, 0
		mov	[ebp+var_30], eax
		mov	[ebp+var_2C], ecx

loc_93D4:				; CODE XREF: _ucstrTextClone+FCj
		mov	eax, [ebp+var_8]
		cdq
		mov	[ebp+var_FC], eax
		mov	[ebp+var_F8], edx
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_F8]
		jg	short loc_9430
		jl	short loc_93FC
		mov	ecx, [ebp+var_30]
		cmp	ecx, [ebp+var_FC]
		jnb	short loc_9430

loc_93FC:				; CODE XREF: _ucstrTextClone+12Bj
		push	0
		push	2
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_30]
		push	ecx
		call	__allmul
		mov	esi, eax
		push	0
		push	2
		mov	edx, [ebp+var_2C]
		push	edx
		mov	eax, [ebp+var_30]
		push	eax
		call	__allmul
		mov	ecx, [ebp+var_20]
		mov	edx, [ebp+var_14]
		mov	dx, [edx+esi]
		mov	[ecx+eax], dx
		jmp	short loc_93C2
; ---------------------------------------------------------------------------

loc_9430:				; CODE XREF: _ucstrTextClone+129j
					; _ucstrTextClone+136j
		xor	eax, eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_20]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_20]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+8]
		or	ecx, 20h
		mov	edx, [ebp+Dst]
		mov	[edx+8], ecx

loc_9454:				; CODE XREF: _ucstrTextClone+3Bj
					; _ucstrTextClone+54j ...
		mov	eax, [ebp+Dst]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucstrTextClone	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 946Ch
		public ??_C@_1FC@DHKAKMO@?$AAu?$AAt?$AAe?$AAx?$AAt?$AA_?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA_?$AA5?$AA6?$AA?$CI?$AAd?$AAe?$AAs?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx@
; wchar_t `string'
??_C@_1FC@DHKAKMO@?$AAu?$AAt?$AAe?$AAx?$AAt?$AA_?$AAn?$AAa?$AAt?$AAi?$AAv?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA_?$AA5?$AA6?$AA?$CI?$AAd?$AAe?$AAs?$AAt?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx@:
					; DATA XREF: _ucstrTextClone+9Ao
		unicode	0, <utext_nativeLength_56(dest)	>
		dw 3Ch
		unicode	0, < 0x7fffffff>,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 94C0h
		public ?__LINE__Var@?1??ucstrTextClone@@9@4JA@8d672338
?__LINE__Var@?1??ucstrTextClone@@9@4JA@8d672338	dd 91Bh
					; DATA XREF: _ucstrTextClone:loc_934Dr
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 94C4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_ucstrTextClose	proc near		; DATA XREF: .rdata:00000260o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 20h
		jz	short loc_950C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+3Ch], 0

loc_950C:				; CODE XREF: _ucstrTextClose+27j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucstrTextClose	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9520h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_ucstrTextLength proc near		; DATA XREF: .rdata:00000244o

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_D0], eax
		mov	ecx, [ebp+var_D0]
		cmp	dword ptr [ecx+54h], 0
		jg	loc_95E2
		jl	short loc_9565
		mov	edx, [ebp+var_D0]
		cmp	dword ptr [edx+50h], 0
		jnb	short loc_95E2

loc_9565:				; CODE XREF: _ucstrTextLength+37j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx

loc_956E:				; CODE XREF: _ucstrTextLength+87j
		mov	eax, [ebp+arg_0]
		push	0
		push	2
		mov	ecx, [eax+14h]
		push	ecx
		mov	edx, [eax+10h]
		push	edx
		call	__allmul
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+eax]
		test	edx, edx
		jnz	short loc_958F
		jmp	short loc_95A9
; ---------------------------------------------------------------------------

loc_958F:				; CODE XREF: _ucstrTextLength+6Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		add	ecx, 1
		mov	edx, [eax+14h]
		adc	edx, 0
		mov	eax, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	[eax+14h], edx
		jmp	short loc_956E
; ---------------------------------------------------------------------------

loc_95A9:				; CODE XREF: _ucstrTextLength+6Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+10h]
		mov	[eax+50h], edx
		mov	ecx, [ecx+14h]
		mov	[eax+54h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	[edx+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_95E2:				; CODE XREF: _ucstrTextLength+31j
					; _ucstrTextLength+43j
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+50h]
		mov	edx, [ecx+54h]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucstrTextLength endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9600h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_ucstrTextAccess proc near		; CODE XREF: _ucstrTextExtract+7Cp
					; DATA XREF: .rdata:00000248o

var_F8		= dword	ptr -0F8h
var_F4		= dword	ptr -0F4h
var_29		= byte ptr -29h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F8]
		mov	ecx, 3Eh ; '>'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_8], 0
		jg	short loc_9648
		jl	short loc_9635
		cmp	[ebp+arg_4], 0
		jnb	short loc_9648

loc_9635:				; CODE XREF: _ucstrTextAccess+2Dj
		mov	[ebp+arg_4], 0
		mov	[ebp+arg_8], 0
		jmp	$breakout$37535
; ---------------------------------------------------------------------------

loc_9648:				; CODE XREF: _ucstrTextAccess+2Bj
					; _ucstrTextAccess+33j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+var_F4]
		mov	edx, [ebp+arg_8]
		cmp	edx, [ecx+14h]
		jg	loc_96E6
		jl	short loc_9673
		mov	eax, [ebp+var_F4]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+10h]
		jnb	short loc_96E6

loc_9673:				; CODE XREF: _ucstrTextAccess+63j
		push	0
		push	2
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	__allmul
		mov	edx, [ebp+var_8]
		movzx	eax, word ptr [edx+eax]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_96E1
		cmp	[ebp+arg_8], 0
		jl	short loc_96E1
		jg	short loc_96A5
		cmp	[ebp+arg_4], 0
		jbe	short loc_96E1

loc_96A5:				; CODE XREF: _ucstrTextAccess+9Dj
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		sbb	ecx, 0
		push	0
		push	2
		push	ecx
		push	eax
		call	__allmul
		mov	edx, [ebp+var_8]
		movzx	eax, word ptr [edx+eax]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_96E1
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		sbb	ecx, 0
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], ecx

loc_96E1:				; CODE XREF: _ucstrTextAccess+95j
					; _ucstrTextAccess+9Bj	...
		jmp	$breakout$37535
; ---------------------------------------------------------------------------

loc_96E6:				; CODE XREF: _ucstrTextAccess+5Dj
					; _ucstrTextAccess+71j
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_F4], eax
		mov	ecx, [ebp+var_F4]
		cmp	dword ptr [ecx+54h], 0
		jl	short loc_971D
		jg	short loc_9709
		mov	edx, [ebp+var_F4]
		cmp	dword ptr [edx+50h], 0
		jb	short loc_971D

loc_9709:				; CODE XREF: _ucstrTextAccess+FBj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+50h]
		mov	[ebp+arg_4], ecx
		mov	edx, [eax+54h]
		mov	[ebp+arg_8], edx
		jmp	$breakout$37535
; ---------------------------------------------------------------------------

loc_971D:				; CODE XREF: _ucstrTextAccess+F9j
					; _ucstrTextAccess+107j
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	ecx, [ebp+arg_8]
		adc	ecx, 0
		mov	[ebp+var_F8], eax
		mov	[ebp+var_F4], ecx
		cmp	[ebp+var_F4], 0
		jg	short loc_9781
		jl	short loc_9755
		cmp	[ebp+var_F8], 7FFFFFFFh
		ja	short loc_9781

loc_9755:				; CODE XREF: _ucstrTextAccess+147j
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	ecx, [ebp+arg_8]
		adc	ecx, 0
		mov	[ebp+var_F8], eax
		mov	[ebp+var_F4], ecx
		cmp	[ebp+var_F4], 0
		jg	short loc_9788
		jl	short loc_9781
		cmp	[ebp+var_F8], 0
		jnb	short loc_9788

loc_9781:				; CODE XREF: _ucstrTextAccess+145j
					; _ucstrTextAccess+153j ...
		mov	[ebp+var_14], 7FFFFFFFh

loc_9788:				; CODE XREF: _ucstrTextAccess+174j
					; _ucstrTextAccess+17Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_20], ecx
		jmp	short loc_979C
; ---------------------------------------------------------------------------

loc_9793:				; CODE XREF: _ucstrTextAccess:loc_98A1j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_979C:				; CODE XREF: _ucstrTextAccess+191j
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	loc_98A6
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+eax*2]
		test	edx, edx
		jnz	loc_98A1
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+50h], eax
		mov	[ecx+54h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_20]
		cdq
		mov	[ebp+var_F8], eax
		mov	[ebp+var_F4], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_F4]
		jl	short loc_980D
		jg	short loc_9801
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_F8]
		jb	short loc_980D

loc_9801:				; CODE XREF: _ucstrTextAccess+1F4j
		mov	eax, [ebp+var_20]
		cdq
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx
		jmp	short loc_987B
; ---------------------------------------------------------------------------

loc_980D:				; CODE XREF: _ucstrTextAccess+1F2j
					; _ucstrTextAccess+1FFj
		push	0
		push	2
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	__allmul
		mov	edx, [ebp+var_8]
		movzx	eax, word ptr [edx+eax]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_987B
		cmp	[ebp+arg_8], 0
		jl	short loc_987B
		jg	short loc_983F
		cmp	[ebp+arg_4], 0
		jbe	short loc_987B

loc_983F:				; CODE XREF: _ucstrTextAccess+237j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		sbb	ecx, 0
		push	0
		push	2
		push	ecx
		push	eax
		call	__allmul
		mov	edx, [ebp+var_8]
		movzx	eax, word ptr [edx+eax]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_987B
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		sbb	ecx, 0
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], ecx

loc_987B:				; CODE XREF: _ucstrTextAccess+20Bj
					; _ucstrTextAccess+22Fj ...
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx
		jmp	$breakout$37535
; ---------------------------------------------------------------------------
		jmp	$breakout$37535
; ---------------------------------------------------------------------------

loc_98A1:				; CODE XREF: _ucstrTextAccess+1B4j
		jmp	loc_9793
; ---------------------------------------------------------------------------

loc_98A6:				; CODE XREF: _ucstrTextAccess+1A2j
		push	0
		push	2
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	__allmul
		mov	edx, [ebp+var_8]
		movzx	eax, word ptr [edx+eax]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_9914
		cmp	[ebp+arg_8], 0
		jl	short loc_9914
		jg	short loc_98D8
		cmp	[ebp+arg_4], 0
		jbe	short loc_9914

loc_98D8:				; CODE XREF: _ucstrTextAccess+2D0j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		sbb	ecx, 0
		push	0
		push	2
		push	ecx
		push	eax
		call	__allmul
		mov	edx, [ebp+var_8]
		movzx	eax, word ptr [edx+eax]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_9914
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	ecx, [ebp+arg_8]
		sbb	ecx, 0
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], ecx

loc_9914:				; CODE XREF: _ucstrTextAccess+2C8j
					; _ucstrTextAccess+2CEj ...
		cmp	[ebp+var_20], 7FFFFFFFh
		jnz	short loc_998C
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+50h], eax
		mov	[ecx+54h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_20]
		cdq
		mov	[ebp+var_F8], eax
		mov	[ebp+var_F4], edx
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+var_F4]
		jl	short loc_996E
		jg	short loc_9964
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+var_F8]
		jbe	short loc_996E

loc_9964:				; CODE XREF: _ucstrTextAccess+357j
		mov	eax, [ebp+var_20]
		cdq
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_8], edx

loc_996E:				; CODE XREF: _ucstrTextAccess+355j
					; _ucstrTextAccess+362j
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		and	ecx, 0FFFFFFFDh
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx
		jmp	short $breakout$37535
; ---------------------------------------------------------------------------

loc_998C:				; CODE XREF: _ucstrTextAccess+31Bj
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_8]
		movzx	edx, word ptr [ecx+eax*2-2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0D800h
		jnz	short loc_99AE
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax

loc_99AE:				; CODE XREF: _ucstrTextAccess+3A3j
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+2Ch], ecx

$breakout$37535:			; CODE XREF: _ucstrTextAccess+43j
					; _ucstrTextAccess:loc_96E1j ...
		cmp	[ebp+arg_8], 0
		jl	short loc_9A03
		jg	short loc_99DE
		cmp	[ebp+arg_4], 7FFFFFFFh
		jbe	short loc_9A03

loc_99DE:				; CODE XREF: _ucstrTextAccess+3D3j
		mov	eax, ds:?__LINE__Var@?1??ucstrTextAccess@@9@4JA@8d672338
		add	eax, 4Eh ; 'N'
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1CE@DHOOMOBN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$DM?$AA?$DN?$AA0?$AAx?$AA7?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AAf?$AA?$AA@ ; "index<=0x7fffffff"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9A03:				; CODE XREF: _ucstrTextAccess+3D1j
					; _ucstrTextAccess+3DCj
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_9A3B
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_F4], ecx
		mov	edx, [ebp+var_F4]
		mov	eax, [ebp+arg_8]
		cmp	eax, [edx+14h]
		jl	short loc_9A5A
		jg	short loc_9A3B
		mov	ecx, [ebp+var_F4]
		mov	edx, [ebp+arg_4]
		cmp	edx, [ecx+10h]
		jb	short loc_9A5A

loc_9A3B:				; CODE XREF: _ucstrTextAccess+412j
					; _ucstrTextAccess+42Bj
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_9A51
		cmp	[ebp+arg_8], 0
		jg	short loc_9A5A
		jl	short loc_9A51
		cmp	[ebp+arg_4], 0
		ja	short loc_9A5A

loc_9A51:				; CODE XREF: _ucstrTextAccess+441j
					; _ucstrTextAccess+449j
		mov	byte ptr [ebp+var_F8+3], 0
		jmp	short loc_9A61
; ---------------------------------------------------------------------------

loc_9A5A:				; CODE XREF: _ucstrTextAccess+429j
					; _ucstrTextAccess+439j ...
		mov	byte ptr [ebp+var_F8+3], 1

loc_9A61:				; CODE XREF: _ucstrTextAccess+458j
		mov	cl, byte ptr [ebp+var_F8+3]
		mov	[ebp+var_29], cl
		mov	al, [ebp+var_29]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucstrTextAccess endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9A84h
		public ?__LINE__Var@?1??ucstrTextAccess@@9@4JA@8d672338
?__LINE__Var@?1??ucstrTextAccess@@9@4JA@8d672338 dd offset ?char32At@Replaceable@icu_56@@QBEHH@Z
					; DATA XREF: _ucstrTextAccess:loc_99DEr
_data		ends			; icu_56::Replaceable::char32At(int)

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9A88h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_ucstrTextExtract proc near		; DATA XREF: .rdata:0000024Co

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9AC2
		xor	eax, eax
		jmp	loc_9CDB
; ---------------------------------------------------------------------------

loc_9AC2:				; CODE XREF: _ucstrTextExtract+31j
		cmp	[ebp+arg_18], 0
		jl	short loc_9AE6
		cmp	[ebp+arg_14], 0
		jnz	short loc_9AD4
		cmp	[ebp+arg_18], 0
		jg	short loc_9AE6

loc_9AD4:				; CODE XREF: _ucstrTextExtract+44j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jl	short loc_9AF6
		jg	short loc_9AE6
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jbe	short loc_9AF6

loc_9AE6:				; CODE XREF: _ucstrTextExtract+3Ej
					; _ucstrTextExtract+4Aj ...
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_9CDB
; ---------------------------------------------------------------------------

loc_9AF6:				; CODE XREF: _ucstrTextExtract+52j
					; _ucstrTextExtract+5Cj
		push	1
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_ucstrTextAccess
		add	esp, 10h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+30h]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+50h]
		mov	[ebp+var_44], ecx
		cmp	[ebp+var_44], 0
		jl	short loc_9B44
		mov	eax, [ebp+var_44]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		jmp	short loc_9B5A
; ---------------------------------------------------------------------------

loc_9B44:				; CODE XREF: _ucstrTextExtract+A3j
		push	0
		push	7FFFFFFFh
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax

loc_9B5A:				; CODE XREF: _ucstrTextExtract+BAj
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_20]
		mov	[ebp+var_8], eax
		jmp	short loc_9B72
; ---------------------------------------------------------------------------

loc_9B69:				; CODE XREF: _ucstrTextExtract+1A7j
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_9B72:				; CODE XREF: _ucstrTextExtract+DFj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jge	loc_9C34
		cmp	[ebp+var_44], 0
		jge	short loc_9BC6
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		movzx	edx, word ptr [ecx+eax*2]
		test	edx, edx
		jnz	short loc_9BC6
		mov	eax, [ebp+var_8]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+50h], eax
		mov	[ecx+54h], edx
		mov	eax, [ebp+var_8]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_44], eax
		jmp	short loc_9C34
; ---------------------------------------------------------------------------

loc_9BC6:				; CODE XREF: _ucstrTextExtract+FAj
					; _ucstrTextExtract+108j
		cmp	[ebp+var_14], 0
		jge	short loc_9BF1
		mov	eax, ds:?__LINE__Var@?1??ucstrTextExtract@@9@4JA@8d672338
		add	eax, 27h ; '''
		mov	esi, esp
		push	eax		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1M@FKAEOMMA@?$AAd?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; "di>=0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_9BF1:				; CODE XREF: _ucstrTextExtract+142j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_18]
		jge	short loc_9C0F
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_14]
		mov	edx, [ebp+var_8]
		mov	esi, [ebp+var_38]
		mov	dx, [esi+edx*2]
		mov	[ecx+eax*2], dx
		jmp	short loc_9C26
; ---------------------------------------------------------------------------

loc_9C0F:				; CODE XREF: _ucstrTextExtract+16Fj
		cmp	[ebp+var_44], 0
		jl	short loc_9C26
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_8], eax
		jmp	short loc_9C34
; ---------------------------------------------------------------------------

loc_9C26:				; CODE XREF: _ucstrTextExtract+185j
					; _ucstrTextExtract+18Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	loc_9B69
; ---------------------------------------------------------------------------

loc_9C34:				; CODE XREF: _ucstrTextExtract+F0j
					; _ucstrTextExtract+13Cj ...
		cmp	[ebp+var_8], 0
		jle	short loc_9CA7
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		movzx	edx, word ptr [ecx+eax*2-2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0D800h
		jnz	short loc_9CA7
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_44]
		jl	short loc_9C61
		cmp	[ebp+var_44], 0
		jge	short loc_9CA7

loc_9C61:				; CODE XREF: _ucstrTextExtract+1D1j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		movzx	edx, word ptr [ecx+eax*2]
		and	edx, 0FFFFFC00h
		cmp	edx, 0DC00h
		jnz	short loc_9CA7
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_18]
		jge	short loc_9CA7
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_14]
		mov	edx, [ebp+var_8]
		mov	esi, [ebp+var_38]
		mov	dx, [esi+edx*2]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		mov	[ebp+var_8], ecx

loc_9CA7:				; CODE XREF: _ucstrTextExtract+1B0j
					; _ucstrTextExtract+1C9j ...
		mov	eax, [ebp+var_20]
		add	eax, [ebp+arg_18]
		push	eax
		mov	ecx, [ebp+var_44]
		push	ecx
		call	_uprv_min_56
		add	esp, 8
		mov	edx, [ebp+arg_0]
		mov	[edx+28h], eax
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h
		mov	eax, [ebp+var_14]

loc_9CDB:				; CODE XREF: _ucstrTextExtract+35j
					; _ucstrTextExtract+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_ucstrTextExtract endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9CF0h
		public ??_C@_1M@FKAEOMMA@?$AAd?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1M@FKAEOMMA@?$AAd?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@:
					; DATA XREF: _ucstrTextExtract+154o
		unicode	0, <di>
		dw 3Eh
		unicode	0, <=0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9CFCh
		public ?__LINE__Var@?1??ucstrTextExtract@@9@4JA@8d672338
?__LINE__Var@?1??ucstrTextExtract@@9@4JA@8d672338 dd 9BDh
					; DATA XREF: _ucstrTextExtract+144r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9D00h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utext_openUChars_56
_utext_openUChars_56 proc near		; CODE XREF: _utext_openConstUnicodeString_56+50p

var_C8		= dword	ptr -0C8h
var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C8]
		mov	ecx, 32h ; '2'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_9D3A
		xor	eax, eax
		jmp	loc_9E82
; ---------------------------------------------------------------------------

loc_9D3A:				; CODE XREF: _utext_openUChars_56+31j
		cmp	[ebp+arg_4], 0
		jnz	short loc_9D4F
		mov	eax, [ebp+arg_8]
		or	eax, [ebp+arg_C]
		jnz	short loc_9D4F
		mov	[ebp+arg_4], offset _gEmptyUString

loc_9D4F:				; CODE XREF: _utext_openUChars_56+3Ej
					; _utext_openUChars_56+46j
		cmp	[ebp+arg_4], 0
		jz	short loc_9D74
		cmp	[ebp+arg_C], 0FFFFFFFFh
		jl	short loc_9D74
		jg	short loc_9D63
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jb	short loc_9D74

loc_9D63:				; CODE XREF: _utext_openUChars_56+5Bj
		cmp	[ebp+arg_C], 0
		jl	short loc_9D84
		jg	short loc_9D74
		cmp	[ebp+arg_8], 7FFFFFFFh
		jbe	short loc_9D84

loc_9D74:				; CODE XREF: _utext_openUChars_56+53j
					; _utext_openUChars_56+59j ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_9E82
; ---------------------------------------------------------------------------

loc_9D84:				; CODE XREF: _utext_openUChars_56+67j
					; _utext_openUChars_56+72j
		mov	eax, [ebp+arg_10]
		push	eax
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utext_setup_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_9E7F
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], offset _ucstrFuncs
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 4
		mov	eax, [ebp+arg_8]
		and	eax, [ebp+arg_C]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_9DE9
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		or	ecx, 2
		mov	edx, [ebp+arg_0]
		mov	[edx+8], ecx

loc_9DE9:				; CODE XREF: _utext_openUChars_56+D8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_8]
		mov	[eax+50h], ecx
		mov	edx, [ebp+arg_C]
		mov	[eax+54h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+30h], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+24h], 0
		cmp	[ebp+arg_C], 0
		jl	short loc_9E34
		jg	short loc_9E20
		cmp	[ebp+arg_8], 0
		jb	short loc_9E34

loc_9E20:				; CODE XREF: _utext_openUChars_56+118j
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_C8], eax
		mov	ecx, [ebp+arg_C]
		mov	[ebp+var_C4], ecx
		jmp	short loc_9E48
; ---------------------------------------------------------------------------

loc_9E34:				; CODE XREF: _utext_openUChars_56+116j
					; _utext_openUChars_56+11Ej
		mov	[ebp+var_C8], 0
		mov	[ebp+var_C4], 0

loc_9E48:				; CODE XREF: _utext_openUChars_56+132j
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_C8]
		mov	[edx+10h], eax
		mov	ecx, [ebp+var_C4]
		mov	[edx+14h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	[edx+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+1Ch], edx

loc_9E7F:				; CODE XREF: _utext_openUChars_56+ACj
		mov	eax, [ebp+arg_0]

loc_9E82:				; CODE XREF: _utext_openUChars_56+35j
					; _utext_openUChars_56+7Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_openUChars_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9E98h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_charIterTextClose proc	near		; DATA XREF: .rdata:000002A8o

var_E8		= dword	ptr -0E8h
var_E0		= dword	ptr -0E0h
var_D4		= dword	ptr -0D4h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+48h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	[ebp+var_D4], eax
		mov	ecx, [ebp+var_D4]
		mov	[ebp+var_E0], ecx
		cmp	[ebp+var_E0], 0
		jz	short loc_9F02
		mov	esi, esp
		push	1
		mov	edx, [ebp+var_E0]
		mov	eax, [edx]
		mov	ecx, [ebp+var_E0]
		mov	edx, [eax]
		call	edx
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_E8], eax
		jmp	short loc_9F0C
; ---------------------------------------------------------------------------

loc_9F02:				; CODE XREF: _charIterTextClose+43j
		mov	[ebp+var_E8], 0

loc_9F0C:				; CODE XREF: _charIterTextClose+68j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+48h], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_charIterTextClose endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_charIterTextLength proc near		; DATA XREF: .rdata:0000028Co

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+50h]
		cdq
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_charIterTextLength endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9F58h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_charIterTextAccess proc near		; CODE XREF: _charIterTextExtract+1E5p
					; DATA XREF: .rdata:00000290o

var_120		= dword	ptr -120h
var_11C		= dword	ptr -11Ch
var_118		= dword	ptr -118h
var_4D		= byte ptr -4Dh
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_9F94
		mov	[ebp+var_14], 0
		jmp	short loc_9FDA
; ---------------------------------------------------------------------------

loc_9F94:				; CODE XREF: _charIterTextAccess+31j
		mov	eax, [ebp+var_14]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_118], edx
		mov	[ebp+var_120], ecx
		mov	edx, [ebp+var_120]
		mov	eax, [ebp+var_118]
		cmp	eax, [edx+54h]
		jl	short loc_9FDA
		jg	short loc_9FD1
		mov	ecx, [ebp+var_120]
		mov	edx, [ebp+var_11C]
		cmp	edx, [ecx+50h]
		jb	short loc_9FDA

loc_9FD1:				; CODE XREF: _charIterTextAccess+66j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+50h]
		mov	[ebp+var_14], ecx

loc_9FDA:				; CODE XREF: _charIterTextAccess+3Aj
					; _charIterTextAccess+64j ...
		mov	eax, [ebp+var_14]
		mov	[ebp+var_20], eax
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_9FF9
		cmp	[ebp+var_20], 0
		jle	short loc_9FF9
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_A04B
; ---------------------------------------------------------------------------

loc_9FF9:				; CODE XREF: _charIterTextAccess+8Ej
					; _charIterTextAccess+94j
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_A04B
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_118], edx
		mov	[ebp+var_120], ecx
		mov	edx, [ebp+var_120]
		mov	eax, [ebp+var_11C]
		cmp	eax, [edx+50h]
		jnz	short loc_A04B
		mov	ecx, [ebp+var_120]
		mov	edx, [ebp+var_118]
		cmp	edx, [ecx+54h]
		jnz	short loc_A04B
		cmp	[ebp+var_20], 0
		jle	short loc_A04B
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax

loc_A04B:				; CODE XREF: _charIterTextAccess+9Fj
					; _charIterTextAccess+A7j ...
		mov	eax, [ebp+var_20]
		and	eax, 8000000Fh
		jns	short loc_A05A
		dec	eax
		or	eax, 0FFFFFFF0h
		inc	eax

loc_A05A:				; CODE XREF: _charIterTextAccess+FBj
		mov	ecx, [ebp+var_20]
		sub	ecx, eax
		mov	[ebp+var_20], ecx
		mov	[ebp+var_2C], 0
		mov	[ebp+var_35], 1
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_118], ecx
		mov	[ebp+var_120], eax
		mov	[ebp+var_11C], edx
		mov	edx, [ebp+var_118]
		mov	eax, [edx+20h]
		cmp	eax, [ebp+var_120]
		jnz	short loc_A0B1
		mov	ecx, [ebp+var_118]
		mov	edx, [ecx+24h]
		cmp	edx, [ebp+var_11C]
		jnz	short loc_A0B1
		mov	[ebp+var_35], 0
		jmp	loc_A199
; ---------------------------------------------------------------------------

loc_A0B1:				; CODE XREF: _charIterTextAccess+13Dj
					; _charIterTextAccess+14Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+58h]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_A0CA
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		mov	[ebp+var_2C], ecx
		jmp	loc_A199
; ---------------------------------------------------------------------------

loc_A0CA:				; CODE XREF: _charIterTextAccess+162j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+5Ch]
		cmp	ecx, [ebp+var_20]
		jnz	short loc_A0E3
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_2C], ecx
		jmp	loc_A199
; ---------------------------------------------------------------------------

loc_A0E3:				; CODE XREF: _charIterTextAccess+17Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+40h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+40h]
		cmp	edx, [ecx+30h]
		jnz	short loc_A103
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+44h]
		mov	[ebp+var_2C], ecx

loc_A103:				; CODE XREF: _charIterTextAccess+1A0j
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+38h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_44], 0
		jmp	short loc_A12F
; ---------------------------------------------------------------------------

loc_A126:				; CODE XREF: _charIterTextAccess:loc_A197j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_A12F:				; CODE XREF: _charIterTextAccess+1CCj
		cmp	[ebp+var_44], 10h
		jge	short loc_A199
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+10h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_44]
		mov	edx, [ebp+var_2C]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_11C], eax
		mov	[ebp+var_118], edx
		mov	[ebp+var_120], ecx
		mov	edx, [ebp+var_120]
		mov	eax, [ebp+var_118]
		cmp	eax, [edx+54h]
		jl	short loc_A197
		jg	short loc_A195
		mov	ecx, [ebp+var_120]
		mov	edx, [ebp+var_11C]
		cmp	edx, [ecx+50h]
		jbe	short loc_A197

loc_A195:				; CODE XREF: _charIterTextAccess+22Aj
		jmp	short loc_A199
; ---------------------------------------------------------------------------

loc_A197:				; CODE XREF: _charIterTextAccess+228j
					; _charIterTextAccess+23Bj
		jmp	short loc_A126
; ---------------------------------------------------------------------------

loc_A199:				; CODE XREF: _charIterTextAccess+154j
					; _charIterTextAccess+16Dj ...
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jz	loc_A27B
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_2C]
		mov	[eax+30h], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+2Ch], 10h
		mov	eax, [ebp+var_20]
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+20h], eax
		mov	[ecx+24h], edx
		mov	eax, [ebp+var_20]
		add	eax, 10h
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_118], eax
		mov	[ebp+var_11C], ecx
		mov	edx, [ebp+var_118]
		mov	eax, [ebp+var_11C]
		mov	ecx, [edx+14h]
		cmp	ecx, [eax+54h]
		jl	short loc_A237
		jg	short loc_A211
		mov	edx, [ebp+var_118]
		mov	eax, [ebp+var_11C]
		mov	ecx, [edx+10h]
		cmp	ecx, [eax+50h]
		jbe	short loc_A237

loc_A211:				; CODE XREF: _charIterTextAccess+2A3j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+50h]
		mov	[eax+10h], edx
		mov	ecx, [ecx+54h]
		mov	[eax+14h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+20h]
		sub	ecx, eax
		mov	edx, [ebp+arg_0]
		mov	[edx+2Ch], ecx

loc_A237:				; CODE XREF: _charIterTextAccess+2A1j
					; _charIterTextAccess+2B7j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2Ch]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jl	short loc_A255
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+28h], 10h
		jle	short loc_A27B

loc_A255:				; CODE XREF: _charIterTextAccess+2F2j
		mov	edx, ds:?__LINE__Var@?1??charIterTextAccess@@9@4JA@8d672338
		add	edx, 3Eh ; '>'
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1FE@MMBHBCHK@?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO@ ; "ut->chunkOffset>=0	&& ut->chunkOffset<="...
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A27B:				; CODE XREF: _charIterTextAccess+247j
					; _charIterTextAccess+2FBj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		mov	edx, [ebp+var_14]
		sub	edx, ecx
		mov	eax, [ebp+arg_0]
		mov	[eax+28h], edx
		movsx	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_A2AD
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+28h]
		xor	ecx, ecx
		cmp	eax, [edx+2Ch]
		setl	cl
		mov	[ebp+var_118], ecx
		jmp	short loc_A2BF
; ---------------------------------------------------------------------------

loc_A2AD:				; CODE XREF: _charIterTextAccess+33Aj
		mov	edx, [ebp+arg_0]
		xor	eax, eax
		cmp	dword ptr [edx+28h], 0
		setnle	al
		mov	[ebp+var_118], eax

loc_A2BF:				; CODE XREF: _charIterTextAccess+353j
		mov	cl, byte ptr [ebp+var_118]
		mov	[ebp+var_4D], cl
		mov	al, [ebp+var_4D]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_charIterTextAccess endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0A2E0h
		public ??_C@_1FE@MMBHBCHK@?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO@
; wchar_t `string'
??_C@_1FE@MMBHBCHK@?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAt?$AA?9?$AA?$DO?$AAc?$AAh?$AAu?$AAn?$AAk?$AAO@:
					; DATA XREF: _charIterTextAccess+30Eo
		unicode	0, <ut->
		dw 3Eh
		unicode	0, <chunkOffset>
		dw 3Eh
		unicode	0, <=0 && ut->
		dw 3Eh
		unicode	0, <chunkOffset>
		dw 3Ch
		unicode	0, <=16>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A334h
		public ?__LINE__Var@?1??charIterTextAccess@@9@4JA@8d672338
?__LINE__Var@?1??charIterTextAccess@@9@4JA@8d672338 dd 0A60h
					; DATA XREF: _charIterTextAccess:loc_A255r
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A338h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_charIterTextClone proc	near		; DATA XREF: .rdata:00000288o

var_DC		= byte ptr -0DCh
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0DCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_DC]
		mov	ecx, 37h ; '7'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A372
		xor	eax, eax
		jmp	loc_A414
; ---------------------------------------------------------------------------

loc_A372:				; CODE XREF: _charIterTextClone+31j
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_A38F
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_A414
; ---------------------------------------------------------------------------
		jmp	loc_A411
; ---------------------------------------------------------------------------

loc_A38F:				; CODE XREF: _charIterTextClone+40j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_8]
		mov	eax, [edx+1Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		push	eax		; int
		mov	ecx, [ebp+var_8]
		push	ecx		; icu_56::CharacterIterator *
		mov	edx, [ebp+arg_0]
		push	edx		; int
		call	_utext_openCharacterIterator_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A3E2
		mov	eax, [ebp+arg_0]
		jmp	short loc_A414
; ---------------------------------------------------------------------------

loc_A3E2:				; CODE XREF: _charIterTextClone+A3j
		mov	eax, [ebp+arg_4]
		push	eax
		call	_utext_getNativeIndex_56
		add	esp, 4
		mov	[ebp+var_18], eax
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_18]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utext_setNativeIndex_56
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+48h], ecx

loc_A411:				; CODE XREF: _charIterTextClone+52j
		mov	eax, [ebp+arg_0]

loc_A414:				; CODE XREF: _charIterTextClone+35j
					; _charIterTextClone+4Dj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0DCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_charIterTextClone endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A428h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_charIterTextExtract proc near		; DATA XREF: .rdata:00000294o

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_1C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A462
		xor	eax, eax
		jmp	loc_A630
; ---------------------------------------------------------------------------

loc_A462:				; CODE XREF: _charIterTextExtract+31j
		cmp	[ebp+arg_18], 0
		jl	short loc_A486
		cmp	[ebp+arg_14], 0
		jnz	short loc_A474
		cmp	[ebp+arg_18], 0
		jg	short loc_A486

loc_A474:				; CODE XREF: _charIterTextExtract+44j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jl	short loc_A496
		jg	short loc_A486
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [ebp+arg_C]
		jbe	short loc_A496

loc_A486:				; CODE XREF: _charIterTextExtract+3Ej
					; _charIterTextExtract+4Aj ...
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_A630
; ---------------------------------------------------------------------------

loc_A496:				; CODE XREF: _charIterTextExtract+52j
					; _charIterTextExtract+5Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+50h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_4]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		cdq
		push	edx
		push	eax
		lea	eax, [ebp+arg_C]
		push	eax
		call	?pinIndex@@YAHAA_J_J@Z ; pinIndex(__int64 &,__int64)
		add	esp, 0Ch
		mov	[ebp+var_20], eax
		mov	[ebp+var_2C], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+3Ch]
		mov	[ebp+var_50], ecx
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_50]
		mov	edx, [ecx]
		mov	ecx, [ebp+var_50]
		mov	eax, [edx+3Ch]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	ecx, [ebp+var_50] ; this
		call	?getIndex@CharacterIterator@icu_56@@QBEHXZ ; icu_56::CharacterIterator::getIndex(void)
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_38]
		mov	[ebp+var_44], eax

loc_A504:				; CODE XREF: _charIterTextExtract+1D4j
		mov	eax, [ebp+var_38]
		cmp	eax, [ebp+var_20]
		jge	loc_A601
		mov	eax, [ebp+var_50]
		mov	edx, [eax]
		mov	esi, esp
		mov	ecx, [ebp+var_50]
		mov	eax, [edx+14h]
		call	eax
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_5C], eax
		mov	eax, 0FFFFh
		cmp	eax, [ebp+var_5C]
		sbb	ecx, ecx
		neg	ecx
		add	ecx, 1
		mov	[ebp+var_68], ecx
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_68]
		test	eax, eax
		jg	short loc_A56B
		mov	ecx, ds:?__LINE__Var@?1??charIterTextExtract@@9@4JA@8d672338
		add	ecx, 16h
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FI@DOHBLNEC@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BI@DBALLOBD@?$AAd?$AAe?$AAs?$AAt?$AAi?$AA?$CL?$AAl?$AAe?$AAn?$AA?$DO?$AA0?$AA?$AA@ ; "desti+len>0"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_A56B:				; CODE XREF: _charIterTextExtract+11Bj
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_68]
		cmp	eax, [ebp+arg_18]
		jg	short loc_A5E1
		cmp	[ebp+var_5C], 0FFFFh
		ja	short loc_A598
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+arg_14]
		mov	dx, word ptr [ebp+var_5C]
		mov	[ecx+eax*2], dx
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		jmp	short loc_A5D6
; ---------------------------------------------------------------------------

loc_A598:				; CODE XREF: _charIterTextExtract+155j
		mov	eax, [ebp+var_5C]
		sar	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_2C]
		mov	edx, [ebp+arg_14]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_5C]
		and	eax, 3FFh
		or	eax, 0DC00h
		mov	ecx, [ebp+var_2C]
		mov	edx, [ebp+arg_14]
		mov	[edx+ecx*2], ax
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_A5D6:				; CODE XREF: _charIterTextExtract+16Ej
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_68]
		mov	[ebp+var_44], eax
		jmp	short loc_A5F3
; ---------------------------------------------------------------------------

loc_A5E1:				; CODE XREF: _charIterTextExtract+14Cj
		mov	eax, [ebp+var_2C]
		add	eax, [ebp+var_68]
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [eax], 0Fh

loc_A5F3:				; CODE XREF: _charIterTextExtract+1B7j
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_68]
		mov	[ebp+var_38], eax
		jmp	loc_A504
; ---------------------------------------------------------------------------

loc_A601:				; CODE XREF: _charIterTextExtract+E2j
		push	1
		mov	eax, [ebp+var_44]
		cdq
		push	edx
		push	eax
		mov	eax, [ebp+arg_0]
		push	eax
		call	_charIterTextAccess
		add	esp, 10h
		mov	eax, [ebp+arg_1C]
		push	eax
		mov	ecx, [ebp+var_2C]
		push	ecx
		mov	edx, [ebp+arg_18]
		push	edx
		mov	eax, [ebp+arg_14]
		push	eax
		call	_u_terminateUChars_56
		add	esp, 10h
		mov	eax, [ebp+var_2C]

loc_A630:				; CODE XREF: _charIterTextExtract+35j
					; _charIterTextExtract+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 12Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_charIterTextExtract endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A644h
		public ??_C@_1BI@DBALLOBD@?$AAd?$AAe?$AAs?$AAt?$AAi?$AA?$CL?$AAl?$AAe?$AAn?$AA?$DO?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_1BI@DBALLOBD@?$AAd?$AAe?$AAs?$AAt?$AAi?$AA?$CL?$AAl?$AAe?$AAn?$AA?$DO?$AA0?$AA?$AA@:
					; DATA XREF: _charIterTextExtract+12Eo
		unicode	0, <desti+len>
		dw 3Eh
		unicode	0, <0>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0A65Ch
		public ?__LINE__Var@?1??charIterTextExtract@@9@4JA@8d672338
?__LINE__Var@?1??charIterTextExtract@@9@4JA@8d672338 dd	0AC4h
					; DATA XREF: _charIterTextExtract+11Dr
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A660h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utext_openCharacterIterator_56(int, icu_56::CharacterIterator *, int)
		public _utext_openCharacterIterator_56
_utext_openCharacterIterator_56	proc near ; CODE XREF: _charIterTextClone+85p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_A69A
		xor	eax, eax
		jmp	loc_A79C
; ---------------------------------------------------------------------------

loc_A69A:				; CODE XREF: _utext_openCharacterIterator_56+31j
		mov	ecx, [ebp+arg_4] ; this
		call	?startIndex@CharacterIterator@icu_56@@QBEHXZ ; icu_56::CharacterIterator::startIndex(void)
		test	eax, eax
		jle	short loc_A6B6
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 10h
		xor	eax, eax
		jmp	loc_A79C
; ---------------------------------------------------------------------------

loc_A6B6:				; CODE XREF: _utext_openCharacterIterator_56+44j
		mov	[ebp+var_8], 40h ; '@'
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	_utext_setup_56
		add	esp, 0Ch
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_A799
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], offset _charIterFuncs
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+3Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0
		mov	ecx, [ebp+arg_4] ; this
		call	?endIndex@CharacterIterator@icu_56@@QBEHXZ ; icu_56::CharacterIterator::endIndex(void)
		cdq
		mov	ecx, [ebp+arg_0]
		mov	[ecx+50h], eax
		mov	[ecx+54h], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+38h]
		mov	[eax+40h], edx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+58h], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+38h]
		add	ecx, 20h ; ' '
		mov	edx, [ebp+arg_0]
		mov	[edx+44h], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+5Ch], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+40h]
		mov	[eax+30h], edx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+20h], 0FFFFFFFFh
		mov	dword ptr [eax+24h], 0FFFFFFFFh
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+28h], 1
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+10h], 0
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+2Ch], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+28h]
		mov	[eax+1Ch], edx

loc_A799:				; CODE XREF: _utext_openCharacterIterator_56+87j
		mov	eax, [ebp+arg_0]

loc_A79C:				; CODE XREF: _utext_openCharacterIterator_56+35j
					; _utext_openCharacterIterator_56+51j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utext_openCharacterIterator_56	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A7B0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::data(void)const
		public ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A7F0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
		public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::data(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8]
		call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ;	std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A830h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
		public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
					; CODE XREF: icu_56::StringPiece::StringPiece(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const	&)+33p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+14h]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A860h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Myptr(void)const
		public ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
					; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+26p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+18h], 10h
		jb	short loc_A89A
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		mov	[ebp+var_D0], edx
		jmp	short loc_A8A6
; ---------------------------------------------------------------------------

loc_A89A:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+2Aj
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_D0], eax

loc_A8A6:				; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Myptr(void)+38j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000003ECo
					; .rdata:000006A0o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+51p ...
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+3Dp ...
		extrn __purecall:near	; DATA XREF: .rdata:000006A4o
					; .rdata:000006A8o ...
; public: virtual signed char __thiscall icu_56::Replaceable::hasMetaData(void)const
		extrn ?hasMetaData@Replaceable@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:000006B0o
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::Replaceable::clone(void)const
		extrn ?clone@Replaceable@icu_56@@UBEPAV12@XZ:near
					; DATA XREF: .rdata:000006B4o
; _DWORD __thiscall icu_56::Replaceable::~Replaceable(icu_56::Replaceable *__hidden this)
		extrn ??1Replaceable@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::Replaceable::`scalar deleting destructor'(uint)+26p
					; icu_56::Replaceable::`vector deleting	destructor'(uint)+64p
					; DATA XREF: ...
; _DWORD __thiscall icu_56::StringPiece::StringPiece(icu_56::StringPiece *__hidden this, const struct icu_56::StringPiece *, int, int)
		extrn ??0StringPiece@icu_56@@QAE@ABV01@HH@Z:near
					; CODE XREF: icu_56::StringPiece::substr(int,int)+32p
; public: virtual char * __thiscall icu_56::ByteSink::GetAppendBuffer(int, int,	char *,	int, int *)
		extrn ?GetAppendBuffer@ByteSink@icu_56@@UAEPADHHPADHPAH@Z:near
					; DATA XREF: .rdata:00000D60o
; public: virtual void __thiscall icu_56::ByteSink::Flush(void)
		extrn ?Flush@ByteSink@icu_56@@UAEXXZ:near ; DATA XREF: .rdata:00000D64o
; _DWORD __thiscall icu_56::ByteSink::~ByteSink(icu_56::ByteSink *__hidden this)
		extrn ??1ByteSink@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::ByteSink::`scalar deleting	destructor'(uint)+26p
					; icu_56::ByteSink::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::moveFrom(icu_56::UnicodeString *__hidden this, struct	icu_56::UnicodeString *)
		extrn ?moveFrom@UnicodeString@icu_56@@QAEAAV12@AAV12@@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(icu_56::UnicodeString &&)+2Ap
; void __thiscall icu_56::UnicodeString::swap(icu_56::UnicodeString *__hidden this, struct icu_56::UnicodeString *)
		extrn ?swap@UnicodeString@icu_56@@QAEXAAV12@@Z:near
					; CODE XREF: icu_56::swap(icu_56::UnicodeString	&,icu_56::UnicodeString	&)+25p
; _DWORD __thiscall icu_56::UnicodeString::~UnicodeString(icu_56::UnicodeString	*__hidden this)
		extrn ??1UnicodeString@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UnicodeString::`scalar deleting destructor'(uint)+26p
					; icu_56::UnicodeString::`vector deleting destructor'(uint)+64p ...
; public: virtual void * __thiscall icu_56::UnicodeString::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UnicodeString@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:000012DCo
; public: virtual void __thiscall icu_56::UnicodeString::extractBetween(int, int, class	icu_56::UnicodeString &)const
		extrn ?extractBetween@UnicodeString@icu_56@@UBEXHHAAV12@@Z:near
					; DATA XREF: .rdata:000012E0o
; public: virtual void __thiscall icu_56::UnicodeString::handleReplaceBetween(int, int,	class icu_56::UnicodeString const &)
		extrn ?handleReplaceBetween@UnicodeString@icu_56@@UAEXHHABV12@@Z:near
					; DATA XREF: .rdata:000012E4o
; public: virtual void __thiscall icu_56::UnicodeString::copy(int, int,	int)
		extrn ?copy@UnicodeString@icu_56@@UAEXHHH@Z:near
					; DATA XREF: .rdata:000012E8o
; public: virtual signed char __thiscall icu_56::UnicodeString::hasMetaData(void)const
		extrn ?hasMetaData@UnicodeString@icu_56@@UBECXZ:near
					; DATA XREF: .rdata:000012ECo
; public: virtual class	icu_56::Replaceable * __thiscall icu_56::UnicodeString::clone(void)const
		extrn ?clone@UnicodeString@icu_56@@UBEPAVReplaceable@2@XZ:near
					; DATA XREF: .rdata:000012F0o
; protected: virtual int __thiscall icu_56::UnicodeString::getLength(void)const
		extrn ?getLength@UnicodeString@icu_56@@MBEHXZ:near
					; DATA XREF: .rdata:000012F4o
; protected: virtual wchar_t __thiscall	icu_56::UnicodeString::getCharAt(int)const
		extrn ?getCharAt@UnicodeString@icu_56@@MBE_WH@Z:near
					; DATA XREF: .rdata:000012F8o
; protected: virtual int __thiscall icu_56::UnicodeString::getChar32At(int)const
		extrn ?getChar32At@UnicodeString@icu_56@@MBEHH@Z:near
					; DATA XREF: .rdata:000012FCo
; int __thiscall icu_56::UnicodeString::doHashCode(icu_56::UnicodeString *__hidden this)
		extrn ?doHashCode@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::hashCode(void)+26p
; int __thiscall icu_56::UnicodeString::refCount(icu_56::UnicodeString *__hidden this)
		extrn ?refCount@UnicodeString@icu_56@@ABEHXZ:near
					; CODE XREF: icu_56::UnicodeString::isBufferWritable(void)+3Ep
; signed __int8	__thiscall icu_56::UnicodeString::doCompare(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doCompare@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompare(int,int,icu_56::UnicodeString const &,int,int)+72p
					; icu_56::UnicodeString::compare(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doEquals(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int)
		extrn ?doEquals@UnicodeString@icu_56@@ABECABV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator==(icu_56::UnicodeString const &)+76p
; signed __int8	__thiscall icu_56::UnicodeString::doCompareCodePointOrder(icu_56::UnicodeString	*__hidden this,	int, int, const	wchar_t	*, int,	int)
		extrn ?doCompareCodePointOrder@UnicodeString@icu_56@@ABECHHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::doCompareCodePointOrder(int,int,icu_56::UnicodeString const	&,int,int)+72p
					; icu_56::UnicodeString::compareCodePointOrder(wchar_t const *,int)+3Bp ...
; signed __int8	__thiscall icu_56::UnicodeString::doCaseCompare(icu_56::UnicodeString *__hidden	this, int, int,	const wchar_t *, int, int, unsigned int)
		extrn ?doCaseCompare@UnicodeString@icu_56@@ABECHHPB_WHHI@Z:near
					; CODE XREF: icu_56::UnicodeString::doCaseCompare(int,int,icu_56::UnicodeString	const &,int,int,uint)+76p
					; icu_56::UnicodeString::caseCompare(wchar_t const *,int,uint)+3Fp ...
; int __thiscall icu_56::UnicodeString::indexOf(icu_56::UnicodeString *__hidden	this, const wchar_t *, int, int, int, int)
		extrn ?indexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(icu_56::UnicodeString const	&,int,int,int,int)+64p
					; icu_56::UnicodeString::indexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	wchar_t, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::indexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doIndexOf(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?doIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::indexOf(int,int,int)+32p
; int __thiscall icu_56::UnicodeString::lastIndexOf(icu_56::UnicodeString *__hidden this, const	wchar_t	*, int,	int, int, int)
		extrn ?lastIndexOf@UnicodeString@icu_56@@QBEHPB_WHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t	const *,int,int,int)+38p
					; icu_56::UnicodeString::lastIndexOf(wchar_t const *,int,int)+4Cp ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, wchar_t, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEH_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(wchar_t,int,int)+33p
					; icu_56::UnicodeString::lastIndexOf(wchar_t)+36p ...
; int __thiscall icu_56::UnicodeString::doLastIndexOf(icu_56::UnicodeString *__hidden this, int, int, int)
		extrn ?doLastIndexOf@UnicodeString@icu_56@@ABEHHHH@Z:near
					; CODE XREF: icu_56::UnicodeString::lastIndexOf(int,int,int)+32p
		extrn _u_strlen_56:near	; CODE XREF: icu_56::UnicodeString::startsWith(wchar_t const *,int)+2Dp
					; icu_56::UnicodeString::startsWith(wchar_t const *,int,int)+2Dp ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const	&)+3Dp
					; icu_56::UnicodeString::replace(int,int,icu_56::UnicodeString const &,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReplace(icu_56::UnicodeString *__hidden this, int, int, const wchar_t *, int, int)
		extrn ?doReplace@UnicodeString@icu_56@@AAEAAV12@HHPB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::replace(int,int,wchar_t const *,int)+38p
					; icu_56::UnicodeString::replace(int,int,wchar_t const *,int,int)+3Ap ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString *__hidden this, int, int, const struct icu_56::UnicodeString *, int, int, const struct icu_56::UnicodeString *, int, int)
		extrn ?findAndReplace@UnicodeString@icu_56@@QAEAAV12@HHABV12@HH0HH@Z:near
					; CODE XREF: icu_56::UnicodeString::findAndReplace(icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Fp
					; icu_56::UnicodeString::findAndReplace(int,int,icu_56::UnicodeString const &,icu_56::UnicodeString const &)+4Cp
; void __thiscall icu_56::UnicodeString::doExtract(icu_56::UnicodeString *__hidden this, int, int, wchar_t *, int)
		extrn ?doExtract@UnicodeString@icu_56@@ABEXHHPA_WH@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,wchar_t *,int)+36p
					; icu_56::UnicodeString::extractBetween(int,int,wchar_t	*,int)+51p
; int __thiscall icu_56::UnicodeString::extract(icu_56::UnicodeString *__hidden	this, int, int,	char *,	unsigned int, const char *)
		extrn ?extract@UnicodeString@icu_56@@QBEHHHPADIPBD@Z:near
					; CODE XREF: icu_56::UnicodeString::extract(int,int,char *,char	const *)+3Ep
; struct icu_56::UnicodeString __thiscall __high icu_56::UnicodeString::tempSubString(int, int)
		extrn ?tempSubString@UnicodeString@icu_56@@QBE?AV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::tempSubStringBetween(int,int)+3Fp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::replace(icu_56::UnicodeString	*__hidden this,	int, int, int)
		extrn ?replace@UnicodeString@icu_56@@QAEAAV12@HHH@Z:near
					; CODE XREF: icu_56::UnicodeString::operator=(int)+35p
					; icu_56::UnicodeString::setTo(int)+3Dp ...
; void __thiscall icu_56::UnicodeString::unBogus(icu_56::UnicodeString *__hidden this)
		extrn ?unBogus@UnicodeString@icu_56@@AAEXXZ:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &,int,int)+26p
					; icu_56::UnicodeString::setTo(icu_56::UnicodeString const &,int)+26p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::copyFrom(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, signed __int8)
		extrn ?copyFrom@UnicodeString@icu_56@@AAEAAV12@ABV12@C@Z:near
					; CODE XREF: icu_56::UnicodeString::setTo(icu_56::UnicodeString	const &)+2Cp
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@ABV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(icu_56::UnicodeString const &,int,int)+32p
					; icu_56::UnicodeString::append(icu_56::UnicodeString const &)+35p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doAppend(icu_56::UnicodeString *__hidden this, const wchar_t *, int, int)
		extrn ?doAppend@UnicodeString@icu_56@@AAEAAV12@PB_WHH@Z:near
					; CODE XREF: icu_56::UnicodeString::append(wchar_t const *,int,int)+32p
					; icu_56::UnicodeString::append(wchar_t	const *,int)+30p ...
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::append(icu_56::UnicodeString *__hidden this, int)
		extrn ?append@UnicodeString@icu_56@@QAEAAV12@H@Z:near
					; CODE XREF: icu_56::UnicodeString::operator+=(int)+2Ap
; struct icu_56::UnicodeString *__thiscall icu_56::UnicodeString::doReverse(icu_56::UnicodeString *__hidden this, int, int)
		extrn ?doReverse@UnicodeString@icu_56@@AAEAAV12@HH@Z:near
					; CODE XREF: icu_56::UnicodeString::reverse(void)+31p
					; icu_56::UnicodeString::reverse(int,int)+2Ep
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	_utext_current32_56+169p
					; _utf8TextAccess+509p	...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _utext_setup_56+2A0p
		extrn _uprv_free_56:near ; CODE	XREF: _utext_setup_56+136p
					; _utext_close_56+8Ap ...
		extrn _uprv_malloc_56:near ; CODE XREF:	_utext_setup_56+5Bp
					; _utext_setup_56+14Cp	...
		extrn _utf8_prevCharSafeBody_56:near ; CODE XREF: _utf8TextAccess+E03p
		extrn _utf8_nextCharSafeBody_56:near ; CODE XREF: _utf8TextAccess+9F4p
					; _utext_strFromUTF8+C6p ...
		extrn _utf8_back1SafeBody_56:near ; CODE XREF: _utf8TextAccess+712p
					; _utf8TextAccess+C67p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _utf8TextAccess+FF7p
					; _utf8TextExtract+221p ...
		extrn _u_terminateUChars_56:near ; CODE	XREF: _utext_strFromUTF8+1CDp
					; _repTextExtract+1BDp	...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _utf8TextClone+ABp
					; _shallowTextClone+C0p ...
		extrn _uprv_checkValidMemory:near ; CODE XREF: _utf8TextClone+91p
					; _shallowTextClone+ACp ...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, wchar_t *, int, int)
		extrn ??0UnicodeString@icu_56@@QAE@PA_WHH@Z:near
					; CODE XREF: _repTextAccess+3B2p
					; _repTextExtract+172p
		extrn ___security_cookie:near ;	DATA XREF: _repTextAccess+1Er
					; _repTextExtract+1Er ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _repTextAccess+5B6p
					; _repTextExtract+1F2p	...
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, signed __int8, const wchar_t *, int)
		extrn ??0UnicodeString@icu_56@@QAE@CPB_WH@Z:near
					; CODE XREF: _repTextReplace+178p
; _DWORD __thiscall icu_56::UnicodeString::UnicodeString(icu_56::UnicodeString *__hidden this, const struct icu_56::UnicodeString *)
		extrn ??0UnicodeString@icu_56@@QAE@ABV01@@Z:near
					; CODE XREF: _unistrTextClone+82p
; void *__cdecl	static icu_56::UMemory::operator new(unsigned int)
		extrn ??2UMemory@icu_56@@SAPAXI@Z:near ; CODE XREF: _unistrTextClone+61p
; int __thiscall icu_56::UnicodeString::getChar32Start(icu_56::UnicodeString *__hidden this, int)
		extrn ?getChar32Start@UnicodeString@icu_56@@QBEHH@Z:near
					; CODE XREF: _unistrTextExtract+C8p
					; _unistrTextExtract+116p ...
		extrn __allmul:near	; CODE XREF: _ucstrTextClone+144p
					; _ucstrTextClone+157p	...
		extrn _uprv_min_56:near	; CODE XREF: _ucstrTextExtract+22Ap


		end
