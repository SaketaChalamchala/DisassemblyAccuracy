;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	D996EB2B58BE89A1AF0BDE7A71DAC8B5
; Input	CRC32 :	0ECC986A

; File Name   :	D:\compspace\objfiles\firefox\common\uvector.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing
; char `public:	static void * __cdecl icu_56::UVector::getStaticClassID(void)'::`2'::classID
?classID@?1??getStaticClassID@UVector@icu_56@@SAPAXXZ@4DA db ?
					; DATA XREF: icu_56::UVector::getStaticClassID(void)+1Eo
		align 4
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 3Ch
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 40h
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase	; DATA XREF: .rdata$r:000001A0o
					; .rdata$r:000001BCo ...
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 44h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 78h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near	; CODE XREF: icu_56::UVector::UVector(UErrorCode &)+45p
					; icu_56::UVector::UVector(int,UErrorCode &)+45p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 130h
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 13Ch
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:00000130o
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 150h
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000148o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 170h
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:0000014Co
					; .rdata$r:000001A4o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 180h
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:0000017Co
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 18Ch
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; .rdata$r:00000A20o
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A8h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000184o
					; .rdata$r:00000A24o
					; icu_56::UMemory `RTTI	Type Descriptor'
		align 10h
		dd 4, 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1C4h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E4h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000001C0o
					; .rdata$r:00000214o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1F4h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000001F0o
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1FCh
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 218h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_24F
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_259
; ---------------------------------------------------------------------------

loc_24F:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_259:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 270h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2DF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_2DF:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_359
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_351
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_351:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_378
; ---------------------------------------------------------------------------

loc_359:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_375
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_375:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_378:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 390h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector::`scalar deleting destructor'(unsigned int)
		public ??_GUVector@icu_56@@UAEPAXI@Z
??_GUVector@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_3CF
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_3CF:				; CODE XREF: icu_56::UVector::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUVector@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3E8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UVector::`vector deleting destructor'(unsigned int)
		public ??_EUVector@icu_56@@UAEPAXI@Z
??_EUVector@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UVector::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_449
		push	offset ??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	18h
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_441
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_441:				; CODE XREF: icu_56::UVector::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_468
; ---------------------------------------------------------------------------

loc_449:				; CODE XREF: icu_56::UVector::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UVector@icu_56@@UAE@XZ ; icu_56::UVector::~UVector(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_465
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_465:				; CODE XREF: icu_56::UVector::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_468:				; CODE XREF: icu_56::UVector::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUVector@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 480h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::size(icu_56::UVector *__hidden this)
		public ?size@UVector@icu_56@@QBEHXZ
?size@UVector@icu_56@@QBEHXZ proc near	; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&)+38p
					; icu_56::UVector::containsNone(icu_56::UVector	const &)+38p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	eax, [eax+4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?size@UVector@icu_56@@QBEHXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::isEmpty(icu_56::UVector *__hidden this)
		public ?isEmpty@UVector@icu_56@@QBECXZ
?isEmpty@UVector@icu_56@@QBECXZ	proc near ; CODE XREF: icu_56::UStack::empty(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+4], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isEmpty@UVector@icu_56@@QBECXZ	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4E4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, void *)
		public ?contains@UVector@icu_56@@QBECPAX@Z
?contains@UVector@icu_56@@QBECPAX@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHPAXH@Z ; icu_56::UVector::indexOf(void *,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 530h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::contains(icu_56::UVector *this, int)
		public ?contains@UVector@icu_56@@QBECH@Z
?contains@UVector@icu_56@@QBECH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHHH@Z ; icu_56::UVector::indexOf(int,int)
		test	eax, eax
		setnl	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?contains@UVector@icu_56@@QBECH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 57Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::firstElement(icu_56::UVector *__hidden this)
		public ?firstElement@UVector@icu_56@@QBEPAXXZ
?firstElement@UVector@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?firstElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5C0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::lastElement(icu_56::UVector	*__hidden this)
		public ?lastElement@UVector@icu_56@@QBEPAXXZ
?lastElement@UVector@icu_56@@QBEPAXXZ proc near	; CODE XREF: icu_56::UStack::peek(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElement@UVector@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 60Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::lastElementi(icu_56::UVector *__hidden this)
		public ?lastElementi@UVector@icu_56@@QBEHXZ
?lastElementi@UVector@icu_56@@QBEHXZ proc near ; CODE XREF: icu_56::UStack::peeki(void)+26p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAti@UVector@icu_56@@QBEHH@Z ; icu_56::UVector::elementAti(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?lastElementi@UVector@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 658h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void * __thiscall icu_56::UVector::operator[](int)const
		public ??AUVector@icu_56@@QBEPAXH@Z
??AUVector@icu_56@@QBEPAXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?elementAt@UVector@icu_56@@QBEPAXH@Z ; icu_56::UVector::elementAt(int)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??AUVector@icu_56@@QBEPAXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6A0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector::operator!=(class icu_56::UVector const &)
		public ??9UVector@icu_56@@QAECABV01@@Z
??9UVector@icu_56@@QAECABV01@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		call	??8UVector@icu_56@@QAECABV01@@Z	; icu_56::UVector::operator==(icu_56::UVector const &)
		movsx	ecx, al
		test	ecx, ecx
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??9UVector@icu_56@@QAECABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 6F0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UStack::empty(icu_56::UStack	*__hidden this)
		public ?empty@UStack@icu_56@@QBECXZ
?empty@UStack@icu_56@@QBECXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?isEmpty@UVector@icu_56@@QBECXZ	; icu_56::UVector::isEmpty(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?empty@UStack@icu_56@@QBECXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 730h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::peek(icu_56::UStack *__hidden this)
		public ?peek@UStack@icu_56@@QBEPAXXZ
?peek@UStack@icu_56@@QBEPAXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElement@UVector@icu_56@@QBEPAXXZ ;	icu_56::UVector::lastElement(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peek@UStack@icu_56@@QBEPAXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 770h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::peeki(icu_56::UStack *__hidden	this)
		public ?peeki@UStack@icu_56@@QBEHXZ
?peeki@UStack@icu_56@@QBEHXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	?lastElementi@UVector@icu_56@@QBEHXZ ; icu_56::UVector::lastElementi(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?peeki@UStack@icu_56@@QBEHXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UStack::push(icu_56::UStack *this, void *, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z ;	icu_56::UVector::addElement(void *,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEPAXPAXAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7FCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UStack::push(icu_56::UStack *this, int, enum UErrorCode *)
		public ?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::addElement(int,UErrorCode &)
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?push@UStack@icu_56@@QAEHHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 848h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UVector::getStaticClassID()
		public ?getStaticClassID@UVector@icu_56@@SAPAXXZ
?getStaticClassID@UVector@icu_56@@SAPAXXZ proc near
					; CODE XREF: icu_56::UVector::getDynamicClassID(void)+23p

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, offset ?classID@?1??getStaticClassID@UVector@icu_56@@SAPAXXZ@4DA ;	char `icu_56::UVector::getStaticClassID(void)'::`2'::classID
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?getStaticClassID@UVector@icu_56@@SAPAXXZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 874h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::getDynamicClassID(icu_56::UVector *__hidden	this)
		public ?getDynamicClassID@UVector@icu_56@@UBEPAXXZ
?getDynamicClassID@UVector@icu_56@@UBEPAXXZ proc near ;	DATA XREF: .rdata:000009A8o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		call	?getStaticClassID@UVector@icu_56@@SAPAXXZ ; icu_56::UVector::getStaticClassID(void)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDynamicClassID@UVector@icu_56@@UBEPAXXZ endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 8B0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *this, enum UErrorCode *)
		public ??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z
??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector@icu_56@@6B@	; const	icu_56::UVector::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+arg_0]
		push	eax		; enum UErrorCode *
		push	8		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 978h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:000009B0o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UVector::UVector(UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9A0h
		dd offset ??_R4UVector@icu_56@@6B@ ; const icu_56::UVector::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UVector@icu_56@@6B@
; const	icu_56::UVector::`vftable'
??_7UVector@icu_56@@6B@	dd offset ??_EUVector@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UVector::UVector(UErrorCode &)+54o
					; icu_56::UVector::UVector(int,UErrorCode &)+54o ...
					; icu_56::UVector::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UVector@icu_56@@UBEPAXXZ ;	icu_56::UVector::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 9ACh
__unwindtable$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z	dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:000009BCo
		dd offset __unwindfunclet$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 9D8h
		public ??_R4UVector@icu_56@@6B@
; const	icu_56::UVector::`RTTI Complete	Object Locator'
??_R4UVector@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:000009A0o
		dd offset ??_R0?AVUVector@icu_56@@@8 ; icu_56::UVector `RTTI Type Descriptor'
		dd offset ??_R3UVector@icu_56@@8 ; icu_56::UVector::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 9ECh
		public ??_R0?AVUVector@icu_56@@@8
; class	icu_56::UVector	`RTTI Type Descriptor'
??_R0?AVUVector@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:000009E4o
					; .rdata$r:icu_56::UVector::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuvector@ic	db '.?AVUVector@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A0Ch
		public ??_R3UVector@icu_56@@8
; icu_56::UVector::`RTTI Class Hierarchy Descriptor'
??_R3UVector@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000009E8o
					; .rdata$r:00000A44o
		dd 3
		dd offset ??_R2UVector@icu_56@@8 ; icu_56::UVector::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A1Ch
		public ??_R2UVector@icu_56@@8
; icu_56::UVector::`RTTI Base Class Array'
??_R2UVector@icu_56@@8 dd offset ??_R1A@?0A@EA@UVector@icu_56@@8
					; DATA XREF: .rdata$r:00000A18o
					; icu_56::UVector::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R1A@?0A@EA@UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base	Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 0A2Ch
		public ??_R1A@?0A@EA@UVector@icu_56@@8
; icu_56::UVector::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UVector@icu_56@@8	dd offset ??_R0?AVUVector@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UVector::`RTTI Base Class	Array'o
					; icu_56::UVector `RTTI	Type Descriptor'
		dd 2, 0
		dd 0FFFFFFFFh, 0
		dd offset __RTC_InitBase_rtc$IMZ
		dd offset ??_R3UVector@icu_56@@8 ; icu_56::UVector::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A48h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *this, int, enum UErrorCode *)
		public ??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z
??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector@icu_56@@6B@	; const	icu_56::UVector::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0B10h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000B3Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UVector::UVector(int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0B38h
__unwindtable$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000B48o
		dd offset __unwindfunclet$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z	dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z
		align 20h
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0B64h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *this, void (__cdecl *)(void *), signed __int8 (__cdecl __high *)(union UElement, union UElement),	enum UErrorCode	*)
		public ??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z
??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector@icu_56@@6B@	; const	icu_56::UVector::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+14h], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		push	8		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0C28h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z$0 proc near
					; DATA XREF: .xdata$x:00000C54o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UVector::UVector(void (*)(void *),signed char (*)(UElement,UElement),UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0C50h
__unwindtable$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000C60o
		dd offset __unwindfunclet$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z dd 19930522h,	1
					; DATA XREF: __ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C7Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector::UVector(icu_56::UVector *this, void (__cdecl *)(void *), signed __int8 (__cdecl __high *)(union UElement, union UElement),	int, enum UErrorCode *)
		public ??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z
??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	ecx, [ebp+var_14] ; this
		call	??0UObject@icu_56@@QAE@XZ ; icu_56::UObject::UObject(void)
		mov	[ebp+var_4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector@icu_56@@6B@	; const	icu_56::UVector::`vftable'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+14h], ecx
		mov	eax, [ebp+arg_C]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_8]
		push	ecx		; int
		mov	ecx, [ebp+var_14] ; this
		call	?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::_init(int,UErrorCode &)
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	10h
??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0D44h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z$0	proc near
					; DATA XREF: .xdata$x:00000D70o
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z$0	endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z proc near
					; DATA XREF: icu_56::UVector::UVector(void (*)(void *),signed char (*)(UElement,UElement),int,UErrorCode &)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z
		jmp	___CxxFrameHandler3
__ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0D6Ch
__unwindtable$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z dd 0FFFFFFFFh
					; DATA XREF: .xdata$x:00000D7Co
		dd offset __unwindfunclet$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z$0
__ehfuncinfo$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z dd 19930522h, 1
					; DATA XREF: __ehhandler$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z+14o
		dd offset __unwindtable$??0UVector@icu_56@@QAE@P6AXPAX@ZP6ACTUElement@@2@ZHAAW4UErrorCode@@@Z
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0D98h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::_init(icu_56::UVector *this,	int, enum UErrorCode *)
		public ?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z
?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector::UVector(UErrorCode &)+95p
					; icu_56::UVector::UVector(int,UErrorCode &)+97p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_DD2
		jmp	short loc_E1A
; ---------------------------------------------------------------------------

loc_DD2:				; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+36j
		cmp	[ebp+arg_0], 1
		jl	short loc_DE1
		cmp	[ebp+arg_0], 1FFFFFFFh
		jle	short loc_DE8

loc_DE1:				; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+3Ej
		mov	[ebp+arg_0], 8

loc_DE8:				; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+47j
		mov	eax, [ebp+arg_0]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+var_8]
		mov	[ecx+0Ch], eax
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_E11
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		jmp	short loc_E1A
; ---------------------------------------------------------------------------

loc_E11:				; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+6Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+8], ecx

loc_E1A:				; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+38j
					; icu_56::UVector::_init(int,UErrorCode	&)+77j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?_init@UVector@icu_56@@AAEXHAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E30h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+29p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E5Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UVector::~UVector(icu_56::UVector *__hidden	this)
		public ??1UVector@icu_56@@UAE@XZ
??1UVector@icu_56@@UAE@XZ proc near	; CODE XREF: icu_56::UVector::`scalar deleting destructor'(uint)+26p
					; icu_56::UVector::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFFh
		push	offset __ehhandler$??1UVector@icu_56@@UAE@XZ
		mov	eax, large fs:0
		push	eax
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		push	eax
		lea	eax, [ebp+var_C]
		mov	large fs:0, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], offset	??_7UVector@icu_56@@6B@	; const	icu_56::UVector::`vftable'
		mov	[ebp+var_4], 0
		mov	ecx, [ebp+var_14] ; this
		call	?removeAllElements@UVector@icu_56@@QAEXXZ ; icu_56::UVector::removeAllElements(void)
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+0Ch], 0
		mov	[ebp+var_4], 0FFFFFFFFh
		mov	ecx, [ebp+var_14] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	ecx, [ebp+var_C]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1UVector@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$x		segment	para public 'CODE' use32
		assume cs:_text$x
		;org 0F00h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


__unwindfunclet$??1UVector@icu_56@@UAE@XZ$0 proc near ;	DATA XREF: .xdata$x:00000F2Co
		mov	ecx, [ebp-14h]	; this
		jmp	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
__unwindfunclet$??1UVector@icu_56@@UAE@XZ$0 endp


; =============== S U B	R O U T	I N E =======================================


__ehhandler$??1UVector@icu_56@@UAE@XZ proc near
					; DATA XREF: icu_56::UVector::~UVector(void)+5o

arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		lea	eax, [edx+0Ch]
		mov	ecx, [edx-0DCh]
		xor	ecx, eax
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	eax, offset __ehfuncinfo$??1UVector@icu_56@@UAE@XZ
		jmp	___CxxFrameHandler3
__ehhandler$??1UVector@icu_56@@UAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text$x		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_xdata$x	segment	dword public 'DATA' use32
		assume cs:_xdata$x
		;org 0F28h
__unwindtable$??1UVector@icu_56@@UAE@XZ	dd 0FFFFFFFFh ;	DATA XREF: .xdata$x:00000F38o
		dd offset __unwindfunclet$??1UVector@icu_56@@UAE@XZ$0
__ehfuncinfo$??1UVector@icu_56@@UAE@XZ dd 19930522h, 1
					; DATA XREF: __ehhandler$??1UVector@icu_56@@UAE@XZ+14o
		dd offset __unwindtable$??1UVector@icu_56@@UAE@XZ
		dd 5 dup(0)
		dd 1
_xdata$x	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F54h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::assign(icu_56::UVector *this, const struct icu_56::UVector *, void (__cdecl *)(union	UElement *, union UElement *), enum UErrorCode *)
		public ?assign@UVector@icu_56@@QAEXABV12@P6AXPATUElement@@1@ZAAW4UErrorCode@@@Z
?assign@UVector@icu_56@@QAEXABV12@P6AXPATUElement@@1@ZAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	loc_1042
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?setSize@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z ; icu_56::UVector::setSize(int,UErrorCode &)
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	loc_1042
		mov	[ebp+var_14], 0
		jmp	short loc_FD3
; ---------------------------------------------------------------------------

loc_FCA:				; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+ECj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_FD3:				; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+74j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_1042
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		cmp	dword ptr [ecx+edx*4], 0
		jz	short loc_1017
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_1017
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1017:				; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+97j
					; icu_56::UVector::assign(icu_56::UVector const	&,void (*)(UElement *,UElement *),UErrorCode &)+A0j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4]
		mov	esi, esp
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*4]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		jmp	short loc_FCA
; ---------------------------------------------------------------------------

loc_1042:				; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+3Bj
					; icu_56::UVector::assign(icu_56::UVector const	&,void (*)(UElement *,UElement *),UErrorCode &)+67j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?assign@UVector@icu_56@@QAEXABV12@P6AXPATUElement@@1@ZAAW4UErrorCode@@@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1058h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+5Ap
					; icu_56::UVector::sorti(UErrorCode &)+29p ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1084h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: signed char __thiscall icu_56::UVector::operator==(class icu_56::UVector const &)
		public ??8UVector@icu_56@@QAECABV01@@Z
??8UVector@icu_56@@QAECABV01@@Z	proc near
					; CODE XREF: icu_56::UVector::operator!=(icu_56::UVector const &)+2Ap

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jz	short loc_10B9
		xor	al, al
		jmp	short loc_111C
; ---------------------------------------------------------------------------

loc_10B9:				; CODE XREF: icu_56::UVector::operator==(icu_56::UVector const &)+2Fj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_111A
		mov	[ebp+var_14], 0
		jmp	short loc_10D4
; ---------------------------------------------------------------------------

loc_10CB:				; CODE XREF: icu_56::UVector::operator==(icu_56::UVector const &):loc_1118j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_10D4:				; CODE XREF: icu_56::UVector::operator==(icu_56::UVector const &)+45j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_111A
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	eax, [ebp+var_14]
		mov	ecx, [edx+eax*4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1118
		xor	al, al
		jmp	short loc_111C
; ---------------------------------------------------------------------------

loc_1118:				; CODE XREF: icu_56::UVector::operator==(icu_56::UVector const &)+8Ej
		jmp	short loc_10CB
; ---------------------------------------------------------------------------

loc_111A:				; CODE XREF: icu_56::UVector::operator==(icu_56::UVector const &)+3Cj
					; icu_56::UVector::operator==(icu_56::UVector const &)+59j
		mov	al, 1

loc_111C:				; CODE XREF: icu_56::UVector::operator==(icu_56::UVector const &)+33j
					; icu_56::UVector::operator==(icu_56::UVector const &)+92j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??8UVector@icu_56@@QAECABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1134h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::addElement(icu_56::UVector *this, void *, enum UErrorCode *)
		public ?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z
?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UStack::push(void *,UErrorCode &)+2Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1195
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	edx, [ebp+arg_0]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1195:				; CODE XREF: icu_56::UVector::addElement(void *,UErrorCode &)+3Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?addElement@UVector@icu_56@@QAEXPAXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11ACh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::addElement(icu_56::UVector *this, int, enum UErrorCode *)
		public ?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z
?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UStack::push(int,UErrorCode &)+2Ep

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1220
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	dword ptr [eax+ecx*4], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	edx, [ebp+arg_0]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1220:				; CODE XREF: icu_56::UVector::addElement(int,UErrorCode	&)+3Ej
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?addElement@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1238h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::setElementAt(icu_56::UVector	*this, void *, int)
		public ?setElementAt@UVector@icu_56@@QAEXPAXH@Z
?setElementAt@UVector@icu_56@@QAEXPAXH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jl	short loc_12B4
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_12B4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		cmp	dword ptr [ecx+edx*4], 0
		jz	short loc_12A5
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_12A5
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+arg_4]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_12A5:				; CODE XREF: icu_56::UVector::setElementAt(void	*,int)+41j
					; icu_56::UVector::setElementAt(void *,int)+4Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax

loc_12B4:				; CODE XREF: icu_56::UVector::setElementAt(void	*,int)+27j
					; icu_56::UVector::setElementAt(void *,int)+32j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setElementAt@UVector@icu_56@@QAEXPAXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12CCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::setElementAt(icu_56::UVector	*this, int, int)
		public ?setElementAt@UVector@icu_56@@QAEXHH@Z
?setElementAt@UVector@icu_56@@QAEXHH@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jl	short loc_1358
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jge	short loc_1358
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		cmp	dword ptr [ecx+edx*4], 0
		jz	short loc_1339
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_1339
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+arg_4]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1339:				; CODE XREF: icu_56::UVector::setElementAt(int,int)+41j
					; icu_56::UVector::setElementAt(int,int)+4Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ecx+edx*4], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax

loc_1358:				; CODE XREF: icu_56::UVector::setElementAt(int,int)+27j
					; icu_56::UVector::setElementAt(int,int)+32j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setElementAt@UVector@icu_56@@QAEXHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1370h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::insertElementAt(icu_56::UVector *this, void *, int, enum UErrorCode *)
		public ?insertElementAt@UVector@icu_56@@QAEXPAXHAAW4UErrorCode@@@Z
?insertElementAt@UVector@icu_56@@QAEXPAXHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jl	short loc_1416
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jg	short loc_1416
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_1416
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_13D5
; ---------------------------------------------------------------------------

loc_13CC:				; CODE XREF: icu_56::UVector::insertElementAt(void *,int,UErrorCode &)+86j
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_13D5:				; CODE XREF: icu_56::UVector::insertElementAt(void *,int,UErrorCode &)+5Aj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jle	short loc_13F8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4-4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	ecx, [ebp+var_14]
		mov	[edx+ecx*4], eax
		jmp	short loc_13CC
; ---------------------------------------------------------------------------

loc_13F8:				; CODE XREF: icu_56::UVector::insertElementAt(void *,int,UErrorCode &)+6Bj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1416:				; CODE XREF: icu_56::UVector::insertElementAt(void *,int,UErrorCode &)+27j
					; icu_56::UVector::insertElementAt(void	*,int,UErrorCode &)+32j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insertElementAt@UVector@icu_56@@QAEXPAXHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 142Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::insertElementAt(icu_56::UVector *this, int, int, enum UErrorCode *)
		public ?insertElementAt@UVector@icu_56@@QAEXHHAAW4UErrorCode@@@Z
?insertElementAt@UVector@icu_56@@QAEXHHAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_4], 0
		jl	loc_14EA
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+4]
		jg	loc_14EA
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_14EA
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_1499
; ---------------------------------------------------------------------------

loc_1490:				; CODE XREF: icu_56::UVector::insertElementAt(int,int,UErrorCode &)+8Ej
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_1499:				; CODE XREF: icu_56::UVector::insertElementAt(int,int,UErrorCode &)+62j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jle	short loc_14BC
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4-4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	ecx, [ebp+var_14]
		mov	[edx+ecx*4], eax
		jmp	short loc_1490
; ---------------------------------------------------------------------------

loc_14BC:				; CODE XREF: icu_56::UVector::insertElementAt(int,int,UErrorCode &)+73j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ecx+edx*4], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_14EA:				; CODE XREF: icu_56::UVector::insertElementAt(int,int,UErrorCode &)+27j
					; icu_56::UVector::insertElementAt(int,int,UErrorCode &)+36j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?insertElementAt@UVector@icu_56@@QAEXHHAAW4UErrorCode@@@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1500h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::elementAt(icu_56::UVector *this, int)
		public ?elementAt@UVector@icu_56@@QBEPAXH@Z
?elementAt@UVector@icu_56@@QBEPAXH@Z proc near
					; CODE XREF: icu_56::UVector::firstElement(void)+28p
					; icu_56::UVector::lastElement(void)+30p ...

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_1548
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jge	short loc_1548
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+ecx*4]
		mov	[ebp+var_D0], edx
		jmp	short loc_1552
; ---------------------------------------------------------------------------

loc_1548:				; CODE XREF: icu_56::UVector::elementAt(int)+27j
					; icu_56::UVector::elementAt(int)+32j
		mov	[ebp+var_D0], 0

loc_1552:				; CODE XREF: icu_56::UVector::elementAt(int)+46j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?elementAt@UVector@icu_56@@QBEPAXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1564h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::elementAti(icu_56::UVector *this, int)
		public ?elementAti@UVector@icu_56@@QBEHH@Z
?elementAti@UVector@icu_56@@QBEHH@Z proc near
					; CODE XREF: icu_56::UVector::lastElementi(void)+30p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jl	short loc_15AC
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jge	short loc_15AC
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+ecx*4]
		mov	[ebp+var_D0], edx
		jmp	short loc_15B6
; ---------------------------------------------------------------------------

loc_15AC:				; CODE XREF: icu_56::UVector::elementAti(int)+27j
					; icu_56::UVector::elementAti(int)+32j
		mov	[ebp+var_D0], 0

loc_15B6:				; CODE XREF: icu_56::UVector::elementAti(int)+46j
		mov	eax, [ebp+var_D0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?elementAti@UVector@icu_56@@QBEHH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 15C8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::containsAll(icu_56::UVector	*this, const struct icu_56::UVector *)
		public ?containsAll@UVector@icu_56@@QBECABV12@@Z
?containsAll@UVector@icu_56@@QBECABV12@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_15FD
; ---------------------------------------------------------------------------

loc_15F4:				; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&):loc_162Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_15FD:				; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&)+2Aj
		mov	ecx, [ebp+arg_0] ; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_162D
		push	0
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z ; icu_56::UVector::indexOf(UElement,int,signed char)
		test	eax, eax
		jge	short loc_162B
		xor	al, al
		jmp	short loc_162F
; ---------------------------------------------------------------------------

loc_162B:				; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&)+5Dj
		jmp	short loc_15F4
; ---------------------------------------------------------------------------

loc_162D:				; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&)+40j
		mov	al, 1

loc_162F:				; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&)+61j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsAll@UVector@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1648h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::containsNone(icu_56::UVector *this,	const struct icu_56::UVector *)
		public ?containsNone@UVector@icu_56@@QBECABV12@@Z
?containsNone@UVector@icu_56@@QBECABV12@@Z proc	near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		jmp	short loc_167D
; ---------------------------------------------------------------------------

loc_1674:				; CODE XREF: icu_56::UVector::containsNone(icu_56::UVector const &):loc_16ABj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_167D:				; CODE XREF: icu_56::UVector::containsNone(icu_56::UVector const &)+2Aj
		mov	ecx, [ebp+arg_0] ; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_14], eax
		jge	short loc_16AD
		push	0
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z ; icu_56::UVector::indexOf(UElement,int,signed char)
		test	eax, eax
		jl	short loc_16AB
		xor	al, al
		jmp	short loc_16AF
; ---------------------------------------------------------------------------

loc_16AB:				; CODE XREF: icu_56::UVector::containsNone(icu_56::UVector const &)+5Dj
		jmp	short loc_1674
; ---------------------------------------------------------------------------

loc_16AD:				; CODE XREF: icu_56::UVector::containsNone(icu_56::UVector const &)+40j
		mov	al, 1

loc_16AF:				; CODE XREF: icu_56::UVector::containsNone(icu_56::UVector const &)+61j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?containsNone@UVector@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 16C8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::removeAll(icu_56::UVector *this, const struct icu_56::UVector *)
		public ?removeAll@UVector@icu_56@@QAECABV12@@Z
?removeAll@UVector@icu_56@@QAECABV12@@Z	proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_11], 0
		mov	[ebp+var_20], 0
		jmp	short loc_1701
; ---------------------------------------------------------------------------

loc_16F8:				; CODE XREF: icu_56::UVector::removeAll(icu_56::UVector	const &):loc_1740j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_1701:				; CODE XREF: icu_56::UVector::removeAll(icu_56::UVector	const &)+2Ej
		mov	ecx, [ebp+arg_0] ; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		cmp	[ebp+var_20], eax
		jge	short loc_1742
		push	0
		push	0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		call	?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z ; icu_56::UVector::indexOf(UElement,int,signed char)
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jl	short loc_1740
		mov	eax, [ebp+var_2C]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?removeElementAt@UVector@icu_56@@QAEXH@Z ; icu_56::UVector::removeElementAt(int)
		mov	[ebp+var_11], 1

loc_1740:				; CODE XREF: icu_56::UVector::removeAll(icu_56::UVector	const &)+66j
		jmp	short loc_16F8
; ---------------------------------------------------------------------------

loc_1742:				; CODE XREF: icu_56::UVector::removeAll(icu_56::UVector	const &)+44j
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?removeAll@UVector@icu_56@@QAECABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 175Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::retainAll(icu_56::UVector *this, const struct icu_56::UVector *)
		public ?retainAll@UVector@icu_56@@QAECABV12@@Z
?retainAll@UVector@icu_56@@QAECABV12@@Z	proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_11], 0
		mov	ecx, [ebp+var_8] ; this
		call	?size@UVector@icu_56@@QBEHXZ ; icu_56::UVector::size(void)
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_179C
; ---------------------------------------------------------------------------

loc_1793:				; CODE XREF: icu_56::UVector::retainAll(icu_56::UVector	const &):loc_17D4j
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax

loc_179C:				; CODE XREF: icu_56::UVector::retainAll(icu_56::UVector	const &)+35j
		cmp	[ebp+var_20], 0
		jl	short loc_17D6
		push	0
		push	0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+arg_0]
		call	?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z ; icu_56::UVector::indexOf(UElement,int,signed char)
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jge	short loc_17D4
		mov	eax, [ebp+var_20]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?removeElementAt@UVector@icu_56@@QAEXH@Z ; icu_56::UVector::removeElementAt(int)
		mov	[ebp+var_11], 1

loc_17D4:				; CODE XREF: icu_56::UVector::retainAll(icu_56::UVector	const &)+66j
		jmp	short loc_1793
; ---------------------------------------------------------------------------

loc_17D6:				; CODE XREF: icu_56::UVector::retainAll(icu_56::UVector	const &)+44j
		mov	al, [ebp+var_11]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?retainAll@UVector@icu_56@@QAECABV12@@Z	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17F0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::removeElementAt(icu_56::UVector *this, int)
		public ?removeElementAt@UVector@icu_56@@QAEXH@Z
?removeElementAt@UVector@icu_56@@QAEXH@Z proc near
					; CODE XREF: icu_56::UVector::removeAll(icu_56::UVector	const &)+6Fp
					; icu_56::UVector::retainAll(icu_56::UVector const &)+6Fp ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?orphanElementAt@UVector@icu_56@@QAEPAXH@Z ; icu_56::UVector::orphanElementAt(int)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jz	short loc_1849
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_1849
		mov	esi, esp
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_1849:				; CODE XREF: icu_56::UVector::removeElementAt(int)+36j
					; icu_56::UVector::removeElementAt(int)+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?removeElementAt@UVector@icu_56@@QAEXH@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1860h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::removeElement(icu_56::UVector *this, void *)
		public ?removeElement@UVector@icu_56@@QAECPAX@Z
?removeElement@UVector@icu_56@@QAECPAX@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; int
		mov	eax, [ebp+arg_0]
		push	eax		; void *
		mov	ecx, [ebp+var_8] ; this
		call	?indexOf@UVector@icu_56@@QBEHPAXH@Z ; icu_56::UVector::indexOf(void *,int)
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jl	short loc_18AA
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?removeElementAt@UVector@icu_56@@QAEXH@Z ; icu_56::UVector::removeElementAt(int)
		mov	al, 1
		jmp	short loc_18AC
; ---------------------------------------------------------------------------

loc_18AA:				; CODE XREF: icu_56::UVector::removeElement(void *)+38j
		xor	al, al

loc_18AC:				; CODE XREF: icu_56::UVector::removeElement(void *)+48j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?removeElement@UVector@icu_56@@QAECPAX@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 18C4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::removeAllElements(icu_56::UVector *__hidden this)
		public ?removeAllElements@UVector@icu_56@@QAEXXZ
?removeAllElements@UVector@icu_56@@QAEXXZ proc near
					; CODE XREF: icu_56::UVector::~UVector(void)+55p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+10h], 0
		jz	short loc_193F
		mov	[ebp+var_14], 0
		jmp	short loc_1902
; ---------------------------------------------------------------------------

loc_18F9:				; CODE XREF: icu_56::UVector::removeAllElements(void):loc_193Dj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1902:				; CODE XREF: icu_56::UVector::removeAllElements(void)+33j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_193F
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		cmp	dword ptr [ecx+edx*4], 0
		jz	short loc_193D
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+10h]
		call	edx
		add	esp, 4
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_193D:				; CODE XREF: icu_56::UVector::removeAllElements(void)+56j
		jmp	short loc_18F9
; ---------------------------------------------------------------------------

loc_193F:				; CODE XREF: icu_56::UVector::removeAllElements(void)+2Aj
					; icu_56::UVector::removeAllElements(void)+47j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax+4], 0
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?removeAllElements@UVector@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1960h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::equals(icu_56::UVector *this, const	struct icu_56::UVector *)
		public ?equals@UVector@icu_56@@QBECABV12@@Z
?equals@UVector@icu_56@@QBECABV12@@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [eax+4]
		cmp	edx, [ecx+4]
		jz	short loc_1998
		xor	al, al
		jmp	loc_1A40
; ---------------------------------------------------------------------------

loc_1998:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+2Fj
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_19E0
		mov	[ebp+var_14], 0
		jmp	short loc_19B3
; ---------------------------------------------------------------------------

loc_19AA:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &):loc_19DCj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_19B3:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+48j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_19DE
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+0Ch]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_14]
		mov	ecx, [ecx+edx*4]
		cmp	ecx, [eax+esi*4]
		jz	short loc_19DC
		xor	al, al
		jmp	short loc_1A40
; ---------------------------------------------------------------------------

loc_19DC:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+76j
		jmp	short loc_19AA
; ---------------------------------------------------------------------------

loc_19DE:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+5Cj
		jmp	short loc_1A3E
; ---------------------------------------------------------------------------

loc_19E0:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+3Fj
		mov	[ebp+var_14], 0
		jmp	short loc_19F2
; ---------------------------------------------------------------------------

loc_19E9:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &):loc_1A3Cj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_19F2:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+87j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_1A3E
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_1A3C
		xor	al, al
		jmp	short loc_1A40
; ---------------------------------------------------------------------------

loc_1A3C:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+D6j
		jmp	short loc_19E9
; ---------------------------------------------------------------------------

loc_1A3E:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &):loc_19DEj
					; icu_56::UVector::equals(icu_56::UVector const	&)+9Bj
		mov	al, 1

loc_1A40:				; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+33j
					; icu_56::UVector::equals(icu_56::UVector const	&)+7Aj	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?equals@UVector@icu_56@@QBECABV12@@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN16		dd 1			; DATA XREF: icu_56::UVector::equals(icu_56::UVector const &)+E4o
		dd offset $LN15
$LN15		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001A6Co
		dd offset $LN14
$LN14		dd 79656Bh		; DATA XREF: .text:00001A78o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1A80h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *this, void *, int)
		public ?indexOf@UVector@icu_56@@QBEHPAXH@Z
?indexOf@UVector@icu_56@@QBEHPAXH@Z proc near
					; CODE XREF: icu_56::UVector::contains(void *)+2Cp
					; icu_56::UVector::removeElement(void *)+2Cp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z ; icu_56::UVector::indexOf(UElement,int,signed char)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UVector@icu_56@@QBEHPAXH@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN5		dd 1			; DATA XREF: icu_56::UVector::indexOf(void *,int)+3Fo
		dd offset $LN4
$LN4		dd 0FFFFFFECh, 4	; DATA XREF: .text:00001AE8o
		dd offset $LN3
$LN3		dd 79656Bh		; DATA XREF: .text:00001AF4o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AFCh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __thiscall icu_56::UVector::indexOf(icu_56::UVector *this, int, int)
		public ?indexOf@UVector@icu_56@@QBEHHH@Z
?indexOf@UVector@icu_56@@QBEHHH@Z proc near ; CODE XREF: icu_56::UVector::contains(int)+2Cp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		push	0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		mov	ecx, [ebp+var_8]
		call	?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z ; icu_56::UVector::indexOf(UElement,int,signed char)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?indexOf@UVector@icu_56@@QBEHHH@Z endp

; ---------------------------------------------------------------------------
		align 10h
$LN5_0		dd 1			; DATA XREF: icu_56::UVector::indexOf(int,int)+3Fo
		dd offset $LN4_0
$LN4_0		dd 0FFFFFFECh, 4	; DATA XREF: .text:00001B64o
		dd offset $LN3_0
$LN3_0		dd 79656Bh		; DATA XREF: .text:00001B70o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1B78h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: int __thiscall icu_56::UVector::indexOf(union UElement, int,	signed char)const
		public ?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z
?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z proc near
					; CODE XREF: icu_56::UVector::containsAll(icu_56::UVector const	&)+56p
					; icu_56::UVector::containsNone(icu_56::UVector	const &)+56p ...

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+14h], 0
		jz	short loc_1BF5
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		jmp	short loc_1BB5
; ---------------------------------------------------------------------------

loc_1BAC:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char):loc_1BF1j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1BB5:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+32j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_1BF3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	esi, esp
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+14h]
		call	eax
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_1BF1
		mov	eax, [ebp+var_14]
		jmp	short loc_1C4D
; ---------------------------------------------------------------------------

loc_1BF1:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+72j
		jmp	short loc_1BAC
; ---------------------------------------------------------------------------

loc_1BF3:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+46j
		jmp	short loc_1C4A
; ---------------------------------------------------------------------------

loc_1BF5:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+2Aj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_14], eax
		jmp	short loc_1C06
; ---------------------------------------------------------------------------

loc_1BFD:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char):loc_1C48j
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1C06:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+83j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+4]
		jge	short loc_1C4A
		movsx	eax, [ebp+arg_8]
		and	eax, 1
		jz	short loc_1C32
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4]
		jnz	short loc_1C30
		mov	eax, [ebp+var_14]
		jmp	short loc_1C4D
; ---------------------------------------------------------------------------

loc_1C30:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+B1j
		jmp	short loc_1C48
; ---------------------------------------------------------------------------

loc_1C32:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+A0j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		cmp	eax, [ecx+edx*4]
		jnz	short loc_1C48
		mov	eax, [ebp+var_14]
		jmp	short loc_1C4D
; ---------------------------------------------------------------------------

loc_1C48:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char):loc_1C30j
					; icu_56::UVector::indexOf(UElement,int,signed char)+C9j
		jmp	short loc_1BFD
; ---------------------------------------------------------------------------

loc_1C4A:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char):loc_1BF3j
					; icu_56::UVector::indexOf(UElement,int,signed char)+97j
		or	eax, 0FFFFFFFFh

loc_1C4D:				; CODE XREF: icu_56::UVector::indexOf(UElement,int,signed char)+77j
					; icu_56::UVector::indexOf(UElement,int,signed char)+B6j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?indexOf@UVector@icu_56@@ABEHTUElement@@HC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C64h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	__thiscall icu_56::UVector::ensureCapacity(icu_56::UVector *this, int, enum UErrorCode *)
		public ?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z
?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+31p
					; icu_56::UVector::addElement(void *,UErrorCode	&)+34p	...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jge	short loc_1C9D
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	loc_1D34
; ---------------------------------------------------------------------------

loc_1C9D:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+27j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		cmp	ecx, [ebp+arg_0]
		jge	loc_1D32
		mov	eax, [ebp+var_8]
		cmp	dword ptr [eax+8], 3FFFFFFFh
		jle	short loc_1CC5
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	short loc_1D34
; ---------------------------------------------------------------------------

loc_1CC5:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+52j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+8]
		shl	ecx, 1
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_1CDE
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax

loc_1CDE:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+72j
		cmp	[ebp+var_14], 1FFFFFFFh
		jle	short loc_1CF4
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	al, al
		jmp	short loc_1D34
; ---------------------------------------------------------------------------

loc_1CF4:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+81j
		mov	eax, [ebp+var_14]
		shl	eax, 2
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_uprv_realloc_56
		add	esp, 8
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jnz	short loc_1D20
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 7
		xor	al, al
		jmp	short loc_1D34
; ---------------------------------------------------------------------------

loc_1D20:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+ADj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx

loc_1D32:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+42j
		mov	al, 1

loc_1D34:				; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+34j
					; icu_56::UVector::ensureCapacity(int,UErrorCode &)+5Fj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D4Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::setSize(icu_56::UVector *this, int, enum UErrorCode *)
		public ?setSize@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z
?setSize@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z proc near
					; CODE XREF: icu_56::UVector::assign(icu_56::UVector const &,void (*)(UElement *,UElement *),UErrorCode	&)+4Fp

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jge	short loc_1D7A
		jmp	loc_1E11
; ---------------------------------------------------------------------------

loc_1D7A:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+27j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jle	short loc_1DDB
		mov	eax, [ebp+arg_4]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+arg_0]
		push	ecx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	edx, al
		test	edx, edx
		jnz	short loc_1D9E
		jmp	short loc_1E11
; ---------------------------------------------------------------------------

loc_1D9E:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+4Ej
		mov	[ebp+var_20], 0
		mov	[ebp+var_20], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_14], ecx
		jmp	short loc_1DC0
; ---------------------------------------------------------------------------

loc_1DB7:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+8Bj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_1DC0:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+69j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jge	short loc_1DD9
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_20]
		mov	[ecx+edx*4], eax
		jmp	short loc_1DB7
; ---------------------------------------------------------------------------

loc_1DD9:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+7Aj
		jmp	short loc_1E08
; ---------------------------------------------------------------------------

loc_1DDB:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+37j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	[ebp+var_14], ecx
		jmp	short loc_1DF2
; ---------------------------------------------------------------------------

loc_1DE9:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+BAj
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax

loc_1DF2:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+9Bj
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_0]
		jl	short loc_1E08
		mov	eax, [ebp+var_14]
		push	eax		; int
		mov	ecx, [ebp+var_8] ; this
		call	?removeElementAt@UVector@icu_56@@QAEXH@Z ; icu_56::UVector::removeElementAt(int)
		jmp	short loc_1DE9
; ---------------------------------------------------------------------------

loc_1E08:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &):loc_1DD9j
					; icu_56::UVector::setSize(int,UErrorCode &)+ACj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+4], ecx

loc_1E11:				; CODE XREF: icu_56::UVector::setSize(int,UErrorCode &)+29j
					; icu_56::UVector::setSize(int,UErrorCode &)+50j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN15_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?setSize@UVector@icu_56@@QAEXHAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN15_0		dd 1			; DATA XREF: icu_56::UVector::setSize(int,UErrorCode &)+C9o
		dd offset $LN14_0
$LN14_0		dd 0FFFFFFE0h, 4	; DATA XREF: .text:00001E3Co
		dd offset $LN13		; "empty"
$LN13		db 'empty',0            ; DATA XREF: .text:00001E48o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1E54h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void **__thiscall icu_56::UVector::toArray(icu_56::UVector *this, void **)
		public ?toArray@UVector@icu_56@@QBEPAPAXPAPAX@Z
?toArray@UVector@icu_56@@QBEPAPAXPAPAX@Z proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	[ebp+var_20], 0
		jmp	short loc_1E8F
; ---------------------------------------------------------------------------

loc_1E86:				; CODE XREF: icu_56::UVector::toArray(void * *)+60j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_1E8F:				; CODE XREF: icu_56::UVector::toArray(void * *)+30j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_20]
		cmp	ecx, [eax+4]
		jge	short loc_1EB6
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+var_20]
		mov	ecx, [ecx+eax*4]
		mov	[edx], ecx
		mov	edx, [ebp+var_14]
		add	edx, 4
		mov	[ebp+var_14], edx
		jmp	short loc_1E86
; ---------------------------------------------------------------------------

loc_1EB6:				; CODE XREF: icu_56::UVector::toArray(void * *)+44j
		mov	eax, [ebp+arg_0]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?toArray@UVector@icu_56@@QBEPAPAXPAPAX@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1EC4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void (__cdecl	*__thiscall icu_56::UVector::setDeleter(icu_56::UVector	*this, void (__cdecl *)(void *)))(void *)
		public ?setDeleter@UVector@icu_56@@QAEP6AXPAX@ZP6AX0@Z@Z
?setDeleter@UVector@icu_56@@QAEP6AXPAX@ZP6AX0@Z@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+10h], ecx
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setDeleter@UVector@icu_56@@QAEP6AXPAX@ZP6AX0@Z@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F08h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed __int8	(__cdecl __high	*__thiscall icu_56::UVector::setComparer(icu_56::UVector *this,	signed __int8 (__cdecl __high *)(union UElement, union UElement)))(union UElement, union UElement)
		public ?setComparer@UVector@icu_56@@QAEP6ACTUElement@@0@ZP6AC00@Z@Z
?setComparer@UVector@icu_56@@QAEP6ACTUElement@@0@ZP6AC00@Z@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+14h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax+14h], ecx
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?setComparer@UVector@icu_56@@QAEP6ACTUElement@@0@ZP6AC00@Z@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1F4Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__thiscall icu_56::UVector::orphanElementAt(icu_56::UVector *this, int)
		public ?orphanElementAt@UVector@icu_56@@QAEPAXH@Z
?orphanElementAt@UVector@icu_56@@QAEPAXH@Z proc	near
					; CODE XREF: icu_56::UVector::removeElementAt(int)+2Ap

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		cmp	[ebp+arg_0], 0
		jl	short loc_1FDF
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		cmp	ecx, [eax+4]
		jge	short loc_1FDF
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+arg_0]
		mov	eax, [ecx+edx*4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_20], eax
		jmp	short loc_1FA7
; ---------------------------------------------------------------------------

loc_1F9E:				; CODE XREF: icu_56::UVector::orphanElementAt(int)+82j
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax

loc_1FA7:				; CODE XREF: icu_56::UVector::orphanElementAt(int)+50j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		cmp	[ebp+var_20], ecx
		jge	short loc_1FD0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_20]
		mov	eax, [ecx+edx*4+4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	ecx, [ebp+var_20]
		mov	[edx+ecx*4], eax
		jmp	short loc_1F9E
; ---------------------------------------------------------------------------

loc_1FD0:				; CODE XREF: icu_56::UVector::orphanElementAt(int)+67j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		sub	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_1FDF:				; CODE XREF: icu_56::UVector::orphanElementAt(int)+2Ej
					; icu_56::UVector::orphanElementAt(int)+39j
		mov	eax, [ebp+var_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
?orphanElementAt@UVector@icu_56@@QAEPAXH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1FECh
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::sortedInsert(icu_56::UVector	*this, void *, signed __int8 (__cdecl __high *)(union UElement,	union UElement), enum UErrorCode *)
		public ?sortedInsert@UVector@icu_56@@QAEXPAXP6ACTUElement@@1@ZAAW4UErrorCode@@@Z
?sortedInsert@UVector@icu_56@@QAEXPAXP6ACTUElement@@1@ZAAW4UErrorCode@@@Z proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?sortedInsert@UVector@icu_56@@AAEXTUElement@@P6AC00@ZAAW4UErrorCode@@@Z	; icu_56::UVector::sortedInsert(UElement,signed	char (*)(UElement,UElement),UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?sortedInsert@UVector@icu_56@@QAEXPAXP6ACTUElement@@1@ZAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
$LN5_1		dd 1			; DATA XREF: icu_56::UVector::sortedInsert(void	*,signed char (*)(UElement,UElement),UErrorCode	&)+41o
		dd offset $LN4_1
$LN4_1		dd 0FFFFFFECh, 4	; DATA XREF: .text:00002054o
		dd offset $LN3_1
$LN3_1		db 65h,	0		; DATA XREF: .text:00002060o
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2068h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::sortedInsert(icu_56::UVector	*this, int, signed __int8 (__cdecl __high *)(union UElement, union UElement), enum UErrorCode *)
		public ?sortedInsert@UVector@icu_56@@QAEXHP6ACTUElement@@0@ZAAW4UErrorCode@@@Z
?sortedInsert@UVector@icu_56@@QAEXHP6ACTUElement@@0@ZAAW4UErrorCode@@@Z	proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	ecx, [ebp+var_8]
		call	?sortedInsert@UVector@icu_56@@AAEXTUElement@@P6AC00@ZAAW4UErrorCode@@@Z	; icu_56::UVector::sortedInsert(UElement,signed	char (*)(UElement,UElement),UErrorCode &)
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN5_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?sortedInsert@UVector@icu_56@@QAEXHP6ACTUElement@@0@ZAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
$LN5_2		dd 1			; DATA XREF: icu_56::UVector::sortedInsert(int,signed char (*)(UElement,UElement),UErrorCode &)+41o
		dd offset $LN4_2
$LN4_2		dd 0FFFFFFECh, 4	; DATA XREF: .text:000020D0o
		dd offset $LN3_2
$LN3_2		db 65h,	0		; DATA XREF: .text:000020DCo
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 20E4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; private: void	__thiscall icu_56::UVector::sortedInsert(union UElement, signed	char (__cdecl *)(union UElement, union UElement), enum	UErrorCode &)
		public ?sortedInsert@UVector@icu_56@@AAEXTUElement@@P6AC00@ZAAW4UErrorCode@@@Z
?sortedInsert@UVector@icu_56@@AAEXTUElement@@P6AC00@ZAAW4UErrorCode@@@Z	proc near
					; CODE XREF: icu_56::UVector::sortedInsert(void	*,signed char (*)(UElement,UElement),UErrorCode	&)+38p
					; icu_56::UVector::sortedInsert(int,signed char	(*)(UElement,UElement),UErrorCode &)+38p

var_108		= byte ptr -108h
var_44		= dword	ptr -44h
var_35		= byte ptr -35h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 108h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_108]
		mov	ecx, 42h ; 'B'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	[ebp+var_14], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_20], ecx

loc_2117:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &):loc_2169j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jz	short loc_216B
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_20]
		cdq
		sub	eax, edx
		sar	eax, 1
		mov	[ebp+var_2C], eax
		mov	esi, esp
		mov	eax, [ebp+arg_0]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	eax, [ebp+var_2C]
		mov	ecx, [edx+eax*4]
		push	ecx
		call	[ebp+arg_4]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		mov	[ebp+var_35], al
		movsx	eax, [ebp+var_35]
		test	eax, eax
		jle	short loc_2160
		mov	eax, [ebp+var_2C]
		mov	[ebp+var_20], eax
		jmp	short loc_2169
; ---------------------------------------------------------------------------

loc_2160:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+72j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_14], eax

loc_2169:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+7Aj
		jmp	short loc_2117
; ---------------------------------------------------------------------------

loc_216B:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+39j
		mov	eax, [ebp+arg_8]
		push	eax		; enum UErrorCode *
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		add	edx, 1
		push	edx		; int
		mov	ecx, [ebp+var_8] ; this
		call	?ensureCapacity@UVector@icu_56@@QAECHAAW4UErrorCode@@@Z	; icu_56::UVector::ensureCapacity(int,UErrorCode &)
		movsx	eax, al
		test	eax, eax
		jz	short loc_21DD
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		mov	[ebp+var_44], ecx
		jmp	short loc_219C
; ---------------------------------------------------------------------------

loc_2193:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+D9j
		mov	eax, [ebp+var_44]
		sub	eax, 1
		mov	[ebp+var_44], eax

loc_219C:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+ADj
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_14]
		jle	short loc_21BF
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_44]
		mov	eax, [ecx+edx*4-4]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		mov	ecx, [ebp+var_44]
		mov	[edx+ecx*4], eax
		jmp	short loc_2193
; ---------------------------------------------------------------------------

loc_21BF:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+BEj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+4], ecx

loc_21DD:				; CODE XREF: icu_56::UVector::sortedInsert(UElement,signed char	(*)(UElement,UElement),UErrorCode &)+A2j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 108h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?sortedInsert@UVector@icu_56@@AAEXTUElement@@P6AC00@ZAAW4UErrorCode@@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 21F4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::sorti(icu_56::UVector *this,	enum UErrorCode	*)
		public ?sorti@UVector@icu_56@@QAEXAAW4UErrorCode@@@Z
?sorti@UVector@icu_56@@QAEXAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2251
		mov	eax, [ebp+arg_0]
		push	eax
		push	0
		push	0
		push	offset ?sortiComparator@icu_56@@YAHPBX00@Z ; icu_56::sortiComparator(void const	*,void const *,void const *)
		push	4
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+0Ch]
		push	ecx
		call	_uprv_sortArray_56
		add	esp, 1Ch

loc_2251:				; CODE XREF: icu_56::UVector::sorti(UErrorCode &)+36j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
?sorti@UVector@icu_56@@QAEXAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2268h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::sortiComparator(void const *, void const *, void const *)
?sortiComparator@icu_56@@YAHPBX00@Z proc near
					; DATA XREF: icu_56::UVector::sorti(UErrorCode &)+40o

var_E8		= dword	ptr -0E8h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E8]
		mov	ecx, 3Ah ; ':'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jge	short loc_22AA
		mov	[ebp+var_E8], 0FFFFFFFFh
		jmp	short loc_22BF
; ---------------------------------------------------------------------------

loc_22AA:				; CODE XREF: icu_56::sortiComparator(void const	*,void const *,void const *)+34j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	edx, [eax]
		xor	eax, eax
		cmp	edx, [ecx]
		setnz	al
		mov	[ebp+var_E8], eax

loc_22BF:				; CODE XREF: icu_56::sortiComparator(void const	*,void const *,void const *)+40j
		mov	ecx, [ebp+var_E8]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_20]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?sortiComparator@icu_56@@YAHPBX00@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 22D4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::sort(icu_56::UVector	*this, signed __int8 (__cdecl __high *)(union UElement,	union UElement), enum UErrorCode *)
		public ?sort@UVector@icu_56@@QAEXP6ACTUElement@@0@ZAAW4UErrorCode@@@Z
?sort@UVector@icu_56@@QAEXP6ACTUElement@@0@ZAAW4UErrorCode@@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2333
		mov	eax, [ebp+arg_4]
		push	eax
		push	0
		lea	ecx, [ebp+arg_0]
		push	ecx
		push	offset ?sortComparator@icu_56@@YAHPBX00@Z ; icu_56::sortComparator(void	const *,void const *,void const	*)
		push	4
		mov	edx, [ebp+var_8]
		mov	eax, [edx+4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+0Ch]
		push	edx
		call	_uprv_sortArray_56
		add	esp, 1Ch

loc_2333:				; CODE XREF: icu_56::UVector::sort(signed char (*)(UElement,UElement),UErrorCode &)+36j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	8
?sort@UVector@icu_56@@QAEXP6ACTUElement@@0@ZAAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 234Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl icu_56::sortComparator(void const	*, void	const *, void const *)
?sortComparator@icu_56@@YAHPBX00@Z proc	near
					; DATA XREF: icu_56::UVector::sort(signed char (*)(UElement,UElement),UErrorCode &)+42o

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		mov	[ebp+var_20], ecx
		mov	esi, esp
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_14]
		push	ecx
		call	[ebp+var_8]
		add	esp, 8
		cmp	esi, esp
		call	__RTC_CheckEsp
		movsx	edx, al
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_2C]
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN6
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?sortComparator@icu_56@@YAHPBX00@Z endp

; ---------------------------------------------------------------------------
		align 4
$LN6		dd 2			; DATA XREF: icu_56::sortComparator(void const *,void const *,void const *)+5Ao
		dd offset $LN5_3
$LN5_3		dd 0FFFFFFECh, 4	; DATA XREF: .text:000023CCo
		dd offset $LN3_3
		dd 0FFFFFFE0h, 4
		dd offset $LN4_3
$LN4_3		db 65h,	32h, 0		; DATA XREF: .text:000023E4o
$LN3_3		db 65h			; DATA XREF: .text:000023D8o
		db 31h,	0
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23F0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __thiscall icu_56::UVector::sortWithUComparator(icu_56::UVector *this, int (__cdecl *)(const void *, const void *, const	void *), const void *, enum UErrorCode *)
		public ?sortWithUComparator@UVector@icu_56@@QAEXP6AHPBX00@Z0AAW4UErrorCode@@@Z
?sortWithUComparator@UVector@icu_56@@QAEXP6AHPBX00@Z0AAW4UErrorCode@@@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_244E
		mov	eax, [ebp+arg_8]
		push	eax
		push	1
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		push	4
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+0Ch]
		push	eax
		call	_uprv_sortArray_56
		add	esp, 1Ch

loc_244E:				; CODE XREF: icu_56::UVector::sortWithUComparator(int (*)(void const *,void const *,void const *),void const *,UErrorCode &)+36j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	0Ch
?sortWithUComparator@UVector@icu_56@@QAEXP6AHPBX00@Z0AAW4UErrorCode@@@Z	endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o ...
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000138o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p ...
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
					; icu_56::UVector::`vector deleting destructor'(uint)+51p
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
					; icu_56::UVector::`vector deleting destructor'(uint)+3Dp
		extrn ___security_cookie:near
					; DATA XREF: icu_56::UVector::UVector(UErrorCode &)+2Er
					; icu_56::UVector::UVector(int,UErrorCode &)+2Er ...
		extrn ___CxxFrameHandler3:near
					; CODE XREF: __ehhandler$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z+19j
					; __ehhandler$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z+19j ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: __ehhandler$??0UVector@icu_56@@QAE@AAW4UErrorCode@@@Z+Fp
					; __ehhandler$??0UVector@icu_56@@QAE@HAAW4UErrorCode@@@Z+Fp ...
		extrn _uprv_malloc_56:near
					; CODE XREF: icu_56::UVector::_init(int,UErrorCode &)+57p
		extrn _uprv_free_56:near ; CODE	XREF: icu_56::UVector::~UVector(void)+61p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: icu_56::UVector::equals(icu_56::UVector const &)+EAp
					; icu_56::UVector::indexOf(void	*,int)+45p ...
		extrn _uprv_realloc_56:near
					; CODE XREF: icu_56::UVector::ensureCapacity(int,UErrorCode &)+9Ep
		extrn _uprv_sortArray_56:near
					; CODE XREF: icu_56::UVector::sorti(UErrorCode &)+55p
					; icu_56::UVector::sort(signed char (*)(UElement,UElement),UErrorCode &)+57p ...


		end
