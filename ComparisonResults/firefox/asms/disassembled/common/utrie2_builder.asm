;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	22182F02FE942AA4B6BAFE1D2E1861C4
; Input	CRC32 :	5836D6F7

; File Name   :	D:\compspace\objfiles\firefox\common\utrie2_builder.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	operator new(unsigned int)
		public ??2@YAPAXI@Z
??2@YAPAXI@Z	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2@YAPAXI@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 38h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 3Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 40h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl operator	delete(void *)
		public ??3@YAXPAX@Z
??3@YAXPAX@Z	proc near		; DATA XREF: .rdata$r:0000019Co
					; .rdata$r:000001B8o ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_8], 0
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax],	5
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3@YAXPAX@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 74h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void *__cdecl	icu_56::UMemory::operator new(unsigned int, void *)
		public ??2UMemory@icu_56@@SAPAXIPAX@Z
??2UMemory@icu_56@@SAPAXIPAX@Z proc near

var_C0		= byte ptr -0C0h
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??2UMemory@icu_56@@SAPAXIPAX@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 9Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl icu_56::UMemory::operator delete(void *)
		public ??3UMemory@icu_56@@SAXPAX0@Z
??3UMemory@icu_56@@SAXPAX0@Z proc near

var_C0		= byte ptr -0C0h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??3UMemory@icu_56@@SAXPAX0@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UMemory	& __thiscall icu_56::UMemory::operator=(class icu_56::UMemory const &)
		public ??4UMemory@icu_56@@QAEAAV01@ABV01@@Z
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UMemory@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *__hidden this)
		public ??0UObject@icu_56@@QAE@XZ
??0UObject@icu_56@@QAE@XZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
??0UObject@icu_56@@QAE@XZ endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12Ch
		dd offset ??_R4UObject@icu_56@@6B@ ; const icu_56::UObject::`RTTI Complete Object Locator'
;
; Exported entry
;
		public ??_7UObject@icu_56@@6B@
; const	icu_56::UObject::`vftable'
??_7UObject@icu_56@@6B@	dd offset ??_EUObject@icu_56@@UAEPAXI@Z
					; DATA XREF: icu_56::UObject::UObject(void)+26o
					; icu_56::UObject::UObject(icu_56::UObject const &)+44o
					; icu_56::UObject::`vector deleting destructor'(uint)
		dd offset ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ ;	icu_56::UObject::getDynamicClassID(void)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 138h
		public ??_R4UObject@icu_56@@6B@
; const	icu_56::UObject::`RTTI Complete	Object Locator'
??_R4UObject@icu_56@@6B@ dd 3 dup(0)	; DATA XREF: .rdata:0000012Co
		dd offset ??_R0?AVUObject@icu_56@@@8 ; icu_56::UObject `RTTI Type Descriptor'
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 14Ch
		public ??_R0?AVUObject@icu_56@@@8
; class	icu_56::UObject	`RTTI Type Descriptor'
??_R0?AVUObject@icu_56@@@8 dd offset ??_7type_info@@6B@	; DATA XREF: .rdata$r:00000144o
					; .rdata$r:icu_56::UObject::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		dd 0
a_?avuobject@ic	db '.?AVUObject@icu_56@@',0
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 16Ch
		public ??_R3UObject@icu_56@@8
; icu_56::UObject::`RTTI Class Hierarchy Descriptor'
??_R3UObject@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:00000148o
					; .rdata$r:000001A0o
		dd 2
		dd offset ??_R2UObject@icu_56@@8 ; icu_56::UObject::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 17Ch
		public ??_R2UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Array'
??_R2UObject@icu_56@@8 dd offset ??_R1A@?0A@EA@UObject@icu_56@@8
					; DATA XREF: .rdata$r:00000178o
					; icu_56::UObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
		dd offset ??_R13?0A@EA@UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Descriptor	at (4,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 188h
		public ??_R1A@?0A@EA@UObject@icu_56@@8
; icu_56::UObject::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UObject@icu_56@@8	dd offset ??_R0?AVUObject@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UObject::`RTTI Base Class	Array'o
					; icu_56::UObject `RTTI	Type Descriptor'
		dd 1, 0
		dd 0FFFFFFFFh, 0
		dd offset ??3@YAXPAX@Z	; operator delete(void *)
		dd offset ??_R3UObject@icu_56@@8 ; icu_56::UObject::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1A4h
		public ??_R13?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (4, -1, 0, 64)'
??_R13?0A@EA@UMemory@icu_56@@8 dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:00000180o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 0
		dd 4, 0FFFFFFFFh, 0
		dd offset ??3@YAXPAX@Z	; operator delete(void *)
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 1C0h
		public ??_R0?AVUMemory@icu_56@@@8
; class	icu_56::UMemory	`RTTI Type Descriptor'
??_R0?AVUMemory@icu_56@@@8 dd offset ??_7type_info@@6B@
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Descriptor at (4,-1,0,64)'o
					; .rdata$r:icu_56::UMemory::`RTTI Base Class Descriptor	at (0,-1,0,64)'o
					; const	type_info::`vftable'
		align 8
a_?avumemory@ic	db '.?AVUMemory@icu_56@@',0
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1E0h
		public ??_R3UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Class Hierarchy Descriptor'
??_R3UMemory@icu_56@@8 dd 2 dup(0)	; DATA XREF: .rdata$r:000001BCo
					; .rdata$r:00000210o
		dd 1
		dd offset ??_R2UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Base Class Array'
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1F0h
		public ??_R2UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Array'
??_R2UMemory@icu_56@@8 dd offset ??_R1A@?0A@EA@UMemory@icu_56@@8
					; DATA XREF: .rdata$r:000001ECo
					; icu_56::UMemory::`RTTI Base Class Descriptor at (0,-1,0,64)'
		db 0
		align 4
_rdata$r	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$r	segment	dword public 'DATA' use32
		assume cs:_rdata$r
		;org 1F8h
		public ??_R1A@?0A@EA@UMemory@icu_56@@8
; icu_56::UMemory::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
??_R1A@?0A@EA@UMemory@icu_56@@8	dd offset ??_R0?AVUMemory@icu_56@@@8
					; DATA XREF: .rdata$r:icu_56::UMemory::`RTTI Base Class	Array'o
					; icu_56::UMemory `RTTI	Type Descriptor'
		dd 2 dup(0)
		dd 0FFFFFFFFh, 0
		dd offset ??3@YAXPAX@Z	; operator delete(void *)
		dd offset ??_R3UMemory@icu_56@@8 ; icu_56::UMemory::`RTTI Class	Hierarchy Descriptor'
_rdata$r	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 214h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::UObject::UObject(icu_56::UObject *this, const struct icu_56::UObject *)
		public ??0UObject@icu_56@@QAE@ABV01@@Z
??0UObject@icu_56@@QAE@ABV01@@Z	proc near

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		cmp	[ebp+arg_0], 0
		jz	short loc_24B
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+var_D0], eax
		jmp	short loc_255
; ---------------------------------------------------------------------------

loc_24B:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+27j
		mov	[ebp+var_D0], 0

loc_255:				; CODE XREF: icu_56::UObject::UObject(icu_56::UObject const &)+35j
		mov	eax, [ebp+var_8]
		mov	dword ptr [eax], offset	??_7UObject@icu_56@@6B@	; const	icu_56::UObject::`vftable'
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??0UObject@icu_56@@QAE@ABV01@@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 26Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: class	icu_56::UObject	& __thiscall icu_56::UObject::operator=(class icu_56::UObject const &)
		public ??4UObject@icu_56@@QAEAAV01@ABV01@@Z
??4UObject@icu_56@@QAEAAV01@ABV01@@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn	4
??4UObject@icu_56@@QAEAAV01@ABV01@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`scalar deleting destructor'(unsigned int)
		public ??_GUObject@icu_56@@UAEPAXI@Z
??_GUObject@icu_56@@UAEPAXI@Z proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_2DB
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_2DB:				; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+31j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_GUObject@icu_56@@UAEPAXI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2F4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: virtual void * __thiscall icu_56::UObject::`vector deleting destructor'(unsigned int)
		public ??_EUObject@icu_56@@UAEPAXI@Z
??_EUObject@icu_56@@UAEPAXI@Z proc near	; DATA XREF: .rdata:const icu_56::UObject::`vftable'o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		and	eax, 2
		jz	short loc_355
		push	offset ??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+var_8]
		mov	ecx, [eax-4]
		push	ecx
		push	4
		mov	edx, [ebp+var_8]
		push	edx
		call	??_M@YGXPAXIHP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,int,void (*)(void *))
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_34D
		mov	eax, [ebp+var_8]
		sub	eax, 4
		push	eax		; void *
		call	??_VUMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator delete[](void *)
		add	esp, 4

loc_34D:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+48j
		mov	eax, [ebp+var_8]
		sub	eax, 4
		jmp	short loc_374
; ---------------------------------------------------------------------------

loc_355:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+29j
		mov	ecx, [ebp+var_8] ; this
		call	??1UObject@icu_56@@UAE@XZ ; icu_56::UObject::~UObject(void)
		mov	eax, [ebp+arg_0]
		and	eax, 1
		jz	short loc_371
		mov	eax, [ebp+var_8]
		push	eax		; void *
		call	??3UMemory@icu_56@@SAXPAX@Z ; icu_56::UMemory::operator	delete(void *)
		add	esp, 4

loc_371:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+6Fj
		mov	eax, [ebp+var_8]

loc_374:				; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+5Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??_EUObject@icu_56@@UAEPAXI@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 38Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; public: void __thiscall icu_56::Mutex::`default constructor closure'(void)
		public ??_FMutex@icu_56@@QAEXXZ
??_FMutex@icu_56@@QAEXXZ proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		push	0		; struct UMutex	*
		mov	ecx, [ebp+var_8] ; this
		call	??0Mutex@icu_56@@QAE@PAUUMutex@@@Z ; icu_56::Mutex::Mutex(UMutex *)
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??_FMutex@icu_56@@QAEXXZ endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 3D0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Mutex::Mutex(icu_56::Mutex *this, struct UMutex *)
		public ??0Mutex@icu_56@@QAE@PAUUMutex@@@Z
??0Mutex@icu_56@@QAE@PAUUMutex@@@Z proc	near
					; CODE XREF: icu_56::Mutex::`default constructor closure'(void)+28p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_umtx_lock_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn	4
??0Mutex@icu_56@@QAE@PAUUMutex@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 424h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _DWORD __thiscall icu_56::Mutex::~Mutex(icu_56::Mutex	*__hidden this)
		public ??1Mutex@icu_56@@QAE@XZ
??1Mutex@icu_56@@QAE@XZ	proc near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		push	ecx
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		pop	ecx
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_umtx_unlock_56
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
??1Mutex@icu_56@@QAE@XZ	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 46Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_open_56
_utrie2_open_56	proc near		; CODE XREF: _utrie2_cloneAsThawed_56+A3p
					; _utrie2_fromUTrie_56+5Fp

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
Dst		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_4A6
		xor	eax, eax
		jmp	loc_846
; ---------------------------------------------------------------------------

loc_4A6:				; CODE XREF: _utrie2_open_56+31j
		push	38h ; '8'
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		push	453BCh
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_14], eax
		push	10000h
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+var_20], eax
		cmp	[ebp+Dst], 0
		jz	short loc_4E5
		cmp	[ebp+var_14], 0
		jz	short loc_4E5
		cmp	[ebp+var_20], 0
		jnz	short loc_519

loc_4E5:				; CODE XREF: _utrie2_open_56+6Bj
					; _utrie2_open_56+71j
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_14]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_20]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		xor	eax, eax
		jmp	loc_846
; ---------------------------------------------------------------------------

loc_519:				; CODE XREF: _utrie2_open_56+77j
		push	38h ; '8'       ; Size
		push	0		; Val
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_0]
		mov	[eax+18h], ecx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+arg_4]
		mov	[eax+1Ch], ecx
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+20h], 110000h
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_14]
		mov	[eax+34h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_20]
		mov	[eax+23300h], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+23310h],	4000h
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	[eax+23304h], ecx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_4]
		mov	[eax+23308h], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+23324h],	110000h
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+23318h],	0
		mov	eax, [ebp+var_14]
		mov	byte ptr [eax+23328h], 0
		mov	[ebp+var_2C], 0
		jmp	short loc_5B5
; ---------------------------------------------------------------------------

loc_5AC:				; CODE XREF: _utrie2_open_56+164j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_5B5:				; CODE XREF: _utrie2_open_56+13Ej
		cmp	[ebp+var_2C], 80h ; '€'
		jge	short loc_5D2
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		jmp	short loc_5AC
; ---------------------------------------------------------------------------

loc_5D2:				; CODE XREF: _utrie2_open_56+150j
		jmp	short loc_5DD
; ---------------------------------------------------------------------------

loc_5D4:				; CODE XREF: _utrie2_open_56+18Cj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_5DD:				; CODE XREF: _utrie2_open_56:loc_5D2j
		cmp	[ebp+var_2C], 0C0h ; 'À'
		jge	short loc_5FA
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+arg_4]
		mov	[ecx+edx*4], eax
		jmp	short loc_5D4
; ---------------------------------------------------------------------------

loc_5FA:				; CODE XREF: _utrie2_open_56+178j
		mov	[ebp+var_2C], 0C0h ; 'À'
		jmp	short loc_60C
; ---------------------------------------------------------------------------

loc_603:				; CODE XREF: _utrie2_open_56+1BBj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_60C:				; CODE XREF: _utrie2_open_56+195j
		cmp	[ebp+var_2C], 100h
		jge	short loc_629
		mov	eax, [ebp+var_14]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+var_2C]
		mov	eax, [ebp+arg_0]
		mov	[ecx+edx*4], eax
		jmp	short loc_603
; ---------------------------------------------------------------------------

loc_629:				; CODE XREF: _utrie2_open_56+1A7j
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+23320h],	0C0h ; 'À'
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+23314h],	100h
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		jmp	short loc_665
; ---------------------------------------------------------------------------

loc_653:				; CODE XREF: _utrie2_open_56+223j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 20h ; ' '
		mov	[ebp+var_38], ecx

loc_665:				; CODE XREF: _utrie2_open_56+1E5j
		cmp	[ebp+var_38], 80h ; '€'
		jge	short loc_691
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_38]
		mov	[ecx+eax*4+880h], edx
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+2332Ch], 1
		jmp	short loc_653
; ---------------------------------------------------------------------------

loc_691:				; CODE XREF: _utrie2_open_56+200j
		jmp	short loc_6A5
; ---------------------------------------------------------------------------

loc_693:				; CODE XREF: _utrie2_open_56+253j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 20h ; ' '
		mov	[ebp+var_38], ecx

loc_6A5:				; CODE XREF: _utrie2_open_56:loc_691j
		cmp	[ebp+var_38], 0C0h ; 'À'
		jge	short loc_6C1
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+2332Ch], 0
		jmp	short loc_693
; ---------------------------------------------------------------------------

loc_6C1:				; CODE XREF: _utrie2_open_56+240j
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+2332Ch], 881Dh
		mov	edx, [ebp+var_2C]
		add	edx, 1
		mov	[ebp+var_2C], edx
		mov	eax, [ebp+var_38]
		add	eax, 20h ; ' '
		mov	[ebp+var_38], eax
		jmp	short loc_6F8
; ---------------------------------------------------------------------------

loc_6E6:				; CODE XREF: _utrie2_open_56+2A6j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 20h ; ' '
		mov	[ebp+var_38], ecx

loc_6F8:				; CODE XREF: _utrie2_open_56+278j
		cmp	[ebp+var_38], 100h
		jge	short loc_714
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+2332Ch], 0
		jmp	short loc_6E6
; ---------------------------------------------------------------------------

loc_714:				; CODE XREF: _utrie2_open_56+293j
		mov	[ebp+var_2C], 4
		jmp	short loc_726
; ---------------------------------------------------------------------------

loc_71D:				; CODE XREF: _utrie2_open_56+2D4j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_726:				; CODE XREF: _utrie2_open_56+2AFj
		cmp	[ebp+var_2C], 820h
		jge	short loc_742
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+880h], 0C0h ; 'À'
		jmp	short loc_71D
; ---------------------------------------------------------------------------

loc_742:				; CODE XREF: _utrie2_open_56+2C1j
		mov	[ebp+var_2C], 0
		jmp	short loc_754
; ---------------------------------------------------------------------------

loc_74B:				; CODE XREF: _utrie2_open_56+302j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_754:				; CODE XREF: _utrie2_open_56+2DDj
		cmp	[ebp+var_2C], 240h
		jge	short loc_770
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+2900h], 0FFFFFFFFh
		jmp	short loc_74B
; ---------------------------------------------------------------------------

loc_770:				; CODE XREF: _utrie2_open_56+2EFj
		mov	[ebp+var_2C], 0
		jmp	short loc_782
; ---------------------------------------------------------------------------

loc_779:				; CODE XREF: _utrie2_open_56+32Dj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_782:				; CODE XREF: _utrie2_open_56+30Bj
		cmp	[ebp+var_2C], 40h ; '@'
		jge	short loc_79B
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4+3200h], 0C0h ; 'À'
		jmp	short loc_779
; ---------------------------------------------------------------------------

loc_79B:				; CODE XREF: _utrie2_open_56+31Aj
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2331Ch],	0A60h
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax+2330Ch],	0AA0h
		mov	[ebp+var_2C], 0
		mov	[ebp+var_38], 0
		jmp	short loc_7D7
; ---------------------------------------------------------------------------

loc_7C5:				; CODE XREF: _utrie2_open_56+37Dj
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax
		mov	ecx, [ebp+var_38]
		add	ecx, 40h ; '@'
		mov	[ebp+var_38], ecx

loc_7D7:				; CODE XREF: _utrie2_open_56+357j
		cmp	[ebp+var_2C], 20h ; ' '
		jge	short loc_7EB
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_38]
		mov	[ecx+eax*4], edx
		jmp	short loc_7C5
; ---------------------------------------------------------------------------

loc_7EB:				; CODE XREF: _utrie2_open_56+36Fj
		jmp	short loc_7F6
; ---------------------------------------------------------------------------

loc_7ED:				; CODE XREF: _utrie2_open_56+3A0j
		mov	eax, [ebp+var_2C]
		add	eax, 1
		mov	[ebp+var_2C], eax

loc_7F6:				; CODE XREF: _utrie2_open_56:loc_7EBj
		cmp	[ebp+var_2C], 220h
		jge	short loc_80E
		mov	eax, [ebp+var_2C]
		mov	ecx, [ebp+var_14]
		mov	dword ptr [ecx+eax*4], 0A60h
		jmp	short loc_7ED
; ---------------------------------------------------------------------------

loc_80E:				; CODE XREF: _utrie2_open_56+391j
		mov	[ebp+var_2C], 80h ; '€'
		jmp	short loc_820
; ---------------------------------------------------------------------------

loc_817:				; CODE XREF: _utrie2_open_56+3D5j
		mov	eax, [ebp+var_2C]
		add	eax, 20h ; ' '
		mov	[ebp+var_2C], eax

loc_820:				; CODE XREF: _utrie2_open_56+3A9j
		cmp	[ebp+var_2C], 800h
		jge	short loc_843
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		mov	edx, [ebp+var_2C]
		push	edx
		mov	eax, [ebp+Dst]
		push	eax
		call	_utrie2_set32_56
		add	esp, 10h
		jmp	short loc_817
; ---------------------------------------------------------------------------

loc_843:				; CODE XREF: _utrie2_open_56+3BBj
		mov	eax, [ebp+Dst]

loc_846:				; CODE XREF: _utrie2_open_56+35j
					; _utrie2_open_56+A8j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_open_56	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 85Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_FAILURE(enum  UErrorCode)
?U_FAILURE@@YACW4UErrorCode@@@Z	proc near ; CODE XREF: _utrie2_open_56+24p
					; _utrie2_clone_56+24p	...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setnle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_FAILURE@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 888h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utrie2_clone_56(void *Src, int)
		public _utrie2_clone_56
_utrie2_clone_56 proc near		; CODE XREF: _utrie2_cloneAsThawed_56+84p

var_CC		= byte ptr -0CCh
Dst		= dword	ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_8C2
		xor	eax, eax
		jmp	loc_A2F
; ---------------------------------------------------------------------------

loc_8C2:				; CODE XREF: _utrie2_clone_56+31j
		cmp	[ebp+Src], 0
		jz	short loc_8DA
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_8EA
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+34h], 0
		jnz	short loc_8EA

loc_8DA:				; CODE XREF: _utrie2_clone_56+3Ej
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_A2F
; ---------------------------------------------------------------------------

loc_8EA:				; CODE XREF: _utrie2_clone_56+47j
					; _utrie2_clone_56+50j
		push	38h ; '8'
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_904
		xor	eax, eax
		jmp	loc_A2F
; ---------------------------------------------------------------------------

loc_904:				; CODE XREF: _utrie2_clone_56+73j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	38h ; '8'       ; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+28h], 0
		jz	loc_9F2
		mov	eax, [ebp+Src]
		mov	ecx, [eax+2Ch]
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+Dst]
		mov	[edx+28h], eax
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+28h], 0
		jz	loc_9F0
		mov	eax, [ebp+Dst]
		mov	byte ptr [eax+30h], 1
		push	1
		mov	eax, [ebp+Src]
		mov	ecx, [eax+28h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Src]
		mov	eax, [edx+2Ch]
		push	eax		; Size
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+28h]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+Src]
		mov	edx, [eax]
		sub	edx, [ecx+28h]
		sar	edx, 1
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		lea	edx, [ecx+edx*2]
		mov	eax, [ebp+Dst]
		mov	[eax], edx
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+4], 0
		jz	short loc_9C9
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+Src]
		mov	edx, [eax+4]
		sub	edx, [ecx+28h]
		sar	edx, 1
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		lea	edx, [ecx+edx*2]
		mov	eax, [ebp+Dst]
		mov	[eax+4], edx

loc_9C9:				; CODE XREF: _utrie2_clone_56+122j
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+8], 0
		jz	short loc_9F0
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+Src]
		mov	edx, [eax+8]
		sub	edx, [ecx+28h]
		sar	edx, 2
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+28h]
		lea	edx, [ecx+edx*4]
		mov	eax, [ebp+Dst]
		mov	[eax+8], edx

loc_9F0:				; CODE XREF: _utrie2_clone_56+C5j
					; _utrie2_clone_56+148j
		jmp	short loc_A07
; ---------------------------------------------------------------------------

loc_9F2:				; CODE XREF: _utrie2_clone_56+A3j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+34h]
		push	ecx		; Src
		call	?cloneBuilder@@YAPAUUNewTrie2@@PBU1@@Z ; cloneBuilder(UNewTrie2	const *)
		add	esp, 4
		mov	edx, [ebp+Dst]
		mov	[edx+34h], eax

loc_A07:				; CODE XREF: _utrie2_clone_56:loc_9F0j
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_A2C
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+34h], 0
		jnz	short loc_A2C
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	[ebp+Dst], 0

loc_A2C:				; CODE XREF: _utrie2_clone_56+186j
					; _utrie2_clone_56+18Fj
		mov	eax, [ebp+Dst]

loc_A2F:				; CODE XREF: _utrie2_clone_56+35j
					; _utrie2_clone_56+5Dj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_clone_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0A44h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl cloneBuilder(void	*Src)
?cloneBuilder@@YAPAUUNewTrie2@@PBU1@@Z proc near ; CODE	XREF: _utrie2_clone_56+171p

var_CC		= byte ptr -0CCh
Dst		= dword	ptr -8
Src		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	453BCh
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_A7F
		xor	eax, eax
		jmp	loc_C69
; ---------------------------------------------------------------------------

loc_A7F:				; CODE XREF: cloneBuilder(UNewTrie2 const *)+32j
		mov	eax, [ebp+Src]
		mov	ecx, [eax+23310h]
		shl	ecx, 2
		push	ecx
		call	_uprv_malloc_56
		add	esp, 4
		mov	edx, [ebp+Dst]
		mov	[edx+23300h], eax
		mov	eax, [ebp+Dst]
		cmp	dword ptr [eax+23300h],	0
		jnz	short loc_ABC
		mov	eax, [ebp+Dst]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		xor	eax, eax
		jmp	loc_C69
; ---------------------------------------------------------------------------

loc_ABC:				; CODE XREF: cloneBuilder(UNewTrie2 const *)+63j
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23310h]
		mov	[eax+23310h], edx
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	880h		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+Dst]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		push	1
		mov	eax, [ebp+Src]
		add	eax, 880h
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+2330Ch]
		shl	edx, 2
		push	edx		; Size
		mov	eax, [ebp+Src]
		add	eax, 880h
		push	eax		; Src
		mov	ecx, [ebp+Dst]
		add	ecx, 880h
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+2331Ch]
		mov	[eax+2331Ch], edx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+2330Ch]
		mov	[eax+2330Ch], edx
		push	1
		mov	eax, [ebp+Src]
		mov	ecx, [eax+23300h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+Src]
		mov	eax, [edx+23314h]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23300h]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		mov	ecx, [eax+23300h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23320h]
		mov	[eax+23320h], edx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23314h]
		mov	[eax+23314h], edx
		mov	eax, [ebp+Src]
		movsx	ecx, byte ptr [eax+23328h]
		test	ecx, ecx
		jz	short loc_BCE
		mov	eax, [ebp+Dst]
		mov	dword ptr [eax+23318h],	0
		jmp	short loc_C1E
; ---------------------------------------------------------------------------

loc_BCE:				; CODE XREF: cloneBuilder(UNewTrie2 const *)+179j
		push	1
		mov	eax, [ebp+Src]
		add	eax, 2332Ch
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23314h]
		sar	edx, 5
		shl	edx, 2
		push	edx		; Size
		mov	eax, [ebp+Src]
		add	eax, 2332Ch
		push	eax		; Src
		mov	ecx, [ebp+Dst]
		add	ecx, 2332Ch
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23318h]
		mov	[eax+23318h], edx

loc_C1E:				; CODE XREF: cloneBuilder(UNewTrie2 const *)+188j
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23304h]
		mov	[eax+23304h], edx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23308h]
		mov	[eax+23308h], edx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+23324h]
		mov	[eax+23324h], edx
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+Src]
		mov	dl, [ecx+23328h]
		mov	[eax+23328h], dl
		mov	eax, [ebp+Dst]

loc_C69:				; CODE XREF: cloneBuilder(UNewTrie2 const *)+36j
					; cloneBuilder(UNewTrie2 const *)+73j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?cloneBuilder@@YAPAUUNewTrie2@@PBU1@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C80h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl utrie2_cloneAsThawed_56(void *Src, int)
		public _utrie2_cloneAsThawed_56
_utrie2_cloneAsThawed_56 proc near

var_EC		= byte ptr -0ECh
var_28		= dword	ptr -28h
var_1C		= word ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= byte ptr -8
Src		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0ECh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_EC]
		mov	ecx, 3Bh ; ';'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_CBA
		xor	eax, eax
		jmp	loc_E46
; ---------------------------------------------------------------------------

loc_CBA:				; CODE XREF: _utrie2_cloneAsThawed_56+31j
		cmp	[ebp+Src], 0
		jz	short loc_CD2
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_CE2
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+34h], 0
		jnz	short loc_CE2

loc_CD2:				; CODE XREF: _utrie2_cloneAsThawed_56+3Ej
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_E46
; ---------------------------------------------------------------------------

loc_CE2:				; CODE XREF: _utrie2_cloneAsThawed_56+47j
					; _utrie2_cloneAsThawed_56+50j
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+34h], 0
		jz	short loc_D11
		mov	eax, [ebp+Src]
		mov	ecx, [eax+34h]
		movsx	edx, byte ptr [ecx+23328h]
		test	edx, edx
		jnz	short loc_D11
		mov	eax, [ebp+arg_4]
		push	eax		; int
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		call	_utrie2_clone_56
		add	esp, 8
		jmp	loc_E46
; ---------------------------------------------------------------------------

loc_D11:				; CODE XREF: _utrie2_cloneAsThawed_56+69j
					; _utrie2_cloneAsThawed_56+7Aj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+Src]
		mov	edx, [ecx+1Ch]
		push	edx
		mov	eax, [ebp+Src]
		mov	ecx, [eax+18h]
		push	ecx
		call	_utrie2_open_56
		add	esp, 0Ch
		mov	[ebp+var_10], eax
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_D4A
		xor	eax, eax
		jmp	loc_E46
; ---------------------------------------------------------------------------

loc_D4A:				; CODE XREF: _utrie2_cloneAsThawed_56+C1j
		mov	[ebp+var_8], 0
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+var_10]
		push	eax
		push	offset ?copyEnumRange@@YACPBXHHI@Z ; copyEnumRange(void	const *,int,int,uint)
		push	0
		mov	ecx, [ebp+Src]
		push	ecx
		call	_utrie2_enum_56
		add	esp, 10h
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+var_C]
		mov	[eax], ecx
		mov	eax, 0D800h
		mov	[ebp+var_1C], ax
		jmp	short loc_D8C
; ---------------------------------------------------------------------------

loc_D80:				; CODE XREF: _utrie2_cloneAsThawed_56:loc_E16j
		mov	ax, [ebp+var_1C]
		add	ax, 1
		mov	[ebp+var_1C], ax

loc_D8C:				; CODE XREF: _utrie2_cloneAsThawed_56+FEj
		movzx	eax, [ebp+var_1C]
		cmp	eax, 0DC00h
		jge	loc_E1B
		mov	eax, [ebp+Src]
		cmp	dword ptr [eax+8], 0
		jnz	short loc_DCC
		movzx	eax, [ebp+var_1C]
		sar	eax, 5
		mov	ecx, [ebp+Src]
		mov	edx, [ecx]
		movzx	eax, word ptr [edx+eax*2]
		movzx	ecx, [ebp+var_1C]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	eax, [ebp+Src]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+edx*2]
		mov	[ebp+var_28], edx
		jmp	short loc_DF2
; ---------------------------------------------------------------------------

loc_DCC:				; CODE XREF: _utrie2_cloneAsThawed_56+122j
		movzx	eax, [ebp+var_1C]
		sar	eax, 5
		mov	ecx, [ebp+Src]
		mov	edx, [ecx]
		movzx	eax, word ptr [edx+eax*2]
		movzx	ecx, [ebp+var_1C]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	eax, [ebp+Src]
		mov	ecx, [eax+8]
		mov	edx, [ecx+edx*4]
		mov	[ebp+var_28], edx

loc_DF2:				; CODE XREF: _utrie2_cloneAsThawed_56+14Aj
		mov	eax, [ebp+Src]
		mov	ecx, [ebp+var_28]
		cmp	ecx, [eax+18h]
		jz	short loc_E16
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_28]
		push	ecx
		movzx	edx, [ebp+var_1C]
		push	edx
		mov	eax, [ebp+var_10]
		push	eax
		call	_utrie2_set32ForLeadSurrogateCodeUnit_56
		add	esp, 10h

loc_E16:				; CODE XREF: _utrie2_cloneAsThawed_56+17Bj
		jmp	loc_D80
; ---------------------------------------------------------------------------

loc_E1B:				; CODE XREF: _utrie2_cloneAsThawed_56+115j
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_E43
		mov	eax, [ebp+var_10]
		push	eax
		call	_utrie2_close_56
		add	esp, 4
		mov	[ebp+var_10], 0

loc_E43:				; CODE XREF: _utrie2_cloneAsThawed_56+1AEj
		mov	eax, [ebp+var_10]

loc_E46:				; CODE XREF: _utrie2_cloneAsThawed_56+35j
					; _utrie2_cloneAsThawed_56+5Dj	...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN17
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0ECh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_cloneAsThawed_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN17		dd 1			; DATA XREF: _utrie2_cloneAsThawed_56+1CAo
		dd offset $LN16
$LN16		dd 0FFFFFFF0h, 0Ch	; DATA XREF: .text:00000E70o
		dd offset $LN15		; "context"
$LN15		db 'context',0          ; DATA XREF: .text:00000E7Co
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0E88h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl copyEnumRange(void const *, int, int, unsigned int)
?copyEnumRange@@YACPBXHHI@Z proc near	; DATA XREF: _utrie2_cloneAsThawed_56+DAo
					; _utrie2_fromUTrie_56+96o

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		mov	edx, [ebp+arg_C]
		cmp	edx, [ecx+18h]
		jz	short loc_F2A
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+8]
		test	ecx, ecx
		jz	short loc_ECD
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax

loc_ECD:				; CODE XREF: copyEnumRange(void	const *,int,int,uint)+3Aj
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jnz	short loc_EF4
		mov	eax, [ebp+var_8]
		add	eax, 4
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax]
		push	ecx
		call	_utrie2_set32_56
		add	esp, 10h
		jmp	short loc_F17
; ---------------------------------------------------------------------------

loc_EF4:				; CODE XREF: copyEnumRange(void	const *,int,int,uint)+4Bj
		mov	eax, [ebp+var_8]
		add	eax, 4
		push	eax
		push	1
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx]
		push	edx
		call	_utrie2_setRange32_56
		add	esp, 18h

loc_F17:				; CODE XREF: copyEnumRange(void	const *,int,int,uint)+6Aj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+4]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		jmp	short loc_F2C
; ---------------------------------------------------------------------------
		jmp	short loc_F2C
; ---------------------------------------------------------------------------

loc_F2A:				; CODE XREF: copyEnumRange(void	const *,int,int,uint)+2Fj
		mov	al, 1

loc_F2C:				; CODE XREF: copyEnumRange(void	const *,int,int,uint)+9Ej
					; copyEnumRange(void const *,int,int,uint)+A0j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?copyEnumRange@@YACPBXHHI@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F40h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl U_SUCCESS(enum  UErrorCode)
?U_SUCCESS@@YACW4UErrorCode@@@Z	proc near
					; CODE XREF: copyEnumRange(void	const *,int,int,uint)+96p
					; _utrie2_fromUTrie_56+15Dp ...

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		setle	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?U_SUCCESS@@YACW4UErrorCode@@@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F6Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_fromUTrie_56
_utrie2_fromUTrie_56 proc near

var_EC		= byte ptr -0ECh
var_28		= dword	ptr -28h
var_1C		= word ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= byte ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0ECh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_EC]
		mov	ecx, 3Bh ; ';'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_FA6
		xor	eax, eax
		jmp	loc_1120
; ---------------------------------------------------------------------------

loc_FA6:				; CODE XREF: _utrie2_fromUTrie_56+31j
		cmp	[ebp+arg_0], 0
		jnz	short loc_FBC
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_1120
; ---------------------------------------------------------------------------

loc_FBC:				; CODE XREF: _utrie2_fromUTrie_56+3Ej
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		push	eax
		call	_utrie2_open_56
		add	esp, 0Ch
		mov	[ebp+var_10], eax
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_FF2
		xor	eax, eax
		jmp	loc_1120
; ---------------------------------------------------------------------------

loc_FF2:				; CODE XREF: _utrie2_fromUTrie_56+7Dj
		mov	[ebp+var_8], 1
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		mov	[ebp+var_C], ecx
		lea	eax, [ebp+var_10]
		push	eax
		push	offset ?copyEnumRange@@YACPBXHHI@Z ; copyEnumRange(void	const *,int,int,uint)
		push	0
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utrie_enum_56
		add	esp, 10h
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+var_C]
		mov	[eax], ecx
		mov	eax, 0D800h
		mov	[ebp+var_1C], ax
		jmp	short loc_1034
; ---------------------------------------------------------------------------

loc_1028:				; CODE XREF: _utrie2_fromUTrie_56:loc_10BEj
		mov	ax, [ebp+var_1C]
		add	ax, 1
		mov	[ebp+var_1C], ax

loc_1034:				; CODE XREF: _utrie2_fromUTrie_56+BAj
		movzx	eax, [ebp+var_1C]
		cmp	eax, 0DC00h
		jge	loc_10C3
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+4], 0
		jnz	short loc_1074
		movzx	eax, [ebp+var_1C]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		movzx	eax, word ptr [edx+eax*2]
		movzx	ecx, [ebp+var_1C]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		movzx	edx, word ptr [ecx+edx*2]
		mov	[ebp+var_28], edx
		jmp	short loc_109A
; ---------------------------------------------------------------------------

loc_1074:				; CODE XREF: _utrie2_fromUTrie_56+DEj
		movzx	eax, [ebp+var_1C]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx]
		movzx	eax, word ptr [edx+eax*2]
		movzx	ecx, [ebp+var_1C]
		and	ecx, 1Fh
		lea	edx, [ecx+eax*4]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+edx*4]
		mov	[ebp+var_28], edx

loc_109A:				; CODE XREF: _utrie2_fromUTrie_56+106j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_28]
		cmp	ecx, [eax+14h]
		jz	short loc_10BE
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+var_28]
		push	ecx
		movzx	edx, [ebp+var_1C]
		push	edx
		mov	eax, [ebp+var_10]
		push	eax
		call	_utrie2_set32ForLeadSurrogateCodeUnit_56
		add	esp, 10h

loc_10BE:				; CODE XREF: _utrie2_fromUTrie_56+137j
		jmp	loc_1028
; ---------------------------------------------------------------------------

loc_10C3:				; CODE XREF: _utrie2_fromUTrie_56+D1j
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_10F5
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		xor	edx, edx
		cmp	dword ptr [ecx+4], 0
		setnz	dl
		push	edx
		mov	eax, [ebp+var_10]
		push	eax
		call	_utrie2_freeze_56
		add	esp, 0Ch

loc_10F5:				; CODE XREF: _utrie2_fromUTrie_56+16Aj
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_111D
		mov	eax, [ebp+var_10]
		push	eax
		call	_utrie2_close_56
		add	esp, 4
		mov	[ebp+var_10], 0

loc_111D:				; CODE XREF: _utrie2_fromUTrie_56+19Cj
		mov	eax, [ebp+var_10]

loc_1120:				; CODE XREF: _utrie2_fromUTrie_56+35j
					; _utrie2_fromUTrie_56+4Bj ...
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN16_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0ECh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_fromUTrie_56 endp

; ---------------------------------------------------------------------------
		align 4
$LN16_0		dd 1			; DATA XREF: _utrie2_fromUTrie_56+1B8o
		dd offset $LN15_0
$LN15_0		dd 0FFFFFFF0h, 0Ch	; DATA XREF: .text:0000114Co
		dd offset $LN14		; "context"
$LN14		db 'context',0          ; DATA XREF: .text:00001158o
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1164h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_set32_56
_utrie2_set32_56 proc near		; CODE XREF: _utrie2_open_56+3CDp
					; copyEnumRange(void const *,int,int,uint)+62p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1199
		jmp	short loc_11CA
; ---------------------------------------------------------------------------

loc_1199:				; CODE XREF: _utrie2_set32_56+31j
		cmp	[ebp+arg_4], 10FFFFh
		jbe	short loc_11AD
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	short loc_11CA
; ---------------------------------------------------------------------------

loc_11AD:				; CODE XREF: _utrie2_set32_56+3Cj
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	1
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		push	ecx
		call	?set32@@YAXPAUUNewTrie2@@HCIPAW4UErrorCode@@@Z ; set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)
		add	esp, 14h

loc_11CA:				; CODE XREF: _utrie2_set32_56+33j
					; _utrie2_set32_56+47j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_set32_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 11E0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl set32(struct UNewTrie2 *, int, signed char, unsigned int, enum  UErrorCode *)
?set32@@YAXPAUUNewTrie2@@HCIPAW4UErrorCode@@@Z proc near ; CODE	XREF: _utrie2_set32_56+5Ep
					; _utrie2_set32ForLeadSurrogateCodeUnit_56+64p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_0], 0
		jz	short loc_1212
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+23328h]
		test	ecx, ecx
		jz	short loc_121D

loc_1212:				; CODE XREF: set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)+22j
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1Eh
		jmp	short loc_125E
; ---------------------------------------------------------------------------

loc_121D:				; CODE XREF: set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)+30j
		movzx	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?getDataBlock@@YAHPAUUNewTrie2@@HC@Z ; getDataBlock(UNewTrie2 *,int,signed char)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jge	short loc_1246
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 7
		jmp	short loc_125E
; ---------------------------------------------------------------------------

loc_1246:				; CODE XREF: set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)+59j
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		add	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+23300h]
		mov	ecx, [ebp+arg_C]
		mov	[edx+eax*4], ecx

loc_125E:				; CODE XREF: set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)+3Bj
					; set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)+64j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?set32@@YAXPAUUNewTrie2@@HCIPAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1274h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getDataBlock(struct UNewTrie2 *, int, signed char)
?getDataBlock@@YAHPAUUNewTrie2@@HC@Z proc near
					; CODE XREF: set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)+4Ap
					; _utrie2_setRange32_56+C5p ...

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?getIndex2Block@@YAHPAUUNewTrie2@@HC@Z ; getIndex2Block(UNewTrie2 *,int,signed char)
		add	esp, 0Ch
		mov	[ebp+var_8], eax
		cmp	[ebp+var_8], 0
		jge	short loc_12B5
		or	eax, 0FFFFFFFFh
		jmp	short loc_1325
; ---------------------------------------------------------------------------

loc_12B5:				; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+3Aj
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	eax, [ebp+var_8]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+880h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?isWritableBlock@@YACPAUUNewTrie2@@H@Z ; isWritableBlock(UNewTrie2 *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_12F0
		mov	eax, [ebp+var_14]
		jmp	short loc_1325
; ---------------------------------------------------------------------------

loc_12F0:				; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+75j
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?allocDataBlock@@YAHPAUUNewTrie2@@H@Z ;	allocDataBlock(UNewTrie2 *,int)
		add	esp, 8
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jge	short loc_130E
		or	eax, 0FFFFFFFFh
		jmp	short loc_1325
; ---------------------------------------------------------------------------

loc_130E:				; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+93j
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+arg_0]
		push	edx
		call	?setIndex2Entry@@YAXPAUUNewTrie2@@HH@Z ; setIndex2Entry(UNewTrie2 *,int,int)
		add	esp, 0Ch
		mov	eax, [ebp+var_20]

loc_1325:				; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+3Fj
					; getDataBlock(UNewTrie2 *,int,signed char)+7Aj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getDataBlock@@YAHPAUUNewTrie2@@HC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 133Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl getIndex2Block(struct UNewTrie2 *, int, signed char)
?getIndex2Block@@YAHPAUUNewTrie2@@HC@Z proc near
					; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+2Bp
					; _utrie2_setRange32_56+1F3p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_1378
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1378
		mov	eax, 800h
		jmp	short loc_13C4
; ---------------------------------------------------------------------------

loc_1378:				; CODE XREF: getIndex2Block(UNewTrie2 *,int,signed char)+2Bj
					; getIndex2Block(UNewTrie2 *,int,signed	char)+33j
		mov	eax, [ebp+arg_4]
		sar	eax, 0Bh
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+2331Ch]
		jnz	short loc_13C1
		mov	eax, [ebp+arg_0]
		push	eax
		call	?allocIndex2Block@@YAHPAUUNewTrie2@@@Z ; allocIndex2Block(UNewTrie2 *)
		add	esp, 4
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_13B5
		or	eax, 0FFFFFFFFh
		jmp	short loc_13C4
; ---------------------------------------------------------------------------

loc_13B5:				; CODE XREF: getIndex2Block(UNewTrie2 *,int,signed char)+72j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		mov	[ecx+eax*4], edx

loc_13C1:				; CODE XREF: getIndex2Block(UNewTrie2 *,int,signed char)+5Dj
		mov	eax, [ebp+var_14]

loc_13C4:				; CODE XREF: getIndex2Block(UNewTrie2 *,int,signed char)+3Aj
					; getIndex2Block(UNewTrie2 *,int,signed	char)+77j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?getIndex2Block@@YAHPAUUNewTrie2@@HC@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 13D8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl allocIndex2Block(struct UNewTrie2	*)
?allocIndex2Block@@YAHPAUUNewTrie2@@@Z proc near
					; CODE XREF: getIndex2Block(UNewTrie2 *,int,signed char)+63p

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2330Ch]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 40h ; '@'
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 8AA0h
		jle	short loc_1419
		or	eax, 0FFFFFFFFh
		jmp	short loc_1475
; ---------------------------------------------------------------------------

loc_1419:				; CODE XREF: allocIndex2Block(UNewTrie2	*)+3Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+2330Ch], ecx
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2331Ch]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*4+880h]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	100h		; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+2331Ch]
		mov	eax, [ebp+arg_0]
		lea	ecx, [eax+edx*4+880h]
		push	ecx		; Src
		mov	edx, [ebp+var_8]
		mov	eax, [ebp+arg_0]
		lea	ecx, [eax+edx*4+880h]
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]

loc_1475:				; CODE XREF: allocIndex2Block(UNewTrie2	*)+3Fj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?allocIndex2Block@@YAHPAUUNewTrie2@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 148Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl allocDataBlock(struct UNewTrie2 *, int)
?allocDataBlock@@YAHPAUUNewTrie2@@H@Z proc near
					; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+84p

var_F0		= byte ptr -0F0h
Dst		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+23318h],	0
		jz	short loc_14E2
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23318h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+2332Ch]
		neg	edx
		mov	eax, [ebp+arg_0]
		mov	[eax+23318h], edx
		jmp	loc_15CE
; ---------------------------------------------------------------------------

loc_14E2:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+28j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23314h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+var_8]
		add	eax, 20h ; ' '
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+23310h]
		jle	loc_15C2
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+23310h],	20000h
		jge	short loc_1521
		mov	[ebp+var_20], 20000h
		jmp	short loc_1541
; ---------------------------------------------------------------------------

loc_1521:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+8Aj
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+23310h],	110480h
		jge	short loc_1539
		mov	[ebp+var_20], 110480h
		jmp	short loc_1541
; ---------------------------------------------------------------------------

loc_1539:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+A2j
		or	eax, 0FFFFFFFFh
		jmp	loc_162C
; ---------------------------------------------------------------------------

loc_1541:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+93j
					; allocDataBlock(UNewTrie2 *,int)+ABj
		mov	eax, [ebp+var_20]
		shl	eax, 2
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	[ebp+Dst], eax
		cmp	[ebp+Dst], 0
		jnz	short loc_1561
		or	eax, 0FFFFFFFFh
		jmp	loc_162C
; ---------------------------------------------------------------------------

loc_1561:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+CBj
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+23314h]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+23300h]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax+23300h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+23310h], ecx

loc_15C2:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+77j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+23314h], ecx

loc_15CE:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+51j
		push	1
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+arg_4]
		lea	eax, [ecx+edx*4]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	80h ; '€'       ; Size
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+23300h]
		mov	eax, [ebp+arg_4]
		lea	ecx, [edx+eax*4]
		push	ecx		; Src
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+23300h]
		mov	ecx, [ebp+var_8]
		lea	edx, [eax+ecx*4]
		push	edx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	dword ptr [ecx+eax*4+2332Ch], 0
		mov	eax, [ebp+var_8]

loc_162C:				; CODE XREF: allocDataBlock(UNewTrie2 *,int)+B0j
					; allocDataBlock(UNewTrie2 *,int)+D0j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?allocDataBlock@@YAHPAUUNewTrie2@@H@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1640h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isWritableBlock(struct UNewTrie2 *, int)
?isWritableBlock@@YACPAUUNewTrie2@@H@Z proc near
					; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+68p
					; _utrie2_setRange32_56+239p

var_C4		= byte ptr -0C4h
var_C1		= byte ptr -0C1h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		cmp	ecx, [eax+23320h]
		jz	short loc_1688
		mov	edx, [ebp+arg_4]
		sar	edx, 5
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+edx*4+2332Ch], 1
		jnz	short loc_1688
		mov	[ebp+var_C1], 1
		jmp	short loc_168F
; ---------------------------------------------------------------------------

loc_1688:				; CODE XREF: isWritableBlock(UNewTrie2 *,int)+2Aj
					; isWritableBlock(UNewTrie2 *,int)+3Dj
		mov	[ebp+var_C1], 0

loc_168F:				; CODE XREF: isWritableBlock(UNewTrie2 *,int)+46j
		mov	al, [ebp+var_C1]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isWritableBlock@@YACPAUUNewTrie2@@H@Z endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 169Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl setIndex2Entry(struct UNewTrie2 *, int, int)
?setIndex2Entry@@YAXPAUUNewTrie2@@HH@Z proc near
					; CODE XREF: getDataBlock(UNewTrie2 *,int,signed char)+A6p
					; _utrie2_setRange32_56+2D8p

var_D0		= dword	ptr -0D0h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D0]
		mov	ecx, 34h ; '4'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+2332Ch]
		add	edx, 1
		mov	eax, [ebp+arg_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	[ecx+eax*4+2332Ch], edx
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+880h]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+2332Ch]
		sub	edx, 1
		mov	[ebp+var_D0], edx
		mov	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_D0]
		mov	[ecx+eax*4+2332Ch], edx
		cmp	[ebp+var_D0], 0
		jnz	short loc_1735
		mov	eax, [ebp+var_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?releaseDataBlock@@YAXPAUUNewTrie2@@H@Z	; releaseDataBlock(UNewTrie2 *,int)
		add	esp, 8

loc_1735:				; CODE XREF: setIndex2Entry(UNewTrie2 *,int,int)+87j
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_8]
		mov	[ecx+eax*4+880h], edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?setIndex2Entry@@YAXPAUUNewTrie2@@HH@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 175Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl releaseDataBlock(struct UNewTrie2 *, int)
?releaseDataBlock@@YAXPAUUNewTrie2@@H@Z	proc near
					; CODE XREF: setIndex2Entry(UNewTrie2 *,int,int)+91p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23318h]
		neg	ecx
		mov	edx, [ebp+arg_4]
		sar	edx, 5
		mov	eax, [ebp+arg_0]
		mov	[eax+edx*4+2332Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax+23318h], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?releaseDataBlock@@YAXPAUUNewTrie2@@H@Z	endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17A8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_set32ForLeadSurrogateCodeUnit_56
_utrie2_set32ForLeadSurrogateCodeUnit_56 proc near
					; CODE XREF: _utrie2_cloneAsThawed_56+18Ep
					; _utrie2_fromUTrie_56+14Ap

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_C]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_17DD
		jmp	short loc_1814
; ---------------------------------------------------------------------------

loc_17DD:				; CODE XREF: _utrie2_set32ForLeadSurrogateCodeUnit_56+31j
		mov	eax, [ebp+arg_4]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jz	short loc_17F7
		mov	eax, [ebp+arg_C]
		mov	dword ptr [eax], 1
		jmp	short loc_1814
; ---------------------------------------------------------------------------

loc_17F7:				; CODE XREF: _utrie2_set32ForLeadSurrogateCodeUnit_56+42j
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	0
		mov	edx, [ebp+arg_4]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		push	ecx
		call	?set32@@YAXPAUUNewTrie2@@HCIPAW4UErrorCode@@@Z ; set32(UNewTrie2 *,int,signed char,uint,UErrorCode *)
		add	esp, 14h

loc_1814:				; CODE XREF: _utrie2_set32ForLeadSurrogateCodeUnit_56+33j
					; _utrie2_set32ForLeadSurrogateCodeUnit_56+4Dj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_set32ForLeadSurrogateCodeUnit_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1828h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_setRange32_56
_utrie2_setRange32_56 proc near		; CODE XREF: copyEnumRange(void	const *,int,int,uint)+87p
					; compactTrie(UTrie2 *,UErrorCode *)+CFp

var_120		= byte ptr -120h
var_59		= byte ptr -59h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= byte ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_14]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1860
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_1860:				; CODE XREF: _utrie2_setRange32_56+31j
		cmp	[ebp+arg_4], 10FFFFh
		ja	short loc_187A
		cmp	[ebp+arg_8], 10FFFFh
		ja	short loc_187A
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+arg_8]
		jle	short loc_1888

loc_187A:				; CODE XREF: _utrie2_setRange32_56+3Fj
					; _utrie2_setRange32_56+48j
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_1888:				; CODE XREF: _utrie2_setRange32_56+50j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jz	short loc_18A5
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+23328h]
		test	ecx, ecx
		jz	short loc_18B3

loc_18A5:				; CODE XREF: _utrie2_setRange32_56+6Dj
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 1Eh
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_18B3:				; CODE XREF: _utrie2_setRange32_56+7Bj
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_18CE
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		cmp	ecx, [eax+23304h]
		jnz	short loc_18CE
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_18CE:				; CODE XREF: _utrie2_setRange32_56+91j
					; _utrie2_setRange32_56+9Fj
		mov	eax, [ebp+arg_8]
		add	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_4]
		and	eax, 1Fh
		jz	loc_199A
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?getDataBlock@@YAHPAUUNewTrie2@@HC@Z ; getDataBlock(UNewTrie2 *,int,signed char)
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_190C
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_190C:				; CODE XREF: _utrie2_setRange32_56+D4j
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		and	eax, 0FFFFFFE0h
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		cmp	eax, [ebp+var_38]
		jg	short loc_195C
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23304h]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		push	20h ; ' '
		mov	ecx, [ebp+arg_4]
		and	ecx, 1Fh
		push	ecx
		mov	edx, [ebp+var_8]
		mov	eax, [edx+23300h]
		mov	ecx, [ebp+var_14]
		lea	edx, [eax+ecx*4]
		push	edx
		call	?fillBlock@@YAXPAIHHIIC@Z ; fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h
		mov	eax, [ebp+var_44]
		mov	[ebp+arg_4], eax
		jmp	short loc_199A
; ---------------------------------------------------------------------------

loc_195C:				; CODE XREF: _utrie2_setRange32_56+F6j
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23304h]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_38]
		and	ecx, 1Fh
		push	ecx
		mov	edx, [ebp+arg_4]
		and	edx, 1Fh
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+var_14]
		lea	eax, [ecx+edx*4]
		push	eax
		call	?fillBlock@@YAXPAIHHIIC@Z ; fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_199A:				; CODE XREF: _utrie2_setRange32_56+B5j
					; _utrie2_setRange32_56+132j
		mov	eax, [ebp+var_38]
		and	eax, 1Fh
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFFE0h
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		cmp	ecx, [eax+23304h]
		jnz	short loc_19C8
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23320h]
		mov	[ebp+var_2C], ecx
		jmp	short loc_19CF
; ---------------------------------------------------------------------------

loc_19C8:				; CODE XREF: _utrie2_setRange32_56+190j
		mov	[ebp+var_2C], 0FFFFFFFFh

loc_19CF:				; CODE XREF: _utrie2_setRange32_56+19Ej
					; _utrie2_setRange32_56+1E7j ...
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_38]
		jge	loc_1B5D
		mov	[ebp+var_59], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_C]
		cmp	ecx, [eax+23304h]
		jnz	short loc_1A11
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?isInNullBlock@@YACPAUUNewTrie2@@HC@Z ;	isInNullBlock(UNewTrie2	*,int,signed char)
		add	esp, 0Ch
		movsx	edx, al
		test	edx, edx
		jz	short loc_1A11
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	[ebp+arg_4], eax
		jmp	short loc_19CF
; ---------------------------------------------------------------------------

loc_1A11:				; CODE XREF: _utrie2_setRange32_56+1C3j
					; _utrie2_setRange32_56+1DCj
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?getIndex2Block@@YAHPAUUNewTrie2@@HC@Z ; getIndex2Block(UNewTrie2 *,int,signed char)
		add	esp, 0Ch
		mov	[ebp+var_50], eax
		cmp	[ebp+var_50], 0
		jge	short loc_1A3A
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 5
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_1A3A:				; CODE XREF: _utrie2_setRange32_56+202j
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		and	eax, 3Fh
		add	eax, [ebp+var_50]
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+eax*4+880h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?isWritableBlock@@YACPAUUNewTrie2@@H@Z ; isWritableBlock(UNewTrie2 *,int)
		add	esp, 8
		movsx	edx, al
		test	edx, edx
		jz	short loc_1AB8
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jz	short loc_1A87
		cmp	[ebp+var_14], 880h
		jl	short loc_1A87
		mov	[ebp+var_59], 1
		jmp	short loc_1AB6
; ---------------------------------------------------------------------------

loc_1A87:				; CODE XREF: _utrie2_setRange32_56+24Ej
					; _utrie2_setRange32_56+257j
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23304h]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		push	20h ; ' '
		push	0
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23300h]
		mov	eax, [ebp+var_14]
		lea	ecx, [edx+eax*4]
		push	ecx
		call	?fillBlock@@YAXPAIHHIIC@Z ; fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h

loc_1AB6:				; CODE XREF: _utrie2_setRange32_56+25Dj
		jmp	short loc_1AE6
; ---------------------------------------------------------------------------

loc_1AB8:				; CODE XREF: _utrie2_setRange32_56+246j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+var_14]
		mov	eax, [ecx+edx*4]
		cmp	eax, [ebp+arg_C]
		jz	short loc_1AE6
		movsx	eax, [ebp+arg_10]
		test	eax, eax
		jnz	short loc_1AE2
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+23320h]
		jnz	short loc_1AE6

loc_1AE2:				; CODE XREF: _utrie2_setRange32_56+2AAj
		mov	[ebp+var_59], 1

loc_1AE6:				; CODE XREF: _utrie2_setRange32_56:loc_1AB6j
					; _utrie2_setRange32_56+2A2j ...
		movsx	eax, [ebp+var_59]
		test	eax, eax
		jz	short loc_1B4F
		cmp	[ebp+var_2C], 0
		jl	short loc_1B0A
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_50]
		push	ecx
		mov	edx, [ebp+var_8]
		push	edx
		call	?setIndex2Entry@@YAXPAUUNewTrie2@@HH@Z ; setIndex2Entry(UNewTrie2 *,int,int)
		add	esp, 0Ch
		jmp	short loc_1B4F
; ---------------------------------------------------------------------------

loc_1B0A:				; CODE XREF: _utrie2_setRange32_56+2CAj
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?getDataBlock@@YAHPAUUNewTrie2@@HC@Z ; getDataBlock(UNewTrie2 *,int,signed char)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jge	short loc_1B33
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		jmp	loc_1BBA
; ---------------------------------------------------------------------------

loc_1B33:				; CODE XREF: _utrie2_setRange32_56+2FBj
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23300h]
		mov	eax, [ebp+var_2C]
		lea	ecx, [edx+eax*4]
		push	ecx
		call	?writeBlock@@YAXPAII@Z ; writeBlock(uint *,uint)
		add	esp, 8

loc_1B4F:				; CODE XREF: _utrie2_setRange32_56+2C4j
					; _utrie2_setRange32_56+2E0j
		mov	eax, [ebp+arg_4]
		add	eax, 20h ; ' '
		mov	[ebp+arg_4], eax
		jmp	loc_19CF
; ---------------------------------------------------------------------------

loc_1B5D:				; CODE XREF: _utrie2_setRange32_56+1ADj
		cmp	[ebp+var_20], 0
		jle	short loc_1BBA
		push	1
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?getDataBlock@@YAHPAUUNewTrie2@@HC@Z ; getDataBlock(UNewTrie2 *,int,signed char)
		add	esp, 0Ch
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 0
		jge	short loc_1B89
		mov	eax, [ebp+arg_14]
		mov	dword ptr [eax], 7
		jmp	short loc_1BBA
; ---------------------------------------------------------------------------

loc_1B89:				; CODE XREF: _utrie2_setRange32_56+354j
		movzx	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23304h]
		push	edx
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		push	0
		mov	edx, [ebp+var_8]
		mov	eax, [edx+23300h]
		mov	ecx, [ebp+var_14]
		lea	edx, [eax+ecx*4]
		push	edx
		call	?fillBlock@@YAXPAIHHIIC@Z ; fillBlock(uint *,int,int,uint,uint,signed char)
		add	esp, 18h

loc_1BBA:				; CODE XREF: _utrie2_setRange32_56+33j
					; _utrie2_setRange32_56+5Bj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_setRange32_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1BD0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl isInNullBlock(struct UNewTrie2 *,	int, signed char)
?isInNullBlock@@YACPAUUNewTrie2@@HC@Z proc near	; CODE XREF: _utrie2_setRange32_56+1CFp

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	short loc_1C15
		movsx	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1C15
		mov	eax, [ebp+arg_4]
		sar	eax, 5
		add	eax, 140h
		mov	[ebp+var_8], eax
		jmp	short loc_1C2D
; ---------------------------------------------------------------------------

loc_1C15:				; CODE XREF: isInNullBlock(UNewTrie2 *,int,signed char)+2Bj
					; isInNullBlock(UNewTrie2 *,int,signed char)+33j
		mov	eax, [ebp+arg_4]
		sar	eax, 0Bh
		mov	ecx, [ebp+arg_4]
		sar	ecx, 5
		and	ecx, 3Fh
		mov	edx, [ebp+arg_0]
		add	ecx, [edx+eax*4]
		mov	[ebp+var_8], ecx

loc_1C2D:				; CODE XREF: isInNullBlock(UNewTrie2 *,int,signed char)+43j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+880h]
		mov	[ebp+var_14], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+23320h]
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?isInNullBlock@@YACPAUUNewTrie2@@HC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C54h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl writeBlock(unsigned int *, unsigned int)
?writeBlock@@YAXPAII@Z proc near	; CODE XREF: _utrie2_setRange32_56+31Fp

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		add	eax, 80h ; '€'
		mov	[ebp+var_8], eax

loc_1C7D:				; CODE XREF: writeBlock(uint *,uint)+42j
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_8]
		jnb	short loc_1C98
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[eax], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 4
		mov	[ebp+arg_0], edx
		jmp	short loc_1C7D
; ---------------------------------------------------------------------------

loc_1C98:				; CODE XREF: writeBlock(uint *,uint)+2Fj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?writeBlock@@YAXPAII@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CA0h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl fillBlock(unsigned int *, int, int, unsigned int, unsigned int, signed char)
?fillBlock@@YAXPAIHHIIC@Z proc near	; CODE XREF: _utrie2_setRange32_56+124p
					; _utrie2_setRange32_56+165p ...

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= byte ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		mov	[ebp+var_8], edx
		mov	eax, [ebp+arg_4]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		mov	[ebp+arg_0], edx
		movsx	eax, [ebp+arg_14]
		test	eax, eax
		jz	short loc_1CFB

loc_1CDE:				; CODE XREF: fillBlock(uint *,int,int,uint,uint,signed char)+57j
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_8]
		jnb	short loc_1CF9
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		mov	[eax], ecx
		mov	edx, [ebp+arg_0]
		add	edx, 4
		mov	[ebp+arg_0], edx
		jmp	short loc_1CDE
; ---------------------------------------------------------------------------

loc_1CF9:				; CODE XREF: fillBlock(uint *,int,int,uint,uint,signed char)+44j
		jmp	short loc_1D20
; ---------------------------------------------------------------------------

loc_1CFB:				; CODE XREF: fillBlock(uint *,int,int,uint,uint,signed char)+3Cj
					; fillBlock(uint *,int,int,uint,uint,signed char)+7Ej
		mov	eax, [ebp+arg_0]
		cmp	eax, [ebp+var_8]
		jnb	short loc_1D20
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, [ebp+arg_10]
		jnz	short loc_1D15
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_C]
		mov	[eax], ecx

loc_1D15:				; CODE XREF: fillBlock(uint *,int,int,uint,uint,signed char)+6Bj
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+arg_0], eax
		jmp	short loc_1CFB
; ---------------------------------------------------------------------------

loc_1D20:				; CODE XREF: fillBlock(uint *,int,int,uint,uint,signed char):loc_1CF9j
					; fillBlock(uint *,int,int,uint,uint,signed char)+61j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?fillBlock@@YAXPAIHHIIC@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1D28h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_freeze_56
_utrie2_freeze_56 proc near		; CODE XREF: _utrie2_fromUTrie_56+181p

var_154		= dword	ptr -154h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
Dst		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 154h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_154]
		mov	ecx, 55h ; 'U'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1D60
		jmp	loc_2230
; ---------------------------------------------------------------------------

loc_1D60:				; CODE XREF: _utrie2_freeze_56+31j
		cmp	[ebp+arg_0], 0
		jz	short loc_1D72
		cmp	[ebp+arg_4], 0
		jl	short loc_1D72
		cmp	[ebp+arg_4], 2
		jl	short loc_1D80

loc_1D72:				; CODE XREF: _utrie2_freeze_56+3Cj
					; _utrie2_freeze_56+42j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	loc_2230
; ---------------------------------------------------------------------------

loc_1D80:				; CODE XREF: _utrie2_freeze_56+48j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jnz	short loc_1DB4
		mov	eax, [ebp+arg_0]
		xor	ecx, ecx
		cmp	dword ptr [eax+4], 0
		setz	cl
		mov	[ebp+var_74], ecx
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_74]
		jz	short loc_1DAF
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1

loc_1DAF:				; CODE XREF: _utrie2_freeze_56+7Cj
		jmp	loc_2230
; ---------------------------------------------------------------------------

loc_1DB4:				; CODE XREF: _utrie2_freeze_56+65j
		mov	eax, [ebp+var_8]
		movsx	ecx, byte ptr [eax+23328h]
		test	ecx, ecx
		jnz	short loc_1DEC
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	?compactTrie@@YAXPAUUTrie2@@PAW4UErrorCode@@@Z ; compactTrie(UTrie2 *,UErrorCode *)
		add	esp, 8
		mov	eax, [ebp+arg_8]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_1DEC
		jmp	loc_2230
; ---------------------------------------------------------------------------

loc_1DEC:				; CODE XREF: _utrie2_freeze_56+98j
					; _utrie2_freeze_56+BDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+20h]
		mov	[ebp+var_68], ecx
		cmp	[ebp+var_68], 10000h
		jg	short loc_1E07
		mov	[ebp+var_50], 840h
		jmp	short loc_1E13
; ---------------------------------------------------------------------------

loc_1E07:				; CODE XREF: _utrie2_freeze_56+D4j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2330Ch]
		mov	[ebp+var_50], ecx

loc_1E13:				; CODE XREF: _utrie2_freeze_56+DDj
		cmp	[ebp+arg_4], 0
		jnz	short loc_1E21
		mov	eax, [ebp+var_50]
		mov	[ebp+var_5C], eax
		jmp	short loc_1E28
; ---------------------------------------------------------------------------

loc_1E21:				; CODE XREF: _utrie2_freeze_56+EFj
		mov	[ebp+var_5C], 0

loc_1E28:				; CODE XREF: _utrie2_freeze_56+F7j
		cmp	[ebp+var_50], 0FFFFh
		jg	short loc_1E68
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_5C]
		add	ecx, [eax+23320h]
		cmp	ecx, 0FFFFh
		jg	short loc_1E68
		mov	eax, [ebp+var_5C]
		add	eax, 880h
		cmp	eax, 0FFFFh
		jg	short loc_1E68
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_5C]
		add	ecx, [eax+23314h]
		cmp	ecx, 3FFFCh
		jle	short loc_1E76

loc_1E68:				; CODE XREF: _utrie2_freeze_56+107j
					; _utrie2_freeze_56+11Bj ...
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 8
		jmp	loc_2230
; ---------------------------------------------------------------------------

loc_1E76:				; CODE XREF: _utrie2_freeze_56+13Ej
		mov	eax, [ebp+var_50]
		lea	ecx, [eax+eax+10h]
		mov	[ebp+var_44], ecx
		cmp	[ebp+arg_4], 0
		jnz	short loc_1E9A
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		mov	edx, [ebp+var_44]
		lea	eax, [edx+ecx*2]
		mov	[ebp+var_44], eax
		jmp	short loc_1EAC
; ---------------------------------------------------------------------------

loc_1E9A:				; CODE XREF: _utrie2_freeze_56+15Cj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		mov	edx, [ebp+var_44]
		lea	eax, [edx+ecx*4]
		mov	[ebp+var_44], eax

loc_1EAC:				; CODE XREF: _utrie2_freeze_56+170j
		mov	eax, [ebp+var_44]
		push	eax
		call	_uprv_malloc_56
		add	esp, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+28h], eax
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_1ED5
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 7
		jmp	loc_2230
; ---------------------------------------------------------------------------

loc_1ED5:				; CODE XREF: _utrie2_freeze_56+19Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_44]
		mov	[eax+2Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+30h], 1
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_50]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23314h]
		mov	[eax+10h], edx
		cmp	[ebp+var_68], 10000h
		jg	short loc_1F14
		mov	eax, 0FFFFh
		mov	ecx, [ebp+arg_0]
		mov	[ecx+14h], ax
		jmp	short loc_1F25
; ---------------------------------------------------------------------------

loc_1F14:				; CODE XREF: _utrie2_freeze_56+1DCj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	dx, [ecx+2331Ch]
		mov	[eax+14h], dx

loc_1F25:				; CODE XREF: _utrie2_freeze_56+1EAj
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_5C]
		add	ecx, [eax+23320h]
		mov	edx, [ebp+arg_0]
		mov	[edx+16h], cx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	edx, [ebp+var_5C]
		lea	eax, [edx+ecx-4]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+24h], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+28h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_14]
		mov	dword ptr [eax], 54726932h
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+arg_4]
		mov	[eax+4], cx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+0Ch]
		mov	[eax+6], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		sar	ecx, 2
		mov	edx, [ebp+var_14]
		mov	[edx+8], cx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+14h]
		mov	[eax+0Ah], dx
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+arg_0]
		mov	dx, [ecx+16h]
		mov	[eax+0Ch], dx
		mov	eax, [ebp+var_68]
		sar	eax, 0Bh
		mov	ecx, [ebp+var_14]
		mov	[ecx+0Eh], ax
		mov	eax, [ebp+var_14]
		add	eax, 10h
		mov	[ebp+Dst], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax], ecx
		mov	eax, [ebp+var_8]
		add	eax, 880h
		mov	[ebp+var_20], eax
		mov	[ebp+var_38], 820h
		jmp	short loc_1FDD
; ---------------------------------------------------------------------------

loc_1FD4:				; CODE XREF: _utrie2_freeze_56+2DEj
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax

loc_1FDD:				; CODE XREF: _utrie2_freeze_56+2AAj
		cmp	[ebp+var_38], 0
		jle	short loc_2008
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_5C]
		add	ecx, [eax]
		shr	ecx, 2
		mov	edx, [ebp+Dst]
		mov	[edx], cx
		mov	eax, [ebp+Dst]
		add	eax, 2
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 4
		mov	[ebp+var_20], ecx
		jmp	short loc_1FD4
; ---------------------------------------------------------------------------

loc_2008:				; CODE XREF: _utrie2_freeze_56+2B9j
		mov	[ebp+var_38], 0
		jmp	short loc_201A
; ---------------------------------------------------------------------------

loc_2011:				; CODE XREF: _utrie2_freeze_56+30Fj
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_201A:				; CODE XREF: _utrie2_freeze_56+2E7j
		cmp	[ebp+var_38], 2
		jge	short loc_2039
		mov	eax, [ebp+var_5C]
		add	eax, 80h ; '€'
		mov	ecx, [ebp+Dst]
		mov	[ecx], ax
		mov	edx, [ebp+Dst]
		add	edx, 2
		mov	[ebp+Dst], edx
		jmp	short loc_2011
; ---------------------------------------------------------------------------

loc_2039:				; CODE XREF: _utrie2_freeze_56+2F6j
		jmp	short loc_2044
; ---------------------------------------------------------------------------

loc_203B:				; CODE XREF: _utrie2_freeze_56+343j
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax

loc_2044:				; CODE XREF: _utrie2_freeze_56:loc_2039j
		cmp	[ebp+var_38], 20h ; ' '
		jge	short loc_206D
		mov	eax, [ebp+var_38]
		shl	eax, 1
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+var_5C]
		add	edx, [ecx+eax*4+880h]
		mov	eax, [ebp+Dst]
		mov	[eax], dx
		mov	ecx, [ebp+Dst]
		add	ecx, 2
		mov	[ebp+Dst], ecx
		jmp	short loc_203B
; ---------------------------------------------------------------------------

loc_206D:				; CODE XREF: _utrie2_freeze_56+320j
		cmp	[ebp+var_68], 10000h
		jle	loc_2133
		mov	eax, [ebp+var_68]
		sub	eax, 10000h
		sar	eax, 0Bh
		mov	[ebp+var_80], eax
		mov	eax, [ebp+var_80]
		add	eax, 840h
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_8]
		add	eax, 80h ; '€'
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_80]
		mov	[ebp+var_38], eax
		jmp	short loc_20B2
; ---------------------------------------------------------------------------

loc_20A9:				; CODE XREF: _utrie2_freeze_56+3AEj
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax

loc_20B2:				; CODE XREF: _utrie2_freeze_56+37Fj
		cmp	[ebp+var_38], 0
		jle	short loc_20D8
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_20]
		mov	dx, [ecx]
		mov	[eax], dx
		mov	eax, [ebp+Dst]
		add	eax, 2
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 4
		mov	[ebp+var_20], ecx
		jmp	short loc_20A9
; ---------------------------------------------------------------------------

loc_20D8:				; CODE XREF: _utrie2_freeze_56+38Ej
		mov	eax, [ebp+var_8C]
		mov	ecx, [ebp+var_8]
		lea	edx, [ecx+eax*4+880h]
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+2330Ch]
		sub	ecx, [ebp+var_8C]
		mov	[ebp+var_38], ecx
		jmp	short loc_2108
; ---------------------------------------------------------------------------

loc_20FF:				; CODE XREF: _utrie2_freeze_56+409j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax

loc_2108:				; CODE XREF: _utrie2_freeze_56+3D5j
		cmp	[ebp+var_38], 0
		jle	short loc_2133
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_5C]
		add	ecx, [eax]
		shr	ecx, 2
		mov	edx, [ebp+Dst]
		mov	[edx], cx
		mov	eax, [ebp+Dst]
		add	eax, 2
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 4
		mov	[ebp+var_20], ecx
		jmp	short loc_20FF
; ---------------------------------------------------------------------------

loc_2133:				; CODE XREF: _utrie2_freeze_56+34Cj
					; _utrie2_freeze_56+3E4j
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_154], eax
		cmp	[ebp+var_154], 0
		jz	short loc_2153
		cmp	[ebp+var_154], 1
		jz	short loc_21B1
		jmp	loc_21FD
; ---------------------------------------------------------------------------

loc_2153:				; CODE XREF: _utrie2_freeze_56+41Bj
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax+4], ecx
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23300h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		mov	[ebp+var_38], ecx
		jmp	short loc_2189
; ---------------------------------------------------------------------------

loc_2180:				; CODE XREF: _utrie2_freeze_56+485j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax

loc_2189:				; CODE XREF: _utrie2_freeze_56+456j
		cmp	[ebp+var_38], 0
		jle	short loc_21AF
		mov	eax, [ebp+Dst]
		mov	ecx, [ebp+var_20]
		mov	dx, [ecx]
		mov	[eax], dx
		mov	eax, [ebp+Dst]
		add	eax, 2
		mov	[ebp+Dst], eax
		mov	ecx, [ebp+var_20]
		add	ecx, 4
		mov	[ebp+var_20], ecx
		jmp	short loc_2180
; ---------------------------------------------------------------------------

loc_21AF:				; CODE XREF: _utrie2_freeze_56+465j
		jmp	short loc_2208
; ---------------------------------------------------------------------------

loc_21B1:				; CODE XREF: _utrie2_freeze_56+424j
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Dst]
		mov	[eax+8], ecx
		push	1
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23300h]
		push	ecx
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	edx, [ebp+var_8]
		mov	eax, [edx+23314h]
		shl	eax, 2
		push	eax		; Size
		mov	ecx, [ebp+var_8]
		mov	edx, [ecx+23300h]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		jmp	short loc_2208
; ---------------------------------------------------------------------------

loc_21FD:				; CODE XREF: _utrie2_freeze_56+426j
		mov	eax, [ebp+arg_8]
		mov	dword ptr [eax], 1
		jmp	short loc_2230
; ---------------------------------------------------------------------------

loc_2208:				; CODE XREF: _utrie2_freeze_56:loc_21AFj
					; _utrie2_freeze_56+4D3j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23300h]
		push	ecx
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+var_8]
		push	eax
		call	_uprv_free_56
		add	esp, 4
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], 0

loc_2230:				; CODE XREF: _utrie2_freeze_56+33j
					; _utrie2_freeze_56+53j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 154h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_freeze_56 endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2244h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl compactTrie(struct UTrie2 *, enum  UErrorCode *)
?compactTrie@@YAXPAUUTrie2@@PAW4UErrorCode@@@Z proc near ; CODE	XREF: _utrie2_freeze_56+A2p

var_F4		= dword	ptr -0F4h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+34h]
		mov	[ebp+var_8], ecx
		push	10FFFFh
		mov	eax, [ebp+arg_0]
		push	eax
		call	_utrie2_get32_56
		add	esp, 8
		mov	[ebp+var_2C], eax
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		call	?findHighStart@@YAHPAUUNewTrie2@@I@Z ; findHighStart(UNewTrie2 *,uint)
		add	esp, 8
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		add	eax, 7FFh
		and	eax, 0FFFFF800h
		mov	[ebp+var_14], eax
		cmp	[ebp+var_14], 110000h
		jnz	short loc_22B4
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+1Ch]
		mov	[ebp+var_2C], ecx

loc_22B4:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+65j
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_14]
		mov	[eax+23324h], ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_14]
		mov	[edx+20h], eax
		cmp	[ebp+var_14], 110000h
		jge	short loc_2335
		cmp	[ebp+var_14], 10000h
		jg	short loc_22E7
		mov	[ebp+var_F4], 10000h
		jmp	short loc_22F0
; ---------------------------------------------------------------------------

loc_22E7:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+95j
		mov	eax, [ebp+var_14]
		mov	[ebp+var_F4], eax

loc_22F0:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+A1j
		mov	ecx, [ebp+var_F4]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_4]
		push	eax
		push	1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+18h]
		push	edx
		push	10FFFFh
		mov	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utrie2_setRange32_56
		add	esp, 18h
		mov	eax, [ebp+arg_4]
		mov	ecx, [eax]
		push	ecx
		call	?U_FAILURE@@YACW4UErrorCode@@@Z	; U_FAILURE(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2335
		jmp	loc_23CD
; ---------------------------------------------------------------------------

loc_2335:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+8Cj
					; compactTrie(UTrie2 *,UErrorCode *)+EAj
		mov	eax, [ebp+var_8]
		push	eax
		call	?compactData@@YAXPAUUNewTrie2@@@Z ; compactData(UNewTrie2 *)
		add	esp, 4
		cmp	[ebp+var_14], 10000h
		jle	short loc_2356
		mov	eax, [ebp+var_8]
		push	eax
		call	?compactIndex2@@YAXPAUUNewTrie2@@@Z ; compactIndex2(UNewTrie2 *)
		add	esp, 4

loc_2356:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+104j
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+23300h]
		mov	edx, [ebp+var_2C]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+23314h], ecx

loc_2383:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+17Dj
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		and	ecx, 3
		jz	short loc_23C3
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+23300h]
		mov	edx, [ebp+arg_0]
		mov	edx, [edx+18h]
		mov	[eax+ecx*4], edx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+23314h]
		add	ecx, 1
		mov	edx, [ebp+var_8]
		mov	[edx+23314h], ecx
		jmp	short loc_2383
; ---------------------------------------------------------------------------

loc_23C3:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+14Bj
		mov	eax, [ebp+var_8]
		mov	byte ptr [eax+23328h], 1

loc_23CD:				; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+ECj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compactTrie@@YAXPAUUTrie2@@PAW4UErrorCode@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 23E4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl findHighStart(struct UNewTrie2 *,	unsigned int)
?findHighStart@@YAHPAUUNewTrie2@@I@Z proc near
					; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+43p

var_168		= byte ptr -168h
var_A4		= dword	ptr -0A4h
var_98		= dword	ptr -98h
var_8C		= dword	ptr -8Ch
var_80		= dword	ptr -80h
var_74		= dword	ptr -74h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 168h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_168]
		mov	ecx, 5Ah ; 'Z'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23304h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2331Ch]
		mov	[ebp+var_80], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23320h]
		mov	[ebp+var_A4], ecx
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_20]
		jnz	short loc_2451
		mov	eax, [ebp+var_80]
		mov	[ebp+var_74], eax
		mov	eax, [ebp+var_A4]
		mov	[ebp+var_98], eax
		jmp	short loc_2462
; ---------------------------------------------------------------------------

loc_2451:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+57j
		mov	[ebp+var_74], 0FFFFFFFFh
		mov	[ebp+var_98], 0FFFFFFFFh

loc_2462:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+6Bj
		mov	[ebp+var_38], 110000h
		mov	[ebp+var_44], 220h
		mov	eax, [ebp+var_38]
		mov	[ebp+var_2C], eax

loc_2476:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+C4j
					; findHighStart(UNewTrie2 *,uint):loc_2598j
		cmp	[ebp+var_2C], 0
		jle	loc_259D
		mov	eax, [ebp+var_44]
		sub	eax, 1
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_44]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+ecx*4]
		mov	[ebp+var_68], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_74]
		jnz	short loc_24AA
		mov	eax, [ebp+var_2C]
		sub	eax, 800h
		mov	[ebp+var_2C], eax
		jmp	short loc_2476
; ---------------------------------------------------------------------------

loc_24AA:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+B7j
		mov	eax, [ebp+var_68]
		mov	[ebp+var_74], eax
		mov	eax, [ebp+var_68]
		cmp	eax, [ebp+var_80]
		jnz	short loc_24D8
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_20]
		jz	short loc_24C8
		mov	eax, [ebp+var_2C]
		jmp	loc_259F
; ---------------------------------------------------------------------------

loc_24C8:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+DAj
		mov	eax, [ebp+var_2C]
		sub	eax, 800h
		mov	[ebp+var_2C], eax
		jmp	loc_2598
; ---------------------------------------------------------------------------

loc_24D8:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+D2j
		mov	[ebp+var_50], 40h ; '@'

loc_24DF:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+13Bj
					; findHighStart(UNewTrie2 *,uint):loc_2593j
		cmp	[ebp+var_50], 0
		jle	loc_2598
		mov	eax, [ebp+var_50]
		sub	eax, 1
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_68]
		add	ecx, [ebp+var_50]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+ecx*4+880h]
		mov	[ebp+var_8C], eax
		mov	eax, [ebp+var_8C]
		cmp	eax, [ebp+var_98]
		jnz	short loc_2521
		mov	eax, [ebp+var_2C]
		sub	eax, 20h ; ' '
		mov	[ebp+var_2C], eax
		jmp	short loc_24DF
; ---------------------------------------------------------------------------

loc_2521:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+130j
		mov	eax, [ebp+var_8C]
		mov	[ebp+var_98], eax
		mov	eax, [ebp+var_8C]
		cmp	eax, [ebp+var_A4]
		jnz	short loc_2553
		mov	eax, [ebp+arg_4]
		cmp	eax, [ebp+var_20]
		jz	short loc_2548
		mov	eax, [ebp+var_2C]
		jmp	short loc_259F
; ---------------------------------------------------------------------------

loc_2548:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+15Dj
		mov	eax, [ebp+var_2C]
		sub	eax, 20h ; ' '
		mov	[ebp+var_2C], eax
		jmp	short loc_2593
; ---------------------------------------------------------------------------

loc_2553:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+155j
		mov	[ebp+var_5C], 20h ; ' '

loc_255A:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+1ADj
		cmp	[ebp+var_5C], 0
		jle	short loc_2593
		mov	eax, [ebp+var_5C]
		sub	eax, 1
		mov	[ebp+var_5C], eax
		mov	ecx, [ebp+var_8C]
		add	ecx, [ebp+var_5C]
		mov	edx, [ebp+var_8]
		mov	eax, [edx+ecx*4]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+arg_4]
		jz	short loc_2588
		mov	eax, [ebp+var_2C]
		jmp	short loc_259F
; ---------------------------------------------------------------------------

loc_2588:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+19Dj
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax
		jmp	short loc_255A
; ---------------------------------------------------------------------------

loc_2593:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+16Dj
					; findHighStart(UNewTrie2 *,uint)+17Aj
		jmp	loc_24DF
; ---------------------------------------------------------------------------

loc_2598:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+EFj
					; findHighStart(UNewTrie2 *,uint)+FFj
		jmp	loc_2476
; ---------------------------------------------------------------------------

loc_259D:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+96j
		xor	eax, eax

loc_259F:				; CODE XREF: findHighStart(UNewTrie2 *,uint)+DFj
					; findHighStart(UNewTrie2 *,uint)+162j	...
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?findHighStart@@YAHPAUUNewTrie2@@I@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 25A8h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl compactData(struct UNewTrie2 *)
?compactData@@YAXPAUUNewTrie2@@@Z proc near
					; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+F5p

var_120		= byte ptr -120h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_14], 0C0h ; 'À'
		mov	[ebp+var_8], 0
		mov	[ebp+var_44], 0
		jmp	short loc_25EF
; ---------------------------------------------------------------------------

loc_25DD:				; CODE XREF: compactData(UNewTrie2 *)+5Fj
		mov	eax, [ebp+var_8]
		add	eax, 20h ; ' '
		mov	[ebp+var_8], eax
		mov	ecx, [ebp+var_44]
		add	ecx, 1
		mov	[ebp+var_44], ecx

loc_25EF:				; CODE XREF: compactData(UNewTrie2 *)+33j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jge	short loc_2609
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[ecx+eax*4+2332Ch], edx
		jmp	short loc_25DD
; ---------------------------------------------------------------------------

loc_2609:				; CODE XREF: compactData(UNewTrie2 *)+4Dj
		mov	[ebp+var_2C], 40h ; '@'
		mov	eax, [ebp+var_2C]
		sar	eax, 5
		mov	[ebp+var_5C], eax
		mov	eax, [ebp+var_14]
		mov	[ebp+var_8], eax

loc_261F:				; CODE XREF: compactData(UNewTrie2 *)+BCj
					; compactData(UNewTrie2	*)+132j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		cmp	ecx, [eax+23314h]
		jge	loc_2836
		cmp	[ebp+var_8], 880h
		jnz	short loc_2648
		mov	[ebp+var_2C], 20h ; ' '
		mov	[ebp+var_5C], 1

loc_2648:				; CODE XREF: compactData(UNewTrie2 *)+90j
		mov	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+arg_0]
		cmp	dword ptr [ecx+eax*4+2332Ch], 0
		jg	short loc_2666
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_8], eax
		jmp	short loc_261F
; ---------------------------------------------------------------------------

loc_2666:				; CODE XREF: compactData(UNewTrie2 *)+B1j
		mov	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+var_8]
		push	ecx
		mov	edx, [ebp+var_14]
		push	edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		push	ecx
		call	?findSameDataBlock@@YAHPBIHHH@Z	; findSameDataBlock(uint const *,int,int,int)
		add	esp, 10h
		mov	[ebp+var_20], eax
		cmp	[ebp+var_20], 0
		jl	short loc_26DF
		mov	eax, [ebp+var_5C]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_8]
		sar	ecx, 5
		mov	[ebp+var_50], ecx
		jmp	short loc_26A7
; ---------------------------------------------------------------------------

loc_269E:				; CODE XREF: compactData(UNewTrie2 *)+127j
		mov	eax, [ebp+var_44]
		sub	eax, 1
		mov	[ebp+var_44], eax

loc_26A7:				; CODE XREF: compactData(UNewTrie2 *)+F4j
		cmp	[ebp+var_44], 0
		jle	short loc_26D1
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_20]
		mov	[ecx+eax*4+2332Ch], edx
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		add	eax, 20h ; ' '
		mov	[ebp+var_20], eax
		jmp	short loc_269E
; ---------------------------------------------------------------------------

loc_26D1:				; CODE XREF: compactData(UNewTrie2 *)+103j
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_2C]
		mov	[ebp+var_8], eax
		jmp	loc_261F
; ---------------------------------------------------------------------------

loc_26DF:				; CODE XREF: compactData(UNewTrie2 *)+E3j
		mov	eax, [ebp+var_2C]
		sub	eax, 4
		mov	[ebp+var_38], eax
		jmp	short loc_26F3
; ---------------------------------------------------------------------------

loc_26EA:				; CODE XREF: compactData(UNewTrie2 *)+187j
		mov	eax, [ebp+var_38]
		sub	eax, 4
		mov	[ebp+var_38], eax

loc_26F3:				; CODE XREF: compactData(UNewTrie2 *)+140j
		cmp	[ebp+var_38], 0
		jle	short loc_2731
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+23300h]
		mov	eax, [ebp+var_8]
		lea	ecx, [edx+eax*4]
		push	ecx
		mov	edx, [ebp+var_14]
		sub	edx, [ebp+var_38]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		lea	edx, [ecx+edx*4]
		push	edx
		call	?equal_uint32@@YACPBI0H@Z ; equal_uint32(uint const *,uint const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jnz	short loc_2731
		jmp	short loc_26EA
; ---------------------------------------------------------------------------

loc_2731:				; CODE XREF: compactData(UNewTrie2 *)+14Fj
					; compactData(UNewTrie2	*)+185j
		cmp	[ebp+var_38], 0
		jg	short loc_2743
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_8]
		jge	loc_27E7

loc_2743:				; CODE XREF: compactData(UNewTrie2 *)+18Dj
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+var_38]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_5C]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_8]
		sar	ecx, 5
		mov	[ebp+var_50], ecx
		jmp	short loc_2766
; ---------------------------------------------------------------------------

loc_275D:				; CODE XREF: compactData(UNewTrie2 *)+1E6j
		mov	eax, [ebp+var_44]
		sub	eax, 1
		mov	[ebp+var_44], eax

loc_2766:				; CODE XREF: compactData(UNewTrie2 *)+1B3j
		cmp	[ebp+var_44], 0
		jle	short loc_2790
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_20]
		mov	[ecx+eax*4+2332Ch], edx
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_20]
		add	eax, 20h ; ' '
		mov	[ebp+var_20], eax
		jmp	short loc_275D
; ---------------------------------------------------------------------------

loc_2790:				; CODE XREF: compactData(UNewTrie2 *)+1C2j
		mov	eax, [ebp+var_8]
		add	eax, [ebp+var_38]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+var_2C]
		sub	eax, [ebp+var_38]
		mov	[ebp+var_44], eax
		jmp	short loc_27AD
; ---------------------------------------------------------------------------

loc_27A4:				; CODE XREF: compactData(UNewTrie2 *)+23Bj
		mov	eax, [ebp+var_44]
		sub	eax, 1
		mov	[ebp+var_44], eax

loc_27AD:				; CODE XREF: compactData(UNewTrie2 *)+1FAj
		cmp	[ebp+var_44], 0
		jle	short loc_27E5
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+23300h]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+var_8]
		mov	ecx, [ecx+esi*4]
		mov	[eax+edx*4], ecx
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax
		jmp	short loc_27A4
; ---------------------------------------------------------------------------

loc_27E5:				; CODE XREF: compactData(UNewTrie2 *)+209j
		jmp	short loc_2831
; ---------------------------------------------------------------------------

loc_27E7:				; CODE XREF: compactData(UNewTrie2 *)+195j
		mov	eax, [ebp+var_5C]
		mov	[ebp+var_44], eax
		mov	ecx, [ebp+var_8]
		sar	ecx, 5
		mov	[ebp+var_50], ecx
		jmp	short loc_2801
; ---------------------------------------------------------------------------

loc_27F8:				; CODE XREF: compactData(UNewTrie2 *)+281j
		mov	eax, [ebp+var_44]
		sub	eax, 1
		mov	[ebp+var_44], eax

loc_2801:				; CODE XREF: compactData(UNewTrie2 *)+24Ej
		cmp	[ebp+var_44], 0
		jle	short loc_282B
		mov	eax, [ebp+var_50]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_8]
		mov	[ecx+eax*4+2332Ch], edx
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_8]
		add	eax, 20h ; ' '
		mov	[ebp+var_8], eax
		jmp	short loc_27F8
; ---------------------------------------------------------------------------

loc_282B:				; CODE XREF: compactData(UNewTrie2 *)+25Dj
		mov	eax, [ebp+var_8]
		mov	[ebp+var_14], eax

loc_2831:				; CODE XREF: compactData(UNewTrie2 *):loc_27E5j
		jmp	loc_261F
; ---------------------------------------------------------------------------

loc_2836:				; CODE XREF: compactData(UNewTrie2 *)+83j
		mov	[ebp+var_44], 0
		jmp	short loc_2848
; ---------------------------------------------------------------------------

loc_283F:				; CODE XREF: compactData(UNewTrie2 *)+2E9j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	[ebp+var_44], eax

loc_2848:				; CODE XREF: compactData(UNewTrie2 *)+295j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_44]
		cmp	ecx, [eax+2330Ch]
		jge	short loc_2893
		cmp	[ebp+var_44], 820h
		jnz	short loc_286A
		mov	eax, [ebp+var_44]
		add	eax, 240h
		mov	[ebp+var_44], eax

loc_286A:				; CODE XREF: compactData(UNewTrie2 *)+2B5j
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4+880h]
		sar	edx, 5
		mov	eax, [ebp+var_44]
		mov	ecx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	edx, [esi+edx*4+2332Ch]
		mov	[ecx+eax*4+880h], edx
		jmp	short loc_283F
; ---------------------------------------------------------------------------

loc_2893:				; CODE XREF: compactData(UNewTrie2 *)+2ACj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23320h]
		sar	ecx, 5
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+ecx*4+2332Ch]
		mov	[edx+23320h], ecx

loc_28B2:				; CODE XREF: compactData(UNewTrie2 *)+333j
		mov	eax, [ebp+var_14]
		and	eax, 3
		jz	short loc_28DD
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23300h]
		mov	edx, [ebp+var_14]
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+23304h]
		mov	[ecx+edx*4], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1
		mov	[ebp+var_14], ecx
		jmp	short loc_28B2
; ---------------------------------------------------------------------------

loc_28DD:				; CODE XREF: compactData(UNewTrie2 *)+310j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+23314h], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compactData@@YAXPAUUNewTrie2@@@Z endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2900h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl equal_uint32(unsigned int	const *, unsigned int const *, int)
?equal_uint32@@YACPBI0H@Z proc near	; CODE XREF: compactData(UNewTrie2 *)+178p
					; findSameDataBlock(uint const *,int,int,int)+59p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_291E:				; CODE XREF: equal_uint32(uint const *,uint const *,int)+4Bj
		cmp	[ebp+arg_8], 0
		jle	short loc_294D
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_294D
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_4]
		add	eax, 4
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_291E
; ---------------------------------------------------------------------------

loc_294D:				; CODE XREF: equal_uint32(uint const *,uint const *,int)+22j
					; equal_uint32(uint const *,uint const *,int)+2Ej
		cmp	[ebp+arg_8], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?equal_uint32@@YACPBI0H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 295Ch
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl findSameDataBlock(unsigned int const *, int, int,	int)
?findSameDataBlock@@YAHPBIHHH@Z	proc near ; CODE XREF: compactData(UNewTrie2 *)+D4p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		sub	eax, [ebp+arg_C]
		mov	[ebp+arg_4], eax
		mov	[ebp+var_8], 0
		jmp	short loc_2995
; ---------------------------------------------------------------------------

loc_298C:				; CODE XREF: findSameDataBlock(uint const *,int,int,int):loc_29C9j
		mov	eax, [ebp+var_8]
		add	eax, 4
		mov	[ebp+var_8], eax

loc_2995:				; CODE XREF: findSameDataBlock(uint const *,int,int,int)+2Ej
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jg	short loc_29CB
		mov	eax, [ebp+arg_C]
		push	eax
		mov	ecx, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*4]
		push	eax
		mov	ecx, [ebp+var_8]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*4]
		push	eax
		call	?equal_uint32@@YACPBI0H@Z ; equal_uint32(uint const *,uint const *,int)
		add	esp, 0Ch
		movsx	ecx, al
		test	ecx, ecx
		jz	short loc_29C9
		mov	eax, [ebp+var_8]
		jmp	short loc_29CE
; ---------------------------------------------------------------------------

loc_29C9:				; CODE XREF: findSameDataBlock(uint const *,int,int,int)+66j
		jmp	short loc_298C
; ---------------------------------------------------------------------------

loc_29CB:				; CODE XREF: findSameDataBlock(uint const *,int,int,int)+3Fj
		or	eax, 0FFFFFFFFh

loc_29CE:				; CODE XREF: findSameDataBlock(uint const *,int,int,int)+6Bj
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?findSameDataBlock@@YAHPBIHHH@Z	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 29E4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl compactIndex2(struct UNewTrie2 *)
?compactIndex2@@YAXPAUUNewTrie2@@@Z proc near
					; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+10Ap

var_FC		= byte ptr -0FCh
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0FCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_FC]
		mov	ecx, 3Fh ; '?'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	[ebp+var_20], 820h
		mov	[ebp+var_14], 0
		mov	[ebp+var_8], 0
		jmp	short loc_2A2B
; ---------------------------------------------------------------------------

loc_2A19:				; CODE XREF: compactIndex2(UNewTrie2 *)+5Fj
		mov	eax, [ebp+var_14]
		add	eax, 40h ; '@'
		mov	[ebp+var_14], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		mov	[ebp+var_8], ecx

loc_2A2B:				; CODE XREF: compactIndex2(UNewTrie2 *)+33j
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jge	short loc_2A45
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		mov	[ecx+eax*4+2332Ch], edx
		jmp	short loc_2A19
; ---------------------------------------------------------------------------

loc_2A45:				; CODE XREF: compactIndex2(UNewTrie2 *)+4Dj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+23324h]
		sub	ecx, 10000h
		sar	ecx, 0Bh
		mov	edx, [ebp+var_20]
		lea	eax, [edx+ecx+20h]
		mov	[ebp+var_20], eax
		mov	[ebp+var_14], 0A60h

loc_2A68:				; CODE XREF: compactIndex2(UNewTrie2 *)+D5j
					; compactIndex2(UNewTrie2 *):loc_2BA2j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		cmp	ecx, [eax+2330Ch]
		jge	loc_2BA7
		mov	eax, [ebp+var_14]
		push	eax
		mov	ecx, [ebp+var_20]
		push	ecx
		mov	edx, [ebp+arg_0]
		add	edx, 880h
		push	edx
		call	?findSameIndex2Block@@YAHPBHHH@Z ; findSameIndex2Block(int const *,int,int)
		add	esp, 0Ch
		mov	[ebp+var_2C], eax
		cmp	[ebp+var_2C], 0
		jl	short loc_2ABB
		mov	eax, [ebp+var_14]
		sar	eax, 6
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_2C]
		mov	[ecx+eax*4+2332Ch], edx
		mov	eax, [ebp+var_14]
		add	eax, 40h ; '@'
		mov	[ebp+var_14], eax
		jmp	short loc_2A68
; ---------------------------------------------------------------------------

loc_2ABB:				; CODE XREF: compactIndex2(UNewTrie2 *)+B7j
		mov	[ebp+var_38], 3Fh ; '?'
		jmp	short loc_2ACD
; ---------------------------------------------------------------------------

loc_2AC4:				; CODE XREF: compactIndex2(UNewTrie2 *)+121j
		mov	eax, [ebp+var_38]
		sub	eax, 1
		mov	[ebp+var_38], eax

loc_2ACD:				; CODE XREF: compactIndex2(UNewTrie2 *)+DEj
		cmp	[ebp+var_38], 0
		jle	short loc_2B07
		mov	eax, [ebp+var_38]
		push	eax
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*4+880h]
		push	eax
		mov	ecx, [ebp+var_20]
		sub	ecx, [ebp+var_38]
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+ecx*4+880h]
		push	eax
		call	?equal_int32@@YACPBH0H@Z ; equal_int32(int const *,int const *,int)
		add	esp, 0Ch
		movsx	ecx, al
		test	ecx, ecx
		jnz	short loc_2B07
		jmp	short loc_2AC4
; ---------------------------------------------------------------------------

loc_2B07:				; CODE XREF: compactIndex2(UNewTrie2 *)+EDj
					; compactIndex2(UNewTrie2 *)+11Fj
		cmp	[ebp+var_38], 0
		jg	short loc_2B15
		mov	eax, [ebp+var_20]
		cmp	eax, [ebp+var_14]
		jge	short loc_2B80

loc_2B15:				; CODE XREF: compactIndex2(UNewTrie2 *)+127j
		mov	eax, [ebp+var_20]
		sub	eax, [ebp+var_38]
		mov	ecx, [ebp+var_14]
		sar	ecx, 6
		mov	edx, [ebp+arg_0]
		mov	[edx+ecx*4+2332Ch], eax
		mov	eax, [ebp+var_14]
		add	eax, [ebp+var_38]
		mov	[ebp+var_14], eax
		mov	eax, 40h ; '@'
		sub	eax, [ebp+var_38]
		mov	[ebp+var_8], eax
		jmp	short loc_2B4A
; ---------------------------------------------------------------------------

loc_2B41:				; CODE XREF: compactIndex2(UNewTrie2 *)+198j
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax

loc_2B4A:				; CODE XREF: compactIndex2(UNewTrie2 *)+15Bj
		cmp	[ebp+var_8], 0
		jle	short loc_2B7E
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		mov	esi, [ebp+arg_0]
		mov	edx, [esi+edx*4+880h]
		mov	[ecx+eax*4+880h], edx
		mov	eax, [ebp+var_20]
		add	eax, 1
		mov	[ebp+var_20], eax
		mov	ecx, [ebp+var_14]
		add	ecx, 1
		mov	[ebp+var_14], ecx
		jmp	short loc_2B41
; ---------------------------------------------------------------------------

loc_2B7E:				; CODE XREF: compactIndex2(UNewTrie2 *)+16Aj
		jmp	short loc_2BA2
; ---------------------------------------------------------------------------

loc_2B80:				; CODE XREF: compactIndex2(UNewTrie2 *)+12Fj
		mov	eax, [ebp+var_14]
		sar	eax, 6
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+var_14]
		mov	[ecx+eax*4+2332Ch], edx
		mov	eax, [ebp+var_14]
		add	eax, 40h ; '@'
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		mov	[ebp+var_20], eax

loc_2BA2:				; CODE XREF: compactIndex2(UNewTrie2 *):loc_2B7Ej
		jmp	loc_2A68
; ---------------------------------------------------------------------------

loc_2BA7:				; CODE XREF: compactIndex2(UNewTrie2 *)+90j
		mov	[ebp+var_8], 0
		jmp	short loc_2BB9
; ---------------------------------------------------------------------------

loc_2BB0:				; CODE XREF: compactIndex2(UNewTrie2 *)+1FDj
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_2BB9:				; CODE XREF: compactIndex2(UNewTrie2 *)+1CAj
		cmp	[ebp+var_8], 220h
		jge	short loc_2BE3
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+eax*4]
		sar	edx, 6
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		mov	esi, [ebp+arg_0]
		mov	edx, [esi+edx*4+2332Ch]
		mov	[ecx+eax*4], edx
		jmp	short loc_2BB0
; ---------------------------------------------------------------------------

loc_2BE3:				; CODE XREF: compactIndex2(UNewTrie2 *)+1DCj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+2331Ch]
		sar	ecx, 6
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+ecx*4+2332Ch]
		mov	[edx+2331Ch], ecx

loc_2C02:				; CODE XREF: compactIndex2(UNewTrie2 *)+240j
		mov	eax, [ebp+var_20]
		and	eax, 3
		jz	short loc_2C26
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+arg_0]
		mov	dword ptr [ecx+eax*4+880h], 3FFFCh
		mov	edx, [ebp+var_20]
		add	edx, 1
		mov	[ebp+var_20], edx
		jmp	short loc_2C02
; ---------------------------------------------------------------------------

loc_2C26:				; CODE XREF: compactIndex2(UNewTrie2 *)+224j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+2330Ch], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0FCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?compactIndex2@@YAXPAUUNewTrie2@@@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2C48h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; signed char __cdecl equal_int32(int const *, int const *, int)
?equal_int32@@YACPBH0H@Z proc near	; CODE XREF: compactIndex2(UNewTrie2 *)+112p
					; findSameIndex2Block(int const	*,int,int)+57p

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_2C66:				; CODE XREF: equal_int32(int const *,int const *,int)+4Bj
		cmp	[ebp+arg_8], 0
		jle	short loc_2C95
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [eax]
		cmp	edx, [ecx]
		jnz	short loc_2C95
		mov	eax, [ebp+arg_0]
		add	eax, 4
		mov	[ebp+arg_0], eax
		mov	eax, [ebp+arg_4]
		add	eax, 4
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_2C66
; ---------------------------------------------------------------------------

loc_2C95:				; CODE XREF: equal_int32(int const *,int const *,int)+22j
					; equal_int32(int const	*,int const *,int)+2Ej
		cmp	[ebp+arg_8], 0
		setz	al
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
?equal_int32@@YACPBH0H@Z endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2CA4h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl findSameIndex2Block(int const *, int, int)
?findSameIndex2Block@@YAHPBHHH@Z proc near ; CODE XREF:	compactIndex2(UNewTrie2	*)+A8p

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_4]
		sub	eax, 40h ; '@'
		mov	[ebp+arg_4], eax
		mov	[ebp+var_8], 0
		jmp	short loc_2CDD
; ---------------------------------------------------------------------------

loc_2CD4:				; CODE XREF: findSameIndex2Block(int const *,int,int):loc_2D0Fj
		mov	eax, [ebp+var_8]
		add	eax, 1
		mov	[ebp+var_8], eax

loc_2CDD:				; CODE XREF: findSameIndex2Block(int const *,int,int)+2Ej
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+arg_4]
		jg	short loc_2D11
		push	40h ; '@'
		mov	eax, [ebp+arg_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		push	edx
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+arg_0]
		lea	edx, [ecx+eax*4]
		push	edx
		call	?equal_int32@@YACPBH0H@Z ; equal_int32(int const *,int const *,int)
		add	esp, 0Ch
		movsx	eax, al
		test	eax, eax
		jz	short loc_2D0F
		mov	eax, [ebp+var_8]
		jmp	short loc_2D14
; ---------------------------------------------------------------------------

loc_2D0F:				; CODE XREF: findSameIndex2Block(int const *,int,int)+64j
		jmp	short loc_2CD4
; ---------------------------------------------------------------------------

loc_2D11:				; CODE XREF: findSameIndex2Block(int const *,int,int)+3Fj
		or	eax, 0FFFFFFFFh

loc_2D14:				; CODE XREF: findSameIndex2Block(int const *,int,int)+69j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
?findSameIndex2Block@@YAHPBHHH@Z endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2D28h
		assume es:nothing, ss:nothing, ds:_rtc$TMZ, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _utrie2_swapAnyVersion_56
_utrie2_swapAnyVersion_56 proc near

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_10]
		mov	ecx, [eax]
		push	ecx
		call	?U_SUCCESS@@YACW4UErrorCode@@@Z	; U_SUCCESS(UErrorCode)
		add	esp, 4
		movsx	edx, al
		test	edx, edx
		jz	short loc_2DD0
		push	1
		mov	eax, [ebp+arg_8]
		push	eax
		mov	ecx, [ebp+arg_4]
		push	ecx
		call	_utrie2_getVersion_56
		add	esp, 0Ch
		mov	[ebp+var_C4], eax
		cmp	[ebp+var_C4], 1
		jz	short loc_2D87
		cmp	[ebp+var_C4], 2
		jz	short loc_2DA5
		jmp	short loc_2DC3
; ---------------------------------------------------------------------------

loc_2D87:				; CODE XREF: _utrie2_swapAnyVersion_56+52j
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utrie_swap_56
		add	esp, 14h
		jmp	short loc_2DD2
; ---------------------------------------------------------------------------

loc_2DA5:				; CODE XREF: _utrie2_swapAnyVersion_56+5Bj
		mov	eax, [ebp+arg_10]
		push	eax
		mov	ecx, [ebp+arg_C]
		push	ecx
		mov	edx, [ebp+arg_8]
		push	edx
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_utrie2_swap_56
		add	esp, 14h
		jmp	short loc_2DD2
; ---------------------------------------------------------------------------

loc_2DC3:				; CODE XREF: _utrie2_swapAnyVersion_56+5Dj
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 3
		xor	eax, eax
		jmp	short loc_2DD2
; ---------------------------------------------------------------------------

loc_2DD0:				; CODE XREF: _utrie2_swapAnyVersion_56+31j
		xor	eax, eax

loc_2DD2:				; CODE XREF: _utrie2_swapAnyVersion_56+7Bj
					; _utrie2_swapAnyVersion_56+99j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_utrie2_swapAnyVersion_56 endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
; const	type_info::`vftable'
		extrn ??_7type_info@@6B@:near
					; DATA XREF: .data:icu_56::UObject `RTTI Type Descriptor'o
					; .data:icu_56::UMemory	`RTTI Type Descriptor'o
; public: virtual void * __thiscall icu_56::UObject::getDynamicClassID(void)const
		extrn ?getDynamicClassID@UObject@icu_56@@UBEPAXXZ:near
					; DATA XREF: .rdata:00000134o
; void __cdecl icu_56::UMemory::operator delete(void *)
		extrn ??3UMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+37p
					; icu_56::UObject::`vector deleting destructor'(uint)+75p
; _DWORD __thiscall icu_56::UObject::~UObject(icu_56::UObject *__hidden	this)
		extrn ??1UObject@icu_56@@UAE@XZ:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+26p
					; icu_56::UObject::`vector deleting destructor'(uint)+64p
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: icu_56::UObject::`scalar deleting destructor'(uint)+4Dp
					; icu_56::UObject::`vector deleting destructor'(uint)+8Bp ...
; void __cdecl icu_56::UMemory::operator delete[](void *)
		extrn ??_VUMemory@icu_56@@SAXPAX@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+51p
; void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *))
		extrn ??_M@YGXPAXIHP6EX0@Z@Z:near
					; CODE XREF: icu_56::UObject::`vector deleting destructor'(uint)+3Dp
		extrn _umtx_lock_56:near ; CODE	XREF: icu_56::Mutex::Mutex(UMutex *)+31p
		extrn _umtx_unlock_56:near ; CODE XREF:	icu_56::Mutex::~Mutex(void)+29p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _utrie2_open_56+B5p
		extrn _uprv_free_56:near ; CODE	XREF: _utrie2_open_56+7Dp
					; _utrie2_open_56+89p ...
		extrn _uprv_malloc_56:near ; CODE XREF:	_utrie2_open_56+3Cp
					; _utrie2_open_56+4Cp ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _utrie2_clone_56+94p
					; _utrie2_clone_56+F8p	...
		extrn _uprv_checkValidMemory:near ; CODE XREF: _utrie2_clone_56+82p
					; _utrie2_clone_56+DBp	...
		extrn _utrie2_close_56:near ; CODE XREF: _utrie2_cloneAsThawed_56+1B4p
					; _utrie2_fromUTrie_56+1A2p
		extrn _utrie2_enum_56:near ; CODE XREF:	_utrie2_cloneAsThawed_56+E5p
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near ; CODE XREF: _utrie2_cloneAsThawed_56+1D0p
					; _utrie2_fromUTrie_56+1BEp
		extrn _utrie_enum_56:near ; CODE XREF: _utrie2_fromUTrie_56+A1p
		extrn _utrie2_get32_56:near
					; CODE XREF: compactTrie(UTrie2	*,UErrorCode *)+30p
		extrn _utrie2_swap_56:near ; CODE XREF:	_utrie2_swapAnyVersion_56+91p
		extrn _utrie_swap_56:near ; CODE XREF: _utrie2_swapAnyVersion_56+73p
		extrn _utrie2_getVersion_56:near ; CODE	XREF: _utrie2_swapAnyVersion_56+3Dp


		end
