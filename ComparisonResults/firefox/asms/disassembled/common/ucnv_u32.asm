;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B129DEE3B11B7236443D18EC65611D93
; Input	CRC32 :	102171E1

; File Name   :	D:\compspace\objfiles\firefox\common\ucnv_u32.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
; `T_UConverter_fromUnicode_UTF32_BE'::`4'::bom
?bom@?3??T_UConverter_fromUnicode_UTF32_BE@@9@9	dd 0FFFE0000h
					; DATA XREF: _T_UConverter_fromUnicode_UTF32_BE+6Fo
; `T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC'::`4'::bom
?bom@?3??T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC@@9@9 dd	0FFFE0000h
					; DATA XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+76o
__UTF32BEImpl	dd 7, 5	dup(0)		; DATA XREF: .rdata:000000CCo
		dd offset _T_UConverter_toUnicode_UTF32_BE
		dd offset _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC
		dd offset _T_UConverter_fromUnicode_UTF32_BE
		dd offset _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC
		dd offset _T_UConverter_getNextUChar_UTF32_BE
		dd 4 dup(0)
		dd offset _ucnv_getNonSurrogateUnicodeSet_56
		align 10h
__UTF32BEStaticData dd offset dword_64	; DATA XREF: .rdata:000000C4o
aUtf32be	db 'UTF-32BE',0
		align 10h
		dd 0
dword_64	dd 0Bh dup(0)		; DATA XREF: .rdata:__UTF32BEStaticDatao
					; .rdata:__UTF32LEStaticDatao ...
		dd offset byte_4D0
		dd 4040700h, 0FDFF0000h, 4, 5 dup(0)
; `T_UConverter_fromUnicode_UTF32_LE'::`4'::bom
?bom@?3??T_UConverter_fromUnicode_UTF32_LE@@9@9	dd 0FEFFh
					; DATA XREF: _T_UConverter_fromUnicode_UTF32_LE+6Fo
		public __UTF32BEData_56
__UTF32BEData_56 dd offset dword_E4
		dd 0FFFFFFFFh, 0
		dd offset __UTF32BEStaticData
		dd 0
		dd offset __UTF32BEImpl
		dd 5 dup(0)
dword_E4	dd 2Eh dup(0)		; DATA XREF: .rdata:__UTF32BEData_56o
					; .rdata:__UTF32LEData_56o ...
; `T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC'::`4'::bom
?bom@?3??T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC@@9@9 dd	0FEFFh
					; DATA XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+76o
__UTF32LEImpl	dd 8, 5	dup(0)		; DATA XREF: .rdata:00000264o
		dd offset _T_UConverter_toUnicode_UTF32_LE
		dd offset _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC
		dd offset _T_UConverter_fromUnicode_UTF32_LE
		dd offset _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC
		dd offset _T_UConverter_getNextUChar_UTF32_LE
		dd 4 dup(0)
		dd offset _ucnv_getNonSurrogateUnicodeSet_56
		dd 2 dup(0)
__UTF32LEStaticData dd offset dword_64	; DATA XREF: .rdata:0000025Co
aUtf32le	db 'UTF-32LE',0
		align 4
		dd 0Ch dup(0)
		dd offset word_4D2
		dd 4040800h, 0FFFDh, 4,	6 dup(0)
		public __UTF32LEData_56
__UTF32LEData_56 dd offset dword_E4
		dd 0FFFFFFFFh, 0
		dd offset __UTF32LEStaticData
		dd 0
		dd offset __UTF32LEImpl
		dd 33h dup(0)
_utf32BOM	db 0			; DATA XREF: __UTF32ToUnicodeWithOffsets+DFr
					; __UTF32ToUnicodeWithOffsets+166o ...
		align 2
		dw 0FFFEh
		dd 0FEFFh, 0
__UTF32Impl	dd 1Eh,	2 dup(0)	; DATA XREF: .rdata:00000404o
		dd offset __UTF32Open
		dd 0
		dd offset __UTF32Reset
		dd offset __UTF32ToUnicodeWithOffsets
		dd offset __UTF32ToUnicodeWithOffsets
		dd offset _T_UConverter_fromUnicode_UTF32_LE
		dd offset _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC
		dd offset __UTF32GetNextUChar
		dd 4 dup(0)
		dd offset _ucnv_getNonSurrogateUnicodeSet_56
		dd 2 dup(0)
__UTF32StaticData dd offset dword_64	; DATA XREF: .rdata:000003FCo
aUtf32		db 'UTF-32',0
		align 4
		dd 0Dh dup(0)
		dd offset _T_UConverter_toUnicode_UTF32_BE
		dd 4041E00h, 0FFFDh, 4,	6 dup(0)
		public __UTF32Data_56
__UTF32Data_56	dd offset dword_E4
		dd 0FFFFFFFFh, 0
		dd offset __UTF32StaticData
		dd 0
		dd offset __UTF32Impl
		dd 32h dup(0)
byte_4D0	db 2 dup(0)		; DATA XREF: .rdata:00000090o
word_4D2	dw 0			; DATA XREF: .rdata:00000228o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 4D4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_toUnicode_UTF32_BE proc near ; CODE XREF:	__UTF32ToUnicodeWithOffsets+195p
					; __UTF32ToUnicodeWithOffsets+1D4p ...

var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+2Ch], 0
		jz	short loc_56B
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_56B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+2Ch]
		sub	edx, 1
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+2Ch], 0
		jmp	short $morebytes$8560
; ---------------------------------------------------------------------------

loc_56B:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+58j
					; _T_UConverter_toUnicode_UTF32_BE+60j	...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	$donefornow$8573
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	$donefornow$8573
		mov	[ebp+var_50], 0
		mov	[ebp+var_44], 0

$morebytes$8560:			; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+95j
					; _T_UConverter_toUnicode_UTF32_BE:loc_5F1j
		cmp	[ebp+var_50], 4
		jnb	short loc_5F3
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_5D1
		mov	eax, [ebp+var_44]
		shl	eax, 8
		mov	ecx, [ebp+var_8]
		movzx	edx, byte ptr [ecx]
		or	eax, edx
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_50]
		mov	ecx, [ebp+var_8]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		mov	[ebp+var_8], ecx
		jmp	short loc_5F1
; ---------------------------------------------------------------------------

loc_5D1:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+C9j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_50]
		mov	[ecx+24h], dl
		jmp	$donefornow$8573
; ---------------------------------------------------------------------------

loc_5F1:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+FBj
		jmp	short $morebytes$8560
; ---------------------------------------------------------------------------

loc_5F3:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+C1j
		cmp	[ebp+var_44], 10FFFFh
		ja	loc_6A0
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jz	loc_6A0
		cmp	[ebp+var_44], 0FFFFh
		ja	short loc_631
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_44]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		jmp	short loc_69E
; ---------------------------------------------------------------------------

loc_631:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+146j
		mov	eax, [ebp+var_44]
		shr	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_44]
		and	eax, 3FFh
		or	eax, 0DC00h
		movzx	ecx, ax
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_67B
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_44]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		jmp	short loc_69E
; ---------------------------------------------------------------------------

loc_67B:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+190j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dx, word ptr [ebp+var_44]
		mov	[ecx+74h], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+41h], 1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short $donefornow$8573
; ---------------------------------------------------------------------------

loc_69E:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+15Bj
					; _T_UConverter_toUnicode_UTF32_BE+1A5j
		jmp	short loc_6B7
; ---------------------------------------------------------------------------

loc_6A0:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+126j
					; _T_UConverter_toUnicode_UTF32_BE+139j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_50]
		mov	[ecx+24h], dl
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	short $donefornow$8573
; ---------------------------------------------------------------------------

loc_6B7:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE:loc_69Ej
		jmp	loc_56B
; ---------------------------------------------------------------------------

$donefornow$8573:			; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+9Dj
					; _T_UConverter_toUnicode_UTF32_BE+A9j	...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_6DD
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jb	short loc_6DD
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_6DD
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_6DD:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE+1EEj
					; _T_UConverter_toUnicode_UTF32_BE+1F6j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_toUnicode_UTF32_BE endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 6F8h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 6FCh
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 700h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC proc near
					; CODE XREF: __UTF32ToUnicodeWithOffsets+1E6p
					; DATA XREF: .rdata:00000024o

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		mov	[ebp+var_44], ecx
		mov	[ebp+var_68], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+2Ch], 0
		jz	short loc_7A7
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_7A7
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+2Ch]
		sub	edx, 1
		mov	[ebp+var_50], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+2Ch], 0
		jmp	short $morebytes$8606
; ---------------------------------------------------------------------------

loc_7A7:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+68j
					; _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+70j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	$donefornow$8619
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	$donefornow$8619
		mov	[ebp+var_5C], 0
		mov	[ebp+var_50], 0

$morebytes$8606:			; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+A5j
					; _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC:loc_82Dj
		cmp	[ebp+var_5C], 4
		jnb	short loc_82F
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_80D
		mov	eax, [ebp+var_50]
		shl	eax, 8
		mov	ecx, [ebp+var_8]
		movzx	edx, byte ptr [ecx]
		or	eax, edx
		mov	[ebp+var_50], eax
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_8]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		mov	[ebp+var_8], ecx
		jmp	short loc_82D
; ---------------------------------------------------------------------------

loc_80D:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+D9j
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_5C]
		mov	[ecx+24h], dl
		jmp	$donefornow$8619
; ---------------------------------------------------------------------------

loc_82D:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+10Bj
		jmp	short $morebytes$8606
; ---------------------------------------------------------------------------

loc_82F:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+D1j
		cmp	[ebp+var_50], 10FFFFh
		ja	loc_912
		mov	eax, [ebp+var_50]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jz	loc_912
		cmp	[ebp+var_50], 0FFFFh
		ja	short loc_881
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_50]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_68]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		jmp	loc_910
; ---------------------------------------------------------------------------

loc_881:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+156j
		mov	eax, [ebp+var_50]
		shr	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_68]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_50]
		and	eax, 3FFh
		or	eax, 0DC00h
		movzx	ecx, ax
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_8ED
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_50]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_68]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		jmp	short loc_910
; ---------------------------------------------------------------------------

loc_8ED:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+1C5j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dx, word ptr [ebp+var_50]
		mov	[ecx+74h], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+41h], 1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short $donefornow$8619
; ---------------------------------------------------------------------------

loc_910:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+17Cj
					; _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+1EBj
		jmp	short loc_929
; ---------------------------------------------------------------------------

loc_912:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+136j
					; _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+149j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_5C]
		mov	[ecx+24h], dl
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	short $donefornow$8619
; ---------------------------------------------------------------------------

loc_929:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC:loc_910j
		mov	eax, [ebp+var_68]
		add	eax, [ebp+var_5C]
		mov	[ebp+var_68], eax
		jmp	loc_7A7
; ---------------------------------------------------------------------------

$donefornow$8619:			; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+ADj
					; _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+B9j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_958
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jb	short loc_958
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_958
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_958:				; CODE XREF: _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+23Dj
					; _T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC+245j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+18h], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 97Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_fromUnicode_UTF32_BE proc	near ; DATA XREF: .rdata:00000028o

var_120		= byte ptr -120h
var_5C		= byte ptr -5Ch
var_5B		= byte ptr -5Bh
var_5A		= byte ptr -5Ah
var_59		= byte ptr -59h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jb	short loc_9C2
		jmp	loc_BF4
; ---------------------------------------------------------------------------

loc_9C2:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+3Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+34h], 1
		jnz	short loc_A0C
		mov	eax, [ebp+arg_4]
		push	eax
		push	0FFFFFFFFh
		mov	ecx, [ebp+arg_0]
		add	ecx, 18h
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		push	ecx
		push	4
		push	offset ?bom@?3??T_UConverter_fromUnicode_UTF32_BE@@9@9 ; `T_UConverter_fromUnicode_UTF32_BE'::`4'::bom
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		push	eax
		call	_ucnv_fromUWriteBytes_56
		add	esp, 20h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+34h], 0

loc_A0C:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+50j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_5C], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+38h], 0
		jz	short loc_A40
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+38h]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+38h], 0
		jmp	short $lowsurogate$8658
; ---------------------------------------------------------------------------

loc_A40:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+A7j
					; _T_UConverter_fromUnicode_UTF32_BE:loc_BBCj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	loc_BC1
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	loc_BC1
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_38], ecx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_B30
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	loc_B16

$lowsurogate$8658:			; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+C2j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_AEF
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_AD3
		mov	eax, [ebp+var_38]
		sub	eax, 0D800h
		shl	eax, 0Ah
		mov	ecx, [ebp+var_44]
		lea	edx, [eax+ecx+2400h]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_8]
		add	eax, 2
		mov	[ebp+var_8], eax
		jmp	short loc_AED
; ---------------------------------------------------------------------------

loc_AD3:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+132j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_38]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_BC1
; ---------------------------------------------------------------------------

loc_AED:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+155j
		jmp	short loc_B14
; ---------------------------------------------------------------------------

loc_AEF:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+11Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_38]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	short loc_B0F
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_B0F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+188j
		jmp	loc_BC1
; ---------------------------------------------------------------------------

loc_B14:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE:loc_AEDj
		jmp	short loc_B30
; ---------------------------------------------------------------------------

loc_B16:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+10Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_38]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_BC1
; ---------------------------------------------------------------------------

loc_B30:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+FBj
					; _T_UConverter_fromUnicode_UTF32_BE:loc_B14j
		mov	eax, [ebp+var_38]
		sar	eax, 10h
		and	eax, 1Fh
		mov	[ebp+var_5B], al
		mov	eax, [ebp+var_38]
		sar	eax, 8
		mov	[ebp+var_5A], al
		mov	al, byte ptr [ebp+var_38]
		mov	[ebp+var_59], al
		mov	[ebp+var_50], 0
		jmp	short loc_B5D
; ---------------------------------------------------------------------------

loc_B54:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE:loc_BBAj
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax

loc_B5D:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+1D6j
		cmp	[ebp+var_50], 3
		ja	short loc_BBC
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_B82
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_50]
		mov	dl, [ebp+ecx+var_5C]
		mov	[eax], dl
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_BBA
; ---------------------------------------------------------------------------

loc_B82:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+1EDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_50]
		mov	al, [ebp+eax+var_5C]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_BBA:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+204j
		jmp	short loc_B54
; ---------------------------------------------------------------------------

loc_BBC:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+1E5j
		jmp	loc_A40
; ---------------------------------------------------------------------------

loc_BC1:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+CAj
					; _T_UConverter_fromUnicode_UTF32_BE+D6j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_BE2
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jb	short loc_BE2
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_BE2
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_BE2:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+24Bj
					; _T_UConverter_fromUnicode_UTF32_BE+253j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx

loc_BF4:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+41j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_fromUnicode_UTF32_BE endp

; ---------------------------------------------------------------------------
		align 4
$LN24		dd 1			; DATA XREF: _T_UConverter_fromUnicode_UTF32_BE+27Co
		dd offset $LN23
$LN23		dd 0FFFFFFA4h, 4	; DATA XREF: .text:00000C20o
		dd offset $LN22		; "temp"
$LN22		db 'temp',0             ; DATA XREF: .text:00000C2Co
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C38h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC	proc near ; DATA XREF: .rdata:0000002Co

var_138		= byte ptr -138h
var_74		= byte ptr -74h
var_73		= byte ptr -73h
var_72		= byte ptr -72h
var_71		= byte ptr -71h
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		mov	[ebp+var_5C], 0
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jb	short loc_C85
		jmp	loc_EEE
; ---------------------------------------------------------------------------

loc_C85:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+46j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+34h], 1
		jnz	short loc_CCF
		mov	eax, [ebp+arg_4]
		push	eax
		push	0FFFFFFFFh
		mov	ecx, [ebp+arg_0]
		add	ecx, 18h
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		push	ecx
		push	4
		push	offset ?bom@?3??T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC@@9@9 ; `T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC'::`4'::bom
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		push	eax
		call	_ucnv_fromUWriteBytes_56
		add	esp, 20h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+34h], 0

loc_CCF:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+57j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_20], ecx
		mov	[ebp+var_74], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+38h], 0
		jz	short loc_D0C
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+38h]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+38h], 0
		jmp	short $lowsurogate$8707
; ---------------------------------------------------------------------------

loc_D0C:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+B7j
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+275j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	loc_EB2
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	loc_EB2
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_DFC
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	loc_DE2

$lowsurogate$8707:			; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+D2j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_DBB
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_50]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_D9F
		mov	eax, [ebp+var_44]
		sub	eax, 0D800h
		shl	eax, 0Ah
		mov	ecx, [ebp+var_50]
		lea	edx, [eax+ecx+2400h]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+var_8]
		add	eax, 2
		mov	[ebp+var_8], eax
		jmp	short loc_DB9
; ---------------------------------------------------------------------------

loc_D9F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+142j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_44]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_EB2
; ---------------------------------------------------------------------------

loc_DB9:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+165j
		jmp	short loc_DE0
; ---------------------------------------------------------------------------

loc_DBB:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+12Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_44]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	short loc_DDB
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_DDB:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+198j
		jmp	loc_EB2
; ---------------------------------------------------------------------------

loc_DE0:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC:loc_DB9j
		jmp	short loc_DFC
; ---------------------------------------------------------------------------

loc_DE2:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+11Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_44]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_EB2
; ---------------------------------------------------------------------------

loc_DFC:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+10Bj
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC:loc_DE0j
		mov	eax, [ebp+var_44]
		sar	eax, 10h
		and	eax, 1Fh
		mov	[ebp+var_73], al
		mov	eax, [ebp+var_44]
		sar	eax, 8
		mov	[ebp+var_72], al
		mov	al, byte ptr [ebp+var_44]
		mov	[ebp+var_71], al
		mov	[ebp+var_68], 0
		jmp	short loc_E29
; ---------------------------------------------------------------------------

loc_E20:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC:loc_E97j
		mov	eax, [ebp+var_68]
		add	eax, 1
		mov	[ebp+var_68], eax

loc_E29:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+1E6j
		cmp	[ebp+var_68], 3
		ja	short loc_E99
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_E5F
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_68]
		mov	dl, [ebp+ecx+var_74]
		mov	[eax], dl
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_5C]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		jmp	short loc_E97
; ---------------------------------------------------------------------------

loc_E5F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+1FDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_68]
		mov	al, [ebp+eax+var_74]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_E97:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+225j
		jmp	short loc_E20
; ---------------------------------------------------------------------------

loc_E99:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+1F5j
		movzx	eax, [ebp+var_73]
		neg	eax
		sbb	eax, eax
		neg	eax
		mov	ecx, [ebp+var_5C]
		lea	edx, [ecx+eax+1]
		mov	[ebp+var_5C], edx
		jmp	loc_D0C
; ---------------------------------------------------------------------------

loc_EB2:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+DAj
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+E6j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_ED3
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jb	short loc_ED3
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_ED3
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_ED3:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+280j
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+288j	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+18h], ecx

loc_EEE:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+48j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24_0
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC	endp

; ---------------------------------------------------------------------------
		align 4
$LN24_0		dd 1			; DATA XREF: _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+2BAo
		dd offset $LN23_0
$LN23_0		dd 0FFFFFF8Ch, 4	; DATA XREF: .text:00000F18o
		dd offset $LN22_0	; "temp"
$LN22_0		db 'temp',0             ; DATA XREF: .text:00000F24o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F30h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_getNextUChar_UTF32_BE proc near ;	CODE XREF: __UTF32GetNextUChar+49p
					; DATA XREF: .rdata:00000030o

var_E4		= byte ptr -0E4h
Size		= dword	ptr -20h
var_14		= dword	ptr -14h
Src		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+Src], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Src]
		cmp	ecx, [eax+0Ch]
		jb	short loc_F75
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 8
		mov	eax, 0FFFFh
		jmp	loc_106E
; ---------------------------------------------------------------------------

loc_F75:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_BE+30j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		sub	ecx, [ebp+Src]
		mov	[ebp+Size], ecx
		cmp	[ebp+Size], 4
		jge	short loc_FDA
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+Size]
		mov	[ecx+24h], dl
		mov	eax, [ebp+Src]
		add	eax, [ebp+Size]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Bh
		mov	eax, 0FFFFh
		jmp	loc_106E
; ---------------------------------------------------------------------------

loc_FDA:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_BE+55j
		mov	eax, [ebp+Src]
		movzx	ecx, byte ptr [eax]
		shl	ecx, 18h
		mov	edx, [ebp+Src]
		movzx	eax, byte ptr [edx+1]
		shl	eax, 10h
		or	ecx, eax
		mov	edx, [ebp+Src]
		movzx	eax, byte ptr [edx+2]
		shl	eax, 8
		or	ecx, eax
		mov	edx, [ebp+Src]
		movzx	eax, byte ptr [edx+3]
		or	ecx, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+Src]
		add	eax, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		cmp	[ebp+var_14], 10FFFFh
		ja	short loc_1030
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jz	short loc_1030
		mov	eax, [ebp+var_14]
		jmp	short loc_106E
; ---------------------------------------------------------------------------

loc_1030:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_BE+EAj
					; _T_UConverter_getNextUChar_UTF32_BE+F9j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		add	eax, 25h ; '%'
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 4
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, 0FFFFh

loc_106E:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_BE+40j
					; _T_UConverter_getNextUChar_UTF32_BE+A5j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_getNextUChar_UTF32_BE endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1084h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_toUnicode_UTF32_LE proc near ; CODE XREF:	__UTF32ToUnicodeWithOffsets+210p
					; __UTF32ToUnicodeWithOffsets+2D3p
					; DATA XREF: ...

var_114		= byte ptr -114h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 114h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_114]
		mov	ecx, 45h ; 'E'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+2Ch], 0
		jz	short loc_111B
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_111B
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+2Ch]
		sub	edx, 1
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+2Ch], 0
		jmp	short $morebytes$8797
; ---------------------------------------------------------------------------

loc_111B:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+58j
					; _T_UConverter_toUnicode_UTF32_LE+60j	...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	$donefornow$8810
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	$donefornow$8810
		mov	[ebp+var_50], 0
		mov	[ebp+var_44], 0

$morebytes$8797:			; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+95j
					; _T_UConverter_toUnicode_UTF32_LE:loc_11A4j
		cmp	[ebp+var_50], 4
		jnb	short loc_11A6
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_1184
		mov	eax, [ebp+var_8]
		movzx	edx, byte ptr [eax]
		mov	ecx, [ebp+var_50]
		shl	ecx, 3
		shl	edx, cl
		or	edx, [ebp+var_44]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+var_38]
		add	eax, [ebp+var_50]
		mov	ecx, [ebp+var_8]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		mov	[ebp+var_8], ecx
		jmp	short loc_11A4
; ---------------------------------------------------------------------------

loc_1184:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+C9j
		mov	eax, [ebp+var_44]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_50]
		mov	[ecx+24h], dl
		jmp	$donefornow$8810
; ---------------------------------------------------------------------------

loc_11A4:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+FEj
		jmp	short $morebytes$8797
; ---------------------------------------------------------------------------

loc_11A6:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+C1j
		cmp	[ebp+var_44], 10FFFFh
		ja	loc_1253
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jz	loc_1253
		cmp	[ebp+var_44], 0FFFFh
		ja	short loc_11E4
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_44]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		jmp	short loc_1251
; ---------------------------------------------------------------------------

loc_11E4:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+149j
		mov	eax, [ebp+var_44]
		shr	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_44]
		and	eax, 3FFh
		or	eax, 0DC00h
		movzx	ecx, ax
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_122E
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_44]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		jmp	short loc_1251
; ---------------------------------------------------------------------------

loc_122E:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+193j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dx, word ptr [ebp+var_44]
		mov	[ecx+74h], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+41h], 1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short $donefornow$8810
; ---------------------------------------------------------------------------

loc_1251:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+15Ej
					; _T_UConverter_toUnicode_UTF32_LE+1A8j
		jmp	short loc_126A
; ---------------------------------------------------------------------------

loc_1253:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+129j
					; _T_UConverter_toUnicode_UTF32_LE+13Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_50]
		mov	[ecx+24h], dl
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	short $donefornow$8810
; ---------------------------------------------------------------------------

loc_126A:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE:loc_1251j
		jmp	loc_111B
; ---------------------------------------------------------------------------

$donefornow$8810:			; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+9Dj
					; _T_UConverter_toUnicode_UTF32_LE+A9j	...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_1290
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jb	short loc_1290
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_1290
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_1290:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE+1F1j
					; _T_UConverter_toUnicode_UTF32_LE+1F9j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_toUnicode_UTF32_LE endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 12ACh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC proc near
					; CODE XREF: __UTF32ToUnicodeWithOffsets+222p
					; DATA XREF: .rdata:000001BCo

var_12C		= byte ptr -12Ch
var_68		= dword	ptr -68h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 12Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_12C]
		mov	ecx, 4Bh ; 'K'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		mov	[ebp+var_44], ecx
		mov	[ebp+var_68], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+2Ch], 0
		jz	short loc_1353
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_1353
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		movsx	edx, byte ptr [ecx+24h]
		mov	[ebp+var_5C], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+2Ch]
		sub	edx, 1
		mov	[ebp+var_50], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+2Ch], 0
		jmp	short $morebytes$8843
; ---------------------------------------------------------------------------

loc_1353:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+68j
					; _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+70j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	$donefornow$8856
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	$donefornow$8856
		mov	[ebp+var_5C], 0
		mov	[ebp+var_50], 0

$morebytes$8843:			; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+A5j
					; _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC:loc_13DCj
		cmp	[ebp+var_5C], 4
		jnb	short loc_13DE
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_13BC
		mov	eax, [ebp+var_8]
		movzx	edx, byte ptr [eax]
		mov	ecx, [ebp+var_5C]
		shl	ecx, 3
		shl	edx, cl
		or	edx, [ebp+var_50]
		mov	[ebp+var_50], edx
		mov	eax, [ebp+var_44]
		add	eax, [ebp+var_5C]
		mov	ecx, [ebp+var_8]
		mov	dl, [ecx]
		mov	[eax], dl
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax
		mov	ecx, [ebp+var_8]
		add	ecx, 1
		mov	[ebp+var_8], ecx
		jmp	short loc_13DC
; ---------------------------------------------------------------------------

loc_13BC:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+D9j
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+2Ch], eax
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_5C]
		mov	[ecx+24h], dl
		jmp	$donefornow$8856
; ---------------------------------------------------------------------------

loc_13DC:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+10Ej
		jmp	short $morebytes$8843
; ---------------------------------------------------------------------------

loc_13DE:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+D1j
		cmp	[ebp+var_50], 10FFFFh
		ja	loc_14C1
		mov	eax, [ebp+var_50]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jz	loc_14C1
		cmp	[ebp+var_50], 0FFFFh
		ja	short loc_1430
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_50]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_68]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		jmp	loc_14BF
; ---------------------------------------------------------------------------

loc_1430:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+159j
		mov	eax, [ebp+var_50]
		shr	eax, 0Ah
		add	eax, 0D7C0h
		mov	ecx, [ebp+var_14]
		mov	[ecx], ax
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_68]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		mov	eax, [ebp+var_50]
		and	eax, 3FFh
		or	eax, 0DC00h
		movzx	ecx, ax
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_149C
		mov	eax, [ebp+var_14]
		mov	cx, word ptr [ebp+var_50]
		mov	[eax], cx
		mov	edx, [ebp+var_14]
		add	edx, 2
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_68]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		jmp	short loc_14BF
; ---------------------------------------------------------------------------

loc_149C:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+1C8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dx, word ptr [ebp+var_50]
		mov	[ecx+74h], dx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+41h], 1
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh
		jmp	short $donefornow$8856
; ---------------------------------------------------------------------------

loc_14BF:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+17Fj
					; _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+1EEj
		jmp	short loc_14D8
; ---------------------------------------------------------------------------

loc_14C1:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+139j
					; _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+14Cj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+var_5C]
		mov	[ecx+24h], dl
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	short $donefornow$8856
; ---------------------------------------------------------------------------

loc_14D8:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC:loc_14BFj
		mov	eax, [ebp+var_68]
		add	eax, [ebp+var_5C]
		mov	[ebp+var_68], eax
		jmp	loc_1353
; ---------------------------------------------------------------------------

$donefornow$8856:			; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+ADj
					; _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+B9j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_1507
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jb	short loc_1507
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_1507
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_1507:				; CODE XREF: _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+240j
					; _T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC+248j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+18h], ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 152Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_fromUnicode_UTF32_LE proc	near ; DATA XREF: .rdata:000001C0o
					; .rdata:00000360o

var_120		= byte ptr -120h
var_5C		= byte ptr -5Ch
var_5B		= byte ptr -5Bh
var_5A		= byte ptr -5Ah
var_59		= byte ptr -59h
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 120h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_120]
		mov	ecx, 48h ; 'H'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jb	short loc_1572
		jmp	loc_17A4
; ---------------------------------------------------------------------------

loc_1572:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+3Fj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+34h], 1
		jnz	short loc_15BC
		mov	eax, [ebp+arg_4]
		push	eax
		push	0FFFFFFFFh
		mov	ecx, [ebp+arg_0]
		add	ecx, 18h
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		push	ecx
		push	4
		push	offset ?bom@?3??T_UConverter_fromUnicode_UTF32_LE@@9@9 ; `T_UConverter_fromUnicode_UTF32_LE'::`4'::bom
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		push	eax
		call	_ucnv_fromUWriteBytes_56
		add	esp, 20h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+34h], 0

loc_15BC:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+50j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	[ebp+var_59], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+38h], 0
		jz	short loc_15F0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+38h]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+38h], 0
		jmp	short $lowsurogate$8895
; ---------------------------------------------------------------------------

loc_15F0:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+A7j
					; _T_UConverter_fromUnicode_UTF32_LE:loc_176Cj
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	loc_1771
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	loc_1771
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_38], ecx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_16E0
		mov	eax, [ebp+var_38]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	loc_16C6

$lowsurogate$8895:			; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+C2j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_169F
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_1683
		mov	eax, [ebp+var_38]
		sub	eax, 0D800h
		shl	eax, 0Ah
		mov	ecx, [ebp+var_44]
		lea	edx, [eax+ecx+2400h]
		mov	[ebp+var_38], edx
		mov	eax, [ebp+var_8]
		add	eax, 2
		mov	[ebp+var_8], eax
		jmp	short loc_169D
; ---------------------------------------------------------------------------

loc_1683:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+132j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_38]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_1771
; ---------------------------------------------------------------------------

loc_169D:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+155j
		jmp	short loc_16C4
; ---------------------------------------------------------------------------

loc_169F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+11Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_38]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	short loc_16BF
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_16BF:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+188j
		jmp	loc_1771
; ---------------------------------------------------------------------------

loc_16C4:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE:loc_169Dj
		jmp	short loc_16E0
; ---------------------------------------------------------------------------

loc_16C6:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+10Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_38]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_1771
; ---------------------------------------------------------------------------

loc_16E0:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+FBj
					; _T_UConverter_fromUnicode_UTF32_LE:loc_16C4j
		mov	eax, [ebp+var_38]
		sar	eax, 10h
		and	eax, 1Fh
		mov	[ebp+var_5A], al
		mov	eax, [ebp+var_38]
		sar	eax, 8
		mov	[ebp+var_5B], al
		mov	al, byte ptr [ebp+var_38]
		mov	[ebp+var_5C], al
		mov	[ebp+var_50], 0
		jmp	short loc_170D
; ---------------------------------------------------------------------------

loc_1704:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE:loc_176Aj
		mov	eax, [ebp+var_50]
		add	eax, 1
		mov	[ebp+var_50], eax

loc_170D:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+1D6j
		cmp	[ebp+var_50], 3
		ja	short loc_176C
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_1732
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_50]
		mov	dl, [ebp+ecx+var_5C]
		mov	[eax], dl
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	short loc_176A
; ---------------------------------------------------------------------------

loc_1732:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+1EDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_50]
		mov	al, [ebp+eax+var_5C]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_176A:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+204j
		jmp	short loc_1704
; ---------------------------------------------------------------------------

loc_176C:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+1E5j
		jmp	loc_15F0
; ---------------------------------------------------------------------------

loc_1771:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+CAj
					; _T_UConverter_fromUnicode_UTF32_LE+D6j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_20]
		jnb	short loc_1792
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_2C]
		jb	short loc_1792
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_1792
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_1792:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+24Bj
					; _T_UConverter_fromUnicode_UTF32_LE+253j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx

loc_17A4:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE+41j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24_1
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 120h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_fromUnicode_UTF32_LE endp

; ---------------------------------------------------------------------------
		align 4
$LN24_1		dd 1			; DATA XREF: _T_UConverter_fromUnicode_UTF32_LE+27Co
		dd offset $LN23_1
$LN23_1		dd 0FFFFFFA4h, 4	; DATA XREF: .text:000017D0o
		dd offset $LN22_1	; "temp"
$LN22_1		db 'temp',0             ; DATA XREF: .text:000017DCo
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 17E8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC	proc near ; DATA XREF: .rdata:000001C4o
					; .rdata:00000364o

var_138		= byte ptr -138h
var_74		= dword	ptr -74h
var_68		= byte ptr -68h
var_67		= byte ptr -67h
var_66		= byte ptr -66h
var_65		= byte ptr -65h
var_5C		= dword	ptr -5Ch
var_50		= dword	ptr -50h
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_138]
		mov	ecx, 4Eh ; 'N'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+14h]
		mov	[ebp+var_38], ecx
		mov	[ebp+var_74], 0
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jb	short loc_1835
		jmp	loc_1A9E
; ---------------------------------------------------------------------------

loc_1835:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+46j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+34h], 1
		jnz	short loc_187F
		mov	eax, [ebp+arg_4]
		push	eax
		push	0FFFFFFFFh
		mov	ecx, [ebp+arg_0]
		add	ecx, 18h
		push	ecx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+14h]
		push	eax
		mov	ecx, [ebp+arg_0]
		add	ecx, 10h
		push	ecx
		push	4
		push	offset ?bom@?3??T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC@@9@9 ; `T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC'::`4'::bom
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		push	eax
		call	_ucnv_fromUWriteBytes_56
		add	esp, 20h
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+34h], 0

loc_187F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+57j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+10h]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_20], ecx
		mov	[ebp+var_65], 0
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		cmp	dword ptr [ecx+38h], 0
		jz	short loc_18BC
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+38h]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dword ptr [ecx+38h], 0
		jmp	short $lowsurogate$8944
; ---------------------------------------------------------------------------

loc_18BC:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+B7j
					; _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+275j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	loc_1A62
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	loc_1A62
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_44], ecx
		mov	edx, [ebp+var_8]
		add	edx, 2
		mov	[ebp+var_8], edx
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jnz	loc_19AC
		mov	eax, [ebp+var_44]
		and	eax, 0FFFFFC00h
		cmp	eax, 0D800h
		jnz	loc_1992

$lowsurogate$8944:			; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+D2j
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_196B
		mov	eax, [ebp+var_8]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_50], ecx
		mov	eax, [ebp+var_50]
		and	eax, 0FFFFFC00h
		cmp	eax, 0DC00h
		jnz	short loc_194F
		mov	eax, [ebp+var_44]
		sub	eax, 0D800h
		shl	eax, 0Ah
		mov	ecx, [ebp+var_50]
		lea	edx, [eax+ecx+2400h]
		mov	[ebp+var_44], edx
		mov	eax, [ebp+var_8]
		add	eax, 2
		mov	[ebp+var_8], eax
		jmp	short loc_1969
; ---------------------------------------------------------------------------

loc_194F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+142j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_44]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_1A62
; ---------------------------------------------------------------------------

loc_1969:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+165j
		jmp	short loc_1990
; ---------------------------------------------------------------------------

loc_196B:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+12Aj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_44]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	short loc_198B
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch

loc_198B:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+198j
		jmp	loc_1A62
; ---------------------------------------------------------------------------

loc_1990:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC:loc_1969j
		jmp	short loc_19AC
; ---------------------------------------------------------------------------

loc_1992:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+11Ej
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+var_44]
		mov	[ecx+38h], edx
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		jmp	loc_1A62
; ---------------------------------------------------------------------------

loc_19AC:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+10Bj
					; _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC:loc_1990j
		mov	eax, [ebp+var_44]
		sar	eax, 10h
		and	eax, 1Fh
		mov	[ebp+var_66], al
		mov	eax, [ebp+var_44]
		sar	eax, 8
		mov	[ebp+var_67], al
		mov	al, byte ptr [ebp+var_44]
		mov	[ebp+var_68], al
		mov	[ebp+var_5C], 0
		jmp	short loc_19D9
; ---------------------------------------------------------------------------

loc_19D0:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC:loc_1A47j
		mov	eax, [ebp+var_5C]
		add	eax, 1
		mov	[ebp+var_5C], eax

loc_19D9:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+1E6j
		cmp	[ebp+var_5C], 3
		ja	short loc_1A49
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jnb	short loc_1A0F
		mov	eax, [ebp+var_14]
		mov	ecx, [ebp+var_5C]
		mov	dl, [ebp+ecx+var_68]
		mov	[eax], dl
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_20]
		mov	ecx, [ebp+var_74]
		mov	[eax], ecx
		mov	edx, [ebp+var_20]
		add	edx, 4
		mov	[ebp+var_20], edx
		jmp	short loc_1A47
; ---------------------------------------------------------------------------

loc_1A0F:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+1FDj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		movsx	edx, byte ptr [eax+3Fh]
		mov	eax, [ebp+var_5C]
		mov	al, [ebp+eax+var_68]
		mov	[ecx+edx+4Ch], al
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	al, [edx+3Fh]
		add	al, 1
		mov	ecx, [ebp+arg_0]
		mov	edx, [ecx+4]
		mov	[edx+3Fh], al
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_1A47:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+225j
		jmp	short loc_19D0
; ---------------------------------------------------------------------------

loc_1A49:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+1F5j
		movzx	eax, [ebp+var_66]
		neg	eax
		sbb	eax, eax
		neg	eax
		mov	ecx, [ebp+var_74]
		lea	edx, [ecx+eax+1]
		mov	[ebp+var_74], edx
		jmp	loc_18BC
; ---------------------------------------------------------------------------

loc_1A62:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+DAj
					; _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+E6j ...
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_2C]
		jnb	short loc_1A83
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_38]
		jb	short loc_1A83
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	short loc_1A83
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Fh

loc_1A83:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+280j
					; _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+288j	...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+10h], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_8]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+18h], ecx

loc_1A9E:				; CODE XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+48j
		push	edx
		mov	ecx, ebp
		push	eax
		lea	edx, $LN24_2
		call	@_RTC_CheckStackVars@8 ; _RTC_CheckStackVars(x,x)
		pop	eax
		pop	edx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 138h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC	endp

; ---------------------------------------------------------------------------
		align 4
$LN24_2		dd 1			; DATA XREF: _T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC+2BAo
		dd offset $LN23_2
$LN23_2		dd 0FFFFFF98h, 4	; DATA XREF: .text:00001AC8o
		dd offset $LN22_2	; "temp"
$LN22_2		db 'temp',0             ; DATA XREF: .text:00001AD4o
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1AE0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_T_UConverter_getNextUChar_UTF32_LE proc near ;	CODE XREF: __UTF32GetNextUChar+5Bp
					; DATA XREF: .rdata:000001C8o

var_E4		= byte ptr -0E4h
Size		= dword	ptr -20h
var_14		= dword	ptr -14h
Src		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+Src], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+Src]
		cmp	ecx, [eax+0Ch]
		jb	short loc_1B25
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 8
		mov	eax, 0FFFFh
		jmp	loc_1C1E
; ---------------------------------------------------------------------------

loc_1B25:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_LE+30j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		sub	ecx, [ebp+Src]
		mov	[ebp+Size], ecx
		cmp	[ebp+Size], 4
		jge	short loc_1B8A
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		add	ecx, 25h ; '%'
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	dl, byte ptr [ebp+Size]
		mov	[ecx+24h], dl
		mov	eax, [ebp+Src]
		add	eax, [ebp+Size]
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Bh
		mov	eax, 0FFFFh
		jmp	loc_1C1E
; ---------------------------------------------------------------------------

loc_1B8A:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_LE+55j
		mov	eax, [ebp+Src]
		movzx	ecx, byte ptr [eax+3]
		shl	ecx, 18h
		mov	edx, [ebp+Src]
		movzx	eax, byte ptr [edx+2]
		shl	eax, 10h
		or	ecx, eax
		mov	edx, [ebp+Src]
		movzx	eax, byte ptr [edx+1]
		shl	eax, 8
		or	ecx, eax
		mov	edx, [ebp+Src]
		movzx	eax, byte ptr [edx]
		or	ecx, eax
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+Src]
		add	eax, 4
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		cmp	[ebp+var_14], 10FFFFh
		ja	short loc_1BE0
		mov	eax, [ebp+var_14]
		and	eax, 0FFFFF800h
		cmp	eax, 0D800h
		jz	short loc_1BE0
		mov	eax, [ebp+var_14]
		jmp	short loc_1C1E
; ---------------------------------------------------------------------------

loc_1BE0:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_LE+EAj
					; _T_UConverter_getNextUChar_UTF32_LE+F9j
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		push	4		; Size
		mov	ecx, [ebp+Src]
		push	ecx		; Src
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		add	eax, 25h ; '%'
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	byte ptr [ecx+24h], 4
		mov	eax, [ebp+arg_4]
		mov	dword ptr [eax], 0Ch
		mov	eax, 0FFFFh

loc_1C1E:				; CODE XREF: _T_UConverter_getNextUChar_UTF32_LE+40j
					; _T_UConverter_getNextUChar_UTF32_LE+A5j ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_T_UConverter_getNextUChar_UTF32_LE endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C34h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__UTF32Reset	proc near		; CODE XREF: __UTF32Open+24p
					; DATA XREF: .rdata:00000354o

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_4], 1
		jg	short loc_1C62
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+30h], 0

loc_1C62:				; CODE XREF: __UTF32Reset+22j
		cmp	[ebp+arg_4], 1
		jz	short loc_1C72
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+34h], 1

loc_1C72:				; CODE XREF: __UTF32Reset+32j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
__UTF32Reset	endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1C7Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__UTF32Open	proc near		; DATA XREF: .rdata:0000034Co

var_C0		= byte ptr -0C0h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		push	0
		mov	eax, [ebp+arg_0]
		push	eax
		call	__UTF32Reset
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__UTF32Open	endp

_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1CBCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__UTF32ToUnicodeWithOffsets proc near	; DATA XREF: .rdata:00000358o
					; .rdata:0000035Co

var_13C		= dword	ptr -13Ch
var_74		= dword	ptr -74h
var_65		= byte ptr -65h
var_5C		= dword	ptr -5Ch
var_4D		= byte ptr -4Dh
var_44		= dword	ptr -44h
var_38		= dword	ptr -38h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 13Ch
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_13C]
		mov	ecx, 4Fh ; 'O'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	[ebp+var_20], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_2C], ecx
		mov	eax, [ebp+var_8]
		mov	ecx, [eax+30h]
		mov	[ebp+var_38], ecx
		mov	[ebp+var_44], 0

loc_1D0E:				; CODE XREF: __UTF32ToUnicodeWithOffsets+C6j
					; __UTF32ToUnicodeWithOffsets+1B6j ...
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jnb	loc_1EF4
		mov	eax, [ebp+arg_4]
		cmp	dword ptr [eax], 0
		jg	loc_1EF4
		mov	eax, [ebp+var_38]
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 9 ; switch 10 cases
		ja	$LN31		; jumptable 00001D49 default case
		mov	ecx, [ebp+var_13C]
		movzx	edx, ds:$LN39[ecx]
		jmp	ds:$LN40[edx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: __UTF32ToUnicodeWithOffsets+8Dj
					; DATA XREF: .text:$LN40o
		mov	eax, [ebp+var_14] ; jumptable 00001D49 case 0
		mov	cl, [eax]
		mov	[ebp+var_4D], cl
		movsx	eax, [ebp+var_4D]
		test	eax, eax
		jnz	short loc_1D69
		mov	[ebp+var_38], 1
		jmp	short loc_1D84
; ---------------------------------------------------------------------------

loc_1D69:				; CODE XREF: __UTF32ToUnicodeWithOffsets+A2j
		movsx	eax, [ebp+var_4D]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_1D7B
		mov	[ebp+var_38], 5
		jmp	short loc_1D84
; ---------------------------------------------------------------------------

loc_1D7B:				; CODE XREF: __UTF32ToUnicodeWithOffsets+B4j
		mov	[ebp+var_38], 8
		jmp	short loc_1D0E
; ---------------------------------------------------------------------------

loc_1D84:				; CODE XREF: __UTF32ToUnicodeWithOffsets+ABj
					; __UTF32ToUnicodeWithOffsets+BDj
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		jmp	$LN31		; jumptable 00001D49 default case
; ---------------------------------------------------------------------------

$LN25:					; CODE XREF: __UTF32ToUnicodeWithOffsets+8Dj
					; DATA XREF: .text:$LN40o
		mov	eax, [ebp+var_14] ; jumptable 00001D49 cases 1-3,5-7
		movsx	ecx, byte ptr [eax]
		mov	edx, [ebp+var_38]
		movsx	eax, _utf32BOM[edx]
		cmp	ecx, eax
		jnz	short loc_1DF1
		mov	eax, [ebp+var_38]
		add	eax, 1
		mov	[ebp+var_38], eax
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		cmp	[ebp+var_38], 4
		jnz	short loc_1DD3
		mov	[ebp+var_38], 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	[ebp+var_44], ecx
		jmp	short loc_1DEC
; ---------------------------------------------------------------------------

loc_1DD3:				; CODE XREF: __UTF32ToUnicodeWithOffsets+100j
		cmp	[ebp+var_38], 8
		jnz	short loc_1DEC
		mov	[ebp+var_38], 9
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	[ebp+var_44], ecx

loc_1DEC:				; CODE XREF: __UTF32ToUnicodeWithOffsets+115j
					; __UTF32ToUnicodeWithOffsets+11Bj
		jmp	loc_1E77
; ---------------------------------------------------------------------------

loc_1DF1:				; CODE XREF: __UTF32ToUnicodeWithOffsets+E8j
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		sub	ecx, [eax+8]
		mov	[ebp+var_5C], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_38]
		and	eax, 3
		cmp	[ebp+var_5C], eax
		jnz	short loc_1E13
		jmp	short loc_1E6B
; ---------------------------------------------------------------------------

loc_1E13:				; CODE XREF: __UTF32ToUnicodeWithOffsets+153j
		mov	eax, [ebp+arg_0]
		mov	cl, [eax+2]
		mov	[ebp+var_65], cl
		mov	eax, [ebp+var_38]
		and	eax, 4
		add	eax, offset _utf32BOM
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_38]
		and	eax, 3
		sub	eax, [ebp+var_5C]
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+8]
		mov	edx, [ebp+arg_0]
		mov	[edx+0Ch], eax
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax+2], 0
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_BE
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+0Ch], ecx
		mov	eax, [ebp+arg_0]
		mov	cl, [ebp+var_65]
		mov	[eax+2], cl

loc_1E6B:				; CODE XREF: __UTF32ToUnicodeWithOffsets+155j
		mov	[ebp+var_38], 8
		jmp	loc_1D0E
; ---------------------------------------------------------------------------

loc_1E77:				; CODE XREF: __UTF32ToUnicodeWithOffsets:loc_1DECj
		jmp	short $LN31	; jumptable 00001D49 default case
; ---------------------------------------------------------------------------

$LN17:					; CODE XREF: __UTF32ToUnicodeWithOffsets+8Dj
					; DATA XREF: .text:$LN40o
		mov	eax, [ebp+arg_0] ; jumptable 00001D49 case 8
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		cmp	[ebp+var_2C], 0
		jnz	short loc_1E9A
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_BE
		add	esp, 8
		jmp	short loc_1EAA
; ---------------------------------------------------------------------------

loc_1E9A:				; CODE XREF: __UTF32ToUnicodeWithOffsets+1CAj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC
		add	esp, 8

loc_1EAA:				; CODE XREF: __UTF32ToUnicodeWithOffsets+1DCj
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx
		jmp	short $LN31	; jumptable 00001D49 default case
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: __UTF32ToUnicodeWithOffsets+8Dj
					; DATA XREF: .text:$LN40o
		mov	eax, [ebp+arg_0] ; jumptable 00001D49 case 9
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		cmp	[ebp+var_2C], 0
		jnz	short loc_1ED6
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_LE
		add	esp, 8
		jmp	short loc_1EE6
; ---------------------------------------------------------------------------

loc_1ED6:				; CODE XREF: __UTF32ToUnicodeWithOffsets+206j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC
		add	esp, 8

loc_1EE6:				; CODE XREF: __UTF32ToUnicodeWithOffsets+218j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		mov	[ebp+var_14], ecx

$LN31:					; CODE XREF: __UTF32ToUnicodeWithOffsets+7Aj
					; __UTF32ToUnicodeWithOffsets+8Dj ...
		jmp	loc_1D0E	; jumptable 00001D49 default case
; ---------------------------------------------------------------------------

loc_1EF4:				; CODE XREF: __UTF32ToUnicodeWithOffsets+58j
					; __UTF32ToUnicodeWithOffsets+64j
		cmp	[ebp+var_2C], 0
		jz	short loc_1F29
		cmp	[ebp+var_44], 0
		jz	short loc_1F29
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+18h]
		mov	[ebp+var_74], ecx

loc_1F09:				; CODE XREF: __UTF32ToUnicodeWithOffsets+26Bj
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+var_74]
		jnb	short loc_1F29
		mov	eax, [ebp+var_2C]
		mov	ecx, [eax]
		add	ecx, [ebp+var_44]
		mov	edx, [ebp+var_2C]
		mov	[edx], ecx
		mov	eax, [ebp+var_2C]
		add	eax, 4
		mov	[ebp+var_2C], eax
		jmp	short loc_1F09
; ---------------------------------------------------------------------------

loc_1F29:				; CODE XREF: __UTF32ToUnicodeWithOffsets+23Cj
					; __UTF32ToUnicodeWithOffsets+242j ...
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		mov	eax, [ebp+var_14]
		cmp	eax, [ebp+var_20]
		jnz	loc_1FE5
		mov	eax, [ebp+arg_0]
		movsx	ecx, byte ptr [eax+2]
		test	ecx, ecx
		jz	loc_1FE5
		mov	eax, [ebp+var_38]
		mov	[ebp+var_13C], eax
		cmp	[ebp+var_13C], 0
		jz	short loc_1F73
		cmp	[ebp+var_13C], 8
		jz	short loc_1F75
		cmp	[ebp+var_13C], 9
		jz	short loc_1F87
		jmp	short loc_1F99
; ---------------------------------------------------------------------------

loc_1F73:				; CODE XREF: __UTF32ToUnicodeWithOffsets+2A1j
		jmp	short loc_1FE5
; ---------------------------------------------------------------------------

loc_1F75:				; CODE XREF: __UTF32ToUnicodeWithOffsets+2AAj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_BE
		add	esp, 8
		jmp	short loc_1FE5
; ---------------------------------------------------------------------------

loc_1F87:				; CODE XREF: __UTF32ToUnicodeWithOffsets+2B3j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_LE
		add	esp, 8
		jmp	short loc_1FE5
; ---------------------------------------------------------------------------

loc_1F99:				; CODE XREF: __UTF32ToUnicodeWithOffsets+2B5j
		mov	eax, [ebp+var_38]
		and	eax, 4
		add	eax, offset _utf32BOM
		mov	ecx, [ebp+arg_0]
		mov	[ecx+8], eax
		mov	eax, [ebp+var_38]
		and	eax, 3
		mov	ecx, [ebp+arg_0]
		add	eax, [ecx+8]
		mov	edx, [ebp+arg_0]
		mov	[edx+0Ch], eax
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_toUnicode_UTF32_BE
		add	esp, 8
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_14]
		mov	[eax+8], ecx
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+var_20]
		mov	[eax+0Ch], ecx
		mov	[ebp+var_38], 8

loc_1FE5:				; CODE XREF: __UTF32ToUnicodeWithOffsets+27Cj
					; __UTF32ToUnicodeWithOffsets+28Bj ...
		mov	eax, [ebp+var_8]
		mov	ecx, [ebp+var_38]
		mov	[eax+30h], ecx
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 13Ch
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__UTF32ToUnicodeWithOffsets endp

; ---------------------------------------------------------------------------
		align 4
$LN40		dd offset $LN30		; DATA XREF: __UTF32ToUnicodeWithOffsets+8Dr
		dd offset $LN25		; jump table for switch	statement
		dd offset $LN17
		dd offset $LN14
		dd offset $LN31
$LN39		db	0,     1,     1,     1 ; DATA XREF: __UTF32ToUnicodeWithOffsets+86r
		db	4,     1,     1,     1 ; indirect table	for switch statement
		db	2,     3
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 2024h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

__UTF32GetNextUChar proc near		; DATA XREF: .rdata:00000368o

var_C4		= dword	ptr -0C4h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0C4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C4]
		mov	ecx, 31h ; '1'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+4]
		mov	edx, [ecx+30h]
		mov	[ebp+var_C4], edx
		cmp	[ebp+var_C4], 8
		jz	short loc_2065
		cmp	[ebp+var_C4], 9
		jz	short loc_2077
		jmp	short loc_2089
; ---------------------------------------------------------------------------

loc_2065:				; CODE XREF: __UTF32GetNextUChar+34j
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_getNextUChar_UTF32_BE
		add	esp, 8
		jmp	short loc_208E
; ---------------------------------------------------------------------------

loc_2077:				; CODE XREF: __UTF32GetNextUChar+3Dj
		mov	eax, [ebp+arg_4]
		push	eax
		mov	ecx, [ebp+arg_0]
		push	ecx
		call	_T_UConverter_getNextUChar_UTF32_LE
		add	esp, 8
		jmp	short loc_208E
; ---------------------------------------------------------------------------

loc_2089:				; CODE XREF: __UTF32GetNextUChar+3Fj
		mov	eax, 0FFFFFFF7h

loc_208E:				; CODE XREF: __UTF32GetNextUChar+51j
					; __UTF32GetNextUChar+63j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0C4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
__UTF32GetNextUChar endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _ucnv_getNonSurrogateUnicodeSet_56:near ;	DATA XREF: .rdata:00000044o
					; .rdata:000001DCo ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _ucnv_fromUWriteBytes_56:near
					; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+7Bp
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+82p ...
		extrn __RTC_CheckEsp:near
					; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+294p
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+2D2p	...
; __fastcall _RTC_CheckStackVars(x, x)
		extrn @_RTC_CheckStackVars@8:near
					; CODE XREF: _T_UConverter_fromUnicode_UTF32_BE+282p
					; _T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC+2C0p	...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _T_UConverter_getNextUChar_UTF32_BE+77p
					; _T_UConverter_getNextUChar_UTF32_BE+11Ep ...
		extrn _uprv_checkValidMemory:near
					; CODE XREF: _T_UConverter_getNextUChar_UTF32_BE+5Dp
					; _T_UConverter_getNextUChar_UTF32_BE+106p ...


		end
