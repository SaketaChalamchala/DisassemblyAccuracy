;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	1D6DA6DE13717A007E76FD436A6407C5
; Input	CRC32 :	E7106282

; File Name   :	D:\compspace\objfiles\firefox\common\uinvchar.obj
; Format      :	COFF (X386MAGIC)
; includelib "msvcprtd"
; includelib "MSVCRTD"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
_asciiFromEbcdic db 0			; DATA XREF: _uprv_asciiFromEbcdic_56+9Ar
					; _uprv_copyEbcdic_56+94r ...
		db 1, 2, 3
		dd 7F000900h, 0B000000h, 0F0E0D0Ch, 13121110h, 80A00h
		dd 1918h, 1F1E1D1Ch, 0
		dd 1B170A00h, 0
		dd 7060500h
dword_30	dd 160000h, 4000000h, 0	; DATA XREF: .rdata:`string'o
		dd 1A001514h, 20h, 0
		dd 2E000000h, 7C2B283Ch, 26h, 0
		dd 24210000h, 5E3B292Ah, 2F2Dh,	0
		dd 2C000000h, 3F3E5F25h, 2 dup(0)
		dd 233A6000h, 223D2740h, 63626100h, 67666564h, 6968h, 0
		dd 6C6B6A00h, 706F6E6Dh, 7271h,	0
		dd 74737E00h, 78777675h, 7A79h,	5B00h, 5Eh
		db 3 dup(0)
byte_B7		db 0			; DATA XREF: .data:`u_charsToUChars_56'::`2'::__LINE__Varo
		dd 5D5B0000h, 5D00h, 4342417Bh,	47464544h
		db 48h,	49h
word_CA		dw 0			; DATA XREF: .data:`u_UCharsToChars_56'::`2'::__LINE__Varo
		align 10h
aJklmnopqr	db '}JKLMNOPQR',0
		align 10h
		db '\',0
aStuvwxyz	db 'STUVWXYZ',0
		align 10h
a0123456789	db '0123456789',0
		align 10h
_ebcdicFromAscii db 0			; DATA XREF: _uprv_ebcdicFromAscii_56+E5r
					; _uprv_eastrncpy_56+52r
		db 1, 2, 3
		dd 2F2E2D37h, 0B000516h, 0F0E0D0Ch, 13121110h, 26323D3Ch
		dd 273F1918h, 1F1E1D1Ch, 7F0040h, 7D506C00h, 4E5C5D4Dh
		dd 614B606Bh, 0F3F2F1F0h, 0F7F6F5F4h, 5E7AF9F8h
		db 4Ch,	7Eh, 6Eh
byte_13F	db 6Fh			; DATA XREF: _uprv_eastrncpy_56+6Cr
		dd 0C3C2C100h, 0C7C6C5C4h, 0D2D1C9C8h, 0D6D5D4D3h, 0E2D9D8D7h
		dd 0E6E5E4E3h, 0E9E8E7h, 6D000000h, 83828100h, 87868584h
		dd 92918988h, 96959493h, 0A2999897h, 0A6A5A4A3h, 0A9A8A7h
		dd 7000000h, 20h dup(0)
_lowercaseAsciiFromEbcdic db 0		; DATA XREF: _uprv_ebcdicToLowercaseAscii_56+22r
		db 1, 2, 3
		dd 7F000900h, 0B000000h, 0F0E0D0Ch, 13121110h, 80A00h
		dd 1918h, 1F1E1D1Ch, 0
		dd 1B170A00h, 0
		dd 7060500h, 160000h, 4000000h,	0
		dd 1A001514h, 20h, 0
		dd 2E000000h, 7C2B283Ch, 26h, 0
		dd 24210000h, 5E3B292Ah, 2F2Dh,	0
		dd 2C000000h, 3F3E5F25h, 2 dup(0)
		dd 233A6000h, 223D2740h, 63626100h, 67666564h, 6968h, 0
		dd 6C6B6A00h, 706F6E6Dh, 7271h,	0
		dd 74737E00h, 78777675h, 7A79h,	5B00h, 5Eh, 0
		dd 5D5B0000h, 5D00h, 6362617Bh,	67666564h, 6968h, 0
aJklmnopqr_0	db '}jklmnopqr',0
		align 10h
		db '|',0
aStuvwxyz_0	db 'stuvwxyz',0
		align 10h
a0123456789_0	db '0123456789',0
		align 10h
_invariantChars	dd 0FFFFFBFFh		; DATA XREF: _u_UCharsToChars_56+59r
					; _uprv_isInvariantString_56+8Br ...
		dd 0FFFFFFE5h, 2 dup(87FFFFFEh)
_rdata		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 310h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_charsToUChars_56
_u_charsToUChars_56 proc near

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_32E:				; CODE XREF: _u_charsToUChars_56+90j
		cmp	[ebp+arg_8], 0
		jle	short loc_3A2
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movzx	ax, [ebp+var_11]
		mov	[ebp+var_8], ax
		movzx	eax, [ebp+var_8]
		test	eax, eax
		jnz	short loc_384
		movzx	ecx, [ebp+var_11]
		test	ecx, ecx
		jz	short loc_384
		mov	edx, ds:?__LINE__Var@?1??u_charsToUChars_56@@9@9 ; `u_charsToUChars_56'::`2'::__LINE__Var
		add	edx, 0Ch
		mov	esi, esp
		push	edx		; Line
		push	offset ??_C@_1FK@HJLLJGBM@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_1BO@OMJPKALG@?$AA?$CI?$AAu?$AA?$CB?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAc?$AA?$DN?$AA?$DN?$AA0?$AA?$CJ?$AA?$AA@ ; "(u!=0 ||	c==0)"
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_384:				; CODE XREF: _u_charsToUChars_56+44j
					; _u_charsToUChars_56+4Cj
		mov	eax, [ebp+arg_4]
		mov	cx, [ebp+var_8]
		mov	[eax], cx
		mov	edx, [ebp+arg_4]
		add	edx, 2
		mov	[ebp+arg_4], edx
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_32E
; ---------------------------------------------------------------------------

loc_3A2:				; CODE XREF: _u_charsToUChars_56+22j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_charsToUChars_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3B8h
		public ??_C@_1BO@OMJPKALG@?$AA?$CI?$AAu?$AA?$CB?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAc?$AA?$DN?$AA?$DN?$AA0?$AA?$CJ?$AA?$AA@
; wchar_t `string'
??_C@_1BO@OMJPKALG@?$AA?$CI?$AAu?$AA?$CB?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAc?$AA?$DN?$AA?$DN?$AA0?$AA?$CJ?$AA?$AA@:
					; DATA XREF: _u_charsToUChars_56+5Fo
		unicode	0, <(u!=0 || c==0)>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 3D8h
		public ??_C@_1FK@HJLLJGBM@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
; wchar_t `string'
??_C@_1FK@HJLLJGBM@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@:
					; DATA XREF: _u_charsToUChars_56+5Ao
					; _u_UCharsToChars_56+72o
		unicode	0, <d:\mozilla\intl\icu\source\common\uinvchar.c>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 434h
		public ?__LINE__Var@?1??u_charsToUChars_56@@9@9
; `u_charsToUChars_56'::`2'::__LINE__Var
?__LINE__Var@?1??u_charsToUChars_56@@9@9 dd offset byte_B7
					; DATA XREF: _u_charsToUChars_56+4Er
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$TMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$TMZ
		;org 438h
__RTC_Shutdown_rtc$TMZ dd offset __RTC_Shutdown
_rtc$TMZ	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rtc$IMZ	segment	dword public 'DATA' use32
		assume cs:_rtc$IMZ
		;org 43Ch
__RTC_InitBase_rtc$IMZ dd offset __RTC_InitBase
_rtc$IMZ	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 440h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _u_UCharsToChars_56
_u_UCharsToChars_56 proc near

var_CC		= byte ptr -0CCh
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_45E:				; CODE XREF: _u_UCharsToChars_56+ACj
		cmp	[ebp+arg_8], 0
		jle	loc_4F1
		mov	eax, [ebp+arg_0]
		mov	cx, [eax]
		mov	[ebp+var_8], cx
		mov	edx, [ebp+arg_0]
		add	edx, 2
		mov	[ebp+arg_0], edx
		movzx	eax, [ebp+var_8]
		cmp	eax, 7Fh ; ''
		jg	short loc_4A2
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		movzx	ecx, [ebp+var_8]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_4D2

loc_4A2:				; CODE XREF: _u_UCharsToChars_56+42j
		xor	eax, eax
		jnz	short loc_4CC
		mov	ecx, ds:?__LINE__Var@?1??u_UCharsToChars_56@@9@9 ; `u_UCharsToChars_56'::`2'::__LINE__Var
		add	ecx, 6
		mov	esi, esp
		push	ecx		; Line
		push	offset ??_C@_1FK@HJLLJGBM@?$AAd?$AA?3?$AA?2?$AAm?$AAo?$AAz?$AAi?$AAl?$AAl?$AAa?$AA?2?$AAi?$AAn?$AAt?$AAl?$AA?2?$AAi?$AAc?$AAu?$AA?2?$AAs?$AAo?$AAu?$AAr?$AAc?$AAe?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; "d:\\mozilla\\intl\\icu\\source\\common\"...
		push	offset ??_C@_13COJANIEC@?$AA0?$AA?$AA@ ; Message
		call	dword ptr ds:__imp___wassert
		add	esp, 0Ch
		cmp	esi, esp
		call	__RTC_CheckEsp

loc_4CC:				; CODE XREF: _u_UCharsToChars_56+64j
		xor	eax, eax
		mov	[ebp+var_8], ax

loc_4D2:				; CODE XREF: _u_UCharsToChars_56+60j
		mov	eax, [ebp+arg_4]
		mov	cl, byte ptr [ebp+var_8]
		mov	[eax], cl
		mov	edx, [ebp+arg_4]
		add	edx, 1
		mov	[ebp+arg_4], edx
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	loc_45E
; ---------------------------------------------------------------------------

loc_4F1:				; CODE XREF: _u_UCharsToChars_56+22j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_u_UCharsToChars_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 508h
		public ??_C@_13COJANIEC@?$AA0?$AA?$AA@
; wchar_t `string'
??_C@_13COJANIEC@?$AA0?$AA?$AA@	dd offset dword_30 ; DATA XREF:	_u_UCharsToChars_56+77o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 50Ch
		public ?__LINE__Var@?1??u_UCharsToChars_56@@9@9
; `u_UCharsToChars_56'::`2'::__LINE__Var
?__LINE__Var@?1??u_UCharsToChars_56@@9@9 dd offset word_CA
					; DATA XREF: _u_UCharsToChars_56+66r
_data		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 510h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uprv_isInvariantString_56
_uprv_isInvariantString_56 proc	near

var_CC		= byte ptr -0CCh
var_5		= byte ptr -5
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_52E:				; CODE XREF: _uprv_isInvariantString_56+6Bj
					; _uprv_isInvariantString_56:loc_5A8j
		cmp	[ebp+arg_4], 0
		jge	short loc_551
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_5], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movzx	eax, [ebp+var_5]
		test	eax, eax
		jnz	short loc_54F
		jmp	short loc_5AA
; ---------------------------------------------------------------------------

loc_54F:				; CODE XREF: _uprv_isInvariantString_56+3Bj
		jmp	short loc_57D
; ---------------------------------------------------------------------------

loc_551:				; CODE XREF: _uprv_isInvariantString_56+22j
		cmp	[ebp+arg_4], 0
		jnz	short loc_559
		jmp	short loc_5AA
; ---------------------------------------------------------------------------

loc_559:				; CODE XREF: _uprv_isInvariantString_56+45j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_0]
		mov	cl, [eax]
		mov	[ebp+var_5], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		movzx	eax, [ebp+var_5]
		test	eax, eax
		jnz	short loc_57D
		jmp	short loc_52E
; ---------------------------------------------------------------------------

loc_57D:				; CODE XREF: _uprv_isInvariantString_56:loc_54Fj
					; _uprv_isInvariantString_56+69j
		movzx	eax, [ebp+var_5]
		cmp	eax, 7Fh ; ''
		jg	short loc_5A4
		movzx	eax, [ebp+var_5]
		sar	eax, 5
		movzx	ecx, [ebp+var_5]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_5A8

loc_5A4:				; CODE XREF: _uprv_isInvariantString_56+74j
		xor	al, al
		jmp	short loc_5AC
; ---------------------------------------------------------------------------

loc_5A8:				; CODE XREF: _uprv_isInvariantString_56+92j
		jmp	short loc_52E
; ---------------------------------------------------------------------------

loc_5AA:				; CODE XREF: _uprv_isInvariantString_56+3Dj
					; _uprv_isInvariantString_56+47j
		mov	al, 1

loc_5AC:				; CODE XREF: _uprv_isInvariantString_56+96j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_isInvariantString_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 5B4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uprv_isInvariantUString_56
_uprv_isInvariantUString_56 proc near

var_CC		= byte ptr -0CCh
var_8		= word ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd

loc_5D2:				; CODE XREF: _uprv_isInvariantUString_56:loc_646j
		cmp	[ebp+arg_4], 0
		jge	short loc_5F7
		mov	eax, [ebp+arg_0]
		mov	cx, [eax]
		mov	[ebp+var_8], cx
		mov	edx, [ebp+arg_0]
		add	edx, 2
		mov	[ebp+arg_0], edx
		movzx	eax, [ebp+var_8]
		test	eax, eax
		jnz	short loc_5F5
		jmp	short loc_648
; ---------------------------------------------------------------------------

loc_5F5:				; CODE XREF: _uprv_isInvariantUString_56+3Dj
		jmp	short loc_61B
; ---------------------------------------------------------------------------

loc_5F7:				; CODE XREF: _uprv_isInvariantUString_56+22j
		cmp	[ebp+arg_4], 0
		jnz	short loc_5FF
		jmp	short loc_648
; ---------------------------------------------------------------------------

loc_5FF:				; CODE XREF: _uprv_isInvariantUString_56+47j
		mov	eax, [ebp+arg_4]
		sub	eax, 1
		mov	[ebp+arg_4], eax
		mov	eax, [ebp+arg_0]
		mov	cx, [eax]
		mov	[ebp+var_8], cx
		mov	edx, [ebp+arg_0]
		add	edx, 2
		mov	[ebp+arg_0], edx

loc_61B:				; CODE XREF: _uprv_isInvariantUString_56:loc_5F5j
		movzx	eax, [ebp+var_8]
		cmp	eax, 7Fh ; ''
		jg	short loc_642
		movzx	eax, [ebp+var_8]
		sar	eax, 5
		movzx	ecx, [ebp+var_8]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_646

loc_642:				; CODE XREF: _uprv_isInvariantUString_56+6Ej
		xor	al, al
		jmp	short loc_64A
; ---------------------------------------------------------------------------

loc_646:				; CODE XREF: _uprv_isInvariantUString_56+8Cj
		jmp	short loc_5D2
; ---------------------------------------------------------------------------

loc_648:				; CODE XREF: _uprv_isInvariantUString_56+3Fj
					; _uprv_isInvariantUString_56+49j
		mov	al, 1

loc_64A:				; CODE XREF: _uprv_isInvariantUString_56+90j
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_isInvariantUString_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 654h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uprv_ebcdicFromAscii_56
_uprv_ebcdicFromAscii_56 proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_680
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_687

loc_680:				; CODE XREF: _uprv_ebcdicFromAscii_56+22j
		xor	eax, eax
		jmp	loc_75B
; ---------------------------------------------------------------------------

loc_687:				; CODE XREF: _uprv_ebcdicFromAscii_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_6A5
		cmp	[ebp+arg_4], 0
		jz	short loc_6A5
		cmp	[ebp+arg_8], 0
		jl	short loc_6A5
		cmp	[ebp+arg_8], 0
		jle	short loc_6B5
		cmp	[ebp+arg_C], 0
		jnz	short loc_6B5

loc_6A5:				; CODE XREF: _uprv_ebcdicFromAscii_56+37j
					; _uprv_ebcdicFromAscii_56+3Dj	...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_75B
; ---------------------------------------------------------------------------

loc_6B5:				; CODE XREF: _uprv_ebcdicFromAscii_56+49j
					; _uprv_ebcdicFromAscii_56+4Fj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_2C], eax

loc_6C7:				; CODE XREF: _uprv_ebcdicFromAscii_56+FFj
		cmp	[ebp+var_2C], 0
		jle	loc_758
		mov	eax, [ebp+var_8]
		mov	cl, [eax]
		mov	[ebp+var_1D], cl
		mov	edx, [ebp+var_8]
		add	edx, 1
		mov	[ebp+var_8], edx
		movzx	eax, [ebp+var_1D]
		cmp	eax, 7Fh ; ''
		jg	short loc_709
		movzx	eax, [ebp+var_1D]
		sar	eax, 5
		movzx	ecx, [ebp+var_1D]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_732

loc_709:				; CODE XREF: _uprv_ebcdicFromAscii_56+95j
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	offset ??_C@_0EP@FOAJOBKF@uprv_ebcdicFromAscii?$CI?$CJ?5string?$FL?$CFd@ ; "uprv_ebcdicFromAscii() string[%d] conta"...
		mov	edx, [ebp+arg_0]
		push	edx
		call	_udata_printError_56
		add	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah
		xor	eax, eax
		jmp	short loc_75B
; ---------------------------------------------------------------------------

loc_732:				; CODE XREF: _uprv_ebcdicFromAscii_56+B3j
		movzx	eax, [ebp+var_1D]
		mov	ecx, [ebp+var_14]
		mov	dl, _ebcdicFromAscii[eax]
		mov	[ecx], dl
		mov	eax, [ebp+var_14]
		add	eax, 1
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax
		jmp	loc_6C7
; ---------------------------------------------------------------------------

loc_758:				; CODE XREF: _uprv_ebcdicFromAscii_56+77j
		mov	eax, [ebp+arg_8]

loc_75B:				; CODE XREF: _uprv_ebcdicFromAscii_56+2Ej
					; _uprv_ebcdicFromAscii_56+5Cj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_ebcdicFromAscii_56 endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 770h
		public ??_C@_0EP@FOAJOBKF@uprv_ebcdicFromAscii?$CI?$CJ?5string?$FL?$CFd@
; `string'
??_C@_0EP@FOAJOBKF@uprv_ebcdicFromAscii?$CI?$CJ?5string?$FL?$CFd@ db 'uprv_ebcdicFromAscii() string[%d] contains a variant character in'
					; DATA XREF: _uprv_ebcdicFromAscii_56+C0o
		db ' position %d',0Ah,0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 7C0h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_copyAscii_56(int, void *Src,	size_t Size, void *Dst,	int)
		public _uprv_copyAscii_56
_uprv_copyAscii_56 proc	near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_7EC
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_7F3

loc_7EC:				; CODE XREF: _uprv_copyAscii_56+22j
		xor	eax, eax
		jmp	loc_8D2
; ---------------------------------------------------------------------------

loc_7F3:				; CODE XREF: _uprv_copyAscii_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_811
		cmp	[ebp+Src], 0
		jz	short loc_811
		cmp	[ebp+Size], 0
		jl	short loc_811
		cmp	[ebp+Size], 0
		jle	short loc_821
		cmp	[ebp+Dst], 0
		jnz	short loc_821

loc_811:				; CODE XREF: _uprv_copyAscii_56+37j
					; _uprv_copyAscii_56+3Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_8D2
; ---------------------------------------------------------------------------

loc_821:				; CODE XREF: _uprv_copyAscii_56+49j
					; _uprv_copyAscii_56+4Fj
		mov	eax, [ebp+Src]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+Size]
		mov	[ebp+var_20], eax

loc_82D:				; CODE XREF: _uprv_copyAscii_56+DDj
		cmp	[ebp+var_20], 0
		jle	short loc_89F
		mov	eax, [ebp+var_8]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+var_8]
		add	edx, 1
		mov	[ebp+var_8], edx
		movzx	eax, [ebp+var_11]
		cmp	eax, 7Fh ; ''
		jg	short loc_86B
		movzx	eax, [ebp+var_11]
		sar	eax, 5
		movzx	ecx, [ebp+var_11]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_894

loc_86B:				; CODE XREF: _uprv_copyAscii_56+8Bj
		mov	eax, [ebp+Size]
		sub	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+Size]
		push	ecx
		push	offset ??_C@_0EN@GNKNHFM@uprv_copyFromAscii?$CI?$CJ?5string?$FL?$CFd?$FN?5@ ; "uprv_copyFromAscii() string[%d] contain"...
		mov	edx, [ebp+arg_0]
		push	edx
		call	_udata_printError_56
		add	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah
		xor	eax, eax
		jmp	short loc_8D2
; ---------------------------------------------------------------------------

loc_894:				; CODE XREF: _uprv_copyAscii_56+A9j
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	short loc_82D
; ---------------------------------------------------------------------------

loc_89F:				; CODE XREF: _uprv_copyAscii_56+71j
		cmp	[ebp+Size], 0
		jle	short loc_8CF
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+Dst]
		jz	short loc_8CF
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_8CF:				; CODE XREF: _uprv_copyAscii_56+E3j
					; _uprv_copyAscii_56+EBj
		mov	eax, [ebp+Size]

loc_8D2:				; CODE XREF: _uprv_copyAscii_56+2Ej
					; _uprv_copyAscii_56+5Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_copyAscii_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 8E8h
		public ??_C@_0EN@GNKNHFM@uprv_copyFromAscii?$CI?$CJ?5string?$FL?$CFd?$FN?5@
; `string'
??_C@_0EN@GNKNHFM@uprv_copyFromAscii?$CI?$CJ?5string?$FL?$CFd?$FN?5@ db	'uprv_copyFromAscii() string[%d] contains a variant character in p'
					; DATA XREF: _uprv_copyAscii_56+B6o
		db 'osition %d',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 938h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uprv_asciiFromEbcdic_56
_uprv_asciiFromEbcdic_56 proc near

var_F0		= byte ptr -0F0h
var_2C		= dword	ptr -2Ch
var_1D		= byte ptr -1Dh
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F0]
		mov	ecx, 3Ch ; '<'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_964
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_96B

loc_964:				; CODE XREF: _uprv_asciiFromEbcdic_56+22j
		xor	eax, eax
		jmp	loc_A55
; ---------------------------------------------------------------------------

loc_96B:				; CODE XREF: _uprv_asciiFromEbcdic_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_989
		cmp	[ebp+arg_4], 0
		jz	short loc_989
		cmp	[ebp+arg_8], 0
		jl	short loc_989
		cmp	[ebp+arg_8], 0
		jle	short loc_999
		cmp	[ebp+arg_C], 0
		jnz	short loc_999

loc_989:				; CODE XREF: _uprv_asciiFromEbcdic_56+37j
					; _uprv_asciiFromEbcdic_56+3Dj	...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_A55
; ---------------------------------------------------------------------------

loc_999:				; CODE XREF: _uprv_asciiFromEbcdic_56+49j
					; _uprv_asciiFromEbcdic_56+4Fj
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_2C], eax

loc_9AB:				; CODE XREF: _uprv_asciiFromEbcdic_56+115j
		cmp	[ebp+var_2C], 0
		jle	loc_A52
		mov	eax, [ebp+var_8]
		mov	cl, [eax]
		mov	[ebp+var_1D], cl
		mov	edx, [ebp+var_8]
		add	edx, 1
		mov	[ebp+var_8], edx
		movzx	eax, [ebp+var_1D]
		test	eax, eax
		jz	short loc_A33
		movzx	eax, [ebp+var_1D]
		mov	cl, _asciiFromEbcdic[eax]
		mov	[ebp+var_1D], cl
		movzx	edx, [ebp+var_1D]
		test	edx, edx
		jz	short loc_A0A
		movzx	eax, [ebp+var_1D]
		cmp	eax, 7Fh ; ''
		jg	short loc_A0A
		movzx	eax, [ebp+var_1D]
		sar	eax, 5
		movzx	ecx, [ebp+var_1D]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_A33

loc_A0A:				; CODE XREF: _uprv_asciiFromEbcdic_56+A9j
					; _uprv_asciiFromEbcdic_56+B2j
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+var_2C]
		push	eax
		mov	ecx, [ebp+arg_8]
		push	ecx
		push	offset ??_C@_0EP@ICFODGAO@uprv_asciiFromEbcdic?$CI?$CJ?5string?$FL?$CFd@ ; "uprv_asciiFromEbcdic() string[%d] conta"...
		mov	edx, [ebp+arg_0]
		push	edx
		call	_udata_printError_56
		add	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah
		xor	eax, eax
		jmp	short loc_A55
; ---------------------------------------------------------------------------

loc_A33:				; CODE XREF: _uprv_asciiFromEbcdic_56+94j
					; _uprv_asciiFromEbcdic_56+D0j
		mov	eax, [ebp+var_14]
		mov	cl, [ebp+var_1D]
		mov	[eax], cl
		mov	edx, [ebp+var_14]
		add	edx, 1
		mov	[ebp+var_14], edx
		mov	eax, [ebp+var_2C]
		sub	eax, 1
		mov	[ebp+var_2C], eax
		jmp	loc_9AB
; ---------------------------------------------------------------------------

loc_A52:				; CODE XREF: _uprv_asciiFromEbcdic_56+77j
		mov	eax, [ebp+arg_8]

loc_A55:				; CODE XREF: _uprv_asciiFromEbcdic_56+2Ej
					; _uprv_asciiFromEbcdic_56+5Cj	...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F0h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_asciiFromEbcdic_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0A6Ch
		public ??_C@_0EP@ICFODGAO@uprv_asciiFromEbcdic?$CI?$CJ?5string?$FL?$CFd@
; `string'
??_C@_0EP@ICFODGAO@uprv_asciiFromEbcdic?$CI?$CJ?5string?$FL?$CFd@ db 'uprv_asciiFromEbcdic() string[%d] contains a variant character in'
					; DATA XREF: _uprv_asciiFromEbcdic_56+DDo
		db ' position %d',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0ABCh
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_copyEbcdic_56(int, void *Src, size_t	Size, void *Dst, int)
		public _uprv_copyEbcdic_56
_uprv_copyEbcdic_56 proc near

var_E4		= byte ptr -0E4h
var_20		= dword	ptr -20h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h
Dst		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0E4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_E4]
		mov	ecx, 39h ; '9'
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+arg_10], 0
		jz	short loc_AE8
		mov	eax, [ebp+arg_10]
		cmp	dword ptr [eax], 0
		jle	short loc_AEF

loc_AE8:				; CODE XREF: _uprv_copyEbcdic_56+22j
		xor	eax, eax
		jmp	loc_BF2
; ---------------------------------------------------------------------------

loc_AEF:				; CODE XREF: _uprv_copyEbcdic_56+2Aj
		cmp	[ebp+arg_0], 0
		jz	short loc_B0D
		cmp	[ebp+Src], 0
		jz	short loc_B0D
		cmp	[ebp+Size], 0
		jl	short loc_B0D
		cmp	[ebp+Size], 0
		jle	short loc_B1D
		cmp	[ebp+Dst], 0
		jnz	short loc_B1D

loc_B0D:				; CODE XREF: _uprv_copyEbcdic_56+37j
					; _uprv_copyEbcdic_56+3Dj ...
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 1
		xor	eax, eax
		jmp	loc_BF2
; ---------------------------------------------------------------------------

loc_B1D:				; CODE XREF: _uprv_copyEbcdic_56+49j
					; _uprv_copyEbcdic_56+4Fj
		mov	eax, [ebp+Src]
		mov	[ebp+var_8], eax
		mov	eax, [ebp+Size]
		mov	[ebp+var_20], eax

loc_B29:				; CODE XREF: _uprv_copyEbcdic_56+FEj
		cmp	[ebp+var_20], 0
		jle	loc_BBF
		mov	eax, [ebp+var_8]
		mov	cl, [eax]
		mov	[ebp+var_11], cl
		mov	edx, [ebp+var_8]
		add	edx, 1
		mov	[ebp+var_8], edx
		movzx	eax, [ebp+var_11]
		test	eax, eax
		jz	short loc_BB1
		movzx	eax, [ebp+var_11]
		mov	cl, _asciiFromEbcdic[eax]
		mov	[ebp+var_11], cl
		movzx	edx, [ebp+var_11]
		test	edx, edx
		jz	short loc_B88
		movzx	eax, [ebp+var_11]
		cmp	eax, 7Fh ; ''
		jg	short loc_B88
		movzx	eax, [ebp+var_11]
		sar	eax, 5
		movzx	ecx, [ebp+var_11]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_BB1

loc_B88:				; CODE XREF: _uprv_copyEbcdic_56+A3j
					; _uprv_copyEbcdic_56+ACj
		mov	eax, [ebp+Size]
		sub	eax, [ebp+var_20]
		push	eax
		mov	ecx, [ebp+Size]
		push	ecx
		push	offset ??_C@_0EJ@KCIFDGKN@uprv_copyEbcdic?$CI?$CJ?5string?$FL?$CF?$FN?5cont@ ; "uprv_copyEbcdic() string[%] contains a "...
		mov	edx, [ebp+arg_0]
		push	edx
		call	_udata_printError_56
		add	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	dword ptr [eax], 0Ah
		xor	eax, eax
		jmp	short loc_BF2
; ---------------------------------------------------------------------------

loc_BB1:				; CODE XREF: _uprv_copyEbcdic_56+8Ej
					; _uprv_copyEbcdic_56+CAj
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		jmp	loc_B29
; ---------------------------------------------------------------------------

loc_BBF:				; CODE XREF: _uprv_copyEbcdic_56+71j
		cmp	[ebp+Size], 0
		jle	short loc_BEF
		mov	eax, [ebp+Src]
		cmp	eax, [ebp+Dst]
		jz	short loc_BEF
		push	1
		mov	eax, [ebp+Src]
		push	eax
		call	_uprv_checkValidMemory
		add	esp, 8
		mov	ecx, [ebp+Size]
		push	ecx		; Size
		mov	edx, [ebp+Src]
		push	edx		; Src
		mov	eax, [ebp+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_BEF:				; CODE XREF: _uprv_copyEbcdic_56+107j
					; _uprv_copyEbcdic_56+10Fj
		mov	eax, [ebp+Size]

loc_BF2:				; CODE XREF: _uprv_copyEbcdic_56+2Ej
					; _uprv_copyEbcdic_56+5Cj ...
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0E4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_copyEbcdic_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0C08h
		public ??_C@_0EJ@KCIFDGKN@uprv_copyEbcdic?$CI?$CJ?5string?$FL?$CF?$FN?5cont@
; `string'
??_C@_0EJ@KCIFDGKN@uprv_copyEbcdic?$CI?$CJ?5string?$FL?$CF?$FN?5cont@ db 'uprv_copyEbcdic() string[%] contains a variant character in posit'
					; DATA XREF: _uprv_copyEbcdic_56+D7o
		db 'ion %d',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0C54h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_compareInvAscii_56(int, char	*Str, int, int,	int)
		public _uprv_compareInvAscii_56
_uprv_compareInvAscii_56 proc near

var_F4		= dword	ptr -0F4h
var_29		= byte ptr -29h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+Str], 0
		jz	short loc_C8A
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_C8A
		cmp	[ebp+arg_C], 0
		jz	short loc_C8A
		cmp	[ebp+arg_10], 0FFFFFFFFh
		jge	short loc_C91

loc_C8A:				; CODE XREF: _uprv_compareInvAscii_56+22j
					; _uprv_compareInvAscii_56+28j	...
		xor	eax, eax
		jmp	loc_D91
; ---------------------------------------------------------------------------

loc_C91:				; CODE XREF: _uprv_compareInvAscii_56+34j
		cmp	[ebp+arg_8], 0
		jge	short loc_CA6
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_CA6:				; CODE XREF: _uprv_compareInvAscii_56+41j
		cmp	[ebp+arg_10], 0
		jge	short loc_CBB
		mov	eax, [ebp+arg_C]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_10], eax

loc_CBB:				; CODE XREF: _uprv_compareInvAscii_56+56j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jge	short loc_CCE
		mov	ecx, [ebp+arg_8]
		mov	[ebp+var_F4], ecx
		jmp	short loc_CD7
; ---------------------------------------------------------------------------

loc_CCE:				; CODE XREF: _uprv_compareInvAscii_56+6Dj
		mov	edx, [ebp+arg_10]
		mov	[ebp+var_F4], edx

loc_CD7:				; CODE XREF: _uprv_compareInvAscii_56+78j
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_8], eax

loc_CE0:				; CODE XREF: _uprv_compareInvAscii_56+132j
		cmp	[ebp+var_8], 0
		jle	loc_D8B
		mov	eax, [ebp+Str]
		mov	cl, [eax]
		mov	[ebp+var_29], cl
		mov	edx, [ebp+Str]
		add	edx, 1
		mov	[ebp+Str], edx
		movzx	eax, [ebp+var_29]
		cmp	eax, 7Fh ; ''
		jg	short loc_D2B
		movzx	eax, [ebp+var_29]
		sar	eax, 5
		movzx	ecx, [ebp+var_29]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jz	short loc_D2B
		movzx	eax, [ebp+var_29]
		mov	[ebp+var_14], eax
		jmp	short loc_D32
; ---------------------------------------------------------------------------

loc_D2B:				; CODE XREF: _uprv_compareInvAscii_56+AEj
					; _uprv_compareInvAscii_56+CCj
		mov	[ebp+var_14], 0FFFFFFFFh

loc_D32:				; CODE XREF: _uprv_compareInvAscii_56+D5j
		mov	eax, [ebp+arg_C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_20], ecx
		mov	edx, [ebp+arg_C]
		add	edx, 2
		mov	[ebp+arg_C], edx
		cmp	[ebp+var_20], 7Fh ; ''
		jg	short loc_D66
		mov	eax, [ebp+var_20]
		sar	eax, 5
		mov	ecx, [ebp+var_20]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_D6D

loc_D66:				; CODE XREF: _uprv_compareInvAscii_56+F4j
		mov	[ebp+var_20], 0FFFFFFFEh

loc_D6D:				; CODE XREF: _uprv_compareInvAscii_56+110j
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jz	short loc_D7D
		mov	eax, [ebp+var_14]
		jmp	short loc_D91
; ---------------------------------------------------------------------------

loc_D7D:				; CODE XREF: _uprv_compareInvAscii_56+122j
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax
		jmp	loc_CE0
; ---------------------------------------------------------------------------

loc_D8B:				; CODE XREF: _uprv_compareInvAscii_56+90j
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_10]

loc_D91:				; CODE XREF: _uprv_compareInvAscii_56+38j
					; _uprv_compareInvAscii_56+127j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_compareInvAscii_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0DA8h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_compareInvEbcdic_56(int, char *Str, int, int, int)
		public _uprv_compareInvEbcdic_56
_uprv_compareInvEbcdic_56 proc near

var_F4		= dword	ptr -0F4h
var_29		= byte ptr -29h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 0F4h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_F4]
		mov	ecx, 3Dh ; '='
		mov	eax, 0CCCCCCCCh
		rep stosd
		cmp	[ebp+Str], 0
		jz	short loc_DDE
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jl	short loc_DDE
		cmp	[ebp+arg_C], 0
		jz	short loc_DDE
		cmp	[ebp+arg_10], 0FFFFFFFFh
		jge	short loc_DE5

loc_DDE:				; CODE XREF: _uprv_compareInvEbcdic_56+22j
					; _uprv_compareInvEbcdic_56+28j ...
		xor	eax, eax
		jmp	loc_EFE
; ---------------------------------------------------------------------------

loc_DE5:				; CODE XREF: _uprv_compareInvEbcdic_56+34j
		cmp	[ebp+arg_8], 0
		jge	short loc_DFA
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		mov	[ebp+arg_8], eax

loc_DFA:				; CODE XREF: _uprv_compareInvEbcdic_56+41j
		cmp	[ebp+arg_10], 0
		jge	short loc_E0F
		mov	eax, [ebp+arg_C]
		push	eax
		call	_u_strlen_56
		add	esp, 4
		mov	[ebp+arg_10], eax

loc_E0F:				; CODE XREF: _uprv_compareInvEbcdic_56+56j
		mov	eax, [ebp+arg_8]
		cmp	eax, [ebp+arg_10]
		jge	short loc_E22
		mov	ecx, [ebp+arg_8]
		mov	[ebp+var_F4], ecx
		jmp	short loc_E2B
; ---------------------------------------------------------------------------

loc_E22:				; CODE XREF: _uprv_compareInvEbcdic_56+6Dj
		mov	edx, [ebp+arg_10]
		mov	[ebp+var_F4], edx

loc_E2B:				; CODE XREF: _uprv_compareInvEbcdic_56+78j
		mov	eax, [ebp+var_F4]
		mov	[ebp+var_8], eax

loc_E34:				; CODE XREF: _uprv_compareInvEbcdic_56+14Bj
		cmp	[ebp+var_8], 0
		jle	loc_EF8
		mov	eax, [ebp+Str]
		mov	cl, [eax]
		mov	[ebp+var_29], cl
		mov	edx, [ebp+Str]
		add	edx, 1
		mov	[ebp+Str], edx
		movzx	eax, [ebp+var_29]
		test	eax, eax
		jnz	short loc_E60
		mov	[ebp+var_14], 0
		jmp	short loc_E9F
; ---------------------------------------------------------------------------

loc_E60:				; CODE XREF: _uprv_compareInvEbcdic_56+ADj
		movzx	eax, [ebp+var_29]
		movzx	ecx, _asciiFromEbcdic[eax]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jz	short loc_E98
		cmp	[ebp+var_14], 7Fh ; ''
		jg	short loc_E98
		mov	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+var_14]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jz	short loc_E98
		jmp	short loc_E9F
; ---------------------------------------------------------------------------

loc_E98:				; CODE XREF: _uprv_compareInvEbcdic_56+CAj
					; _uprv_compareInvEbcdic_56+D0j ...
		mov	[ebp+var_14], 0FFFFFFFFh

loc_E9F:				; CODE XREF: _uprv_compareInvEbcdic_56+B6j
					; _uprv_compareInvEbcdic_56+EEj
		mov	eax, [ebp+arg_C]
		movzx	ecx, word ptr [eax]
		mov	[ebp+var_20], ecx
		mov	edx, [ebp+arg_C]
		add	edx, 2
		mov	[ebp+arg_C], edx
		cmp	[ebp+var_20], 7Fh ; ''
		jg	short loc_ED3
		mov	eax, [ebp+var_20]
		sar	eax, 5
		mov	ecx, [ebp+var_20]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_EDA

loc_ED3:				; CODE XREF: _uprv_compareInvEbcdic_56+10Dj
		mov	[ebp+var_20], 0FFFFFFFEh

loc_EDA:				; CODE XREF: _uprv_compareInvEbcdic_56+129j
		mov	eax, [ebp+var_14]
		sub	eax, [ebp+var_20]
		mov	[ebp+var_14], eax
		jz	short loc_EEA
		mov	eax, [ebp+var_14]
		jmp	short loc_EFE
; ---------------------------------------------------------------------------

loc_EEA:				; CODE XREF: _uprv_compareInvEbcdic_56+13Bj
		mov	eax, [ebp+var_8]
		sub	eax, 1
		mov	[ebp+var_8], eax
		jmp	loc_E34
; ---------------------------------------------------------------------------

loc_EF8:				; CODE XREF: _uprv_compareInvEbcdic_56+90j
		mov	eax, [ebp+arg_8]
		sub	eax, [ebp+arg_10]

loc_EFE:				; CODE XREF: _uprv_compareInvEbcdic_56+38j
					; _uprv_compareInvEbcdic_56+140j
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0F4h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_compareInvEbcdic_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 0F14h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uprv_compareInvEbcdicAsAscii_56
_uprv_compareInvEbcdicAsAscii_56 proc near

var_D8		= byte ptr -0D8h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		jmp	short loc_F46
; ---------------------------------------------------------------------------

loc_F34:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56:loc_1004j
		mov	eax, [ebp+arg_0]
		add	eax, 1
		mov	[ebp+arg_0], eax
		mov	ecx, [ebp+arg_4]
		add	ecx, 1
		mov	[ebp+arg_4], ecx

loc_F46:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+1Ej
		mov	eax, [ebp+arg_0]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_8], ecx
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		mov	[ebp+var_14], ecx
		mov	eax, [ebp+var_8]
		cmp	eax, [ebp+var_14]
		jz	loc_FFA
		cmp	[ebp+var_8], 0
		jz	short loc_FAA
		mov	eax, [ebp+var_8]
		movzx	ecx, _asciiFromEbcdic[eax]
		mov	[ebp+var_8], ecx
		cmp	[ebp+var_8], 0
		jz	short loc_F9F
		cmp	[ebp+var_8], 7Fh ; ''
		jg	short loc_F9F
		mov	eax, [ebp+var_8]
		sar	eax, 5
		mov	ecx, [ebp+var_8]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_FAA

loc_F9F:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+67j
					; _uprv_compareInvEbcdicAsAscii_56+6Dj
		mov	eax, [ebp+arg_0]
		movzx	ecx, byte ptr [eax]
		neg	ecx
		mov	[ebp+var_8], ecx

loc_FAA:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+54j
					; _uprv_compareInvEbcdicAsAscii_56+89j
		cmp	[ebp+var_14], 0
		jz	short loc_FF0
		mov	eax, [ebp+var_14]
		movzx	ecx, _asciiFromEbcdic[eax]
		mov	[ebp+var_14], ecx
		cmp	[ebp+var_14], 0
		jz	short loc_FE5
		cmp	[ebp+var_14], 7Fh ; ''
		jg	short loc_FE5
		mov	eax, [ebp+var_14]
		sar	eax, 5
		mov	ecx, [ebp+var_14]
		and	ecx, 1Fh
		mov	edx, 1
		shl	edx, cl
		and	edx, _invariantChars[eax*4]
		jnz	short loc_FF0

loc_FE5:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+ADj
					; _uprv_compareInvEbcdicAsAscii_56+B3j
		mov	eax, [ebp+arg_4]
		movzx	ecx, byte ptr [eax]
		neg	ecx
		mov	[ebp+var_14], ecx

loc_FF0:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+9Aj
					; _uprv_compareInvEbcdicAsAscii_56+CFj
		mov	eax, [ebp+var_8]
		sub	eax, [ebp+var_14]
		jmp	short loc_1009
; ---------------------------------------------------------------------------
		jmp	short loc_1004
; ---------------------------------------------------------------------------

loc_FFA:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+4Aj
		cmp	[ebp+var_8], 0
		jnz	short loc_1004
		xor	eax, eax
		jmp	short loc_1009
; ---------------------------------------------------------------------------

loc_1004:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+E4j
					; _uprv_compareInvEbcdicAsAscii_56+EAj
		jmp	loc_F34
; ---------------------------------------------------------------------------

loc_1009:				; CODE XREF: _uprv_compareInvEbcdicAsAscii_56+E2j
					; _uprv_compareInvEbcdicAsAscii_56+EEj
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_compareInvEbcdicAsAscii_56 endp

_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1010h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _uprv_ebcdicToLowercaseAscii_56
_uprv_ebcdicToLowercaseAscii_56	proc near

var_C0		= byte ptr -0C0h
arg_0		= byte ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0C0h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_C0]
		mov	ecx, 30h ; '0'
		mov	eax, 0CCCCCCCCh
		rep stosd
		movzx	eax, [ebp+arg_0]
		mov	al, _lowercaseAsciiFromEbcdic[eax]
		pop	edi
		pop	esi
		pop	ebx
		mov	esp, ebp
		pop	ebp
		retn
_uprv_ebcdicToLowercaseAscii_56	endp

; ---------------------------------------------------------------------------
		align 10h
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 1040h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_aestrncpy_56(int, char *Str,	int)
		public _uprv_aestrncpy_56
_uprv_aestrncpy_56 proc	near

var_CC		= byte ptr -0CCh
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0CCh
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_CC]
		mov	ecx, 33h ; '3'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jnz	short loc_107C
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		mov	[ebp+arg_8], eax

loc_107C:				; CODE XREF: _uprv_aestrncpy_56+28j
					; _uprv_aestrncpy_56+78j
		mov	eax, [ebp+Str]
		movzx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_10BA
		cmp	[ebp+arg_8], 0
		jle	short loc_10BA
		mov	eax, [ebp+Str]
		movzx	ecx, byte ptr [eax]
		mov	edx, [ebp+arg_0]
		mov	al, _asciiFromEbcdic[ecx]
		mov	[edx], al
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	edx, [ebp+Str]
		add	edx, 1
		mov	[ebp+Str], edx
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_107C
; ---------------------------------------------------------------------------

loc_10BA:				; CODE XREF: _uprv_aestrncpy_56+44j
					; _uprv_aestrncpy_56+4Aj ...
		cmp	[ebp+arg_8], 0
		jle	short loc_10DA
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax],	0
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_10BA
; ---------------------------------------------------------------------------

loc_10DA:				; CODE XREF: _uprv_aestrncpy_56+7Ej
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0CCh
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_aestrncpy_56 endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10F4h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl uprv_eastrncpy_56(int, char *Str,	int)
		public _uprv_eastrncpy_56
_uprv_eastrncpy_56 proc	near

var_D8		= byte ptr -0D8h
var_11		= byte ptr -11h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
Str		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 0D8h
		push	ebx
		push	esi
		push	edi
		lea	edi, [ebp+var_D8]
		mov	ecx, 36h ; '6'
		mov	eax, 0CCCCCCCCh
		rep stosd
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], eax
		cmp	[ebp+arg_8], 0FFFFFFFFh
		jnz	short loc_1130
		mov	eax, [ebp+Str]
		push	eax		; Str
		call	_strlen
		add	esp, 4
		add	eax, 1
		mov	[ebp+arg_8], eax

loc_1130:				; CODE XREF: _uprv_eastrncpy_56+28j
					; _uprv_eastrncpy_56+8Ej
		mov	eax, [ebp+Str]
		movzx	ecx, byte ptr [eax]
		test	ecx, ecx
		jz	short loc_1184
		cmp	[ebp+arg_8], 0
		jle	short loc_1184
		mov	eax, [ebp+Str]
		movzx	ecx, byte ptr [eax]
		mov	dl, _ebcdicFromAscii[ecx]
		mov	[ebp+var_11], dl
		mov	eax, [ebp+Str]
		add	eax, 1
		mov	[ebp+Str], eax
		movsx	eax, [ebp+var_11]
		test	eax, eax
		jnz	short loc_1168
		mov	al, byte_13F
		mov	[ebp+var_11], al

loc_1168:				; CODE XREF: _uprv_eastrncpy_56+6Aj
		mov	eax, [ebp+arg_0]
		mov	cl, [ebp+var_11]
		mov	[eax], cl
		mov	edx, [ebp+arg_0]
		add	edx, 1
		mov	[ebp+arg_0], edx
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_1130
; ---------------------------------------------------------------------------

loc_1184:				; CODE XREF: _uprv_eastrncpy_56+44j
					; _uprv_eastrncpy_56+4Aj ...
		cmp	[ebp+arg_8], 0
		jle	short loc_11A4
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax],	0
		mov	ecx, [ebp+arg_0]
		add	ecx, 1
		mov	[ebp+arg_0], ecx
		mov	eax, [ebp+arg_8]
		sub	eax, 1
		mov	[ebp+arg_8], eax
		jmp	short loc_1184
; ---------------------------------------------------------------------------

loc_11A4:				; CODE XREF: _uprv_eastrncpy_56+94j
		mov	eax, [ebp+var_8]
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 0D8h
		cmp	ebp, esp
		call	__RTC_CheckEsp
		mov	esp, ebp
		pop	ebp
		retn
_uprv_eastrncpy_56 endp

_text		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __cdecl __wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
		extrn __imp___wassert:near ; CODE XREF:	_u_charsToUChars_56+64p
					; _u_UCharsToChars_56+7Cp
					; DATA XREF: ...
		extrn __RTC_CheckEsp:near ; CODE XREF: _u_charsToUChars_56+6Fp
					; _u_charsToUChars_56+9Dp ...
		extrn __RTC_Shutdown:near ; DATA XREF: .rtc$TMZ:__RTC_Shutdown_rtc$TMZo
		extrn __RTC_InitBase:near ; DATA XREF: .rtc$IMZ:__RTC_InitBase_rtc$IMZo
		extrn _udata_printError_56:near	; CODE XREF: _uprv_ebcdicFromAscii_56+C9p
					; _uprv_copyAscii_56+BFp ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _uprv_copyAscii_56+107p
					; _uprv_copyEbcdic_56+12Bp
		extrn _uprv_checkValidMemory:near ; CODE XREF: _uprv_copyAscii_56+F3p
					; _uprv_copyEbcdic_56+117p
		extrn _u_strlen_56:near	; CODE XREF: _uprv_compareInvAscii_56+5Cp
					; _uprv_compareInvEbcdic_56+5Cp
; size_t __cdecl strlen(const char *Str)
		extrn _strlen:near	; CODE XREF: _uprv_compareInvAscii_56+47p
					; _uprv_compareInvEbcdic_56+47p ...


		end
